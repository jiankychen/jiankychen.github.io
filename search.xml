<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LaTeX 转 Word</title>
      <link href="/posts/a351e8c0/"/>
      <url>/posts/a351e8c0/</url>
      
        <content type="html"><![CDATA[<h1 id="pandoc"><a class="anchor" href="#pandoc">#</a> Pandoc</h1><p>利用 Pandoc 读取 tex 源码并输出 docx 文件</p><h2 id="安装"><a class="anchor" href="#安装">#</a> 安装</h2><p>Pandoc 下载地址：<span class="exturl" data-url="aHR0cHM6Ly9wYW5kb2Mub3JnL2luc3RhbGxpbmcuaHRtbA==">Pandoc</span></p><p>按默认配置安装即可</p><h2 id="使用"><a class="anchor" href="#使用">#</a> 使用</h2><p>步骤：</p><ul><li><p>配置路径：打开 cmd ，切换到需转换的 LaTeX 文件所在的路径</p></li><li><p>转换：在 cmd 中输入转换命令</p></li></ul><p>命令模板（不可执行）：</p><pre><code class="language-powershell">pandoc main.tex -o output.docx ^    --reference-doc template.docx ^    --filter pandoc-crossref -M tableEqns -M autoEqnLabels ^    --resource-path=.;Figures ^    --bibliography ref.bib ^    --citeproc ^    --csl references_style.csl ^    -M reference-section-title=Reference ^    --number-sections ^    --toc</code></pre><p>相关命令及参数介绍：</p><ul><li><p><code>main.tex</code> ：输入 LaTeX 文件名</p></li><li><p><code>-o output.docx</code> ：输出 Word 文件名</p></li><li><p><code>--reference-doc template.docx</code> ：参考模板 Docx 文件，可从 <span class="exturl" data-url="aHR0cHM6Ly90ZW1wbGF0ZS1zZWxlY3Rvci5pZWVlLm9yZy9zZWN1cmUvdGVtcGxhdGVTZWxlY3Rvci9wdWJsaWNhdGlvblR5cGU=">IEEE article template</span> 下载【可选】</p></li><li><p><code>--filter pandoc-crossref</code> ：用于公式、图片、表格等的交叉引用【可选】</p><ul><li>需要从 Github 下载 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpZXJkYWtpbC9wYW5kb2MtY3Jvc3NyZWYvcmVsZWFzZXM=">pandoc-crossref</span> ，并将 pandoc-crossref.exe 放到 Pandoc 的安装目录中</li><li><code>-M tableEqns -M autoEqnLabels</code> ： <code>autoEqnLabels</code>  为公式编号， <code>tableEqns</code>  以表格形式显示公式编号（即：创建一个两列表，将公式放在左边列，将公式编号放在右边列）（具体可查看 <span class="exturl" data-url="aHR0cDovL2xpZXJkYWtpbC5naXRodWIuaW8vcGFuZG9jLWNyb3NzcmVmLw==">pandoc-crossref 文档</span>）</li></ul></li><li><p><code>--resource-path=.;Figures</code> ：指定 tex 源图片的存放文件夹</p><ul><li><code>.;Figures</code> ： <code>.</code>  表示当前工作目录， <code>;</code>  是 Windows 系统的分隔符（Linux、Unix、macOs 用  <code>:</code>  ）， <code>Figures</code>  是存放 tex 源图片的子文件夹的名称</li><li>eps、pdf 等格式无法正常转化进 Word 文件，需提前将图片转为 jpg 等格式</li></ul></li><li><p><code>--bibliography ref.bib</code> ：参考文献 bib 文件 【可选】</p></li><li><p><code>--citeproc</code> ：用于参考文献的引用 【可选】</p></li><li><p><code>--csl references_style.csl</code> ：参考文献的样式文件，可从 <span class="exturl" data-url="aHR0cHM6Ly93d3cuem90ZXJvLm9yZy9zdHlsZXM=">Zotero Style Repository</span> 下载 【可选】</p></li><li><p><code>-M reference-section-title=Reference</code> ：添加参考文献的章节名 【可选】</p></li><li><p><code>--number-sections</code> ：用于章节自动编号 【可选】</p></li><li><p><code>--toc</code> ：生成目录 【可选】</p></li></ul><p>详细信息请查看：<span class="exturl" data-url="aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1s">Pandoc User's Guide</span></p><p>示例：</p><pre><code class="language-powershell">pandoc input.tex --filter pandoc-crossref -M tableEqns -M autoEqnLabels --bibliography ref.bib --citeproc --csl ieee-wireless-communications-letters.csl --resource-path=.;Figures --number-sections -M reference-section-title=Reference -o output.docx</code></pre><h2 id="注意事项"><a class="anchor" href="#注意事项">#</a> 注意事项</h2><ul><li><p>带  <code>*</code>  的图表不能正确转化，例如： <code>\begin&#123;figure*&#125;</code>  应改为  <code>\begin&#123;figure&#125;</code></p></li><li><p>表格中带子 tabular 的不能正确生成</p></li><li><p>由于 pandoc-crossref 使用与 citeproc 相同的引用语法，因此，pandoc-crossref 相关命令必须放在 citeproc 前面</p></li><li><p>LaTeX 伪代码算法无法正常转化，可通过第三方工具实现（例如：Aurora 插件）</p></li></ul><blockquote><p>经测试，图片、表格、章节的交叉引用可以显示编号，但公式的交叉引用无法显示编号（无论是  <code>\ref</code>  命令还是  <code>\eqref</code>  命令都无法显示）。</p></blockquote><h2 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h2><p>Pandoc：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzc1ODU1L2FydGljbGUvZGV0YWlscy8xMjIwNDQwMDQ=">Pandoc: LaTeX 转 Word 文档 （含参考文献样式）</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNTYyODUvYXJ0aWNsZS9kZXRhaWxzLzEyODIxOTQ5NQ==">pandoc LaTeX 转 Word (.docx) 踩坑记录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NDY0MzIxL2FydGljbGUvZGV0YWlscy84ODg1MzI3MA==">Windows 下 Pandoc 转换 LaTex 成 Word 最全指令</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9nZS1jaHVueXUuZ2l0aHViLmlvL3Bvc3RzLzIwMTktMTEtcGFuZG9jLWxhcmdlLWRvY3VtZW50Lw==">用 Pandoc 生成大型中文文档的痛点与解决方案</span></li></ul><p>Aurora：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jYWxsbWVqYWNreS5ibG9nLmNzZG4ubmV0L2FydGljbGUvZGV0YWlscy85ODYxNTEyNA==">Aurora：在 Word 中插入算法伪代码、表格和公式</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1Y2tzdS9hcnRpY2xlL2RldGFpbHMvMTE2MzA3MjQ0">使用 Aurora 在 Word 中插入算法伪代码教程</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjc4ODQ3NjU=">使用 Aurora + Algorithm2e 在 Word 中输入伪代码</span></li></ul><h1 id="acrobat"><a class="anchor" href="#acrobat">#</a> Acrobat</h1><p>直接使用 Adobe Acrobat Pro DC 软件将 PDF 文件转换成 Word 文件</p><p>除部分公式无法准确转换外，其余的转换效果都挺不错的</p><p>可以考虑将 Acrobat 与 Pandoc 结合使用，取长补短</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> LaTeX </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL 基础</title>
      <link href="/posts/f416b295/"/>
      <url>/posts/f416b295/</url>
      
        <content type="html"><![CDATA[<h1 id="sql-简介"><a class="anchor" href="#sql-简介">#</a> SQL 简介</h1><p>SQL（Structured Query Language），结构化查询语言，用于访问和处理数据库的标准的计算机语言</p><p>SQL 语法特征：</p><ul><li><p>大小写不敏感</p></li><li><p>可以单行或多行书写，最后以  <code>;</code>  号结束</p></li><li><p>支持单行、多行注释：</p><ul><li>单行注释： <code>-- 注释内容</code> （-- 后面一定要有一个空格）</li><li>单行注释： <code># 注释内容</code> （# 后面可以不加空格，但推荐加上）</li><li>多行注释： <code>/*  注释内容  */</code></li></ul></li></ul><p>根据 SQL 语句的功能，可将其分为四类：</p><ul><li><p>数据定义：DDL（Data Definition Language）</p><ul><li>库的创建删除、表的创建删除等</li></ul></li><li><p>数据操纵：DML（Data Manipulation Language）</p><ul><li>新增数据、删除数据、修改数据等</li></ul></li><li><p>数据控制：DCL（Data Control Language）</p><ul><li>新增用户、删除用户、密码修改、权限管理等</li></ul></li><li><p>数据查询：DQL（Data Query Language）</p><ul><li>基于需求查询和计算数据</li></ul></li></ul><h1 id="ddl"><a class="anchor" href="#ddl">#</a> DDL</h1><h2 id="数据库操作"><a class="anchor" href="#数据库操作">#</a> 数据库操作</h2><p>查看所有数据库</p><pre><code class="language-sql">show databases;</code></pre><p>查看当前使用的数据库</p><pre><code class="language-sql">select database();</code></pre><p>创建数据库</p><pre><code class="language-sql">create database 数据库名 charset utf8;</code></pre><p>删除数据库</p><pre><code class="language-sql">drop database 数据库名;</code></pre><p>使用数据库</p><pre><code class="language-sql">use 数据库名;</code></pre><h2 id="表操作"><a class="anchor" href="#表操作">#</a> 表操作</h2><p>查看数据库中所有表（需要先选择数据库）</p><pre><code class="language-sql">show tables;</code></pre><p>查看表结构</p><pre><code class="language-sql">desc 表名;</code></pre><p>创建表</p><pre><code class="language-sql">create table 表名(  列名 列类型 [约束条件],  列名 列类型 [约束条件],  ...）;</code></pre><blockquote><p><code>[]</code>  表示可选的内容</p></blockquote><p>其中，列类型有：</p><ul><li><code>int</code>  ：整数</li><li><code>float</code>  ：浮点数</li><li><code>varchar(长度)</code>  ：文本（长度填写整数类型，用于限制文本长度，可填的最大数字为 255）</li><li><code>date</code>  ：日期类型</li><li><code>timestamp</code>  ：时间戳类型</li></ul><p>修改表–添加字段</p><pre><code class="language-sql">alter table 表名 add 列名 类型;</code></pre><p>修改表–修改字段–重命名版</p><pre><code class="language-sql">alert table 表名 change 原名 新名 类型及约束;</code></pre><p>修改表–修改字段–不重命名</p><pre><code class="language-sql">alter table 表名 modify 列名 类型及约束;</code></pre><p>删除表–删除字段</p><pre><code class="language-sql">alter table 表名 drop 列名;</code></pre><p>删除表</p><pre><code class="language-sql">drop table 表名;# 如果表存在，则删除；如不存在，则跳过drop table if exists 表名;</code></pre><blockquote><p>有些数据库系统不支持  <code>if exists</code>  选项，支持  <code>if exists</code>  选项的有：MySQL，PostgreSQL 和 SQL Server 2016</p></blockquote><p>查看表的创建语句–详细过程</p><pre><code class="language-sql">show create table 表名;</code></pre><h1 id="dml"><a class="anchor" href="#dml">#</a> DML</h1><h2 id="数据插入"><a class="anchor" href="#数据插入">#</a> 数据插入</h2><p>全列插入：值的顺序与表结构字段的顺序完全对应，此时可以省略列名的列表</p><pre><code class="language-sql">insert into 表名 values (...);</code></pre><p>部分列插入：值的顺序与给出的列名顺序对应</p><pre><code class="language-sql">insert into 表名 (列1, 列2, ...) values (值1, 值2, ...);</code></pre><p>全列多行插入</p><pre><code class="language-sql">insert into 表名 values (...), (...), ...;</code></pre><p>部分列多行插入</p><pre><code class="language-sql">insert into 表名 (列1, 列2, ...) values (值1, 值2, ...), (值1, 值2, ...), ...;</code></pre><blockquote><p>注意：如果数据是字符型，必须使用单引号或双引号包围</p></blockquote><p>例如：</p><pre><code class="language-sql"># 创建名为 test 的数据库create database test charset UTF8;# 使用名为 test 的数据库use test;# 创建表create table student(id int,name varchar(10),age int);# 为 id 列插入多行数据insert into student(id) values(1), (2), (3);# 为 id 列和 name 列插入多行数据insert into student(id, name) values(4, 'Ellon'), (5, 'John');# 为全部列插入数据insert into student values(6, 'Ale', 20);</code></pre><h2 id="数据删除"><a class="anchor" href="#数据删除">#</a> 数据删除</h2><p>清空表（删除整个表中的数据）</p><pre><code class="language-sql">delete from 表名;</code></pre><p>按特定条件删除数据</p><pre><code class="language-sql">delete from 表名 where 条件;</code></pre><p>例如：</p><pre><code class="language-sql"># 删除 id 为 3 的行delete from student where id = 3;</code></pre><h3 id="where"><a class="anchor" href="#where">#</a> where</h3><p><code>where</code>  后面跟条件语句，以进行条件处理</p><p>条件语句支持以下运算符：</p><ul><li>比较运算符<ul><li>等于： <code>=</code></li><li>大于： <code>&gt;</code></li><li>大于等于： <code>&gt;=</code></li><li>小于： <code>&lt;</code></li><li>小于等于： <code>&lt;=</code></li><li>不等于： <code>!=</code>  或  <code>&lt;&gt;</code></li></ul></li><li>逻辑运算符<ul><li>与： <code>and</code></li><li>或： <code>or</code></li><li>非： <code>not</code></li></ul></li><li>使用 like 关键字的模糊查询<ul><li><code>%</code>  通配符：表示任意多个任意字符</li><li><code>_</code>  通配符：表示一个任意字符</li></ul></li><li>范围查询<ul><li>连续范围查询： <code>between ... and ...</code></li><li>非连续范围查询： <code>in(... , ...)</code></li></ul></li><li>空判断<ul><li>判断为空： <code>is null</code></li><li>判断不为空： <code>is not null</code></li></ul></li></ul><p>条件的优先级：</p><ul><li>优先级由高到低的顺序为：小括号， <code>not</code> ，比较运算符，逻辑运算符</li><li><code>and</code>  比  <code>or</code>  先运算（如果同时出现并希望先算  <code>or</code>  ，需要结合  <code>()</code>  使用）</li></ul><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzI1NTkuaHRtbA==">MySQL WHERE：条件查询</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbnhpYW9oYWk4ODgvYXJ0aWNsZS9kZXRhaWxzLzc3NjU3MTA4">SQL 条件 (限定) 查询</span></li></ul><h2 id="数据修改"><a class="anchor" href="#数据修改">#</a> 数据修改</h2><pre><code class="language-sql">update 表名 set 列名 = 值 [where 条件];</code></pre><p>例如：</p><pre><code class="language-sql"># 将 id 为 2 所对应的 name 修改为 Mikeupdate student set name = 'Mike' where id = 2;</code></pre><blockquote><p><code>update 表名 set 列名 = 值</code>  会修改整列的数据</p></blockquote><h1 id="dql"><a class="anchor" href="#dql">#</a> DQL</h1><h2 id="基础查询"><a class="anchor" href="#基础查询">#</a> 基础查询</h2><p>查询所有列</p><pre><code class="language-sql">select * from 表名;</code></pre><p>查询指定列</p><pre><code class="language-sql">select 列1，列2，... from 表名;</code></pre><p>条件查询</p><pre><code class="language-sql">select 列1，列2，... from 表名 where 条件;</code></pre><p>例如：</p><pre><code class="language-sql"># 查询 id 和 name 两列，年龄小于 35select id, name from student where age &gt;= 18 and age &lt; 35;</code></pre><h2 id="分组聚合"><a class="anchor" href="#分组聚合">#</a> 分组聚合</h2><pre><code class="language-sql">select 字段, 聚合函数 from 表名 [where 条件] group by 列名;</code></pre><p>聚合函数：</p><ul><li>求和： <code>sum(列)</code></li><li>求平均值： <code>avg(列)</code></li><li>求最小值： <code>min(列)</code></li><li>求最大值： <code>max(列)</code></li><li>求数量： <code>count(列/*)</code></li></ul><p>注意：</p><ul><li>一条 SQL 查询语句可以写多个聚合函数，以同时展示多个统计信息</li><li>除了聚合函数外， <code>select 字段</code>  中的 字段 只能包含  <code>GROUP BY 列名</code>  中出现的 列名</li></ul><p>例如：</p><pre><code class="language-sql">create table person(  id int,  name varchar(10),  age int,  gender varchar(10));insert into person values(1, 'Tom', 23, 'male'), (2, 'Jerry', 22, 'male'), (3, 'Morty', 21, 'male'), (4, 'Rick', 26, 'male'), (5, 'Marry', 23, 'female'), (6, 'Angel', 22, 'female');# 按性别分组，统计各组人数select gender, count(*) from person group by gender;# 按性别分组，统计平均年龄select gender, avg(age) from person group by gender;# 按性别分组，统计最大年龄和最小年龄select gender, max(age), min(age) from person group by gender;</code></pre><h2 id="排序分页"><a class="anchor" href="#排序分页">#</a> 排序分页</h2><h3 id="结果排序"><a class="anchor" href="#结果排序">#</a> 结果排序</h3><p>可以对查询的结果使用  <code>order by</code>  关键字，指定某个列进行排序</p><pre><code class="language-sql">select 列|聚合函数|* from 表名where ...group by ...order by ... [asc / desc];</code></pre><p>其中：</p><ul><li>升序（默认）: <code>asc</code></li><li>降序： <code>desc</code></li></ul><p>例如：</p><pre><code class="language-sql"># 显示 age &gt; 22 的所有数据（按 age 列降序排列）select * from person where age &gt; 22 order by age desc;</code></pre><h3 id="结果分页"><a class="anchor" href="#结果分页">#</a> 结果分页</h3><p>可以使用  <code>limit</code>  关键字，对查询结果进行数量限制或者分页显示</p><pre><code class="language-sql">select 列|聚合函数|* from 表名where ...group by ...order by ... [asc / desc]limit n[, m];</code></pre><p>其中：</p><ul><li><code>n</code>  表示：显示  <code>n</code>  条数据</li><li><code>n, m</code>  表示：跳过前  <code>n</code>  条数据，显示后续的  <code>m</code>  条数据</li></ul><p>注意：</p><ul><li><code>select</code>  和  <code>from</code>  是必写的， <code>where</code> 、 <code>group by</code> 、 <code>order by</code> 、 <code>limit</code>  均可按需求省略</li><li>执行顺序：from -&gt;  <code>where</code>  -&gt;  <code>group by</code>  和聚合函数 -&gt;  <code>select</code>  -&gt;  <code>order by</code>  -&gt;  <code>limit</code></li><li><code>limit</code>  后面不可以直接加公式</li></ul><p>例如：</p><pre><code class="language-sql"># 按 age 列升序排列，查询结果只保留 5 条数据select * from person limit 5;# 筛选出年龄最大的 5 人select * from person order by age desc limit 5;# 按 age 列升序排列，查询结果只保留从第 3 条开始的 2 条数据select * from person order by age limit 2, 2;</code></pre><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MzAzNjY2NA==">SQL 常用语句总结</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVT9wPTEyOA==">黑马程序员 Python 教程：数据库介绍</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NmejEyMzQ1Njc4OTAvYXJ0aWNsZS9kZXRhaWxzLzExMDc5MTI4MA==">面试必备 ——SQL 基础语句大全 (详细）</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 面向对象</title>
      <link href="/posts/59bf225c/"/>
      <url>/posts/59bf225c/</url>
      
        <content type="html"><![CDATA[<p>Python 是一种面向对象的编程语言</p><p>简单理解 面向对象 ：基于模板（类）去创建实体（对象），使用对象完成功能开发</p><p>面向对象的三大特征：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>面向对象技术简介</p><ul><li>类（Class）: 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法</li><li>实例化：创建一个类的实例（类的具体对象）</li><li>方法：类中定义的函数</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用</li><li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写</li><li>局部变量：定义在方法中的变量，只作用于当前实例的类</li><li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟 &quot;是一个（is-a）&quot; 关系（即，Dog 是一个 Animal）</li></ul><h1 id="类和对象"><a class="anchor" href="#类和对象">#</a> 类和对象</h1><p>类的组成：</p><ul><li>成员变量：定义在类中的属性（变量）</li><li>成员方法：定义在类中的行为（函数）</li></ul><h2 id="类定义"><a class="anchor" href="#类定义">#</a> 类定义</h2><p>使用关键字  <code>class</code>  定义类：</p><pre><code class="language-python">class Class_Name:    &lt;statement-1&gt;    ...    &lt;statement-N&gt;</code></pre><p>其中， <code>Class_Name</code>  表示类的名称，通常需要首字母大写</p><h2 id="类对象"><a class="anchor" href="#类对象">#</a> 类对象</h2><p>创建对象（实例化）：</p><pre><code class="language-python">obj = Class_Name()</code></pre><p>修改对象属性：</p><pre><code class="language-python">obj.var_name = xx</code></pre><p>删除对象属性：</p><pre><code class="language-python"># 使用 del 关键字删除对象的属性del obj.var_name</code></pre><p>删除对象：</p><pre><code class="language-python"># 使用 del 关键字删除对象del obj</code></pre><h2 id="类的成员方法"><a class="anchor" href="#类的成员方法">#</a> 类的成员方法</h2><ul><li>函数：定义在类的外部</li><li>方法：定义在类的内部</li></ul><p>在类的内部，使用  <code>def</code>  关键字来定义一个方法，与一般函数定义不同，类的成员方法必须必须有一个额外的第一个参数名称，按照惯例它的名称是  <code>self</code>  ，即：</p><pre><code class="language-python">def func_name(self, parameter_1, ..., parameter_N):    ...</code></pre><p>其中：</p><ul><li><p><code>self</code>  参数是对类的当前实例的引用，用于访问属于该类的变量。它不必被命名为  <code>self</code> ，但它必须是类中任意函数的首个参数</p></li><li><p>在方法内部，想要访问类的成员变量，必须使用  <code>self</code>  。即，使用  <code>self.var_name</code>  访问成员变量  <code>var_nam</code></p></li><li><p>调用类的成员方法时， <code>self</code>  会被自动传入，即，不需要在实参列表中写出  <code>self</code></p></li></ul><h2 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h2><p>Python 类中的  <code>__init__</code>  方法，称之为 构造方法</p><p>每次使用类创建新对象时，都会自动调用  <code>__init__</code>  方法，并且会将创建类对象时的传入参数自动传递给  <code>__init__</code>  方法</p><p>因此，使用  <code>__init__</code>  方法可以将值赋给对象属性，或者在创建对象时需要执行的其他操作</p><p>注意，构造方法 也是 成员方法，因此：</p><ul><li>定义构造方法时需要在形参列表中写上  <code>self</code>  参数</li><li>在构造方法内部访问成员变量需要使用  <code>self.var_name</code></li></ul><p>例如：</p><pre><code class="language-python"># 定义类class Person:    name = None     # 由于定义了 __init__ 方法，可以省略这里的初始化    age = None      # 由于定义了 __init__ 方法，可以省略这里的初始化    def __init__(self, name, age):        self.name = name        self.age = age# 创建类对象p = Person(&quot;John&quot;, 24)# 打印类对象的属性print(p.name)print(p.age)</code></pre><h2 id="魔术方法"><a class="anchor" href="#魔术方法">#</a> 魔术方法</h2><p>魔术方法（Magic Methods）是 Python 中的内置方法，一般以  <code>__</code>  （双下划线）为开头和结尾</p><p>例如：</p><ul><li><code>__init__</code>  ：构造方法，当一个实例被创建的时候调用的初始化方法</li><li><code>__del__</code>  ：析构方法，当一个实例被销毁的时候调用的方法</li><li><code>__str__</code>  ：字符串方法，定义当被  <code>str()</code>  调用或者打印对象时的行为</li><li><code>__lt__</code>  ：定义小于号的行为： <code>x &lt; y</code>  调用  <code>x.__lt__(y)</code></li><li><code>__le__</code>  ：定义小于等于号的行为： <code>x &lt;= y</code>  调用  <code>x.__le__(y)</code></li><li><code>__eq__</code>  ：定义等于号的行为： <code>x == y</code>  调用  <code>x.__eq__(y)</code></li></ul><p>之所以称之为魔法方法，是因为这些方法会在进行特定的操作时会被自动调用</p><p>如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZGFjaGVuemkvcC84MTg1NzkyLmh0bWw=">Python 中类的魔术方法</span></p><h2 id="pass-语句"><a class="anchor" href="#pass-语句">#</a> pass 语句</h2><p><code>pass</code>  是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容</p><p>如果因为某种原因写了无内容的函数定义或类定义，需使用  <code>pass</code>  语句来避免错误</p><p>例如：</p><pre><code class="language-python"># 继承class DerivedClassName(BaseClassName):    pass</code></pre><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3B5dGhvbi9weXRob25fY2xhc3Nlcy5hc3A=">W3school：Python 类和对象</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24zL3B5dGhvbjMtY2xhc3MuaHRtbA==">菜鸟教程：Python3 面向对象</span></li></ul><h1 id="封装"><a class="anchor" href="#封装">#</a> 封装</h1><p>在程序设计中，封装（Encapsulation）是对具体对象的一种抽象，即将某些部分隐藏起来（即，定义成私有成员），在程序外部看不到（即，其他程序无法调用）</p><ul><li>封装数据：保护隐私</li><li>封装方法：隔离复杂度（只保留部分接口对外使用）</li></ul><h2 id="私有成员"><a class="anchor" href="#私有成员">#</a> 私有成员</h2><p>类对象无法直接访问私有成员，但类内其它成员可以直接使用私有成员</p><p>私有成员变量：</p><ul><li>定义：变量名以  <code>__</code>  （2 个下划线）开头，例如： <code>__private_attrs</code></li><li>声明该属性为私有属性，只能在类的内部使用，不能在类的外部使用或直接访问</li><li>在类内部的访问方式为： <code>self.__private_attrs</code></li></ul><p>私有成员方法（封装的方法）：</p><ul><li>方法名以  <code>__</code>  （2 个下划线）开头，例如： <code>__private_method</code></li><li>声明该方法为私有方法，只能在类的内部调用，不能在类的外部调用</li><li>在类内部的调用方式为： <code>self.__private_method()</code></li></ul><blockquote><p>与 java 等语言不同，Python 的封装并不是真正意义上的外部无法调用。在 Python 中，如果需要在类外调用封装的属性或方法，须采用  <code>对象名._类名__方法名</code>  和  <code>对象名._类名__变量名</code>  的方式（不建议调用）</p></blockquote><p>例如：</p><pre><code class="language-python">class Foo:    def __init__(self, height, weight):     # 构造方法        self.height = height        self.weight = weight        def __heightpow(self):      # 私有方法        return self.height * self.height        def tell_bmi(self):        return self.weight / self.__heightpow() # 私有成员可以被类内其它成员直接使用egon = Foo(1.7, 120)print(egon.tell_bmi())print(egon._Foo__heightpow())   # 尽管是私有成员方法，但也可以在类外调用以供查看</code></pre><h2 id="property"><a class="anchor" href="#property">#</a> property</h2><p>property 是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值（就是一个装饰器）</p><p>将一个类的方法  <code>func_name</code>  用 propery 装饰以后，类对象  <code>obj</code>  可直接通过  <code>obj.func_name</code>  去使用，以遵循统一访问的原则</p><blockquote><p>被 property 装饰的属性会优先于对象的属性被使用</p></blockquote><p>被 propery 装饰的属性分成三种：</p><ul><li>property</li><li>被装饰的函数名.setter</li><li>被装饰的函数名.deleter</li></ul><p>例如， <code>@property</code>  把类中的方法伪装成属性：</p><pre><code class="language-python">from math import piclass Circle:    def __init__(self, radius):        self.radius = radius    @property   # 装饰器：将一个方法当成一个属性用    def area(self):        return self.radius * self.radius * pi    @property    def peimeter(self):        return 2 * pi * self.radiusc = Circle(10)print(c.area)       # 当成一个属性来调用（即，不需要加括号）print(c.peimeter)   # 当成一个属性来调用（即，不需要加括号）</code></pre><p>注意：此时的特性 area 和 perimeter 不能被赋值</p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTWljaGFlbC0tY2hlbi9wLzY3NDA0NTUuaHRtbA==">Python 基础之封装</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGFpeWFuMTIzL3AvNzM2NzM0My5odG1s">Python 封装</span></li></ul><h1 id="继承"><a class="anchor" href="#继承">#</a> 继承</h1><p>继承允许我们定义继承（复制）另一个类的所有方法和属性的类</p><p>继承可以分为：</p><ul><li>单继承：一个类继承另一个类</li><li>多继承：一个类继承多个类，按照顺序从左向右依次继承</li></ul><p>父类是被继承的类，也称为基类</p><p>子类是从另一个类继承所得的类，也称为派生类</p><h2 id="单继承"><a class="anchor" href="#单继承">#</a> 单继承</h2><blockquote><p>任何类都可以是父类，因此，创建父类的语法与创建任何其他类相同</p></blockquote><p>要创建从其他类继承功能的类，只需在创建子类时将父类作为参数传递即可：</p><pre><code class="language-python">class DerivedClassName(BaseClassName):    &lt;statement-1&gt;    ...    &lt;statement-N&gt;</code></pre><p>其中， <code>DerivedClassName</code>  为子类名， <code>BaseClassName</code>  为父类名</p><blockquote><p>如果不希望向子类中添加任何其他属性或方法，可使用  <code>pass</code>  关键字</p></blockquote><p>例如：</p><pre><code class="language-python"># 创建 Person 类class Person:    def __init__(self, fname, lname):        self.firstname = fname        self.lastname = lname    def print_name(self):    print(self.firstname, self.lastname)# 创建 Person 类对象，并执行 print_name 方法x = Person(&quot;Bill&quot;, &quot;Gates&quot;)x.print_name()# 创建继承自 Person 类的子类 Studentclass Student(Person):    def __init__(self, fname, lname, gra):        self.firstname = fname        self.lastname = lname        self.grade = gra        def print_info(self):        print(self.firstname, self.lastname, self.grade)# 使用 Student 类创建一个对象，然后执行 print_name 和 print_info 方法y = Student(&quot;Elon&quot;, &quot;Musk&quot;, 6)y.print_name()y.print_info()</code></pre><h2 id="多继承"><a class="anchor" href="#多继承">#</a> 多继承</h2><p>创建子类的语法：</p><pre><code class="language-python">class DerivedClassName(Base1, Base2, Base3):    &lt;statement-1&gt;    ...    &lt;statement-N&gt;</code></pre><p>如果多个父类中含有同名的成员，那么默认按照从左向右顺序依次继承，先继承的保留，后继承的被覆盖</p><h2 id="方法重写"><a class="anchor" href="#方法重写">#</a> 方法重写</h2><p>子类继承父类的成员属性和成员方法后，如果对其 “不满意”，可以在子类重写父类的方法</p><p>即：在子类中重新定义同名的属性或方法</p><p>例如：</p><pre><code class="language-python">class Parent:           # 定义父类    def myMethod(self):        print ('调用父类方法')class Child(Parent):    # 定义子类    def myMethod(self):  # 重写父类方法        print ('调用子类方法')c = Child()          # 子类实例c.myMethod()         # 子类调用重写方法</code></pre><h2 id="调用父类同名成员"><a class="anchor" href="#调用父类同名成员">#</a> 调用父类同名成员</h2><p>一旦在子类中重写父类成员以后，子类的类对象调用成员时将是调用复写后的新成员</p><p>如果需要使用被复写的父类的成员，需要特殊的调用方式:</p><ul><li><p>方式一：通过父类调用（单继承</p><ul><li>调用父类成员变量： <code>父类名.成员变量</code></li><li>调用父类成员方法： <code>父类名.成员方法(self)</code></li></ul></li><li><p>方式二：使用  <code>super()</code>  调用</p><ul><li>调用父类成员变量： <code>super().成员变量</code></li><li>调用父类成员方法： <code>super().成员方法()</code></li></ul></li></ul><p>如果是单继承的情况，可以直接用父类名调用父类方法</p><p>但是，如果是多继承的情况，可能会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题，此时，推荐采用  <code>super()</code>  函数调用，以解决多重继承问题。具体可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24vcHl0aG9uLWZ1bmMtc3VwZXIuaHRtbA==">Python super () 函数</span></p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3B5dGhvbi9weXRob25faW5oZXJpdGFuY2UuYXNw">Python 继承</span></li></ul><h1 id="类型注解"><a class="anchor" href="#类型注解">#</a> 类型注解</h1><p>类型注解：在代码中涉及数据交互的地方，提供数据类型的注解（显式的说明）</p><ul><li>帮助第三方 IDE 工具（如 PyCharm）对代码进行类型推断，协助做代码提示</li><li>帮助开发者自身对变量进行类型注释</li></ul><p>有两种注解：</p><ul><li>变量的类型注解</li><li>函数（方法）的类型注解</li></ul><p>需注意：类型注解仅仅是提示性的，不是决定性的，并不会真正地对类型做验证和判断（也就是说：即使注解的数据类型与实际数据类型不一致，程序也不会报错）</p><h2 id="变量的类型注解"><a class="anchor" href="#变量的类型注解">#</a> 变量的类型注解</h2><p>事实上，对于显式的变量定义，一般无需注解。即便不写类型注解，也可以明确知晓变量的类型</p><p>一般而言，在无法直接看出变量类型时（例如，将函数返回值赋给一个变量时），才会添加变量的类型注解</p><h3 id="方式一常用"><a class="anchor" href="#方式一常用">#</a> 方式一（常用）</h3><p>基础语法：</p><pre><code class="language-python">变量: 类型</code></pre><p>例如：</p><p>基础数据类型注解：</p><pre><code class="language-python">var1: int = 3var2: float = 3.14var3: bool = True</code></pre><p>类对象类型注解:</p><pre><code class="language-python">class Person:    passp: Person = Person()</code></pre><p>容器类型简易注解：</p><pre><code class="language-python">mylist: list = [1, 2, 3]mytuple: tuple = (1, 2, 3)myset: set = &#123;1, 2, 3&#125;mydict: dict = &#123;0: &quot;a&quot;, 1: &quot;b&quot;&#125;mystr: str = &quot;Jiankychen&quot;</code></pre><p>容器类型详细注解：</p><ul><li>元组类型设置类型详细注解：需要将每一个元素都标记出来</li><li>字典类型设置类型详细注解：需要 2 个类型，第一个是 key ，第二个是 value</li></ul><pre><code class="language-python">mylist: list[int] = [1, 2, 3]mytuple: tuple[str, int, bool] = (&quot;a&quot;, 0, True)myset: set[int] = &#123;1, 2, 3&#125;mydict: dict[int, str] = &#123;0: &quot;a&quot;, 1: &quot;b&quot;&#125;</code></pre><h3 id="方式二"><a class="anchor" href="#方式二">#</a> 方式二</h3><p>除了使用  <code>变量: 类型</code>  这种语法做注解外，也可以 <strong>在注释中进行类型注解</strong></p><p>基础语法：</p><pre><code class="language-python"># type: 类型</code></pre><p>例如：</p><pre><code class="language-python">class Person:    passdef func():    return 3.14159var1 = random.randint(1, 10)    # type: intvar2 = Person()                 # type: Personvar3 = func()                   # type: float</code></pre><h2 id="函数方法的类型注解"><a class="anchor" href="#函数方法的类型注解">#</a> 函数（方法）的类型注解</h2><h3 id="形参注解"><a class="anchor" href="#形参注解">#</a> 形参注解</h3><p>函数（方法）的形参类型注解语法：</p><pre><code class="language-python">def func_name(形参名: 类型, 形参名: 类型, ...)    statement</code></pre><p>例如：</p><pre><code class="language-python">def add(x: int, y: int):    return x + y</code></pre><h3 id="返回值注解"><a class="anchor" href="#返回值注解">#</a> 返回值注解</h3><p>函数（方法）的返回值也是可以添加类型注解的，语法如下：</p><pre><code class="language-python">def func_name() -&gt; 返回值类型:    statement</code></pre><p>例如：</p><pre><code class="language-python">def func(data: list) -&gt; list:    return data</code></pre><h2 id="union-类型"><a class="anchor" href="#union-类型">#</a> Union 类型</h2><p>通过  <code>Union</code>  可以定义联合类型</p><ul><li>导包： <code>from typing import Union</code></li><li>使用： <code>Union[类型, ..., 类型]</code></li></ul><p>在变量注解、函数（方法）形参和返回值注解中，均可使用  <code>Union</code>  联合类型</p><p>例如：</p><pre><code class="language-python">from typing import Unionmylist: list[Union[str, int]] = [1, 2, &quot;3&quot;, &quot;4&quot;]    # list 元素的数据类型可能是 str ，也可能是 intmydict: dict[str, Union[str, int]] = &#123;&quot;name&quot;: &quot;Jiankychen&quot;, &quot;age&quot;: 24&#125;      # value 的数据类型可能是 str ，也可能是 intdef func(data: Union[int, str]) -&gt; Union[int, str]:    return data</code></pre><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVT9wPTEyMg==">黑马程序员 Python 教程：类型注解</span></li></ul><h1 id="多态"><a class="anchor" href="#多态">#</a> 多态</h1><p>多态：多种状态，即：对于某个行为（函数），使用不同的对象将会得到不同的状态</p><p>例如： <code>Cat</code>  类和  <code>Dog</code>  类都有  <code>speak</code>  成员方法， <code>Cat</code>  类对象和  <code>Dog</code>  类对象都能被传入  <code>command</code>  函数；但是由于两个类定义的  <code>speak</code>  方法的功能不一致，传入不同类的对象就会得到不同的状态</p><pre><code class="language-python">class Cat:    def speak(self):        print &quot;meow!&quot;class Dog:    def speak(self):        print &quot;woof!&quot;def command(pet):    pet.speak()cat = Cat()command(cat)    # 输出：meow!dog = Dog()command(dog)    # 输出：woof!</code></pre><p>多态常作用在继承关系上，比如：定义函数（方法），通过类型注解声明需要父类对象，实际传入子类对象进行工作，从而获得不同的工作状态</p><p>例如，可以将上例中的代码修改为：</p><pre><code class="language-python">class Pet:    def speak(self)        passclass Cat(Pet):    def speak(self):        print &quot;meow!&quot;class Dog(Pet):    def speak(self):        print &quot;woof!&quot;def command(pet: Pet):  # 函数形参的类型注解    pet.speak()cat = Cat()command(cat)    # 输出：meow!dog = Dog()command(dog)    # 输出：woof!</code></pre><h2 id="抽象类接口"><a class="anchor" href="#抽象类接口">#</a> 抽象类（接口）</h2><p>抽象方法：没有具体实现的方法（即：方法体是  <code>pass</code>  语句）</p><p>抽象类：包含抽象方法的类，也可以称之为 接口，比如上例中的  <code>Pet</code>  类</p><p>抽象类相当于定义一个标准，包含了一些抽象的方法，要求子类必须实现</p><p>这种设计的意义在于：</p><ul><li>父类用来确定有哪些方法</li><li>具体的方法实现，由子类自行决定</li></ul><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVT9wPTEyMw==">黑马程序员 Python 教程：多态</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas 基础</title>
      <link href="/posts/ebba65fe/"/>
      <url>/posts/ebba65fe/</url>
      
        <content type="html"><![CDATA[<h1 id="安装及导入"><a class="anchor" href="#安装及导入">#</a> 安装及导入</h1><h2 id="安装"><a class="anchor" href="#安装">#</a> 安装</h2><p>可以使用 pip 安装</p><pre><code>pip install pandas</code></pre><h2 id="导入"><a class="anchor" href="#导入">#</a> 导入</h2><pre><code class="language-python">import pandas as pd</code></pre><h1 id="数据结构"><a class="anchor" href="#数据结构">#</a> 数据结构</h1><h2 id="series"><a class="anchor" href="#series">#</a> Series</h2><p>Series 是一种类似于一维数组的对象，它由一组数据（各种 Numpy 数据类型）以及一组与之相关的数据标签（即索引）组成</p><blockquote><p>Series 只有行索引</p></blockquote><p>例如，创建一个 Series 对象：</p><pre><code class="language-python">ser = pd.Series(data = [1, 2, 3], index = ['a', 'b', 'c'])</code></pre><p>其内容为：</p><pre><code>a   1b   2c   3</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9wYW5kYXMucHlkYXRhLm9yZy9kb2NzL3JlZmVyZW5jZS9zZXJpZXMuaHRtbA==">Series 的各种方法</span></p><h2 id="dataframe"><a class="anchor" href="#dataframe">#</a> DataFrame</h2><p>DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）</p><blockquote><p>DataFrame 既有行索引又有列索引</p></blockquote><p>例如，创建一个 DataFrame 对象：</p><pre><code class="language-python">df = pd.DataFrame(data = np.array([[1, 2, 3], [4, 5, 6]]), columns = ['a', 'b', 'c'])</code></pre><p>其内容为：</p><pre><code>   a  b  c0  1  2  31  4  5  6</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9wYW5kYXMucHlkYXRhLm9yZy9kb2NzL3JlZmVyZW5jZS9mcmFtZS5odG1s">DataFrame 的各种方法</span></p><p>下面将以 DataFrame 对象为例来介绍 pandas 的基本用法</p><h1 id="数据输入"><a class="anchor" href="#数据输入">#</a> 数据输入</h1><pre><code class="language-python"># 使用 read_csv 读取 csv 文件df = pd.read_csv('file_name')# 或者：使用 read_csv 读取 csv 文件# read_csv 默认使用 '\t' 作为数据分隔符，需将分隔符设为 ','df = pd.read_table('file_name', sep=',')# 读取 excel 文件pd.read_excel()# 读取 json 文件pd.json()# 读取 xml 文件pd.read_xml()</code></pre><h1 id="数据输出"><a class="anchor" href="#数据输出">#</a> 数据输出</h1><pre><code class="language-python"># 将 DataFrame 对象写入 csv 文件df.to_csv('file_name')# 写入 excel 文件df.to_excel()# 写入 json 文件df.to_json()# 写入 xml 文件df.to_xml()</code></pre><p><span class="exturl" data-url="aHR0cDovL3BhbmRhcy5weWRhdGEub3JnL2RvY3MvcmVmZXJlbmNlL2lvLmh0bWw=">pandas 读取 / 写入文件</span></p><h1 id="查看数据"><a class="anchor" href="#查看数据">#</a> 查看数据</h1><pre><code class="language-python"># DataFrame 对象的头部数据（默认显示 5 条数据）df.head()# DataFrame 对象的尾部数据（默认显示 5 条数据）df.tail()# DataFrame 对象的索引df.index# DataFrame 对象的列名df.columns# DataFrame 对象的统计信息df.describe()# DataFrame 对象的摘要df.info()# DataFrame 对象的形状df.shape# 查看数据是否为空df.isnull()# 查看各数据类型df.dtypes# 查看某一列的所有值df[['column_name']]         # 方法一df.loc[:, ['column_name']]  # 方法二# 查看某一列的变量名及种类df['column_name'].value_counts()    # 方法一df['column_name'].unique()          # 方法二# 查看满足条件的值df[condition]# 最大值对应的索引df.idxmax()# 最小值对应的索引df.idxmin()</code></pre><h1 id="缺失值处理"><a class="anchor" href="#缺失值处理">#</a> 缺失值处理</h1><p>pandas 主要用  <code>np.nan</code>  表示缺失数据</p><p>一般情况下，运算时默认排除缺失值</p><pre><code class="language-python"># 查找缺失值df.isnull()# 查找非缺失值df.notnull()# 删除所有含缺失值的行df.dropna(how='any')# 用 0 填充缺失值df.fillna(value=0)</code></pre><h1 id="重复值处理"><a class="anchor" href="#重复值处理">#</a> 重复值处理</h1><pre><code class="language-python"># 查看 DataFrame 数据中的重复值df.duplicated()# 统计 DataFrame 数据中重复值的个数df.duplicated().sum()# 删除 DataFrame 数据中的重复值df.drop_duplicates()</code></pre><h1 id="索引变换"><a class="anchor" href="#索引变换">#</a> 索引变换</h1><pre><code class="language-python"># 重置索引df.reset_index()# 将现有的列设为索引df.set_index('column_name')# 修改索引与列标签df.reindex(index=index_labels, columns=column_labels)   # 方法一df.rename(index=index_labels, columns=column_labels)    # 方法二</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzcwMDg0MDM=">reindex 和 rename</span></p><h1 id="排序"><a class="anchor" href="#排序">#</a> 排序</h1><pre><code class="language-python"># 按索引排序df.sort_index()# 按行列的值排序df.sort_values()# 按某一列排序df.sort_values(by='column_name')# 按多列排序df.sort_values(by=['column_name_1', 'column_name_2'])</code></pre><p>特别地，如果数据含有空值，可以用  <code>na_position</code>  参数处理空值，例如：</p><pre><code class="language-python">df.sort_values(na_position='first')</code></pre><h1 id="特征处理"><a class="anchor" href="#特征处理">#</a> 特征处理</h1><pre><code class="language-python">按照数据的值进行离散化pd.cut()# 按照数据的数量进行离散化pd.qcut()# 替换数据值df.replace()# 替换数据值df.map()# one-hot 编码pd.get_dummies()</code></pre><p>具体用法请参考 <span class="exturl" data-url="aHR0cDovL3BhbmRhcy5weWRhdGEub3JnL2RvY3MvcmVmZXJlbmNlLw==">pandas Document</span></p><h1 id="数据拼接"><a class="anchor" href="#数据拼接">#</a> 数据拼接</h1><pre><code class="language-python"># 既可以横向拼接，又可以纵向拼接pd.concat()# 横向拼接pd.merge()# 横向拼接 DataFrame 对象df.join()# 纵向拼接 DataFrame 对象df.append()</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9wYW5kYXMucHlkYXRhLm9yZy9wYW5kYXMtZG9jcy9zdGFibGUvdXNlcl9ndWlkZS9tZXJnaW5nLmh0bWwj">Merge, join, concatenate and compare</span></p><h1 id="数据分组"><a class="anchor" href="#数据分组">#</a> 数据分组</h1><ul><li>分割：按条件把数据分割成多组</li><li>应用：为每组单独应用函数</li><li>组合：将处理结果组合成一个数据结构</li></ul><p>具体请参考：<span class="exturl" data-url="aHR0cHM6Ly9wYW5kYXMucHlkYXRhLm9yZy9wYW5kYXMtZG9jcy9zdGFibGUvdXNlcl9ndWlkZS9ncm91cGJ5Lmh0bWwj">Groupby API</span></p><h1 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h1><ul><li><span class="exturl" data-url="aHR0cDovL3BhbmRhcy5weWRhdGEub3JnL2RvY3MvcmVmZXJlbmNlLw==">pandas 官方文档</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHlwYW5kYXMuY24vZG9jcy9nZXR0aW5nX3N0YXJ0ZWQvdHV0b3JpYWxzLmh0bWw=">pandas 教程资料</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHlwYW5kYXMuY24vZG9jcy9nZXR0aW5nX3N0YXJ0ZWQvMTBtaW4uaHRtbA==">十分钟入门 pandas</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>conda 常用命令</title>
      <link href="/posts/b80c5159/"/>
      <url>/posts/b80c5159/</url>
      
        <content type="html"><![CDATA[<h1 id="conda-基本操作"><a class="anchor" href="#conda-基本操作">#</a> conda 基本操作</h1><h2 id="查看-conda-版本"><a class="anchor" href="#查看-conda-版本">#</a> 查看 conda 版本</h2><pre><code>conda --version</code></pre><h2 id="更新-conda"><a class="anchor" href="#更新-conda">#</a> 更新 conda</h2><pre><code>conda update conda</code></pre><h2 id="查看-conda-环境配置"><a class="anchor" href="#查看-conda-环境配置">#</a> 查看 conda 环境配置</h2><pre><code>conda config --show</code></pre><h2 id="设置镜像源"><a class="anchor" href="#设置镜像源">#</a> 设置镜像源</h2><pre><code># 设置清华镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/# 设置 biocondaconda config --add channels biocondaconda config --add channels conda-forge# 设置搜索时显示通道地址conda config --set show_channel_urls yes</code></pre><h2 id="查询指定命令的功能"><a class="anchor" href="#查询指定命令的功能">#</a> 查询指定命令的功能</h2><pre><code>conda command_name --help</code></pre><h1 id="管理环境"><a class="anchor" href="#管理环境">#</a> 管理环境</h1><h2 id="显示所有虚拟环境"><a class="anchor" href="#显示所有虚拟环境">#</a> 显示所有虚拟环境</h2><pre><code>conda env list</code></pre><h2 id="创建虚拟环境"><a class="anchor" href="#创建虚拟环境">#</a> 创建虚拟环境</h2><pre><code>conda create -n env_name package_name</code></pre><p>如果需要指定 package 版本，可直接在 package_name 之后加上  <code>=</code>  号以及 package 版本号，例如：</p><pre><code>conda create -n env_name python=3.x</code></pre><p>如果需要安装多个 package ，在 env_name 之后用空格分隔多个 package_name 即可，例如：</p><pre><code>conda create -n python310 python=3.10 numpy pandas</code></pre><h2 id="激活环境"><a class="anchor" href="#激活环境">#</a> 激活环境</h2><pre><code>activate env_name</code></pre><h2 id="退出环境"><a class="anchor" href="#退出环境">#</a> 退出环境</h2><pre><code>deactivate env_name</code></pre><h2 id="删除虚拟环境"><a class="anchor" href="#删除虚拟环境">#</a> 删除虚拟环境</h2><pre><code>conda env remove -n env_name</code></pre><h2 id="导出虚拟环境"><a class="anchor" href="#导出虚拟环境">#</a> 导出虚拟环境</h2><pre><code>conda env export --name env_name &gt; environment.yml</code></pre><h2 id="导入虚拟环境"><a class="anchor" href="#导入虚拟环境">#</a> 导入虚拟环境</h2><pre><code>conda env create -n env_name -f environment.yml</code></pre><h1 id="管理-package"><a class="anchor" href="#管理-package">#</a> 管理 package</h1><h2 id="查看当前环境包含的所有-package"><a class="anchor" href="#查看当前环境包含的所有-package">#</a> 查看当前环境包含的所有 package</h2><pre><code>conda list</code></pre><h2 id="更新当前环境包含的所有-package"><a class="anchor" href="#更新当前环境包含的所有-package">#</a> 更新当前环境包含的所有 package</h2><pre><code>conda upgrade --all</code></pre><h2 id="更新指定-package"><a class="anchor" href="#更新指定-package">#</a> 更新指定 package</h2><pre><code>conda update package_name</code></pre><h2 id="安装指定-package"><a class="anchor" href="#安装指定-package">#</a> 安装指定 package</h2><pre><code>conda install package_name</code></pre><p>安装装多个 package ：</p><pre><code>conda installl package_name_1 package_name_2 package_name_3</code></pre><p>安装固定版本的 package ：</p><pre><code>conda install package_name=package_version_number</code></pre><h2 id="移除指定-package"><a class="anchor" href="#移除指定-package">#</a> 移除指定 package</h2><pre><code>conda remove package_name </code></pre><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82Nzc0NTE2MA==">conda 常用命令</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW54eV9id2F2ZS9hcnRpY2xlL2RldGFpbHMvMTE5OTk2MDAx">Anaconda conda 常用命令：从入门到精通</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 异常、模块、包</title>
      <link href="/posts/11ea1840/"/>
      <url>/posts/11ea1840/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a class="anchor" href="#异常">#</a> 异常</h1><p>异常是指程序运行的过程中出现了错误</p><blockquote><p>bug 就是指异常，历史上因为小虫子导致计算机失灵，所以延续至今，bug 就代表软件出现错误</p></blockquote><h2 id="异常的捕获"><a class="anchor" href="#异常的捕获">#</a> 异常的捕获</h2><p>异常处理（捕获异常）：针对可能出现的异常，提前做好准备，当真的出现异常时，可以有后续处置，以免其导致程序无法正常运行</p><h3 id="捕获常规异常"><a class="anchor" href="#捕获常规异常">#</a> 捕获常规异常</h3><p>语法：</p><pre><code class="language-python">try:    尝试执行的代码except:    若出现异常，将会执行本段代码</code></pre><p>例如：</p><pre><code class="language-python"># 尝试以 'r' 模式打开文件，如果文件不存在，则以 'w' 方式打开try:    f = open('linux.txt', 'r')except:    f = open('linux.txt', 'w')</code></pre><h3 id="捕获指定异常"><a class="anchor" href="#捕获指定异常">#</a> 捕获指定异常</h3><pre><code class="language-python">try:    尝试执行的代码except ErrorType as e:    若出现类型为 ErrorType 的异常，将会执行本段代码</code></pre><p>其中，ErrorType 是指要捕获的异常类型</p><p>注意：如果 “尝试执行的代码” 的异常类型和要捕获的异常类型不一致，则无法捕获异常</p><p>常见的异常类型如下表所示：</p><table><thead><tr><th style="text-align:center">类名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>SyntaxError</code></td><td style="text-align:center">发生语法错误时引发</td></tr><tr><td style="text-align:center"><code>FileNotFoundError</code></td><td style="text-align:center">未找到指定文件或目录时引发</td></tr><tr><td style="text-align:center"><code>NameError</code></td><td style="text-align:center">找不到指定名称的变量时引发</td></tr><tr><td style="text-align:center"><code>ZeroDivisionError</code></td><td style="text-align:center">除数为 0 时的异常</td></tr><tr><td style="text-align:center"><code>IndexError</code></td><td style="text-align:center">当使用超出列表范围的索引时引发</td></tr><tr><td style="text-align:center"><code>KeyError</code></td><td style="text-align:center">当使用映射不存在的键时引发</td></tr><tr><td style="text-align:center"><code>AttributeError</code></td><td style="text-align:center">当尝试访问未知对象属性时引发</td></tr><tr><td style="text-align:center"><code>TypeError</code></td><td style="text-align:center">当试图在使用 a 类型的场合使用 b 类型时引发</td></tr></tbody></table><p>例如：</p><pre><code class="language-python">try:    print(name)except NameError as e:    print('未定义 name 变量')</code></pre><h3 id="捕获多个异常"><a class="anchor" href="#捕获多个异常">#</a> 捕获多个异常</h3><p>当需要捕获多个异常时，可以把要捕获的异常类型的名字，放到 except 后，并使用元组的方式进行书写</p><p>例如：</p><p>捕获多个异常（但不输出异常的具体描述）：</p><pre><code class="language-python">try:    print(1 / 0)except (NameError, ZeroDivisionError):    print('错误...')</code></pre><p>捕获多个异常并输出异常的具体信息：</p><pre><code class="language-python">try:    print(num)except (NameError, ZeroDivisionError) as e:    print(e)</code></pre><h3 id="捕获所有异常"><a class="anchor" href="#捕获所有异常">#</a> 捕获所有异常</h3><pre><code class="language-python">try:    尝试执行的代码except Exception as e:    若出现异常，将会执行本段代码</code></pre><p>注意： <code>except:</code>  与  <code>except Exception as e:</code>  这两种方式都可以捕获全部的异常</p><h3 id="异常-else"><a class="anchor" href="#异常-else">#</a> 异常 else</h3><p><code>else</code>  表示没有异常时要执行的代码</p><pre><code class="language-python">try:    尝试执行的代码except Exception as e:    若出现异常，将会执行本段代码else:    若没有出现异常，将会执行本段代码</code></pre><h3 id="异常-finally"><a class="anchor" href="#异常-finally">#</a> 异常 finally</h3><p><code>finally</code>  表示无论是否异常都要执行的代码，例如关闭文件</p><pre><code class="language-python">try:    尝试执行的代码except Exception as e:    若出现异常，将会执行本段代码else:    若没有出现异常，将会执行本段代码finally:    无论是否出现异常，都会执行本段代码</code></pre><h3 id="异常的传递"><a class="anchor" href="#异常的传递">#</a> 异常的传递</h3><p>异常具有传递性：</p><ul><li><p>当函数 / 方法执行出现异常，会将异常传递给函数 / 方法的调用一方</p></li><li><p>如果传递到主程序，仍然没有异常处理，程序才会被终止</p></li></ul><p>利用异常具有传递性的特点，当我们想要保证程序不会因为异常崩溃的时候，就可以在  <code>main</code>  函数中设置异常捕获，由于无论在整个程序哪里发生异常，最终都会传递到  <code>main</code>  函数中，这样就可以确保所有的异常都会被捕获</p><h1 id="模块"><a class="anchor" href="#模块">#</a> 模块</h1><p>Python 模块（Module），是一个 Python 文件，以  <code>.py</code>  为后缀名</p><p>模块能定义函数、类和变量，模块里也能包含可执行的代码</p><p>可以认为一个模块就是一个工具包，每一个工具包中都有各种不同的工具供我们使用，以实现各种不同的功能</p><h2 id="导入模块"><a class="anchor" href="#导入模块">#</a> 导入模块</h2><p>在使用模块之前，需要先将模块导入 Python 程序</p><p>常用的导入模块方式：</p><pre><code class="language-python">import module_namefrom module_name import class_name, var_name, func_namefrom module_name import *import module_name as nick_namefrom module_name import func_name as nick_name</code></pre><p>其中：</p><ul><li>module_name 表示模块</li><li>class_name 表示模块内的类</li><li>var_name 表示模块内的变量</li><li>func_name 表示模块内的函数</li><li>nick_name 表示为模块自定义的别名</li></ul><p>注意：导入模块时，module_name 不需要包含  <code>.py</code>  后缀</p><h3 id="import-module_name"><a class="anchor" href="#import-module_name">#</a> import module_name</h3><p>使用  <code>import</code>  导入模块后，可以通过  <code>'.'</code>  来使用模块中的函数或类</p><pre><code class="language-python">import module_namemodule_name.func_name()module_name.class_namemodule_name.var_name</code></pre><h3 id="from-module_name-import-func_name"><a class="anchor" href="#from-module_name-import-func_name">#</a> from module_name import func_name</h3><p>使用  <code>from … import …</code>  方式导入之后，无需添加前缀，直接调用即可</p><pre><code class="language-python">from module_name import func_namefunc_name()</code></pre><p>注意，利用  <code>from</code>  把内容从模块中导入后，会导致相同名称的内容被覆盖，也就是说，不同模块的命名空间会在此处重叠</p><h3 id="from-module_name-import"><a class="anchor" href="#from-module_name-import">#</a> from module_name import *</h3><p>导入模块全部内容</p><pre><code class="language-python">from module_name import *func_name()class_namevar_name</code></pre><h3 id="as-nick_name"><a class="anchor" href="#as-nick_name">#</a> as nick_name</h3><pre><code class="language-python"># 模块定义别名import module_name as nick_name# 功能定义别名from module_name import func_name as func_nick_name</code></pre><h2 id="自定义模块"><a class="anchor" href="#自定义模块">#</a> 自定义模块</h2><p>每个 Python 文件都可以作为一个模块，模块的名字就是文件的名字</p><p>因此，自定义模块只需在 Python 代码文件中正常写代码即可，通过 import、from 关键字导入（与导入 Python 内置模块一样）即可使用。但是需要注意，自定义模块名必须要符合标识符命名规则</p><h3 id="__main__-变量"><a class="anchor" href="#__main__-变量">#</a> __main__ 变量</h3><p><code>if __main__ == “__main__”</code>  语句的作用：只有当含有该语句的 Python 程序是被直接 run 时，才会进入  <code>if</code>  内部。如果是被导入的，则无法进入  <code>if</code></p><p>该功能常用于测试模块（即，希望某些代码在测试时运行、而在被导入时不运行）</p><p>例如：</p><pre><code class="language-python">def test(a, b):    print(a + b)# 只在当前文件中调用该函数，其他导入的文件内均不执行 test 函数调用if __name__ == '__main__':    test (1, 1)</code></pre><p>如果不加  <code>if __name__ == &quot;__main__&quot;</code>  语句：无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行  <code>test</code>  函数的调用</p><h3 id="__all__-变量"><a class="anchor" href="#__all__-变量">#</a> __all__ 变量</h3><p>如果一个模块文件中有  <code>__all__</code>  变量（该变量为列表对象），在使用  <code>from xxx import *</code>  导入该模块时，只能导入  <code>__all__</code>  列表中的元素</p><p>因此， <code>__all__</code>  变量可以控制  <code>import *</code>  导入模块时的导入内容</p><p>注意： <code>__all__</code>  变量 仅影响  <code>from ... import *</code>  这一导入方式</p><p>例如，自定义如下模块：</p><pre><code class="language-python">__all__ = ['Test_A']def Test_A():    xxxdef Test_B():    xxx</code></pre><p>通过  <code>from ... import *</code>  导入该模块后，只能使用  <code>Test_A</code>  函数，而不能使用  <code>Test_B</code>  函数</p><h1 id="包"><a class="anchor" href="#包">#</a> 包</h1><p>如果 Python 模块太多，可以通过 Python 包（Package）来管理</p><p>当我们的模块文件非常多时，包可以帮助我们管理这些模块，包的作用就是包含多个模块，但包的本质依然是模块</p><ul><li><p>从物理上看：包就是一个文件夹，在该文件夹下包含了一个  <code>__init__.py</code>  文件，该文件夹可包含多个模块文件</p></li><li><p>从逻辑上看：包的本质依然是模块</p></li></ul><h2 id="自定义包"><a class="anchor" href="#自定义包">#</a> 自定义包</h2><p>基本步骤：</p><ul><li>新建 Python Package</li><li>新建 Python 模块</li></ul><p>在 Pycharm 中，点击  <code>new --&gt; Python Package</code>  新建包后，包内部会自动创建  <code>__init__.py</code>  文件，这个文件控制着包的导入行为</p><h2 id="导入包"><a class="anchor" href="#导入包">#</a> 导入包</h2><h3 id="import-xxx"><a class="anchor" href="#import-xxx">#</a> import xxx</h3><h4 id="导入所有模块"><a class="anchor" href="#导入所有模块">#</a> 导入所有模块</h4><pre><code class="language-python">import package_namepackage_name.module_name.func_name()</code></pre><h4 id="导入指定模块"><a class="anchor" href="#导入指定模块">#</a> 导入指定模块</h4><pre><code class="language-python">import package_name.module_namepackage_name.module_name.func_name()</code></pre><p>其中：</p><ul><li>package_name 表示 Python Package 名称</li><li>module_name 表示 Python Package 中的模块名称</li><li>func_name 表示模块中的函数名称</li></ul><h3 id="from-xxx-import"><a class="anchor" href="#from-xxx-import">#</a> from xxx import</h3><h4 id="导入所有模块-2"><a class="anchor" href="#导入所有模块-2">#</a> 导入所有模块</h4><pre><code class="language-python">from package_name import *module_name.func_name()</code></pre><p>注意：必须在  <code>__init__.py</code>  文件中添加  <code>__all__</code>  变量，用于控制  <code>from package_name import *</code>  导入的模块列表（类似于模块文件中的  <code>__all__</code>  变量）</p><h4 id="导入指定模块-2"><a class="anchor" href="#导入指定模块-2">#</a> 导入指定模块</h4><pre><code class="language-python">from package_name import module_namemodule_name.func_name()</code></pre><h4 id="导入指定模块中的指定函数"><a class="anchor" href="#导入指定模块中的指定函数">#</a> 导入指定模块中的指定函数</h4><pre><code class="language-python">from package_name.module_name import func_namefunc_name()</code></pre><h2 id="第三方包"><a class="anchor" href="#第三方包">#</a> 第三方包</h2><p>在 Python 程序的生态中，有许多非常多的第三方包（非 Python 官方），可以极大的帮助我们提高开发效率，如：</p><ul><li>科学计算：numpy</li><li>数据分析：pandas</li><li>大数据计算：pyspark、apache-flink</li><li>图形可视化：matplotlib、pyecharts</li><li>人工智能：tensorflow</li></ul><p>注意，Python 没有内置这些第三方包，需要安装它们才可以导入使用</p><p>可通过 Python 内置的 pip 安装指定的第三方包</p><p>即，在命令行中输入：</p><pre><code class="language-python">pip install package_name</code></pre><p>pip 是连接外网进行下载，若下载速度相对较慢，可考虑通过国内的镜像源下载</p><p>例如：</p><pre><code class="language-python">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple package_name</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 文件操作</title>
      <link href="/posts/78c82d0a/"/>
      <url>/posts/78c82d0a/</url>
      
        <content type="html"><![CDATA[<h1 id="文件编码"><a class="anchor" href="#文件编码">#</a> 文件编码</h1><p>编码：一种规则集合，记录了内容和二进制间进行相互转换的逻辑</p><p>计算机中有许多可用编码，例如：</p><ul><li>UTF-8</li><li>GBK</li><li>Big5</li></ul><p>UTF-8 是目前全球通用的编码格式</p><p>除非有特殊需求，否则，一律以 UTF-8 格式进行文件编码即可</p><h1 id="文件的读取"><a class="anchor" href="#文件的读取">#</a> 文件的读取</h1><h2 id="访问模式"><a class="anchor" href="#访问模式">#</a> 访问模式</h2><p>常用的三种基础访问模式：</p><ul><li><code>'r'</code>  ：以 <strong>只读</strong> 方式打开文件（默认模式）。文件的指针将会放在文件的开头</li><li><code>'w'</code>  ：打开文件只用于 <strong>写入</strong> 。如果该文件已存在，则打开文件，并从开头开始编辑（原有内容会被删除）；如果该文件不存在，创建新文件</li><li><code>'a'</code>  ：打开一个文件用于 <strong>追加</strong> 。如果该文件已存在，新的内容将会被写入到已有内容之后；如果该文件不存在，创建新文件进行写入</li></ul><h2 id="打开文件"><a class="anchor" href="#打开文件">#</a> 打开文件</h2><p>使用  <code>open</code>  函数可以打开一个已经存在的文件，或者创建一个新文件（使用  <code>'w'</code>  模式时）</p><pre><code class="language-python">open(name, mode, encoding)</code></pre><p>其中：</p><ul><li>name：字符串，表示目标文件的文件名（可以包含文件所在的路径）</li><li>mode：设置打开文件的模式（访问模式）：只读、写入、追加等</li><li>encoding：编码格式（推荐使用 UTF-8）</li></ul><p><strong>操作文件需要通过  <code>open</code>  函数打开文件得到文件对象</strong></p><p>例如：</p><pre><code class="language-python"># encoding 不是第三个位置参数，需要采用关键字传参file_obj = open('python.txt', 'r', encoding='UTF-8')</code></pre><p>注意：此时的  <code>file_obj</code>  是  <code>open</code>  函数的文件对象（Python 中一种特殊的数据类型），拥有属性和方法，可以使用  <code>对象.属性</code>  或  <code>对象.方法</code>  对其进行访问</p><h2 id="关闭文件"><a class="anchor" href="#关闭文件">#</a> 关闭文件</h2><p><code>close</code>  关闭文件对象，即，关闭对文件的占用</p><pre><code class="language-python">file_obj.close()</code></pre><p>如果不调用  <code>close</code>  ，并且程序没有停止运行，那么这个文件将一直被 Python 程序占用（除  <code>with open</code>  语法外）</p><h2 id="读操作"><a class="anchor" href="#读操作">#</a> 读操作</h2><h3 id="read-方法"><a class="anchor" href="#read-方法">#</a> read 方法</h3><p><code>read</code>  可以读取给定长度的数据</p><pre><code class="language-python">file_obj.read(num)</code></pre><p>其中，num 表示要从文件中读取的数据的长度（字节数）。如果没有传入 num，表示读取文件中所有的数据</p><h3 id="readlines-方法"><a class="anchor" href="#readlines-方法">#</a> readlines 方法</h3><p><code>readlines</code>  可以一次性读取整个文件中的内容。 <code>readlines</code>  返回的是一个列表，其中，文件每一行的数据对应列表的一个元素</p><pre><code class="language-python">file_obj.readlines()</code></pre><h3 id="readline-方法"><a class="anchor" href="#readline-方法">#</a> readline 方法</h3><p><code>readline</code>  一次读取一行数据</p><pre><code class="language-python">file_obj.readline()</code></pre><h3 id="for-循环读取文件行"><a class="anchor" href="#for-循环读取文件行">#</a> for 循环读取文件行</h3><p>可以使用  <code>for</code>  循环遍历读取文件的每一行内容</p><pre><code class="language-python"># 临时变量 line 记录文件的一行数据for line in open(name, mode, encoding):    print(line)</code></pre><h3 id="with-open-语法"><a class="anchor" href="#with-open-语法">#</a> with open 语法</h3><p>通过在  <code>with open</code>  的语句块中对文件进行操作，可以在操作完成后自动关闭文件，避免因忘记  <code>close</code>  文件对象而导致文件被占用</p><pre><code class="language-python">with open(name, mode, encoding) as file_obj:    file_obj.readlines()</code></pre><h1 id="文件的写入"><a class="anchor" href="#文件的写入">#</a> 文件的写入</h1><h2 id="打开文件-2"><a class="anchor" href="#打开文件-2">#</a> 打开文件</h2><pre><code class="language-python">file_obj = open(name, mode='w', encoding='UTF-8')</code></pre><p>使用  <code>'w'</code>  模式时：</p><ul><li>如果文件不存在，会创建新文件</li><li>如果文件存在，会将原有内容清空</li></ul><h2 id="写操作"><a class="anchor" href="#写操作">#</a> 写操作</h2><pre><code class="language-python">file_obj.write(content)</code></pre><p><code>content</code>  表示需要写入的内容</p><p>注意：调用  <code>write</code>  时，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区</p><p>当调用  <code>flush</code>  时，内容会真正写入文件</p><pre><code class="language-python">file_obj.flush()</code></pre><blockquote><p><code>write</code>  写入内容 +  <code>flush</code>  刷新内容到硬盘，这样做是避免因频繁操作硬盘而导致效率下降</p></blockquote><h2 id="关闭文件-2"><a class="anchor" href="#关闭文件-2">#</a> 关闭文件</h2><pre><code class="language-python">file_obj.close()</code></pre><p>注意： <code>close</code>  方法内置了  <code>flush</code>  的功能</p><h1 id="文件的追加写入"><a class="anchor" href="#文件的追加写入">#</a> 文件的追加写入</h1><h2 id="打开文件-3"><a class="anchor" href="#打开文件-3">#</a> 打开文件</h2><pre><code class="language-python">file_obj = open(name, 'a', encoding='UTF-8')</code></pre><p>使用 'a' 模式时：</p><ul><li>如果文件不存在，会创建文件</li><li>如果文件存在，会在文件最后追加写入</li></ul><h2 id="追加写入操作"><a class="anchor" href="#追加写入操作">#</a> 追加写入操作</h2><pre><code class="language-python"># 写入内容 contentfile_obj.write(content)# 刷新内容file_obj.flush()</code></pre><h2 id="关闭文件-3"><a class="anchor" href="#关闭文件-3">#</a> 关闭文件</h2><pre><code class="language-python">file_obj.close()</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVS8=">黑马程序员</span></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23 求职笔面试</title>
      <link href="/posts/1da13fbe/"/>
      <url>/posts/1da13fbe/</url>
      
        <content type="html"><![CDATA[<h1 id="tp-link嵌入式软件"><a class="anchor" href="#tp-link嵌入式软件">#</a> TP-Link（嵌入式软件）</h1><h2 id="笔试"><a class="anchor" href="#笔试">#</a> 笔试</h2><p>选择题：</p><ul><li>物理层设备</li><li>可能会出现进程饿死的进程调度算法</li><li>调用 Fork 后，产生的子进程保留了父进程的什么</li><li>Huffman 编码</li><li>采用 LRU 算法时，进程访问过程中的缺页次数、缺页率</li><li>二叉树中序遍历所需栈高度与什么有关</li><li>利用栈来执行带括号的算术表达式，对于某个表达式所需的最小栈大小</li><li>排序算法的时间复杂度</li><li>给出两段程序（递归版本、非递归版本），比较</li><li>回文字符串的判断（选出一项，补全代码）</li></ul><p>简答题：</p><ul><li>内存越界是什么，内存越界是否会导致程序崩溃，为什么，举例说明内存越界会造成那些后果</li><li>Java 中的 CAS 机制原理（选做）</li><li>双向链表中的节点替换（补全代码）</li><li>7 位电话号码，给定超过一百万个的电话号码，对电话号码去重，排序，存储号码的内存 buffer 限制为 1MB</li></ul><p>编程题：</p><ul><li>环形链表 II （<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">力扣 142</span>）：核心代码模式</li><li>乘积最大子数组（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkv">力扣 152</span>）：ACM 模式</li></ul><p>选择题、简答题、编程题一共 60 分钟</p><p>行测：（每部分 10 分钟）</p><ul><li>言语理解与表达</li><li>判断推理</li><li>图形推理</li><li>数量关系</li></ul><h2 id="一面"><a class="anchor" href="#一面">#</a> 一面</h2><p>宏</p><p>快速排序、选择排序的基本原理</p><p>全局变量、局部变量、静态变量</p><p>解决哈希冲突的方法</p><p>介绍拉链法的原理</p><p>OSI 参考模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p>第一轮面试一共 10 分钟</p><h2 id="二面"><a class="anchor" href="#二面">#</a> 二面</h2><p>智力题：7g 砝码和 2g 砝码各一个，天平一个，如何用最少次数将 140g 盐分成 50g 和 90g 各一份？</p><ul><li>正确答案：最少需要操作三次<ul><li>利用天平将 140g 盐分成两份 70g</li><li>利用 9g 砝码将 70g 盐分成 9g 和 61g</li><li>利用 2g 砝码与 9g 盐将 61g 盐分成 11g 和 50g</li></ul></li></ul><p>算法题：二叉树的最近公共祖先（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">力扣 236</span>）</p><ul><li>先讲思路，再在自己的 IDE 上编程实现（核心代码模式）</li></ul><p>最后问了项目，大概 10 分钟左右</p><p>第二轮面试一共 40 分钟</p><h2 id="三面"><a class="anchor" href="#三面">#</a> 三面</h2><p>自我介绍</p><p>本科成绩是什么情况？是保研的吗？</p><p>为嵌入式软件岗做了哪些相关准备？</p><p>计算机网络、操作系统、数据结构与算法学过吗？</p><p>数据结构与算法刷了多少题？</p><p>TCP 与 UDP 有什么区别？</p><p>如何理解 TCP 的可靠传输？</p><p>TCP/IP 网络模型是怎样的？每一层对应有哪些协议？</p><p>如何用两个队列实现一个栈？</p><p>研究生课题的主要内容？目的是什么？是不是自己一个人完成的？成果？</p><p>有哪些兴趣爱好？是否拿出摄影作品去参加过学校的展览？骑行都去过哪些地方？</p><p>父母的工作</p><p>兄弟姐妹的情况</p><p>反问：</p><ul><li>部门 / 分组是怎么确定的？入职以后确定</li><li>主要用的编程语言是什么？用的最多的是 C/C++ ，会经常使用数据结构与算法、操作系统的相关内容</li></ul><p>最后，面试官建议认真学一下操作系统</p><p>第三轮面试一共 18 分钟</p><h1 id="shein算法工程师-运筹预测方向"><a class="anchor" href="#shein算法工程师-运筹预测方向">#</a> SHEIN（算法工程师 - 运筹预测方向）</h1><h2 id="测评"><a class="anchor" href="#测评">#</a> 测评</h2><p>一共包含四个模块，全都是选择题</p><ul><li>言语表达，10 题，限时 10 分钟左右</li><li>图表分析，10 题，限时 10 分钟左右</li><li>图形推理，10 题，限时 10 分钟左右</li><li>性格测评，158 题，不限时</li></ul><h2 id="笔试-2"><a class="anchor" href="#笔试-2">#</a> 笔试</h2><p>题型：15 道单选题，2 道算法题，2 道问答题</p><p>限时 60 分钟</p><p>单选题涉及的知识：</p><ul><li>机器学习</li><li>python</li><li>排序算法</li></ul><p>算法题：</p><ul><li>最长回文子序列（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnNlcXVlbmNlLw==">力扣 516</span>）：ACM 模式</li><li>二叉树的层序遍历（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">力扣 102</span>）：核心代码模式</li></ul><p>问答题：</p><ul><li>AUC 的计算</li><li>SQL 语句</li></ul><h1 id="蔚来智能调度和控制算法工程师"><a class="anchor" href="#蔚来智能调度和控制算法工程师">#</a> 蔚来（智能调度和控制算法工程师）</h1><h2 id="提前批"><a class="anchor" href="#提前批">#</a> 提前批</h2><h3 id="笔试大数据的试卷"><a class="anchor" href="#笔试大数据的试卷">#</a> 笔试（大数据的试卷）</h3><p>10 道单选题：设计模式、概率论相关知识点</p><p>9 道不定项选择题：操作系统、数据库相关知识点</p><p>3 道算法题（核心代码模式）：</p><ul><li>合并二叉树（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzLw==">力扣 617</span>）</li><li>爬楼梯（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMv">力扣 70</span> ）进阶版：每次可以爬 1 或 2 或 3 个台阶</li><li>滑动窗口最大值（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">力扣 239</span>）</li></ul><h2 id="正式批"><a class="anchor" href="#正式批">#</a> 正式批</h2><h3 id="测评北森系统"><a class="anchor" href="#测评北森系统">#</a> 测评（北森系统）</h3><p>10 道言语理解，每小题有相应限时</p><p>10 道图表分析，每小题有相应限时</p><p>10 道图形推理，每小题有相应限时</p><p>99 道性格测试，每小题有相应限时</p><h1 id="三一算法工程师"><a class="anchor" href="#三一算法工程师">#</a> 三一（算法工程师）</h1><h2 id="测评北森"><a class="anchor" href="#测评北森">#</a> 测评（北森）</h2><p>行测，每题都有对应的限时：</p><ul><li>言语理解与表达，一共 11 题</li><li>图表分析，一共 10 题</li><li>图形推理，一共 10 题</li></ul><p>性格测评，不限时：</p><ul><li>98 道选择题：每题需从三个选项中选出最符合、最不符合</li><li>100 道单选题</li></ul><h2 id="笔试-3"><a class="anchor" href="#笔试-3">#</a> 笔试</h2><p>一共 30 道选择题（20 道单选，10 道多选），限时 60 分钟：</p><ul><li>数据结构与算法：图论（最短路径、最小生成树、有向图、邻接矩阵）、栈、动态规划的基本要素、贪心思想、回溯法</li><li>机器学习相关：线性回归、生成模型、基于二次准则函数的 H-K 算法、感知器算法、统计模式识别分类问题、map-reduce 框架及相关算法、K - 均值算法、判别式模型、决策树的启发函数</li><li>操作系统：内存管理、线程</li><li>运筹优化相关：分支定界、TSP 问题的时间复杂度、路径规划算法、应用 Johnson 法则的流水作业调度所采用的算法、无约束优化问题的相关算法、PnP 问题的求解方法</li><li>排列数与组合数</li><li>编程语言：C++ 语句、类的静态成员、python 中的复数</li></ul><h2 id="一面-2"><a class="anchor" href="#一面-2">#</a> 一面</h2><p>自我介绍</p><p>学习成绩</p><p>英语六级成绩</p><p>用的什么编程语言</p><p>简述利用 matlab 实现的一个算法</p><p>对汽车有没有什么了解</p><p>建议：</p><ul><li>后续要加强对汽车相关知识的学习</li><li>要进一步熟悉一下 matlab，尤其是 simulink</li></ul><p>面试一共 6 分钟（邮件里写的 20 分钟）</p><h1 id="中兴算法工程师"><a class="anchor" href="#中兴算法工程师">#</a> 中兴（算法工程师）</h1><h2 id="测评北森系统-2"><a class="anchor" href="#测评北森系统-2">#</a> 测评（北森系统）</h2><p>行测：</p><ul><li>言语理解与表达，一共 10 题，限时 10 分钟</li><li>图形推理，一共 10 题，限时 10 分钟</li><li>图表分析，一共 10 题，限时 10 分钟</li></ul><p>性格测评，不限时：</p><ul><li>98 道选择题：每题需从三个选项中选出最符合、最不符合</li><li>100 道单选题</li></ul><h2 id="面试"><a class="anchor" href="#面试">#</a> 面试</h2><p>安排了软件工程师的面试</p><p>拒掉了面试</p><h1 id="用友运筹优化算法工程师"><a class="anchor" href="#用友运筹优化算法工程师">#</a> 用友（运筹优化算法工程师）</h1><h2 id="测评-2"><a class="anchor" href="#测评-2">#</a> 测评</h2><p>行测：数量关系、演绎论证、图形推理、图表分析，一共 28 道选择题，限时 30 分钟</p><p>性格测评：一共 88 题（每题需从三个选项中选出最符合、最不符合），限时 30 分钟</p><h1 id="大疆决策与规划算法工程师"><a class="anchor" href="#大疆决策与规划算法工程师">#</a> 大疆（决策与规划算法工程师）</h1><h2 id="测评-3"><a class="anchor" href="#测评-3">#</a> 测评</h2><p>一共 80 道题，限时 80 分钟</p><ul><li>行测：数量关系，演绎论证，15 题左右</li><li>性格测试</li></ul><h2 id="笔试-4"><a class="anchor" href="#笔试-4">#</a> 笔试</h2><p>一共 25 道不定项选择题，限时 60 分钟</p><p>内容涉及以下方面：</p><ul><li>ROS</li><li>git</li><li>多项式曲线、B spline、羊角螺线</li><li>Dijkstra、A*、RRT、RRT* 路径规划算法（特性比较）</li><li>line search、无约束的路径规划、采用 邻接矩阵或邻接表 的 Dijkstra 算法的复杂度</li><li>判断凸函数、判断凸约束</li><li>多项式曲线刻画曲率能否为凸约束、庞特里亚金最大化原理、半正定优化是否为凸优化问题</li><li>C++ 模板编程、返回值</li><li>算法的时间复杂度</li><li>链表操作的时间复杂度</li><li>unordered_map 的底层实现以及相关特性</li><li>SO ()、SE ()、四元数与自由度</li><li>计算排列数、计算事件发生的概率、计算数学期望</li><li>平面空间索引、K-D tree、R-tree、三维空间索引</li></ul><h1 id="杉数科技算法工程师-运筹优化方向"><a class="anchor" href="#杉数科技算法工程师-运筹优化方向">#</a> 杉数科技（算法工程师 - 运筹优化方向）</h1><h2 id="一面-3"><a class="anchor" href="#一面-3">#</a> 一面</h2><p>自我介绍</p><p>讲解项目（大概聊了 20 分钟）</p><p>KKT 条件</p><ul><li>KKT 条件是最优解的充分条件还是必要条件</li><li>在什么情况下 KKT 能作为充分条件</li><li>KKT 的具体内容</li></ul><p>从 branch-and-bound 、Benders 分解、Largrange 松弛、列生成 四个算法中选择一个算法，讲解其原理以及应用场景</p><p>使用的编程语言，有没有使用 C++ 实现算法</p><p>给两道场景题，要求建立数学模型（口述）：都是排产、排程相关的场景</p><ul><li><p>第一道的大概内容：假设你是某饭店的老板，饭店里有一台冰箱可以存放盒饭（每一份盒饭可以保存两个小时），如果盒饭库存不够就需要现场准备。现场准备所需的成本与提前准备的成本不相等，并且，顾客的数量是随机的（有以往的顾客数量信息）。问：如果规划 冰箱存放的盒饭数量 以及 现场所需准备的盒饭数量，以使得总成本最小？</p></li><li><p>第二道的大概内容：假设你是某电子工厂的老板，现要在一年内生产 A、B 两类产品各 5 千万个，若当天生产的是 A 产品，则可生产 a 个，若当天生产的是 B 产品，则可生产 b 个。假设：若当天生产 A 类产品且第二天生产 B 类产品，或者，当天生产 B 类产品且第二天生产 A 类产品，两种情况都会产生额外的成本。即，生产产品的类别的变化，会带来额外成本。问：如何确定每一天生产的产品类别，使得生产产品类别的变化次数最少？</p></li></ul><p>面试官介绍业务（主要是与工厂的排班排程相关的实际问题），并且主要使用 python</p><p>反问：</p><ul><li>会参与 COPT 求解器的研发吗？</li><li>面试有多少轮（三轮）</li></ul><p>面试一共 50 分钟左右（邮件里写的是 60 分钟）</p><p>面试官很友好，并且会及时提供引导。面试体验挺不错，虽然很多都不会 hh</p><h2 id="笔试-5"><a class="anchor" href="#笔试-5">#</a> 笔试</h2><p>一共两道题，24 小时内做完</p><ul><li><p>现有一家移动运营商（例如中国移动、中国电信）需要为一座城市建造基站，已知该城市终端用户的所在位置和所需的移动流量，可选的基站建造位置，以及不同类型基站的覆盖范围和最大流量。请帮助基站规划员决策需要布置的基站数量，所选的基站位置以及每小时的基站运行状态（无流量需求时基站可关闭，假设基站可随意开关且没有额外成本），使得该家公司的支出总成本最小，包括基站建造成本以及基站运营成本。</p><ul><li>假设每个时间段内的终端需求都需要被满足，建立数学规划模型，设计最优的基站建设及运营方案。可根据需要添加合理的前提假设。</li><li>假设每个时间段内的终端需求不需要都被满足，但是未被满足的流量需求会产生额外成本，请修改模型并简述和模型 1 的差异。</li><li>如果没有可选的基站位置，城市里的任何位置都可建造基站，请简述如何修改你的方案和模型。</li><li>如果可选的基站点过多，请简述如何修改模型，使得在可接受的时间范围内求解模型。</li><li>如果每个终端用户的流量需求不确定，请简述如何求解这个问题。</li></ul></li><li><p>某学生必须在 4 个不同系中选修 10 门课程，每个系至少选 1 门。这个学生将每个系选修课程数目与获得知识量按照 100 分衡量如表格所示。要争取获得的知识量达到最大。</p><ul><li>针对以上场景：<ul><li>请使用动态规划求解该问题。（编程）</li><li>请使用混合整数规划求解该问题。（调用任意求解器编程）</li></ul></li><li>若 C 的选修课数量不得多于 D：<ul><li>请使用动态规划求解该问题。（编程）</li><li>请使用混合整数规划求解该问题。（调用任意求解器编程）</li></ul></li></ul></li></ul><p>备注：优先使用 python</p><h2 id="二面-2"><a class="anchor" href="#二面-2">#</a> 二面</h2><p>两个面试官，副总裁和业务总监</p><p>首先进行自我介绍，讲一讲对杉数的认识，自己的优势</p><p>自己对这一岗位的工作规划，可能遇到的问题以及解决方案</p><p>介绍项目</p><p>反问</p><h1 id="顺丰科技运筹优化算法工程师"><a class="anchor" href="#顺丰科技运筹优化算法工程师">#</a> 顺丰科技（运筹优化算法工程师）</h1><h2 id="测评-4"><a class="anchor" href="#测评-4">#</a> 测评</h2><p>言语理解、性格测评、情景题</p><h2 id="笔试-6"><a class="anchor" href="#笔试-6">#</a> 笔试</h2><p>120 分钟</p><p>选择题：单选、多选共 34 道题，一共 70 分：主要考察运筹优化算法、概率论相关</p><p>编程题：两道，ACM 模式，每题 15 分</p><ul><li><p>幸运数：如果一个数在十进制表示下数字 5 出现了不少于 5 次，则这个数是一个幸运数。求：大于 N 的最小的幸运数</p></li><li><p>猜排列游戏：小明有一个由 1 到 n 的整数组成的排列，让你来猜出这个排列是什么。每次可以猜测某个位置的数字，小明会告知你的猜想是 “大了”、“小了” 或者 “正确”。求：在最坏情况下，需要猜测几次，才能在排列的所有位置都得到小明的 “正确” 的回复。</p></li></ul><h1 id="小米运筹强化学习算法工程师"><a class="anchor" href="#小米运筹强化学习算法工程师">#</a> 小米（运筹 / 强化学习算法工程师）</h1><h2 id="测评北森系统-3"><a class="anchor" href="#测评北森系统-3">#</a> 测评（北森系统）</h2><p>行测：</p><ul><li>言语理解与表达，一共 10 题，每题都有相应限时</li><li>图形推理，一共 10 题，每题都有相应限时</li><li>图表分析，一共 10 题，每题都有相应限时</li></ul><p>性格测评，不限时：</p><ul><li>98 道选择题：每题需从三个选项中选出最符合、最不符合</li><li>100 道单选题</li></ul><p>性格测评的这两个板块直接复用了之前做过中兴的测评</p><h2 id="笔试算法方向"><a class="anchor" href="#笔试算法方向">#</a> 笔试（算法方向）</h2><p>16 道单选题，每题 2 分，主要涉及以下方面的知识点：</p><ul><li>机器学习</li><li>图像处理</li><li>数字信号处理（滤波器、快速傅里叶变换）</li><li>快速排序、链表操作</li><li>概率论与数理统计</li></ul><p>17 道多选题，每题 2 分，涉及以下内容：</p><ul><li>栈操作</li><li>动态规划代码</li><li>向量范数</li><li>快速傅里叶变换</li><li>机器学习（监督学习、生成式模型）</li><li>矩阵的秩</li><li>图像处理过程中的噪声</li><li>凸函数</li></ul><p>2 道编程题，每题 17 分，均为 ACM 模式：</p><ul><li>给定一个数组，每一次可以从数组的最左侧或者最右侧移除一个数，同时，令数字 x 减去移除的这一元素。问：至少需要多少次移除操作，才能使 x 变为 0 。如果无法使得 x 变为 0，则输出 -1<ul><li>输入：一共三行，其中，第一行是一个用 [] 包围一个数字序列（数字与数字之间用逗号分隔），第二行是数字序列的长度，第三行是数字 x</li><li>输出：一个整数，表示需要的移除次数（无法将 x 变为 0 时输出 -1 ）</li></ul></li></ul><ul><li>给定两个序列，计算两个序列的卷积和互相关<ul><li>输入：一共两行，分别为两个序列，其中，每一行的第一个数表示序列长度，紧接着一个逗号，然后是用空格分隔的序列</li><li>输出：一共两行，分别为卷积和互相关的结果，其中，每一行的第一个数表示结果序列长度，紧接着一个逗号，然后是用空格分隔的结果序列</li></ul></li></ul><h1 id="美团运筹优化研发工程师"><a class="anchor" href="#美团运筹优化研发工程师">#</a> 美团（运筹优化研发工程师）</h1><h2 id="笔试-7"><a class="anchor" href="#笔试-7">#</a> 笔试</h2><p>四道编程题，每题 20 分：</p><ul><li>第一题：字符串匹配</li><li>第二题：数组、哈希表</li><li>第三题：字符串分割</li><li>第四题：背包问题</li></ul><p>三道多项选择题：</p><ul><li>第一题，6 分：下列哪些属于分类任务常用损失函数：Softmax 损失、L2 损失、L1 损失、交叉熵损失</li><li>第二题，6 分：目前对于最近邻分类的研究在于：探索更加合理的 K 值、寻求更接近于实际的距离函数、建立高效的索引、运用更加精确的概率估测方法以取代简单的投票机制</li><li>第三题，8 分：当想创建新表的时候，hive 输入命令 create table if not exist，以下哪些情况会发生：表名存在时报错、表名不存在时不报错、表名不存在时报错、表名存在时不报错</li></ul><p>一共限时 120 分钟</p><h2 id="一面-4"><a class="anchor" href="#一面-4">#</a> 一面</h2><p>面试官首先自我介绍，并介绍事业部的主要工作，介绍面试流程</p><p>自我介绍</p><p>有没有实习</p><p>聊项目</p><p>对遗传算法、禁忌搜索等算法有没有了解？</p><p>介绍一下遗传算法</p><p>如果用遗传算法来求解 TSP 问题要怎么求解？</p><p>对禁忌搜索这些算法有没有什么了解？</p><p>对机器学习是否有了解？</p><p>有没有做相应的机器学习算法实践？</p><p>主要用的是什么编程语言？做题用什么语言？</p><p>手撕代码，核心代码模式（在牛客上进行的面试，面试官可以直接在系统上出题）</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLw==">力扣 121 ：买卖股票的最佳时机</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLw==">力扣 42 ：接雨水</span></li></ul><p>反问：</p><ul><li>部门的主要业务</li><li>工作内容</li></ul><p>面试一共 45 分钟，其中，25 分钟项目、10 分钟代码、5 分钟反问</p><h1 id="字节跳动算法工程师-运筹优化"><a class="anchor" href="#字节跳动算法工程师-运筹优化">#</a> 字节跳动（算法工程师 - 运筹优化）</h1><h2 id="笔试-8"><a class="anchor" href="#笔试-8">#</a> 笔试</h2><p>120 分钟</p><p>四道编程题，ACM 模式，分值分别为 20，25，25，30</p><ul><li>弹珠游戏（动态规划）</li><li>三数和赛高数组</li></ul><h1 id="华为ai-工程师-决策推理方向"><a class="anchor" href="#华为ai-工程师-决策推理方向">#</a> 华为（AI 工程师 - 决策推理方向）</h1><h2 id="一次笔试"><a class="anchor" href="#一次笔试">#</a> 一次笔试</h2><p>一共三题，分值分别为 100、200、300，限时 120 分钟</p><p>猪场防疫（第一题）：猪场现有 N 只猪，编号从 0 到 N - 1 （每只猪无论生死都有唯一的编号）。老李在每只猪生产的时候记录了生产的母猪和出生的小猪，格式为 x y1 y2 y3 ... ，其中，x 为母猪，y1、y2、y3... 为新生的小猪，以上编码均在 0 ~ N - 1 范围内，每只猪可以多次生产，每只小猪都只有一个猪妈妈。现需要检查任意两只猪是否有亲戚关系（两只猪具有相同的祖先），并计算出关系亲疏情况（关系距离，若相同编号则距离为 0）</p><ul><li>输入：<ul><li>第一行输入总数 N</li><li>第二行输入后续生产记录行数 M</li><li>后续 M 行输入生产记录，以空格分隔</li><li>最后一行输入待检查的两只猪的编号 m1 和 m2</li></ul></li><li>输出：<ul><li>一个整数，表示 m1 和 m2 之间的关系距离，无亲戚关系输出 -1</li></ul></li></ul><p>速战速决（第二题）：在一个 M 行 N 列的街区中，有一个士兵 S 和一个敌人 E ，标识 X 为无法通过的街区，标识 B 为可以通过的街区；士兵在一个单位时间内可以从一个街区移动到相邻的街区（每次只能水平或垂直方向移动一个街区）；士兵每次改变方向时，需要额外花费一个单位的时间（士兵第一次移动一个街区的时候，不用考虑其初始方向，即，只需要一个单位时间即可到达相邻街区）。计算士兵最少需要多少时间才能到达敌人所在的街区</p><ul><li>输入：<ul><li>第一行两个数字，分别为街区的大小，M 和 N （1 &lt;= M, N &lt;= 1000，M 、N 不同时为 1）</li><li>接下来 M 行，每行 N 个字母，字母 S 表示士兵所在街区，字母 E 表示敌人所在街区，字母 X 表示障碍，字母 B 表示可以经过的街区（只有一个 S，一个 E）</li></ul></li><li>输出：<ul><li>最少需要的时间，当士兵永远无法到达敌人所在街区时输出 -1</li></ul></li></ul><h2 id="二次笔试时隔一个月"><a class="anchor" href="#二次笔试时隔一个月">#</a> 二次笔试（时隔一个月）</h2><ul><li><p>字符串压缩，例如，将 &quot;aaBcaBcaBcc&quot; 压缩成 &quot;a3 (aBc) c&quot;、将 &quot;aAABBAABB&quot; 压缩成 &quot;a2 (2 (A) 2 (B))&quot;</p></li><li><p>三叉树中的最大路径和</p></li><li><p>多进制计算器</p></li></ul><h1 id="京东"><a class="anchor" href="#京东">#</a> 京东</h1><h2 id="笔试-9"><a class="anchor" href="#笔试-9">#</a> 笔试</h2><p>选择题，主要考察算法与数据结构、机器学习相关知识</p><p>三道编程题：</p><ul><li><p>定义一个字符串为 “好串” ：当且仅当相邻两个字母不相同。对于一个仅由 'r' 、'e'、'd' 三种字符组成的字符串，可以将相邻两个相同的字母同时删除，并在其位置生成任意一个字母（'r'、'e'、'd' 三种中的一种）。例如，对于字符串 &quot;dedd&quot;，可以选择将 &quot;dd&quot; 变成 &quot;r&quot;，字符串即变为 &quot;der&quot; 。现给定一个字符串，问：至少需要多少次操作才能将该字符串变成 “ 好串 ”</p><ul><li>输入描述：一个长度不超过 200000 的、仅由 'r' 、'e'、'd' 三种字符组成的字符串</li><li>输出描述：一个整数，代表操作的最小次数</li></ul></li><li><p>对于一个长度为 n 的数组，现希望将一些数（不少于 2 个数）染红，满足任意两个染红的数之和都是偶数。问：一共有多少种不同的染色方案？答案对 10<sup>9</sup> + 7 取模。规定：对于两个方案，只要存在某个数的染色情况不同，则认为是两种不同的方案</p><ul><li>输入描述：第一行输入一个正整数 n，代表数组长度；第二行输入 n 个正整数 a<sub>i</sub> ，代表数组的元素</li><li>数据范围：2 &lt;= n &lt;= 10<sup>5</sup>，1 &lt;= a<sub>i</sub> &lt;= 10<sup>9</sup></li><li>输出描述：一共整数，代表不同的方案数</li></ul></li></ul><h1 id="百度"><a class="anchor" href="#百度">#</a> 百度</h1><h2 id="笔试-10"><a class="anchor" href="#笔试-10">#</a> 笔试</h2><p>15 道单选题，一共 45 分，涉及知识点：</p><ul><li>SQL</li><li>快速排序</li><li>二分查找</li><li>栈</li><li>堆串</li><li>ssh 公钥命令</li><li>内存分配与释放（最佳适配算法）</li><li>linux 系统</li><li>同步关系和互斥关系</li></ul><p>5 道不定项选择题，一共 15 分，涉及知识点：</p><ul><li>linux</li><li>C++</li></ul><p>3 道编程题，分值分别为 10 分、15 分、15 分，均为 ACM 模式</p><ul><li><p>给定字符串 s ，问：字符串 s 中含有多少个形如 baidu 的子串（即，子串长度为 5，第一、四个字母是辅音字母，第二、三、五个字母是元音字母，并且，子串没有重复字母）</p></li><li><p>已知字符串 str 仅包含 '0' 和 '1' ，每一次可反转字符串 s 中的两个连续字符（例如，&quot;01&quot; 反转成 &quot;10&quot; ），问：是否可以在有限次数内将 str 变成所有字符均相同的字符串（即，所有字符均为 '1' ，或者，所有字符均为 '0' ）</p><ul><li>例如，&quot;101&quot; 可以通过 2 次操作变成 &quot;000&quot; ，输出 &quot;Yes&quot; ；&quot;11111&quot; 无需操作即满足条件，输出 &quot;Yes&quot; ；&quot;1011&quot; 无法变成所有字符均相同的字符串，输出 &quot;No&quot;</li><li>注：输入含有多组样例，需针对每组样例进行判断并输出</li></ul></li><li><p>给定一个 m 行 n 列的方格，其中，每个小方格有 'r' 、'e' 、'd' 三种字符中的某一个字符。现从左上角出发，每次可以往四个方向（向上、向下、向左、向右）中的某个方向移动一步，但是，不能从字符 'r' 移到字符 'e' 、不能从字符 'e' 移到字符 'd' 、不能从字符 'd' 移到字符 'r' 。问：至少需要移动多少步才能到达右下角。如果无法到达右下角，则输出 -1</p><ul><li>采用深度优先搜索（回溯）会超时，只能通过 23.08% 的样例</li><li>需要采用广度优先搜索（没来得及写）</li></ul></li></ul><p>笔试一共限时 120 分钟</p><h1 id="招银网络科技"><a class="anchor" href="#招银网络科技">#</a> 招银网络科技</h1><h2 id="测评北森系统-4"><a class="anchor" href="#测评北森系统-4">#</a> 测评（北森系统）</h2><p>行测：</p><ul><li>言语理解与表达，一共 11 题，每题有相应限时</li><li>图形推理，一共 11 题，每题有相应限时</li><li>图表分析，一共 11 题，每题有相应限时</li></ul><p>性格测评，不限时：</p><ul><li>98 道选择题：每题需从三个选项中选出最符合、最不符合</li><li>100 道单选题：需从 非常不符合、比较不符合、比较符合、非常符合 四个选项中选择一个</li></ul><h1 id="美的嵌入式软件"><a class="anchor" href="#美的嵌入式软件">#</a> 美的（嵌入式软件）</h1><h2 id="笔试-11"><a class="anchor" href="#笔试-11">#</a> 笔试</h2><p>10 道单选，每题 2 分，主要考察操作系统、计算机网络的相关知识</p><p>5 道不定项选择题，每题 4 分（少选错选不得分），主要考察操作系统、计算机网络的相关知识</p><p>3 道编程题，ACM 模式：</p><ul><li>给定一个字符串，删除其中连续的多余空格：15 分</li><li>输入一个十六进制数，将其表述成 32 位二进制数然后反转，再将反转得到的二进制数转换成十六进制输出：20 分</li><li>给一个数组和一个目标数，判断存在一个组合使得元素和为目标数：25 分</li></ul><h1 id="中信银行信用卡中心"><a class="anchor" href="#中信银行信用卡中心">#</a> 中信银行信用卡中心</h1><h2 id="测评tas测评系统"><a class="anchor" href="#测评tas测评系统">#</a> 测评（TAS 测评系统）</h2><p>Talent5 大五职业性格测评：共 138 题，不限时</p><p>iLogic 言语推理测评：共 15 题，限时 20 分钟（每题有相应限时）</p><p>iLogic 数字推理测评：共 15 题，限时 20 分钟（每题有相应限时）</p><p>iLogic 逻辑推理测评：共 10 题，限时 17 分钟（每题有相应限时）</p><p>iDriver 职业驱动力测评：共 112 题，不限时</p><p>Menlth 心理状态扫描：共 50 题，不限时</p><h2 id="笔试-12"><a class="anchor" href="#笔试-12">#</a> 笔试</h2><p>30 道单项选择题，每题 2 分，考察 Linux 系统、Java、计算机网络、MySQL、数据结构 相关知识</p><p>3 道编程题，ACM 模式，一共 40 分</p><ul><li>字符串中出现次数不少于 2 次的字母</li><li>给定字符串，将元音字母都变成小写，辅音字母都变成大写</li><li>给定 n 行 n 列的矩阵，将矩阵水平方向和垂直方向各翻转一次</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据容器</title>
      <link href="/posts/23926cd4/"/>
      <url>/posts/23926cd4/</url>
      
        <content type="html"><![CDATA[<p>数据容器：一种可以容纳多份数据的数据类型，容纳的每一份数据称之为 1 个元素，其中，每一个元素可以是任意类型的数据，如字符串、数字、布尔等</p><p>Python 数据容器可以分为 5 类：</p><ul><li>列表（list）</li><li>元组（tuple）</li><li>字符串（str）</li><li>集合（set）</li><li>字典（dict）</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">列表</th><th style="text-align:center">元组</th><th style="text-align:center">字符串</th><th style="text-align:center">集合</th><th style="text-align:center">字典</th></tr></thead><tbody><tr><td style="text-align:center">元素类型</td><td style="text-align:center">任意</td><td style="text-align:center">任意</td><td style="text-align:center">字符</td><td style="text-align:center">任意</td><td style="text-align:center">key-value (key: 除字典外任意类型，value: 任意类型)</td></tr><tr><td style="text-align:center">下标索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">数据有序</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">重复元素</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">可修改性</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table><blockquote><p>在 Python 中，有序是指其中的数据可以通过索引（即下标）进行访问</p></blockquote><h1 id="列表"><a class="anchor" href="#列表">#</a> 列表</h1><h2 id="列表的定义"><a class="anchor" href="#列表的定义">#</a> 列表的定义</h2><pre><code class="language-python"># 字面量[元素1, 元素2, ...]# 定义变量变量名 =  [元素1, 元素2, ...]#定义空列表变量名称 = []变量名称 = list()</code></pre><p>列表可以同时存储不同的数据类型，并且，列表支持嵌套</p><p>例如：</p><pre><code class="language-python">my_list = [&quot;iteration&quot;, 1234, True]nested_list = [[1, 2, 3], [4, 5, 6]]print(my_list)print(type(my_list))print(nested_list)print(type(nested_list))</code></pre><h2 id="列表的方法"><a class="anchor" href="#列表的方法">#</a> 列表的方法</h2><h3 id="访问元素"><a class="anchor" href="#访问元素">#</a> 访问元素</h3><p>可以通过列表的下标索引 idx 获取对应位置的数据</p><pre><code class="language-python">value = list_name[idx]</code></pre><p>其中，列表的下标索引可以分为两种：</p><ul><li>正向索引（从左往右）：从 0 开始，依次递增</li><li>反向索引（从右往左）：从 -1 开始，依次递减</li></ul><blockquote><p>要注意下标索引的取值范围，超出范围会报错</p></blockquote><h3 id="查找元素"><a class="anchor" href="#查找元素">#</a> 查找元素</h3><p>查找元素 element 在列表 list_name 中的下标（元素在列表中的第一个匹配位置），如果找不到则报错 ValueError</p><pre><code class="language-python">list_name.index(element)</code></pre><h3 id="修改元素"><a class="anchor" href="#修改元素">#</a> 修改元素</h3><p>修改下标为 idx 的元素的值</p><pre><code class="language-python">list_name[idx] = value</code></pre><h3 id="插入元素"><a class="anchor" href="#插入元素">#</a> 插入元素</h3><p>在下标 idx 处插入元素 element</p><pre><code class="language-python">list_name.insert(idx, element)</code></pre><h3 id="追加元素"><a class="anchor" href="#追加元素">#</a> 追加元素</h3><p><strong>方式一</strong></p><p>将元素 element 追加到列表 list_name 的尾部</p><pre><code class="language-python">list_name.append(element)</code></pre><p>例如：</p><pre><code class="language-python">name_list = [&quot;it&quot;, &quot;its&quot;, &quot;itself&quot;]name_list.append(&quot;itheima&quot;)</code></pre><p><strong>方式二</strong></p><p>将其他数据容器的内容取出，依次追加到列表 list_name 的尾部</p><pre><code class="language-python">list_name.extend(Data)</code></pre><p>例如：</p><pre><code class="language-python">mylist = [1, 3, 5]temp_list = [2, 4, 6]mylist.extend(temp_list)</code></pre><h3 id="删除指定位置元素"><a class="anchor" href="#删除指定位置元素">#</a> 删除指定位置元素</h3><p>删除下标 idx 处的元素</p><pre><code class="language-python">del list_name[idx]list_name.pop(idx)      # 该方式可以获取返回值（被删除的元素）</code></pre><h3 id="删除指定元素"><a class="anchor" href="#删除指定元素">#</a> 删除指定元素</h3><p>删除指定元素值在列表中的第一个匹配项</p><pre><code class="language-python">list_name.remove(element)   # 删除元素 element 在列表中的第一个匹配项</code></pre><h3 id="清空列表"><a class="anchor" href="#清空列表">#</a> 清空列表</h3><p>清空列表内容</p><pre><code class="language-python">list_name.clear()</code></pre><h3 id="统计指定元素数量"><a class="anchor" href="#统计指定元素数量">#</a> 统计指定元素数量</h3><p>统计元素 element 在列表 list_name 中的数量</p><pre><code class="language-python">list_name.count(element)</code></pre><h2 id="其他"><a class="anchor" href="#其他">#</a> 其他</h2><h3 id="统计列表元素数量"><a class="anchor" href="#统计列表元素数量">#</a> 统计列表元素数量</h3><p>统计整个列表中的元素总数量</p><pre><code class="language-python">len(list_name)</code></pre><h3 id="列表的-while-遍历"><a class="anchor" href="#列表的-while-遍历">#</a> 列表的 while 遍历</h3><pre><code class="language-python">idx = 0while idx &lt; len(list_name):    statement    idx += 1</code></pre><h3 id="列表的-for-遍历"><a class="anchor" href="#列表的-for-遍历">#</a> 列表的 for 遍历</h3><pre><code class="language-python">for i in range(0, len(list_name)):    statement</code></pre><h1 id="元组"><a class="anchor" href="#元组">#</a> 元组</h1><p>元组（tuple）：元组同列表一样，都是一种可以封装多个、不同类型的元素的容器；不同点在于，元素一旦定义完成，就不可以修改</p><h2 id="元组的定义"><a class="anchor" href="#元组的定义">#</a> 元组的定义</h2><p>定义元组：使用小括号包围数据，其中，每个数据之间用逗号隔开（数据可以是不同的数据类型）</p><pre><code class="language-python"># 定义元组字面量(元素1, 元素2, ...)# 定义元组变量变量名称 = (元素1, 元素2, ...)# 定义空元组变量名称 = ()变量名称 = tuple()</code></pre><p>注意：如果元组只有一个数据，需要在这个数据后面添加逗号，否则不是元组类型</p><p>例如：</p><pre><code class="language-python">t4 = (&quot;World&quot;, )</code></pre><p>元组也支持嵌套</p><p>注意：</p><ul><li>不可以修改元组的内容，否则会直接报错</li><li>如果元组内嵌套了 list 列表，则可以修改 list 列表的内容（修改、增加、删除元素，反转等）</li></ul><p>例如：</p><pre><code class="language-python">mytuple = (1, 2, [&quot;it&quot;, &quot;20221124&quot;])mytuple[2][0] = &quot;python&quot;</code></pre><h2 id="元组的方法"><a class="anchor" href="#元组的方法">#</a> 元组的方法</h2><h3 id="访问元素-2"><a class="anchor" href="#访问元素-2">#</a> 访问元素</h3><p>元组支持下标索引</p><pre><code class="language-python">element = tuple_name[idx]</code></pre><h3 id="查找元素-2"><a class="anchor" href="#查找元素-2">#</a> 查找元素</h3><p>查找指定元素的第一个匹配项</p><pre><code class="language-python">tuple_name.index(element)</code></pre><h3 id="统计指定元素数量-2"><a class="anchor" href="#统计指定元素数量-2">#</a> 统计指定元素数量</h3><pre><code class="language-python">tuple_name.count(element)</code></pre><h2 id="其他-2"><a class="anchor" href="#其他-2">#</a> 其他</h2><h3 id="统计元素数量"><a class="anchor" href="#统计元素数量">#</a> 统计元素数量</h3><pre><code class="language-python">len(tuple_name)</code></pre><h3 id="元组的-while-遍历"><a class="anchor" href="#元组的-while-遍历">#</a> 元组的 while 遍历</h3><pre><code class="language-python">idx = 0while idx &lt; len(tuple_name):    statement    idx += 1</code></pre><h3 id="元组的-for-遍历"><a class="anchor" href="#元组的-for-遍历">#</a> 元组的 for 遍历</h3><pre><code class="language-python">for element in tuple_name:    statement</code></pre><h1 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h1><p>字符串（str）：字符串是字符的容器，一个字符串可以存放任意数量的字符</p><p>字符串是一个 无法修改 的数据容器</p><h2 id="字符串的定义"><a class="anchor" href="#字符串的定义">#</a> 字符串的定义</h2><p>使用一对双引号包围一系列字符</p><pre><code class="language-python">str_name = &quot;Here is the content of string&quot;</code></pre><h2 id="字符串的方法"><a class="anchor" href="#字符串的方法">#</a> 字符串的方法</h2><h3 id="访问元素-3"><a class="anchor" href="#访问元素-3">#</a> 访问元素</h3><p>字符串支持下标索引</p><ul><li>从前往后索引：下标从 0 开始</li><li>从后往前索引：下标从 -1 开始</li></ul><h3 id="查找子串"><a class="anchor" href="#查找子串">#</a> 查找子串</h3><p>查找子串 target_str 在字符串 str_name 中的下标索引值</p><pre><code class="language-python">str_name.index(target_str)</code></pre><h3 id="替换子串"><a class="anchor" href="#替换子串">#</a> 替换子串</h3><p>将字符串 str_name 内的 str1 全部替换为 str2</p><pre><code class="language-python">str_name.replace(str1, str2)</code></pre><p>注意，此方法并不是修改字符串本身（字符串是无法修改的），而是得到了一个新的字符串</p><h3 id="分割子串"><a class="anchor" href="#分割子串">#</a> 分割子串</h3><p>按照指定的分隔符字符串 separator，将字符串划分为多个子字符串并存入列表对象中</p><pre><code class="language-python">str_name.split(separator)</code></pre><p>注意，此方法并不是修改字符串本身，而是得到了一个列表对象</p><p>例如：</p><pre><code class="language-python">my_str = &quot;hello python itheima and itcast&quot;result = my_str.split(&quot; &quot;)  # 按照空格进行分割，得到一个列表</code></pre><h3 id="去除前后空格"><a class="anchor" href="#去除前后空格">#</a> 去除前后空格</h3><p>strip () 方法删除开头和结尾的空白字符</p><pre><code class="language-python">str_name.strip()</code></pre><p>例如：</p><pre><code class="language-python">my_str = &quot;   itheima and itcast   &quot;new_my_str = my_str.strip()</code></pre><h3 id="去除前后指定字符串"><a class="anchor" href="#去除前后指定字符串">#</a> 去除前后指定字符串</h3><p>通过给 strip () 方法传入参数，可以删除字符串开头和结尾处的指定字符串</p><pre><code class="language-python">str_name.strip(target_str)</code></pre><p>需要注意，删除操作是按照单个字符进行的</p><p>例如：</p><pre><code class="language-python">my_str = &quot;12itheima and itcast21&quot;new_my_str = my_str.strip(&quot;12&quot;)     # 传入的是 &quot;12&quot;，此时，&quot;1&quot; 和 &quot;2&quot; 都会移除，即，按照单个字符移除</code></pre><h3 id="统计指定字符串数量"><a class="anchor" href="#统计指定字符串数量">#</a> 统计指定字符串数量</h3><p>统计字符串中某子串的出现次数</p><pre><code class="language-python">str_name.count(target_str)</code></pre><p>例如：</p><pre><code class="language-python">my_str = &quot;itheima and itcast&quot;cnt = my_str.count('it')</code></pre><h2 id="其他-3"><a class="anchor" href="#其他-3">#</a> 其他</h2><h3 id="统计字符串长度"><a class="anchor" href="#统计字符串长度">#</a> 统计字符串长度</h3><pre><code class="language-python">len(str_name)</code></pre><h3 id="字符串的-while-遍历"><a class="anchor" href="#字符串的-while-遍历">#</a> 字符串的 while 遍历</h3><pre><code class="language-python">idx = 0while idx &lt; len(str_name)    statement    idx += 1</code></pre><h3 id="字符串的-for-遍历"><a class="anchor" href="#字符串的-for-遍历">#</a> 字符串的 for 遍历</h3><pre><code class="language-python">for element in str_name:    statement</code></pre><h1 id="序列"><a class="anchor" href="#序列">#</a> 序列</h1><p>序列是指内容连续、有序，并且可使用下标索引的一类数据容器</p><p>序列是字符串、元组、列表的统称</p><p>序列支持切片，即：从序列的指定位置开始，依次取出元素，到指定位置结束，得到一个新序列（该操作不会影响原序列，而是生成了一个新的序列）</p><pre><code class="language-python">sequence[start:end:step]</code></pre><p>其中：</p><ul><li>起始下标 start 表示从何处开始，可以省略，省略时视为从头开始</li><li>结束下标 end 表示何处结束（不截取结束下标对应元素），可以省略，省略时视为截取至序列末尾（截取最后一个元素）</li><li>步长 step 表示依次取元素的间隔，步长可以为负数，表示反向取元素（注意，起始下标和结束下标也要反向标记）</li></ul><h1 id="集合"><a class="anchor" href="#集合">#</a> 集合</h1><p>集合（set）：不支持元素重复（自带去重功能），并且内容无序</p><p>集合是无序的，不支持下标索引访问</p><p>集合是可以修改的</p><h2 id="集合的定义"><a class="anchor" href="#集合的定义">#</a> 集合的定义</h2><p>定义集合：使用大括号包围数据，其中，每个数据之间用逗号隔开</p><pre><code class="language-python"># 定义集合字面量&#123;元素1, 元素2, ...&#125;# 定义集合变量变量名称 = &#123;元素1, 元素2, ...&#125;# 定义空集合变量名称 = set()</code></pre><h2 id="集合的方法"><a class="anchor" href="#集合的方法">#</a> 集合的方法</h2><h3 id="添加元素"><a class="anchor" href="#添加元素">#</a> 添加元素</h3><p>将指定元素添加到集合内</p><pre><code class="language-python">set_name.add(element)</code></pre><h3 id="删除元素"><a class="anchor" href="#删除元素">#</a> 删除元素</h3><p>将指定元素从集合内移除</p><pre><code class="language-python">set_name.remove(element)</code></pre><h3 id="随机取出元素"><a class="anchor" href="#随机取出元素">#</a> 随机取出元素</h3><p>从集合中随机取出一个元素（集合本身被修改，元素被移除）</p><p>该操作可以具有返回值</p><pre><code class="language-python">element = set_name.pop()</code></pre><h3 id="清空集合"><a class="anchor" href="#清空集合">#</a> 清空集合</h3><pre><code class="language-python">set_name.clear()</code></pre><h3 id="取两集合的差集"><a class="anchor" href="#取两集合的差集">#</a> 取两集合的差集</h3><p>取出集合 1 与集合 2 的差集：元素在集合 1 中、但不在集合 2 中</p><p>该操作得到一个新集合，集合 1 和集合 2 保持不变</p><pre><code class="language-python">new_set = set1.difference(set2)</code></pre><h3 id="消除两集合的差集"><a class="anchor" href="#消除两集合的差集">#</a> 消除两集合的差集</h3><p>消除集合 1 与集合 2 的差集：对比集合 1 和集合 2，在集合 1 内，删除与集合 2 相同的元素</p><p>该操作修改了集合 2，集合 2 保持不变</p><pre><code class="language-python">set1.difference_update(set2)</code></pre><h3 id="合并两集合"><a class="anchor" href="#合并两集合">#</a> 合并两集合</h3><p>合并 2 个集合：将集合 1 与集合 2 组成新集合</p><p>该操作得到一个新集合，集合 1 与集合 2 保持不变</p><pre><code class="language-python">new_set = set1.union(set2)</code></pre><h2 id="其他-4"><a class="anchor" href="#其他-4">#</a> 其他</h2><h3 id="统计集合元素数量"><a class="anchor" href="#统计集合元素数量">#</a> 统计集合元素数量</h3><pre><code class="language-python">len(set_name)</code></pre><h3 id="集合的遍历"><a class="anchor" href="#集合的遍历">#</a> 集合的遍历</h3><p>集合不支持下标索引，不能使用 while 循环遍历</p><p>集合可以使用 for 循环遍历</p><pre><code class="language-python">for element in set_name    statement</code></pre><h1 id="字典"><a class="anchor" href="#字典">#</a> 字典</h1><p>字典（dict）：存储键值对（即，key-value 对），可以提供基于 key 检索 value 的场景实现</p><p>字典不支持重复的 key ，重复添加等同于覆盖原有数据</p><h2 id="字典的定义"><a class="anchor" href="#字典的定义">#</a> 字典的定义</h2><p>使用大括号 {} 包围元素，其中，每一个元素都是一个键值对（key: value），元素之间用逗号隔开</p><pre><code class="language-python"># 定义字典字面量&#123;key: value, key: value, ...&#125;# 定义字典变量变量名称 = &#123;key: value, key: value, ...&#125;# 定义空字典变量名称 = &#123;&#125;变量名称 = dict()</code></pre><p>字典的 key 和 value 可以是任意数据类型（key 不可为字典）</p><p>因此可以将 字典 2 作为 字典 1 的 value ，实现字典的嵌套</p><p>例如：</p><pre><code class="language-python">score_dict = &#123;    &quot;小红&quot;: &#123;&quot;语文&quot;: 77, &quot;数学&quot;: 66, &quot;英语&quot;: 33&#125;,    &quot;小明&quot;: &#123;&quot;语文&quot;: 88, &quot;数学&quot;: 86, &quot;英语&quot;: 55&#125;,    &quot;小花&quot;: &#123;&quot;语文&quot;: 99, &quot;数学&quot;: 96, &quot;英语&quot;: 66&#125;&#125;print(f&quot;score_dict 的内容为：&#123;score_dict&#125;，类型为：&#123;type(score_dict)&#125;&quot;)print(f&quot;小红的语文成绩为：&#123;score_dict['小红']['语文']&#125;&quot;)print(f&quot;小明的数学成绩为：&#123;score_dict['小明']['数学']&#125;&quot;)print(f&quot;小花的英语成绩为：&#123;score_dict['小花']['英语']&#125;&quot;)print()</code></pre><h2 id="字典的方法"><a class="anchor" href="#字典的方法">#</a> 字典的方法</h2><h3 id="访问元素-4"><a class="anchor" href="#访问元素-4">#</a> 访问元素</h3><p>字典同集合一样，不支持下标索引。但是，字典可以通过 key 来获取对应的 value</p><pre><code class="language-python">value = dict_name[key]</code></pre><h3 id="添加更新元素"><a class="anchor" href="#添加更新元素">#</a> 添加 / 更新元素</h3><p>新增元素 / 更新元素：如果 key 不存在，则新增元素；如果 key 存在，则更新元素（更新 value 值）</p><pre><code class="language-python">dict_name[key] = value</code></pre><h3 id="删除元素-2"><a class="anchor" href="#删除元素-2">#</a> 删除元素</h3><p>将 key 所在键值对从字典中删除</p><p>该操作具有返回值，可以获取 key 所对应的 value</p><pre><code class="language-python">value = dict_name.pop(key)</code></pre><h3 id="清空字典"><a class="anchor" href="#清空字典">#</a> 清空字典</h3><pre><code class="language-python">dict_name.clear()</code></pre><h3 id="获取-key-列表"><a class="anchor" href="#获取-key-列表">#</a> 获取 key 列表</h3><p>获取全部的 key</p><pre><code class="language-python">keys = dict_name.keys()</code></pre><p>例如：</p><pre><code class="language-python">my_dict = &#123;&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2, &quot;d&quot;: 3&#125;keys = my_dict.keys()print(f&quot;通过 keys 方法获取全部的 key ，结果为：&#123;keys&#125; ，其数据类型为：&#123;type(keys)&#125;&quot;)</code></pre><h2 id="其他-5"><a class="anchor" href="#其他-5">#</a> 其他</h2><h3 id="统计元素数量-2"><a class="anchor" href="#统计元素数量-2">#</a> 统计元素数量</h3><p>统计字典的元素数量（一个键值对视为一个元素）</p><pre><code class="language-python">len(dict_name)</code></pre><h3 id="字典的遍历"><a class="anchor" href="#字典的遍历">#</a> 字典的遍历</h3><p>方式 1：获取全部的 key ，从而实现遍历</p><pre><code class="language-python">keys = dict_name.keys()for key in keys:    statement</code></pre><p>方式 2：直接对字典进行 for 循环遍历，每次循环都是直接得到 key</p><pre><code class="language-python">for key in dict_name:    statement</code></pre><h1 id="数据容器的通用操作"><a class="anchor" href="#数据容器的通用操作">#</a> 数据容器的通用操作</h1><h2 id="统计元素数量-3"><a class="anchor" href="#统计元素数量-3">#</a> 统计元素数量</h2><pre><code class="language-python">len(数据容器)</code></pre><h2 id="获取最大元素"><a class="anchor" href="#获取最大元素">#</a> 获取最大元素</h2><pre><code class="language-python">max(数据容器)</code></pre><h2 id="获取最小元素"><a class="anchor" href="#获取最小元素">#</a> 获取最小元素</h2><pre><code class="language-python">min(数据容器)</code></pre><h2 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h2><h3 id="转为列表"><a class="anchor" href="#转为列表">#</a> 转为列表</h3><p>将给定容器转换为列表</p><ul><li>若原容器为字符串，则将字符串中的每个字符分别作为列表的一个元素</li><li>若原容器为字典，则将字典的每个 key 分别作为列表的一个元素（value 被舍弃）</li></ul><pre><code class="language-python">list(数据容器)</code></pre><h3 id="转为元组"><a class="anchor" href="#转为元组">#</a> 转为元组</h3><p>将给定容器转换为元组</p><ul><li>若原容器为字符串，则将字符串中的每个字符分别作为元组的一个元素</li><li>若原容器为字典，则将字典的每个 key 分别作为元组的一个元素（value 被舍弃）</li></ul><pre><code class="language-python">tuple(数据容器)</code></pre><h3 id="转为字符串"><a class="anchor" href="#转为字符串">#</a> 转为字符串</h3><p>将给定容器转换为字符串：整个容器（包括容器的组成括号）均被转换为字符串</p><pre><code class="language-python">str(数据容器)</code></pre><p>例如：</p><pre><code class="language-python">mylist = [1,2,3,4]mytuple = (1,2,3,4,5)myset = &#123;2,3,4,5&#125;mydict = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;str1 = str(mylist)      # '[1, 2, 3, 4]'str2 = str(mytuple)     # '(1, 2, 3, 4, 5)'str3 = str(myset)       # '&#123;2, 3, 4, 5&#125;'str4 = str(mydict)      # &quot;&#123;'a': 1, 'b': 2&#125;&quot;</code></pre><h3 id="转为集合"><a class="anchor" href="#转为集合">#</a> 转为集合</h3><p>将给定容器转换为集合</p><ul><li>若原容器为字典，则将字典的每个 key 分别作为集合的一个元素（value 被舍弃）</li></ul><pre><code class="language-python">set(数据容器)</code></pre><blockquote><p>转换为集合后，原容器的数据有序性将不再保持</p></blockquote><h2 id="排序"><a class="anchor" href="#排序">#</a> 排序</h2><p>将给定容器进行排序：</p><ul><li>排序的结果为列表对象（即，将给定容器的内容进行排序，并将结果放入列表中）</li></ul><p>按升序排序（默认按照升序排序）：</p><pre><code class="language-python">sorted(容器)</code></pre><p>按降序排序：</p><pre><code class="language-python">sorted(容器, reverse=True)</code></pre><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVS8=">黑马程序员</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3B5dGhvbi9pbmRleC5hc3A=">W3school</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24zL3B5dGhvbjMtdHV0b3JpYWwuaHRtbA==">菜鸟教程</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 基本语法</title>
      <link href="/posts/2bc936a0/"/>
      <url>/posts/2bc936a0/</url>
      
        <content type="html"><![CDATA[<h1 id="条件语句"><a class="anchor" href="#条件语句">#</a> 条件语句</h1><h2 id="if"><a class="anchor" href="#if">#</a> if</h2><pre><code class="language-python">if condition:    statement</code></pre><h2 id="if-else"><a class="anchor" href="#if-else">#</a> if - else</h2><pre><code class="language-python">if condition:    statement1else:    statement2</code></pre><h2 id="if-eles-if-else"><a class="anchor" href="#if-eles-if-else">#</a> if - eles if - else</h2><pre><code class="language-python">if condition1:    statement1elif condition2:    statement2else:    statement3</code></pre><h1 id="循环语句"><a class="anchor" href="#循环语句">#</a> 循环语句</h1><h2 id="while"><a class="anchor" href="#while">#</a> while</h2><pre><code class="language-python">while condition:    statement</code></pre><h2 id="for"><a class="anchor" href="#for">#</a> for</h2><p>for 循环无法定义循环条件，只能从 序列 中取出数据处理</p><pre><code class="language-python">for i in sequence:    statement</code></pre><h2 id="range"><a class="anchor" href="#range">#</a> range</h2><p>range 语句：产生一个序列</p><ul><li><code>range(num)</code> : 从 0 开始、到 num 结束（不包含 num 本身）</li><li><code>range(num1, num2)</code> : 从 num1 开始、到 num2 结束（不包含 num2 本身）</li><li><code>range(num1, num2, step)</code> : 从 num1 开始、到 num2 结束（不包含 num2 本身），步长为 step</li></ul><h2 id="continue"><a class="anchor" href="#continue">#</a> continue</h2><p>continue: 中断本次循环，直接进入下一次循环</p><p>continue 可用于 while 和 for 循环</p><h2 id="break"><a class="anchor" href="#break">#</a> break</h2><p>break: 直接结束循环</p><p>break 可用于 while 和 for 循环</p><h1 id="函数"><a class="anchor" href="#函数">#</a> 函数</h1><p>函数的定义：</p><pre><code class="language-python">def func(parameters):    statement    return results</code></pre><p><strong>函数必须先定义后使用</strong></p><h2 id="函数的返回值"><a class="anchor" href="#函数的返回值">#</a> 函数的返回值</h2><p>如果函数没有 return 语句，将默认返回 None</p><blockquote><p>None 可用于声明无初始内容的变量，并且，None 可用于 if 判断</p></blockquote><p>如果函数有多个返回值，则将多个返回值（用逗号分隔）同时放在一个 return 语句中</p><p>例如：</p><pre><code class="language-python">def div(x, y):    quotient = x // y    remainder = x % y    return quotient, remainder</code></pre><h2 id="传参方式"><a class="anchor" href="#传参方式">#</a> 传参方式</h2><h3 id="位置参数"><a class="anchor" href="#位置参数">#</a> 位置参数</h3><p>调用函数时根据函数定义的参数位置来传递参数</p><p>注意：实参的顺序及个数必须与形参列表保持一致</p><h3 id="关键字参数"><a class="anchor" href="#关键字参数">#</a> 关键字参数</h3><p>函数调用时通过 “key=value” 形式传递参数</p><p>可以让函数更见清晰，同时也消除了参数的顺序需求（关键字参数之间不存在先后顺序）</p><p>注意：在调用函数时，如果混用位置参数与关键字参数，必须将位置参数放在关键字参数的前面</p><h3 id="缺省参数默认参数"><a class="anchor" href="#缺省参数默认参数">#</a> 缺省参数（默认参数）</h3><p>定义函数时，如果为参数提供默认值，则在调用函数时可以不传递该默认参数的值</p><p>在调用函数时，如果为缺省参数传递值则修改默认参数值，否则，使用默认值</p><p>注意：无论是定义函数或者调用函数，所有位置参数都必须出现在默认参数之前</p><h3 id="不定长参数可变参数"><a class="anchor" href="#不定长参数可变参数">#</a> 不定长参数（可变参数）</h3><p>不定长参数用于不确定实参数量（不传参也可以）的场景</p><p>不定长参数的类型：</p><ul><li>位置传递</li><li>关键字传递</li></ul><h4 id="位置不定长"><a class="anchor" href="#位置不定长">#</a> 位置不定长</h4><p>位置不定长传递以 * 号标记一个形式参数，以元组的形式接收传入的实参，形式参数一般命名为 args</p><p>例如：</p><pre><code class="language-python">def user_info(*args):    print(args)# ('TOM',)user_info('TOM')# ('TOM', 18)user_info('TOM', 18)</code></pre><h4 id="关键字不定长"><a class="anchor" href="#关键字不定长">#</a> 关键字不定长</h4><p>关键字不定长传递以 ** 号标记一个形式参数，以字典的形式接收传入的实参，形式参数一般命名为 kwargs</p><p>传递的所有实参均为 &quot;key=value&quot; 形式</p><p>例如：</p><pre><code class="language-python">def user_info(**kwargs):    print(kwargs)# ('name': 'TOM', 'age': 18, 'id': 198)user_info(name='TOM', age=18, id=198)</code></pre><h2 id="函数作为参数传递"><a class="anchor" href="#函数作为参数传递">#</a> 函数作为参数传递</h2><p>函数本身是可以作为参数传入到另一个函数中使用的</p><p>将函数作为参数的作用：传入的是计算逻辑，而不是计算数据</p><h2 id="lambda-匿名函数"><a class="anchor" href="#lambda-匿名函数">#</a> lambda 匿名函数</h2><p>函数的两种定义方式：</p><ul><li><code>def</code>  关键字可以定义带有名称的函数，该函数可以重复使用</li><li><code>lambda</code>  关键字可以定义匿名函数（无名称），该函数只可临时使用一次</li></ul><p>匿名函数的定义：</p><pre><code class="language-python">lambda 传入参数: 函数体</code></pre><p>其中：</p><ul><li><code>lambda</code>  是关键字，表示定义匿名函数</li><li>传入参数表示匿名函数的形式参数（可以传入多个参数）</li><li>函数体只能写一行，无法写多行代码</li></ul><p>例如：</p><pre><code class="language-python"># compute 函数作为参数传入 test_func 函数def test_func(compute):    result = compute(1, 2)    print(result)def compute(x, y):    return x + y# 通过 def 定义 compute 函数并传入test_func(compute)  # 结果：3# 通过 lambda 关键字定义匿名函数并传入test_func(lambda x, y: x + y)   # 结果：3</code></pre><h1 id="局部变量与全局变量"><a class="anchor" href="#局部变量与全局变量">#</a> 局部变量与全局变量</h1><p>局部变量：定义在函数体内部的变量，只在函数体内部生效</p><p>全局变量：在函数体内、外都能生效的变量</p><p>在函数内无法修改全局变量</p><blockquote><p>如果尝试在函数内部修改全局变量，实际上是定义了一个与全局变量同名的局部变量</p></blockquote><p>使用 global 关键字，可以在函数内部声明变量为全局变量</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVS8=">黑马程序员</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3B5dGhvbi9pbmRleC5hc3A=">W3school</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24zL3B5dGhvbjMtdHV0b3JpYWwuaHRtbA==">菜鸟教程</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 227. 基本计算器 II</title>
      <link href="/posts/cf6d2393/"/>
      <url>/posts/cf6d2393/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNpYy1jYWxjdWxhdG9yLWlpL2Rlc2NyaXB0aW9uLw==">227. 基本计算器 II</span></p><p>给你一个字符串表达式  <code>s</code>  ，请你实现一个基本计算器来计算并返回它的值</p><p>整数除法仅保留整数部分</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2^{31}, 2^{31} - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的范围内</p><p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数（例如  <code>eval()</code>  ）</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;3+2*2&quot;输出：7</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot; 3/2 &quot;输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot; 3+5 / 2 &quot;输出：5</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></li><li>s 由整数和算符 ( <code>'+'</code> ,  <code>'-'</code> ,  <code>'*'</code> ,  <code>'/'</code> ) 组成，中间由一些 <strong>空格</strong> 隔开</li><li>s 表示一个 <strong>有效表达式</strong></li><li>表达式中的所有整数都是非负整数，且在范围 [0, 2<sup>31</sup> - 1] 内</li><li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li></ul><h1 id="method-栈"><a class="anchor" href="#method-栈">#</a> Method: 栈</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>由于乘除优先于加减计算，可以先进行所有乘除运算，并将这些乘除运算的结果放回原表达式的相应位置，最终，整个表达式的结果就等于一系列整数加减后的值</p><p>因此，可以用一个栈保存这些（进行乘除运算后的）整数的值</p><ul><li>对于  <code>'+'</code>  后面的数字，将其直接压入栈中</li><li>对于  <code>'-'</code>  后面的数组，将其相反数压入栈中</li><li>对于  <code>'*'</code>  或  <code>'/'</code>  后面的数字，可直接将其与栈顶元素计算，并使用计算结果替换栈顶元素</li></ul><p>最后将栈中元素进行累加，即可得到字符串表达式的值</p><h2 id="算法流程"><a class="anchor" href="#算法流程">#</a> 算法流程</h2><p>定义  <code>num</code>  为当前处理的整数</p><p>定义变量  <code>sign</code>  为整数之前的运算符（将第一个数字之前的运算符视为加号）</p><p>遍历字符串  <code>s</code></p><ul><li>若当前字符  <code>s[i]</code>  为数字字符，则更新当前整数值  <code>num</code>  ： <code>num = num * 10 + (s[i] - '0')</code></li><li>若当前字符  <code>s[i]</code>  为运算符或者字符串最后一个字符，则说明已经遍历到了整数  <code>num</code>  的末尾，此时需根据整数  <code>num</code>  之前的运算符  <code>sign</code>  对  <code>num</code>  进行处理：<ul><li>若  <code>sign</code>  为  <code>'+'</code>  ：将  <code>num</code>  压入栈；</li><li>若  <code>sign</code>  为  <code>'-'</code>  ：将  <code>- num</code>  压入栈；</li><li>若  <code>sign</code>  为  <code>'*'</code>  或  <code>'/'</code>  ：将其与栈顶元素计算，并将栈顶元素替换为计算结果</li></ul></li><li>待处理  <code>num</code>  后，更新  <code>sign</code>  为当前遍历到的运算符</li></ul><p>最后，将栈中元素进行累加</p><blockquote><p>这里可以用  <code>vector</code>  数组模拟栈，以便最后计算栈中元素之和</p></blockquote><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int calculate(string s) &#123;    vector&lt;int&gt; stk;     // 模拟栈    int num = 0;         // 当前处理的整数    char sign = '+';     // 整数前面的运算符    for (int i = 0; i &lt; s.size(); ++i) &#123;        // 遇到数字字符，计算对应的整数        if (isdigit(s[i])) &#123;            num = num * 10 + (s[i] - '0');        &#125;        // 遇到算术符或者字符串末尾，执行算术运算        if ((!isdigit(s[i]) &amp;&amp; !isspace(s[i])) || i == s.size() - 1) &#123;            if (sign == '+') &#123;                stk.push_back(num);            &#125; else if (sign == '-') &#123;                stk.push_back(-num);            &#125; else if (sign == '*') &#123;                stk.back() *= num;            &#125; else if (sign == '/') &#123;                stk.back() /= num;            &#125;            sign = s[i]; // 更新 sign 为当前遍历到的运算符            num = 0;     // 重置整数        &#125;    &#125;    int ans = 0;    for (int tmp : stk) ans += tmp;    return ans;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h2><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNpYy1jYWxjdWxhdG9yLWlpL3NvbHV0aW9ucy82NDg2NDcvamktYmVuLWppLXN1YW4tcWktaWktYnktbGVldGNvZGUtc29sdXRpby1jbTI4Lw==">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNpYy1jYWxjdWxhdG9yLWlpL3NvbHV0aW9ucy82NDg4MzIvc2hpLXlvbmctc2h1YW5nLXpoYW4tamllLWp1ZS1qaXUtamktYmlhby1jNjVrLw==">宫水三叶：双栈解法</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1296. 划分数组为连续数字的集合</title>
      <link href="/posts/a1960852/"/>
      <url>/posts/a1960852/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXZpZGUtYXJyYXktaW4tc2V0cy1vZi1rLWNvbnNlY3V0aXZlLW51bWJlcnMvZGVzY3JpcHRpb24v">1296. 划分数组为连续数字的集合</span></p><p>给你一个整数数组  <code>nums</code>  和一个正整数  <code>k</code> ，请你判断是否可以把这个数组划分成一些由  <code>k</code>  个连续数字组成的集合</p><p>如果可以，请返回  <code>true</code> ；否则，返回  <code>false</code></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,3,4,4,5,6], k = 4输出：true解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3输出：true解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3,2,2,1,1], k = 3输出：true</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：nums = [1,2,3,4], k = 3输出：false解释：数组不能分成几个大小为 3 的子数组。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-排序-哈希"><a class="anchor" href="#method-排序-哈希">#</a> Method: 排序 + 哈希</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>题目要求将数组划分成若干个集合，其中，每个集合包含 k 个连续数字</p><p>可以从尚未分组的元素中找出值最小的元素，将其作为集合的第一个元素（记作 x ），于是该集合中数字的范围应为 [x, x + k - 1] 。如果某个数字不存在，则无法将数组划分成符合条件的集合，返回 false</p><p>将 [x, x + k - 1] 这 k 个元素划分到一个集合之后，继续对数组中剩余的数字进行分组，直到 所有元素均已分组 或者 遇到无法分组的情况</p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">bool isPossibleDivide(vector&lt;int&gt;&amp; nums, int k) &#123;    if (nums.size() % k) return false;          // 数组长度无法被 k 整除，返回 false    sort(nums.begin(), nums.end());             // 将数组按从小到大排序    unordered_map&lt;int, int&gt; hashmap;    for (auto num : nums) ++hashmap[num];       // 统计每个数字的出现次数    for (int i = 0; i &lt; nums.size() / k; ++i) &#123; // 一共有 nums.size() / k 个集合        int first = 0;                          // 集合中第一个元素的下标        while (first &lt; nums.size() &amp;&amp; hashmap[nums[first]] == 0) &#123; // 寻找未被使用的、值最小的元素            ++first;        &#125;        --hashmap[nums[first]];                 // 将 nums[first] 添加到集合（可用次数减 1 ）        for (int j = 1; j &lt; k; ++j) &#123;           // 寻找剩余的 k - 1 个元素            if (hashmap[nums[first] + j] == 0)  // 不存在 nums[first] + j 这个数，数字不连续，返回 false                return false;            else                                // 存在 nums[first] + j 这个数，将其可用次数减 1                --hashmap[nums[first] + j];        &#125;    &#125;    return true;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑哈希表所需空间</p><h2 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h2><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXZpZGUtYXJyYXktaW4tc2V0cy1vZi1rLWNvbnNlY3V0aXZlLW51bWJlcnMvc29sdXRpb25zLzEwMTgwOS9odWEtZmVuLXNodS16dS13ZWktbGlhbi14dS1zaHUtemktZGUtamktaGUtYnktbGUtMi8=">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 554. 砖墙</title>
      <link href="/posts/f9f1bc1c/"/>
      <url>/posts/f9f1bc1c/</url>
      
        <content type="html"><![CDATA[<p>你的面前有一堵矩形的、由  <code>n</code>  行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p><p>你现在要画一条 <strong>自顶向下</strong> 的、穿过 <strong>最少</strong> 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的</strong> 。</p><p>给你一个二维数组  <code>wall</code>  ，该数组包含这堵墙的相关信息。其中， <code>wall[i]</code>  是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p><p><img data-src="/posts/f9f1bc1c/Example.jpg" class=""></p><p><strong>示例 1：</strong></p><pre><code>输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：wall = [[1],[1],[1]]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>n == wall.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>wall[i].length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>sum(wall[i].length)</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>对于每一行  <code>i</code>  ， <code>sum(wall[i])</code>  是相同的</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>wall[i][j]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="method-哈希"><a class="anchor" href="#method-哈希">#</a> Method: 哈希</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>穿过最少的砖块 等价于 穿过最多的间隙</p><p>可以使用哈希表记录每个间隙的出现次数（以间隙索引位置为 key ，以间隙出现次数为 value），然后从所有行中找出间隙最大出现次数，利用 <strong>行数 减去 间隙出现最大次数 即为 穿过砖块最小数</strong></p><p>其中，每一行中的间隙的索引 需要按 <strong>前缀和</strong> 方法求得，例如，第一行的第一个间隙的索引为  <code>wall[0][0]</code>  ，第二个间隙的索引为  <code>wall[0][0] + wall[0][1]</code>  ，第 i 个间隙的索引为  <code>wall[0][0] + ... + wall[0][i]</code></p><p>注意：不能沿着砖墙两侧的最边缘画线，因此不需要统计砖墙两侧的间隙</p><p>如下图所示，间隙 4 在所有行中出现次数最多，出现次数为 4 次，而总行数为 6 ，因此穿过砖块数为 2</p><p height="150px"><img data-src="/posts/f9f1bc1c/Flow.png" class=""></p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int leastBricks(vector&lt;vector&lt;int&gt;&gt;&amp; wall) &#123;    unordered_map&lt;int, int&gt; hash;    for (int i = 0; i &lt; wall.size(); ++i) &#123;        int sum = 0;        for (int j = 0; j &lt; wall[i].size() - 1; ++j) &#123; // 不能沿着最边缘画线            sum += wall[i][j];                         // 间隙的索引            ++hash[sum];        &#125;    &#125;    int maxCnt = 0;    for (auto it : hash) &#123;        maxCnt = max(maxCnt, it.second);    &#125;    return wall.size() - maxCnt;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为砖块总个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9icmljay13YWxsL3NvbHV0aW9uL2dvbmctc2h1aS1zYW4teGllLXpoZW5nLW5hbi16ZS1mYW4tc2hpLXktZ3NyaS8=">宫水三叶：使用哈希表求解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9icmljay13YWxsL3NvbHV0aW9uL3podWFuLXFpYW5nLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLTJrbHMv">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 463. 岛屿的周长</title>
      <link href="/posts/a8ab548b/"/>
      <url>/posts/a8ab548b/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pc2xhbmQtcGVyaW1ldGVyLw==">LeetCode 463. Island Perimeter</span></p><p>给定一个  <code>row x col</code>  的二维网格地图  <code>grid</code>  ，其中： <code>grid[i][j] = 1</code>  表示陆地， <code>grid[i][j] = 0</code>  表示水域</p><p>网格中的格子 <strong>水平</strong> 和 <strong>垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）</p><p>岛屿中没有 “湖”（“湖” 是指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/a8ab548b/Example1.png" class=""></p><pre><code>输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[1]]输出：4</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：grid = [[1,0]]输出：4</code></pre><p><strong>提示：</strong></p><ul><li><code>row == grid.length</code></li><li><code>col == grid[i].length</code></li><li><code>1 &lt;= row, col &lt;= 100</code></li><li><code>grid[i][j]</code>  为  <code>0</code>  或  <code>1</code></li></ul><h1 id="method-1-模拟"><a class="anchor" href="#method-1-模拟">#</a> Method 1: 模拟</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>对于一个岛屿格子的每条边：如果这条边为网格的边界，或者这条边是岛屿与水域的分界线，则需将这条边计入岛屿的周长</p><p>因此，可以遍历每个岛屿格子，看其四个方向的边是否为网格边界或水域分界线，如果是，则计入岛屿周长</p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int m = grid.size();    int n = grid[0].size();    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;0,1&#125;, &#123;0,-1&#125;, &#123;1,0&#125;, &#123;-1,0&#125;&#125;;    int res = 0;    for (int i = 0; i &lt; m; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            if (grid[i][j] == 0) continue;            for (int k = 0; k &lt; 4; ++k) &#123;                int x = i + dir[k][0];                int y = j + dir[k][1];                if (x == -1 || x == m || y == -1 || y == n) ++res; // 网格边界                else if (grid[x][y] == 0) ++res;                   // 水域分界线            &#125;        &#125;    &#125;    return res;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别为网格的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-深度优先搜索"><a class="anchor" href="#method-2-深度优先搜索">#</a> Method 2: 深度优先搜索</h1><h2 id="算法思路-2"><a class="anchor" href="#算法思路-2">#</a> 算法思路</h2><p>可以将方法一改成深度优先搜索遍历的方式（该方式可以拓展至多个岛屿情形）</p><p>其中，为避免岛屿格子被重复遍历，需要将已经遍历过的岛屿格子标记。特别地，可以将已经遍历过的岛屿格子的值置为 -1 （不能置为 0，因为置 0 会形成新的 “水域边界线”，进而导致结果出错）</p><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;0,1&#125;, &#123;0,-1&#125;, &#123;1,0&#125;, &#123;-1,0&#125;&#125;;int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123;    int m = grid.size();    int n = grid[0].size();    if (x == -1 || x == m || y == -1 || y == n) return 1;    if (grid[x][y] == 0) return 1;    if (grid[x][y] == -1) return 0;    grid[x][y] = -1;    int count = 0;    for (int k = 0; k &lt; 4; ++k) &#123;        int newx = x + dir[k][0];        int newy = y + dir[k][1];        count += dfs(grid, newx, newy);    &#125;    return count;&#125;int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int m = grid.size();    int n = grid[0].size();    int ans = 0;    for (int i = 0; i &lt; m; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            if (grid[i][j] == 1)                ans += dfs(grid, i, j);        &#125;    &#125;    return ans;&#125;</code></pre><h2 id="复杂度分析-2"><a class="anchor" href="#复杂度分析-2">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别为网格的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pc2xhbmQtcGVyaW1ldGVyL3NvbHV0aW9uL2Rhby15dS1kZS16aG91LWNoYW5nLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类</title>
      <link href="/posts/9e07c79c/"/>
      <url>/posts/9e07c79c/</url>
      
        <content type="html"><![CDATA[<h1 id="定义抽象数据类型"><a class="anchor" href="#定义抽象数据类型">#</a> 定义抽象数据类型</h1><p>类的基本思想是<strong>数据抽象</strong>（data abstraction）和<strong>封装</strong>（encapsulation）</p><p>数据抽象是一种依赖于<strong>接口</strong>（interface）和<strong>实现</strong>（implementation）分离的编程（以及设计）技术</p><ul><li>类的接口：包括用户所能执行的操作</li><li>类的实现：包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数</li></ul><p>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分</p><p>类要想实现数据抽象和封装，需要首先定义一个<strong>抽象数据类型</strong>（abstract data type）</p><ul><li>在抽象数据类型中，由类的设计者负责考虑类的实现过程</li><li>使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节</li></ul><p>本节将以 Sales_data 类为例，介绍类的定义与使用</p><h2 id="设计-sales_data-类"><a class="anchor" href="#设计-sales_data-类">#</a> 设计 Sales_data 类</h2><p>我们希望 Sales_item 类有一个名为 isbn 的成员函数（member function），并且具有一些等效于 + 、= 、+= 、&lt;&lt;和&gt;&gt; 运算符的函数</p><p>于是，Sales_data 的接口应该包含以下操作：</p><ul><li>一个 isbn 成员函数，用于返回对象的 ISBN 编号</li><li>一个 combine 成员函数，用于将一个 Sales_data 对象加到另一个对象上（等效于 += 运算符）</li><li>一个名为 add 的普通函数，执行两个 Sales_data 对象的加法（等效于 + 运算符）</li><li>一个名为 read 的普通函数，将数据从 istream 读入到 Sales_data 对象中（等效于 &gt;&gt; 运算符）</li><li>一个名为 print 的函数，将 Sales_data 对象的值输出到 ostream （等效于 &lt;&lt; 运算符）</li></ul><p>定义 Sales_data 类如下所示：</p><pre><code class="language-cpp">struct Sales_data &#123;    // 数据成员    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;    // 成员函数：关于 Sales_data 对象的操作    std::string isbn() const &#123; return bookNo; &#125;    Sales_data&amp; combine(const Sales_data&amp;);    double avg_price() const;&#125;;// 非成员的普通函数Sales_data add(const Sales_data&amp;, const Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;);</code></pre><p>其中，Sales_data 类的数据成员包括：bookNo 、units_sold 、revenue ，分别表示书本的 ISBN 编号、销量、总销售额；Sales_data 类的成员函数包括 isbn 和 combine ；add、read 和 print 则是普通函数，并未作为 Sales_data 类的成员</p><p>Sales_data 类的使用示例：</p><pre><code class="language-cpp">Sales_data total;if (read(cin, total))  &#123;    Sales_data trans;    while(read(cin, trans)) &#123;        if (total.isbn() == trans.isbn())            total.combine(trans);        else &#123;            print(cout, total) &lt;&lt; endl;            total = trans;        &#125;    &#125;    print(cout, total) &lt;&lt; endl;&#125; else &#123;    cerr &lt;&lt; &quot;No data?!&quot; &lt;&lt; endl;&#125;</code></pre><h3 id="定义成员函数"><a class="anchor" href="#定义成员函数">#</a> 定义成员函数</h3><p><strong>成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部</strong></p><p>例如，上述的 isbn 函数定义在 Sales_data 类的内部，combine 和 avg_price 定义在类的外部</p><p>和其他函数一样，类的成员函数也由函数类型、函数名、形参列表和函数体组成。以 isbn 函数为例，isbn 函数用于返回 Sales_data 对象的 bookNo 数据成员，其定义为</p><pre><code class="language-cpp">std::string isbn() const &#123; return bookNo; &#125;</code></pre><p>然而，isbn 函数是如何获得 bookNo 成员所依赖的对象的呢？</p><h4 id="this"><a class="anchor" href="#this">#</a> this</h4><p>不妨先观察 isbn 成员函数的调用：使用点运算符访问 trans 对象的 isbn 成员，由此来调用该函数</p><pre><code class="language-cpp">Sales_data trans;trans.isbn();</code></pre><p><strong>成员函数通过一个名为 <strong> <code>this</code> </strong> 的隐式参数来访问调用它的那个对象</strong>。具体来说，当我们调用一个成员函数时，请求该函数的对象地址 将会被用于初始化  <code>this</code></p><p>例如，如果调用  <code>trans.isbn()</code>  ，编译器将会把 trans 的地址传递给 isbn 函数的隐式形参  <code>this</code>  。可以等价地认为，编译器将  <code>trans.isbn()</code>  这一调用重写成了如下形式：</p><pre><code class="language-cpp">// 伪代码，用于说明调用成员函数的实际执行过程Sales_data::isbn(&amp;trans)</code></pre><p>其中，调用 Sales_data 的 isbn 成员时传入了 trans 的地址</p><p>在成员函数内部，可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为  <code>this</code>  所指的就是当前对象。<strong>任何对类成员的直接访问都被看作  <code>this</code>  的隐式引用</strong>，也就是说，当 isbn 使用 bookNo 时，它隐式地使用  <code>this</code>  指向的成员，就像我们书写了 this-&gt;bookNo 一样</p><p>this 形参是隐式定义的。任何自定义名为 this 的参数或变量都是非法的</p><p>我们可以在成员函数体内部使用 this （尽管没有必要）</p><pre><code class="language-cpp">std::string isbn() const &#123; return this-&gt;bookNo; &#125;</code></pre><p>需要注意，<strong> <code>this</code>  是一个常量指针</strong>，不允许改变  <code>this</code>  中保存的地址</p><h4 id="const-成员函数"><a class="anchor" href="#const-成员函数">#</a> const 成员函数</h4><p>isbn 函数的另一个关键之处：参数列表后的  <code>const</code>  关键字，用于修改隐式  <code>this</code>  指针的类型</p><p>默认情况下， <code>this</code>  的类型是指向类类型非常量版本的常量指针。例如，在 Sales_data 的成员函数中，this 的类型是 Sales_data *const</p><p>尽管  <code>this</code>  是隐式的，也依然需要遵循初始化规则，这意味着：（在默认情况下）我们不能把  <code>this</code>  绑定到一个常量对象上，即，我们不能在一个常量对象上调用普通的成员函数（不加  <code>const</code>  的成员函数）</p><p>于是，我们不禁会想到：如果想要在常量对象上调用普通成员函数，就应该将  <code>this</code>  声明成指向常量的指针（即，const Sales_data *const ）。然而， <code>this</code>  是隐式的，并不会出现在参数列表中。那我们应该在哪里将  <code>this</code>  声明成指向常量的指针呢？</p><p>C++ 语言的做法是：允许把  <code>const</code>  关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的  <code>const</code>  表示  <code>this</code>  是一个指向常量的指针</p><p>像这样使用  <code>const</code>  的成员函数被称作 <strong>常量成员函数</strong>（const member function）</p><p>因为  <code>this</code>  是指向常量的指针，常量成员函数不能改变调用它的对象的内容</p><p><strong>常量对象，以及常量对象的引用或指针都只能调用常量成员函数</strong></p><h4 id="类作用域和成员函数"><a class="anchor" href="#类作用域和成员函数">#</a> 类作用域和成员函数</h4><p>类本身就是一个作用域，类成员函数的定义嵌套在类的作用域之内</p><p>在上例中，isbn 中用到的名字 bookNo 是定义在 Sales_data 内的数据成员，并且，即使 bookNo 定义在 isbn 之后，isbn 也还是能够使用 bookNo</p><p>这是因为，编译器分两步处理类：首先编译成员的声明，然后才编译成员函数体（如果有的话）</p><p>因此，<strong>成员函数体可以随意使用类中的其他成员，无须在意这些成员出现的次序</strong></p><h4 id="在类的外部定义"><a class="anchor" href="#在类的外部定义">#</a> 在类的外部定义</h4><p>当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配</p><ul><li>返回类型、参数列表和函数名都得与类内部的声明保持一致</li><li>如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定  <code>const</code>  属性</li></ul><p>并且，类外部定义的成员名字必须包含它所属的类名</p><pre><code class="language-cpp">double Sales_data::avg_price() const &#123;    if (units_sold)        return revenue/units_sold;    else        return 0;&#125;</code></pre><p>其中，函数名 Sales_data::avg_price 使用作用域运算符来说明 avg_price 函数被声明在类 Sales_data 的作用域内。因此，当 avg_price 使用 revenue 和 units_sold 时，它实际上是使用了 Sales_data 的成员</p><h4 id="定义一个返回-this-对象的函数"><a class="anchor" href="#定义一个返回-this-对象的函数">#</a> 定义一个返回 this 对象的函数</h4><p>函数 combine 的设计初衷类似于复合赋值运算符 += 。调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数</p><pre><code class="language-cpp">Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs) &#123;    units_sold += rhs.units_sold; // 把 rhs 的成员加到 this 对象的成员上    revenue += rhs.revenue;    return *this;                 // 返回调用该函数的对象&#125;</code></pre><p>当我们的程序调用如下函数时，</p><pre><code class="language-cpp">total.combine(trans);             // 更新变量 total 的值</code></pre><p>total 的地址被绑定到隐式的 this 参数上，而 rhs 绑定到了 trans 上</p><p>因此，当 combine 执行下面的语句时，</p><pre><code class="language-cpp">units_sold += rhs.units_sold;</code></pre><p>等效于 total.units_sold += trans.unit_sold</p><p>一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符</p><ul><li>内置的赋值运算符把它的左侧运算对象当成左值返回</li><li>为了与它保持一致，combine 函数必须返回引用类型。因为此时的左侧运算对象是一个 Sales_data 的对象，所以返回类型应该是 Sales_data&amp;</li></ul><p>如前所述，我们无须使用隐式的  <code>this</code>  指针访问函数调用者的某个具体成员，但是，我们需要使用  <code>this</code>  来把调用函数的对象当成一个整体访问。因此，需要使用</p><pre><code class="language-cpp">return *this; // 返回调用该函数的对象</code></pre><p>以获得执行该函数的对象，其中，解引用  <code>this</code>  指针就是得到了 total 的地址</p><h3 id="定义类相关的非成员函数"><a class="anchor" href="#定义类相关的非成员函数">#</a> 定义类相关的非成员函数</h3><p><strong>作为接口组成部分的非成员函数，它们的定义和声明都在类的外部</strong>，例如 add、read 和 print 等</p><blockquote><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件</p></blockquote><pre><code class="language-cpp">// 定义 read 函数istream &amp;read(istream &amp;is, Sales_data &amp;item) &#123;    double price = 0;    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    item.revenue = price * item.units_sold;    return is;&#125;// 定义 print 函数ostream &amp;print(ostream &amp;os, const Sales_data &amp;item) &#123;    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot;       &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();    return os;&#125;// 定义 add 函数Sales_data add(const Sales_data &amp;lhs, const Sales_data &amp;rhs) &#123;    Sales_data sum = lhs;  // copy data members from lhs into sum    sum.combine(rhs);      // add data members from rhs into sum    return sum;&#125;</code></pre><p>read 函数从给定流中将数据读到给定的对象里，print 函数则负责将给定对象的内容打印到给定的流中。其中，read 和 print 分别接受一个各自 IO 类型的引用作为其参数，这是因为 IO 类属于不能被拷贝的类型，因此我们只能通过引用来传递它们。而且，因为读取和写入的操作会改变流的内容，两个函数接受的都是普通引用，而非对常量的引用</p><h2 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h2><p>每个类都分别定义了它的对象被初始化的方式</p><p>类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做 <strong>构造函数</strong>（constructor）</p><ul><li><p><strong>构造函数的名字和类名相同</strong></p></li><li><p>类似于其他函数，构造函数有一个参数列表（可能为空）和一个函数体（可能为空）</p></li><li><p><strong>构造函数没有返回类型</strong></p></li></ul><p>构造函数的任务是初始化类对象的数据成员。无论何时，只要类的对象被创建，就会执行构造函数</p><p>类可以包含多个构造函数，但是，不同的构造函数之间必须在参数数量或参数类型上有所区别（类似于函数重载）</p><p>不同于其他成员函数，构造函数不能被声明成  <code>const</code>  。当我们创建类的一个  <code>const</code>  对象时，直到构造函数完成初始化过程，对象才能真正取得其 “常量” 属性。因此，构造函数在构造  <code>const</code>  对象的过程中可以向其写值</p><h3 id="合成的默认构造函数"><a class="anchor" href="#合成的默认构造函数">#</a> 合成的默认构造函数</h3><p>我们的 Sales_data 类并没有定义任何构造函数，但是之前使用了 Sales_data 对象的程序仍然可以正确编译和运行，因此可以说明，Sales_data 对象执行了默认初始化</p><pre><code class="language-cpp">Sales_data total; // 没有为 total 提供初始值，执行默认初始化Sales_data trans; // 没有为 trans 提供初始值，执行默认初始化</code></pre><p>类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做 <strong>默认构造函数</strong>（default constructor）</p><ul><li><p>默认构造函数无须任何实参</p></li><li><p>如果我们的类没有显式地定义构造函数，编译器将会为我们隐式地定义一个默认构造函数</p></li></ul><p>编译器自动生成的构造函数被称为<strong>合成的默认构造函数</strong>（synthesized default constructor）</p><p>对于大多数类来说，合成的默认构造函数将按照如下规则初始化类的数据成员：</p><ul><li>如果存在类内的初始值，用类内初始值来初始化成员</li><li>否则，默认初始化该成员</li></ul><pre><code class="language-cpp">struct Sales_data &#123;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;&#125;</code></pre><p>例如，对上面的类而言，因为 Sales_data 为 units_sold 和 revenue 提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员，而 bookNo 并未提供初始值，所以合成的默认构造函数把 bookNo 默认初始化成一个空字符串</p><p>然而，合成的默认构造函数只适合非常简单的类，比如现在定义的这个 Sales_data 版本</p><p>通常来说，<strong>一个类必须定义它自己的默认构造函数，而不能仅依赖于合成的默认构造函数</strong> 。这是因为：</p><ul><li><p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。一旦我们定义了一些其他的构造函数，类将没有默认构造函数（除非我们自己定义一个默认构造函数）</p></li><li><p>对于某些类来说，合成的默认构造函数可能执行错误的操作。如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数</p></li><li><p>有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。此外，还有其他一些情况也会导致编译器无法生成一个正确的默认构造函数，我们将在以后讨论</p></li></ul><h3 id="定义构造函数"><a class="anchor" href="#定义构造函数">#</a> 定义构造函数</h3><p>对于我们的 Sales_data 类来说，我们可根据实际需要而定义不同的构造函数，例如：</p><pre><code class="language-cpp">struct Sales_data &#123;    // 数据成员及成员函数    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;    std::string isbn() const &#123; return bookNo; &#125;    Sales_data&amp; combine(const Sales_data&amp;);    double avg_price() const;    // 构造函数    Sales_data() = default;    Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125;    Sales_data(const std::string &amp;s, unsigned n, double p):               bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;    Sales_data(std::istream &amp;);&#125;;</code></pre><h4 id="default"><a class="anchor" href="#default">#</a> = default</h4><p>在 C++ 11 标准中，如果我们需要默认的行为，可以通过在参数列表后面写上  <code>= default</code>  来要求编译器生成默认构造函数，其作用完全等同于之前使用的合成默认构造函数</p><p>其中， <code>= default</code>  既可以与声明一起出现在类的内部，也可以作为定义出现在类的外部</p><ul><li>如果  <code>= default</code>  在类的内部，则默认构造函数是内联的</li><li>如果它在类的外部，则该成员默认情况下不是内联的</li></ul><blockquote><p>If the  <code>= default</code>  appears inside the class body, the default constructor will be inlined; if it appears on the definition outside the class, the member will not be inlined by default.</p></blockquote><p>例如：</p><pre><code class="language-cpp">Sales_data() = default;</code></pre><p>需注意， <code>= default</code>  生成的默认构造函数之所以对 Sales_data 类有效，是因为我们已经为内置类型的数据成员提供初始值。如果编译器不支持类内初始值，默认构造函数就应该使用构造函数初始值列表来初始化类的每个成员</p><h4 id="构造函数初始值列表"><a class="anchor" href="#构造函数初始值列表">#</a> 构造函数初始值列表</h4><p>对于以下两个构造函数，其定义中出现了新的部分，即，冒号 以及 冒号与花括号之间的代码。我们把新出现的部分称为 <strong>构造函数初始值列表</strong>（constructor initialize list）</p><pre><code class="language-cpp">Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125;Sales_data(const std::string &amp;s, unsigned n, double p):           bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;</code></pre><p>构造函数初始值列表负责为新创建对象的一个或几个数据成员赋初值</p><p>构造函数初始值列表的组成：</p><ul><li>成员名字</li><li>成员名字后面的、括号（或者花括号）括起来的成员初始值</li><li>不同成员之间的逗号分隔符</li></ul><p>以  <code>Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;</code>  为例，该函数使用  <code>s</code>  和  <code>n</code>  来分别初始化成员 bookNo 和 units_sold ，并用  <code>p</code>  与  <code>n</code>  的乘积来初始化 revenue</p><p><code>Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125;</code>  ，其只使用  <code>s</code>  来显式初始化 bookNo 。对于 units_sold 和 revenue 这两个成员而言，将利用类内初始值进行隐式初始化（类似于合成默认构造函数的方式）。因此，该构造函数等价于</p><pre><code class="language-cpp">Sales_data(const std::string &amp;s):           bookNo(s), units_sold(0), revenue(0)&#123; &#125;</code></pre><blockquote><p>当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化</p></blockquote><p>通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员</p><p>另外，我们需要注意， <code>Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125;</code>  中的  <code>&#123; &#125;</code>  实际是构造函数的函数体。因为我们定义这些构造函数的目的是为数据成员赋初值，其并不需要通过函数体实现，所以将函数体定义成空的</p><h4 id="在类的外部定义构造函数"><a class="anchor" href="#在类的外部定义构造函数">#</a> 在类的外部定义构造函数</h4><p>与其他几个构造函数不同，以  <code>istream</code>  对象为参数的构造函数  <code>Sales_data(std::istream &amp;)</code>  需要执行一些实际的操作，在它的函数体内调用了 read 函数来给数据成员赋以初值</p><pre><code class="language-cpp">Sales_data::Sales_data(std::istream &amp;is) &#123;    read(is, *this); // 从 is 中读取一条信息然后存入 this 对象中&#125;</code></pre><p>和其他成员函数一样，<strong>当我们在类的外部定义构造函数时，必须指明该构造函数是哪个类的成员</strong></p><p>因此， <code>Sales_data::Sales_data</code>  指出，我们定义了 Sales_data 类的成员 Sales_data 。因为该成员的名字和类名相同，所以它是一个构造函数（构造函数没有返回类型）</p><p>由于  <code>Sales_data(std::istream &amp;)</code>  函数定义了函数体，在执行该构造函数时，对象的成员是可以被初始化的（尽管这个构造函数初始值列表是空的）</p><h2 id="拷贝-赋值和析构"><a class="anchor" href="#拷贝-赋值和析构">#</a> 拷贝、赋值和析构</h2><p>除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为</p><p>如果我们不主动定义这些操作，编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作</p><p>例如：</p><pre><code class="language-cpp">total = trans;</code></pre><p>实际上等价于</p><pre><code class="language-cpp">// Sales_data 的默认赋值操作等价于total.bookNo = trans.bookNo;total.units_sold = trans.units_sold;total.revenue = trans.revenue;</code></pre><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。例如，管理动态内存的类通常不能依赖于上述操作的合成版本</p><ul><li>很多需要动态内存的类能够并且应该使用 vector 对象或者 string 对象来管理必要的存储空间</li><li>如果类包含 vector 或者 string 成员，则其拷贝、赋值和销毁的合成版本能够正常工作</li></ul><h1 id="访问控制与封装"><a class="anchor" href="#访问控制与封装">#</a> 访问控制与封装</h1><p>在 C++ 语言中，我们使用 <strong>访问说明符</strong>（access specifiers）加强类的封装性：</p><ul><li><p>定义在 <strong> <code>public</code> </strong> 说明符之后的成员可以在整个程序内被访问。 <code>public</code>  成员定义类的接口</p></li><li><p>定义在 <strong> <code>private</code> </strong> 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。 <code>private</code>  封装（即，隐藏）类的实现细节</p></li></ul><p>一个类可以包含 0 个或多个访问说明符，而且，某个访问说明符可以出现多次</p><p>每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止</p><p>再一次定义 Sales_data 类，其新形式如下所示：</p><pre><code class="language-cpp">class Sales_data &#123;public:            // 添加了访问说明符    Sales_data() = default;    Sales_data(const std::string &amp;s, unsigned n, double p):               bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;    Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125;    Sales_data(std::istream&amp;);    std::string isbn() const &#123; return bookNo; &#125;    Sales_data &amp;combine(const Sales_data&amp;);private:            // 添加了访问说明符    double avg_price() const        &#123; return units_sold ? revenue/units_sold : 0; &#125;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;&#125;;</code></pre><p>作为接口的一部分，构造函数和部分成员函数（即 isbn 和 combine ）紧跟在  <code>public</code>  说明符之后；而数据成员和作为实现部分的函数则跟在  <code>private</code>  说明符后面</p><p>在上面的定义中我们还做了一个微妙的变化，我们使用了  <code>class</code>  关键字而非  <code>struct</code>  开始类的定义。这种变化仅仅是形式上有所不同，实际上我们可以使用这两个关键字中的任何一个定义类。唯一的一点区别是，<strong> <code>struct</code>  和  <code>class</code>  的默认访问权限不太一样</strong></p><p><strong>类可以在它的第一个访问说明符之前定义成员，这种成员的访问权限依赖于类定义的方式</strong></p><ul><li><p>如果我们使用  <code>struct</code>  关键字，则定义在第一个访问说明符之前的成员是  <code>public</code>  的</p></li><li><p>如果我们使用  <code>class</code>  关键字，则这些成员是  <code>private</code>  的</p></li></ul><p>出于统一编程风格的考虑，<strong>如果我们希望定义的类的所有成员是  <code>public</code>  的，使用  <code>struct</code>  ；反之，如果希望成员是  <code>private</code>  的，使用  <code>class</code> </strong></p><h2 id="友元"><a class="anchor" href="#友元">#</a> 友元</h2><p>类可以将其他类或者函数声明成为它的 <strong>友元</strong>（friend），从而允许其他类或者函数访问它的非公有成员</p><p><strong>如果类想把一个函数作为它的友元，需要增加一条以  <code>friend</code>  关键字开始的函数声明语句</strong></p><p>例如，此前 <strong>定义抽象数据类型</strong> 时的 read、print 和 add 函数并不是类的成员，但却需要访问 Sales_data 类中  <code>private</code>  的数据成员，因此，我们需要将 read、print 和 add 函数作为 Sales_data 类的友元</p><pre><code class="language-cpp">class Sales_data &#123;    // 为 Sales_data 的非成员函数所做的友元声明    friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);    friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;);    friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);    // 其他成员及访问说明符与之前一致public:    Sales_data() = default;    Sales_data(const std::string &amp;s, unsigned n, double p):            bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;    Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125;    Sales_data(std::istream&amp;);    std::string isbn() const &#123; return bookNo; &#125;    Sales_data &amp;combine(const Sales_data&amp;);private:    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;&#125;;// Sales_data 接口的非成员组成部分的声明Sales_data add(const Sales_data&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);</code></pre><p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束</p><blockquote><p>一般来说，最好在类定义开始或结束前的位置集中声明友元</p></blockquote><h3 id="友元的声明"><a class="anchor" href="#友元的声明">#</a> 友元的声明</h3><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明</p><p>如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明</p><p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）</p><p>因此，我们的 Sales_data 头文件应该为 read 、print 和 add 提供独立的声明（除了类内部的友元声明之外）</p><blockquote><p>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明</p></blockquote><p>一些编译器允许在尚无友元函数的初始声明的情况下就调用它，不过最好还是提供一个独立的函数声明</p><h2 id="封装"><a class="anchor" href="#封装">#</a> 封装</h2><p>封装有两个重要的优点：</p><ul><li>确保用户代码不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码</li></ul><p>一旦把数据成员定义成  <code>private</code>  的，类的作者就可以比较自由地修改数据了</p><ul><li>当实现部分改变时，我们只需要检查类的代码本身以确认这次改变有什么影响。换句话说，只要类的接口不变，用户代码就无须改变</li><li>如果数据是  <code>public</code>  的，所有使用了原来数据成员的代码都可能失效，这时我们必须定位并重写所有依赖于老版本实现的代码，之后才能重新使用该程序</li></ul><p>把数据成员的访问权限设成  <code>private</code>  还有另外一个好处：防止由于用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷</p><blockquote><p>尽管当类的定义发生改变时无须更改用户代码，但是使用了该类的源文件必须重新编译</p></blockquote><p>参考：C++ Primer 中文版（第 5 版）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shoka 主题的若干改动</title>
      <link href="/posts/c61b9a60/"/>
      <url>/posts/c61b9a60/</url>
      
        <content type="html"><![CDATA[<p>相关文章推荐：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmV2ZXJzZXNhY2xlLmNvbS9TdXBwbGVtZW50LWZvci1zaG9rYS10aGVtZS8=">shoka 主题功能介绍补充点</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9jYXRlZ29yaWVzL1NIT0tBLw==">shoka 主题进阶玩法</span></li></ul><h1 id="修改主页标签名"><a class="anchor" href="#修改主页标签名">#</a> 修改主页标签名</h1><p>打开  <code>themes\shoka\languages</code>  路径下的  <code>zh-CN.yml</code>  文件，找到  <code>favicon</code>  板块，修改  <code>show</code>  和  <code>hide</code></p><pre><code class="language-yml">favicon:  show: Jiankychen  hide: Jiankychen</code></pre><blockquote><p>本博客根目录 _config.yml 中的语言设置为  <code>language: zh-CN</code>  ，所以这里是修改  <code>zh-CN.yml</code>  文件。若根目录 _config.yml 中的语言设置为  <code>language: en</code>  ，则应修改  <code>en.yml</code>  文件</p></blockquote><h1 id="修改加载动画"><a class="anchor" href="#修改加载动画">#</a> 修改加载动画</h1><p><strong>实现步骤：</strong></p><ul><li><p>打开  <code>themes\shoka\source\css\_common\components\third-party</code>  路径下的  <code>loading.styl</code>  文件，将第 9 行（  <code>$bgColor = var(--grey-1)</code>  ）及以后的内容全部删除，新增以下内容：</p><pre><code class="language-stylus">+mobile() &#123;  width: 20px;  height: 20px;&#125;+tablet() &#123;  width: 30px;  height: 30px;&#125;.container &#123;  height: 100vh;  width: 100vw;  font-family: Helvetica;&#125;.loader &#123;  height: 20px;  width: 250px;  position: absolute;  top: 0;  bottom: 0;  left: 0;  right: 0;  margin: auto;&#125;.loader--dot &#123;  animation-name: loader;  animation-timing-function: ease-in-out;  animation-duration: 3s;  animation-iteration-count: infinite;  height: 20px;  width: 20px;  border-radius: 100%;  background-color: black;  position: absolute;  border: 2px solid white;&#125;.loader--dot:first-child &#123;  background-color: #8cc759;  animation-delay: 0.5s;&#125;.loader--dot:nth-child(2) &#123;  background-color: #8c6daf;  animation-delay: 0.4s;&#125;.loader--dot:nth-child(3) &#123;  background-color: #ef5d74;  animation-delay: 0.3s;&#125;.loader--dot:nth-child(4) &#123;  background-color: #f9a74b;  animation-delay: 0.2s;&#125;.loader--dot:nth-child(5) &#123;  background-color: #60beeb;  animation-delay: 0.1s;&#125;.loader--dot:nth-child(6) &#123;  background-color: #fbef5a;  animation-delay: 0s;&#125;.loader--text &#123;  position: absolute;  top: 200%;  left: 0;  right: 0;  width: 4rem;  margin: auto;&#125;.loader--text:after &#123;  content: &quot;Loading&quot;;  font-weight: bold;  animation-name: loading-text;  animation-duration: 2.5s;  animation-iteration-count: infinite;&#125;@keyframes loader &#123;  15% &#123;    transform: translateX(0);  &#125;  45% &#123;    transform: translateX(230px);  &#125;  65% &#123;    transform: translateX(230px);  &#125;  95% &#123;    transform: translateX(0);  &#125;&#125;@keyframes loading-text &#123;  0% &#123;    content: &quot;Loading&quot;;  &#125;  25% &#123;    content: &quot;Loading.&quot;;  &#125;  50% &#123;    content: &quot;Loading..&quot;;  &#125;  75% &#123;    content: &quot;Loading...&quot;;  &#125;&#125;</code></pre></li><li><p>打开  <code>themes\shoka\layout\_partials</code>  路径下的  <code>layout.njk</code>  文件，将第 14 行（即   <code>&lt;div class=&quot;cat&quot;&gt;</code>  ）至第 29 行（即  <code>&lt;/div&gt;</code>  ）之间的内容（包括第 14 行和第 29 行）替换为</p><pre><code class="language-markdown">&lt;div class='container'&gt;  &lt;div class='loader'&gt;    &lt;div class='loader--dot'&gt;&lt;/div&gt;    &lt;div class='loader--dot'&gt;&lt;/div&gt;    &lt;div class='loader--dot'&gt;&lt;/div&gt;    &lt;div class='loader--dot'&gt;&lt;/div&gt;    &lt;div class='loader--dot'&gt;&lt;/div&gt;    &lt;div class='loader--dot'&gt;&lt;/div&gt;    &lt;div class='loader--text'&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre></li><li><p>为适配移动端显示，需修改  <code>themes\shoka\source\css\_common\outline</code>  路径下的  <code>outline.styl</code>  文件：将</p><pre><code class="language-stylus">  .cat &#123;    margin-top: 10rem;  &#125;</code></pre><p>替换为</p><pre><code class="language-stylus">  .loader &#123;      margin-top: 15rem;      justify-content: center;  &#125;</code></pre></li></ul><p>效果预览：</p><p><p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="rNvXjjd" data-user="jiankychen" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">  <span>See the Pen <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL2ppYW5reWNoZW4vcGVuL3JOdlhqamQ=">  Untitled</span> by Jiankychen (<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL2ppYW5reWNoZW4=">@jiankychen</span>)  on <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlv">CodePen</span>.</span></p><script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script></p><p>加载动画列表：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL3NlYXJjaC9wZW5zP3E9bG9hZGVy">codepen</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91aXZlcnNlLmlvL2xvYWRlcnM=">uiverse</span></li></ul><blockquote><p>本加载动画源自于 <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL0FzTGl0dGxlRGVzaWduL3Blbi9aYlZWd2E=">Dave McCarthy</span></p></blockquote><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmV2ZXJzZXNhY2xlLmNvbS9TdXBwbGVtZW50LWZvci1zaG9rYS10aGVtZS8=">替换加载动画</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy82MDgwMTIyMzMv">修改加载动画</span></li></ul><h1 id="使用外链头像"><a class="anchor" href="#使用外链头像">#</a> 使用外链头像</h1><p>在采用 Jsdelivr 静态缓存的情况下，由于某种未知原因，博客侧边栏的头像经常无法显示，现考虑使用外部链接的图片作为头像</p><p>实现步骤：</p><ul><li><p>打开  <code>themes\shoka\layout\_partials\post</code>  路径下的  <code>post.njk</code>  文件，将</p><pre><code class="language-markdown">&lt;span hidden itemprop=&quot;author&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt;  &lt;meta itemprop=&quot;image&quot; content=&quot;&amp;#123;&amp;#123; url_for(theme.statics + theme.images + '/' + theme.sidebar.avatar) &amp;#125;&amp;#125;&quot;&gt;  &lt;meta itemprop=&quot;name&quot; content=&quot;&amp;#123;&amp;#123; author &amp;#125;&amp;#125;&quot;&gt;  &lt;meta itemprop=&quot;description&quot; content=&quot;&amp;#123;&amp;#123; subtitle &amp;#125;&amp;#125;, &amp;#123;&amp;#123; description &amp;#125;&amp;#125;&quot;&gt;&lt;/span&gt;</code></pre><p>替换为</p><pre><code class="language-markdown">&lt;span hidden itemprop=&quot;author&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt;  &amp;#123;%- if 'http' in theme.sidebar.avatar %&amp;#125;    &lt;meta itemprop=&quot;image&quot; content=&quot;&amp;#123;&amp;#123; url_for(theme.sidebar.avatar) &amp;#125;&amp;#125;&quot;&gt;  &amp;#123;%- else %&amp;#125;    &lt;meta itemprop=&quot;image&quot; content=&quot;&amp;#123;&amp;#123; url_for(theme.statics + theme.images + '/' + theme.sidebar.avatar) &amp;#125;&amp;#125;&quot;&gt;  &amp;#123;%- endif %&amp;#125;  &lt;meta itemprop=&quot;name&quot; content=&quot;&amp;#123;&amp;#123; author &amp;#125;&amp;#125;&quot;&gt;  &lt;meta itemprop=&quot;description&quot; content=&quot;&amp;#123;&amp;#123; subtitle &amp;#125;&amp;#125;, &amp;#123;&amp;#123; description &amp;#125;&amp;#125;&quot;&gt;&lt;/span&gt;</code></pre></li><li><p>打开  <code>themes\shoka\layout\_partials\sidebar</code>  路径下的  <code>overview.njk</code>  文件，将</p><pre><code class="language-markdown">&lt;div class=&quot;author&quot; itemprop=&quot;author&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt;  &lt;img class=&quot;image&quot; itemprop=&quot;image&quot; alt=&quot;&amp;#123;&amp;#123; author &amp;#125;&amp;#125;&quot;      data-src=&quot;&amp;#123;&amp;#123; url_for(theme.statics + theme.images + '/'+ theme.sidebar.avatar) &amp;#125;&amp;#125;&quot;&gt;  &lt;p class=&quot;name&quot; itemprop=&quot;name&quot;&gt;&amp;#123;&amp;#123; author &amp;#125;&amp;#125;&lt;/p&gt;  &lt;div class=&quot;description&quot; itemprop=&quot;description&quot;&gt;&amp;#123;&amp;#123; description &amp;#125;&amp;#125;&lt;/div&gt;&lt;/div&gt;</code></pre><p>替换为</p><pre><code class="language-markdown">&lt;div class=&quot;author&quot; itemprop=&quot;author&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt;  &lt;img class=&quot;image&quot; itemprop=&quot;image&quot; alt=&quot;&amp;#123;&amp;#123; author &amp;#125;&amp;#125;&quot;    &amp;#123;%- if 'http' in theme.sidebar.avatar %&amp;#125;      data-src=&quot;&amp;#123;&amp;#123; url_for(theme.sidebar.avatar) &amp;#125;&amp;#125;&quot;    &amp;#123;%- else %&amp;#125;      data-src=&quot;&amp;#123;&amp;#123; url_for(theme.statics + theme.images + '/'+ theme.sidebar.avatar) &amp;#125;&amp;#125;&quot;    &amp;#123;%- endif %&amp;#125;  &gt;  &lt;p class=&quot;name&quot; itemprop=&quot;name&quot;&gt;&amp;#123;&amp;#123; author &amp;#125;&amp;#125;&lt;/p&gt;  &lt;div class=&quot;description&quot; itemprop=&quot;description&quot;&gt;&amp;#123;&amp;#123; description &amp;#125;&amp;#125;&lt;/div&gt;&lt;/div&gt;</code></pre></li><li><p>打开主题 _config.yml 文件，找到  <code>sidebar</code>  板块，将  <code>avatar</code>  值设为外部链接，例如</p><pre><code class="language-yml">avatar: https://s2.loli.net/2023/01/01/hnmYMxBAwF9QelU.jpg</code></pre></li></ul><h1 id="去除首页-subtitle-两侧的-号"><a class="anchor" href="#去除首页-subtitle-两侧的-号">#</a> 去除首页 subtitle 两侧的 = 号</h1><p>首页 subtitle 两侧会显示出一个 = 号，这里考虑将其去除</p><p><strong>实现方式：</strong></p><p>打开  <code>themes\shoka\layout\_partials</code>  路径下的  <code>layout.njk</code>  文件，将第 42 行（  <code>&lt;p class=&quot;meta&quot; itemprop=&quot;description&quot;&gt;= &#123;&#123; subtitle &#125;&#125; =&lt;/p&gt;</code>  ）替换为</p><pre><code class="language-markdown">&lt;p class=&quot;meta&quot; itemprop=&quot;description&quot;&gt;&amp;#123;&amp;#123; subtitle &amp;#125;&amp;#125;&lt;/p&gt;</code></pre><p><strong>效果对比：</strong></p><ul><li height="150px"><p>去除前<br /> <img data-src="/posts/c61b9a60/before.png" class=""></p></li><li height="150px"><p>去除后<br /> <img data-src="/posts/c61b9a60/after.png" class=""></p></li></ul><p>也可以将 = 号替换成其他字符或图标，例如：</p><pre><code class="language-markdown">&lt;p class=&quot;meta&quot; itemprop=&quot;description&quot;&gt;~~~ &amp;#123;&amp;#123; subtitle &amp;#125;&amp;#125; ~~~&lt;/p&gt;</code></pre><p><strong>效果：</strong></p><p height="150px"><img data-src="/posts/c61b9a60/replace.png" class=""></p><h1 id="添加页脚站点运行时长"><a class="anchor" href="#添加页脚站点运行时长">#</a> 添加页脚：站点运行时长</h1><p><strong>实现步骤：</strong></p><ul><li><p>打开  <code>themes\shoka\languages</code>  路径下的  <code>zh-CN.yml</code>  文件，找到  <code>footer</code>  板块，添加以下内容：</p><pre><code class="language-yml">timing: 本站已运行days: 天hours: 时minutes: 分seconds: 秒</code></pre></li><li><p>打开  <code>themes\shoka\layout\_partials</code>  路径下的  <code>footer.njk</code>  文件，在  <code>&lt;/div&gt;</code>  与  <code>&#123;%- if theme.footer.count %&#125;</code>  之间插入以下内容：</p><pre><code class="language-markdown">&lt;div class=&quot;timing&quot;&gt;  &lt;span id=&quot;RunTime&quot;&gt;&lt;/span&gt;  &lt;script&gt;    var BootDate = new Date(&quot;2021/10/24 23:00:00&quot;); &amp;#123;# 站点起始时间 #&amp;#125;    function ShowRunTime(id) &#123;      var NowDate = new Date();      var RunDateM = parseInt(NowDate - BootDate);      var RunDays = Math.floor(RunDateM/(24*3600*1000));      var RunHours = Math.floor(RunDateM%(24*3600*1000)/(3600*1000));      var RunMinutes = Math.floor(RunDateM%(24*3600*1000)%(3600*1000)/(60*1000));      var RunSeconds = Math.round(RunDateM%(24*3600*1000)%(3600*1000)%(60*1000)/1000);      var RunTime = RunDays + &quot; &amp;#123;&amp;#123; __('footer.days') &amp;#125;&amp;#125; &quot; + RunHours + &quot; &amp;#123;&amp;#123; __('footer.hours') &amp;#125;&amp;#125; &quot; + RunMinutes + &quot; &amp;#123;&amp;#123; __('footer.minutes') &amp;#125;&amp;#125; &quot; + RunSeconds + &quot; &amp;#123;&amp;#123; __('footer.seconds') &amp;#125;&amp;#125;&quot;;      document.getElementById(id).innerHTML = &quot;&amp;#123;&amp;#123; __('footer.timing') &amp;#125;&amp;#125; &quot; + RunTime;    &#125;    setInterval(&quot;ShowRunTime('RunTime')&quot;, 1000);  &lt;/script&gt;&lt;/div&gt;</code></pre></li></ul><p><strong>效果：</strong></p><p><img data-src="/posts/c61b9a60/runtime.png" class=""></p><h1 id="添加页脚站点访问量"><a class="anchor" href="#添加页脚站点访问量">#</a> 添加页脚：站点访问量</h1><p>可以通过 busuanzi 将 站点 / 某个页面的访客数量 添加到 页脚</p><p><strong>实现步骤：</strong></p><ul><li><p>打开  <code>themes\shoka\languages</code>  路径下的  <code>zh-CN.yml</code>  文件，找到  <code>footer</code>  板块，添加以下内容</p><pre><code class="language-yml">views: 次visitors: 人</code></pre></li><li><p>打开  <code>themes\shoka\layout\_partials</code>  路径下的  <code>footer.njk</code>  文件，将  <code>&#123;%- if theme.footer.count %&#125;</code>  至  <code>&#123;%- endif %&#125;</code>  之间的内容替换为</p><pre><code class="language-markdown">&amp;#123;%- if theme.footer.count %&amp;#125;&lt;script async src=&quot;https://cdn.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;count&quot;&gt;    &lt;span title=&quot;&amp;#123;&amp;#123; __('symbols_count_time.count_total') &amp;#125;&amp;#125;&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;ic i-file&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;span class=&quot;text&quot;&gt;&amp;#123;&amp;#123; symbolsCountTotal(site) &amp;#125;&amp;#125; &amp;#123;&amp;#123;__('symbols_count_time.word')&amp;#125;&amp;#125;&lt;/span&gt;    &lt;/span&gt;    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;    &lt;span title=&quot;&amp;#123;&amp;#123; __('footer.total_visitors') &amp;#125;&amp;#125;&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;ic i-person&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;span class=&quot;views&quot;&gt;      &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &amp;#123;&amp;#123; __('footer.visitors') &amp;#125;&amp;#125;      &lt;/span&gt;    &lt;/span&gt;    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;    &lt;span title=&quot;&amp;#123;&amp;#123; __('footer.total_views') &amp;#125;&amp;#125;&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;ic i-eye&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;span class=&quot;visitors&quot;&gt;        &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &amp;#123;&amp;#123; __('footer.views') &amp;#125;&amp;#125;      &lt;/span&gt;    &lt;/span&gt;    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;    &lt;span title=&quot;&amp;#123;&amp;#123; __('symbols_count_time.time_total') &amp;#125;&amp;#125;&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;ic i-clock&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;span class=&quot;text&quot;&gt;&amp;#123;&amp;#123; symbolsTimeTotal(site, config.symbols_count_time.awl, config.symbols_count_time.wpm, __('symbols_count_time.time_minutes')) &amp;#125;&amp;#125;&lt;/span&gt;    &lt;/span&gt;&lt;/div&gt;&amp;#123;%- endif %&amp;#125;</code></pre></li></ul><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmV2ZXJzZXNhY2xlLmNvbS9Db21wdXRlci1zY2llbmNlL1Nob2thLVRoZW1lL0Fub3RoZXIv">添加网站浏览量统计功能</span></li><li><span class="exturl" data-url="aHR0cDovL2licnVjZS5pbmZvLzIwMTUvMDQvMDQvYnVzdWFuemkv">busuanzi 使用教程</span></li></ul><h1 id="新增页面访问统计与文章统计"><a class="anchor" href="#新增页面访问统计与文章统计">#</a> 新增页面：访问统计与文章统计</h1><h2 id="添加访问统计页面"><a class="anchor" href="#添加访问统计页面">#</a> 添加访问统计页面</h2><p>按照 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi8=">Lavender</span> 的文章 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy8xNDA5NTgzMzg4Lw==">Shoka 主题：新增博客访问统计页面</span> 做相应配置</p><p>其中，百度商业账号和百度账号的调用方法存在差异，普通用户按照 <span class="exturl" data-url="aHR0cHM6Ly90b25namkuYmFpZHUuY29tL2FwaS9tYW51YWwvQ2hhcHRlcjIvb3BlbmFwaS5odG1s">百度账号接口说明</span> 进行操作，以获取 API Key、Secret Key、Refresh Token、Acess_Token、Site_ID 等信息</p><p>一旦 Acess_Token 过期，可根据以下请求更换新的 Acess_Token 和 Refresh_Token ：</p><pre><code>http://openapi.baidu.com/oauth/2.0/token?grant_type=refresh_token&amp;refresh_token=&#123;REFRESH_TOKEN&#125;&amp;client_id=&#123;CLIENT_ID&#125;&amp;client_secret=&#123;CLIENT_SECRET&#125;</code></pre><p>其中：</p><ul><li><p>{REFRESH_TOKEN} 填写 Refresh Token</p></li><li><p>{CLIENT_ID} 填写 API Key</p></li><li><p>{CLIENT_SECRET} 填写 Secret Key</p></li></ul><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy8xNDA5NTgzMzg4Lw==">Shoka 主题：新增博客访问统计页面</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmV1cmtvbi5jb20vcG9zdC82MTc2Mzk3Ny5odG1s">Hexo 博客实时访问统计图</span></li></ul><h2 id="添加文章统计功能"><a class="anchor" href="#添加文章统计功能">#</a> 添加文章统计功能</h2><p>具体可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy8zMjY1MTczNzAxLw==">Shoka 主题：新增文章统计页面</span>、<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmV1cmtvbi5jb20vcG9zdC8xMjEzZWY4Mi5odG1s">Hexo 博客文章统计图</span></p><h1 id="主题-vendors-链接替换-拆分-jsdelivr"><a class="anchor" href="#主题-vendors-链接替换-拆分-jsdelivr">#</a> 主题 vendors 链接替换 - 拆分 Jsdelivr</h1><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmV2ZXJzZXNhY2xlLmNvbS9TdXBwbGVtZW50LWZvci1zaG9rYS10aGVtZS8=">Hexo-Shoka 主题功能介绍补充点：主题插件链接替换思路与案例</span></p><blockquote><p>另一种方案：<span class="exturl" data-url="aHR0cHM6Ly93d3cua2FpdGFrdS54eXovd2ViYnVpbGQvc2hva2Fqc2RlbGl2ci8=">shoka 主题速度优化 - 拆分 jsdelivr</span></p></blockquote><h2 id="修改主题配置文件"><a class="anchor" href="#修改主题配置文件">#</a> 修改主题配置文件</h2><p>打开主题配置文件  <code>_config.shoka.yml</code>  ，找到文件最后的  <code>vendors</code>  板块，将其注释，并在其下方新增以下内容</p><pre><code class="language-yml">vendors:  css:    katex: unpkg.com/katex@0.12.0/dist/katex.min.css    comment: css/comment.css    fancybox: unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css    justifiedGallery: unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css  js:    pace: unpkg.com/pace-js@1.0.2/pace.min.js    pjax: unpkg.com/pjax@0.2.8/pjax.min.js    fetch: unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js    anime: unpkg.com/animejs@3.2.0/lib/anime.min.js    algolia: unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js    instantsearch: unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js    lazyload: unpkg.com/lozad@1/dist/lozad.min.js    quicklink: unpkg.com/quicklink@2/dist/quicklink.umd.js    jquery: unpkg.com/jquery@3.5.1/dist/jquery.min.js    fancybox: unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js    justifiedGallery: unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js    valine: js/MiniValine.min.js    copy_tex: unpkg.com/katex@0.12.0/dist/contrib/copy-tex.min.js    chart: unpkg.com/frappe-charts@1.5.0/dist/frappe-charts.min.iife.js    echarts: unpkg.com/echarts@5.2.2/dist/echarts.min.js</code></pre><p>与原始版本相比，有以下改动：</p><ul><li>除了  <code>comment</code>  和  <code>valine</code>  依然使用本地文件外，其余  <code>vendors</code>  元素的链接前缀均修改为 <span class="exturl" data-url="aHR0cDovL3VucGtnLmNvbQ==">unpkg.com</span></li><li><code>fancybox</code>  元素被拆分成  <code>fancybox</code>  和  <code>justifiedGallery</code></li><li>新增个人所需的  <code>echarts</code>  （用于实现博客统计页面中的图表）</li></ul><h2 id="修改-utilsjs"><a class="anchor" href="#修改-utilsjs">#</a> 修改 utils.js</h2><p>打开  <code>themes\shoka\source\js\_app\utils.js</code>  ，找到  <code>const assetUrl = function (asset, type) &#123;&#125;</code> （文件第 25~39 行左右），将其替换为</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token function-variable function">assetUrl</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">asset<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token constant">CONFIG</span><span class="token punctuation">[</span>asset<span class="token punctuation">]</span><span class="token punctuation">[</span>type<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'unpkg.com'</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">return</span> <span class="token string">"https://"</span> <span class="token operator">+</span> str<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token keyword">return</span> str<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> statics <span class="token operator">+</span> str<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="修改-assetjs"><a class="anchor" href="#修改-assetjs">#</a> 修改 asset.js</h2><p>打开  <code>themes\shoka\scripts\helpers\asset.js</code>  ，找到  <code>hexo.extend.helper.register('_vendor_js', () =&gt; &#123;&#125;)</code>  （第 41~63 行左右），将其替换为</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre>hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>helper<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'_vendor_js'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">const</span> config <span class="token operator">=</span> hexo<span class="token punctuation">.</span>theme<span class="token punctuation">.</span>config<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">//Get a font list from config</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">let</span> vendorJs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'pace'</span><span class="token punctuation">,</span> <span class="token string">'pjax'</span><span class="token punctuation">,</span> <span class="token string">'fetch'</span><span class="token punctuation">,</span> <span class="token string">'anime'</span><span class="token punctuation">,</span> <span class="token string">'algolia'</span><span class="token punctuation">,</span> <span class="token string">'instantsearch'</span><span class="token punctuation">,</span> <span class="token string">'lazyload'</span><span class="token punctuation">,</span> <span class="token string">'quicklink'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">return</span> config<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  </pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">return</span> vendorJs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">url</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>item <span class="token operator">!==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token keyword">return</span> <span class="token function">htmlTag</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">src</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>url<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="修改-scriptjs"><a class="anchor" href="#修改-scriptjs">#</a> 修改 script.js</h2><p>打开  <code>themes\shoka\scripts\generaters\script.js</code>  ，找到 js 和 css 索引代码（第 23~38 行左右），将其替换为</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">js</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token literal-property property">valine</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">.</span>valine<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token literal-property property">chart</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">.</span>chart<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token literal-property property">copy_tex</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">.</span>copy_tex<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token literal-property property">jquery</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">.</span>jquery<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token literal-property property">fancybox</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">.</span>fancybox<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token literal-property property">justifiedGallery</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">.</span>justifiedGallery<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token literal-property property">echarts</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>js<span class="token punctuation">.</span>echarts</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token literal-property property">css</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token literal-property property">valine</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>css <span class="token operator">+</span> <span class="token string">"/comment.css"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token literal-property property">katex</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>css<span class="token punctuation">.</span>katex<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token literal-property property">mermaid</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>css <span class="token operator">+</span> <span class="token string">"/mermaid.css"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token literal-property property">fancybox</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>css<span class="token punctuation">.</span>fancybox<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token literal-property property">justifiedGallery</span><span class="token operator">:</span> theme<span class="token punctuation">.</span>vendors<span class="token punctuation">.</span>css<span class="token punctuation">.</span>justifiedGallery</pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// ...</span></pre></td></tr></table></figure><h2 id="修改-pagejs"><a class="anchor" href="#修改-pagejs">#</a> 修改 page.js</h2><p>打开  <code>themes\shoka\source\js\_app\page.js</code>  ，找到  <code>const postFancybox = function(p) &#123;&#125;</code>  中的  <code>vendorCss</code>  和  <code>vendorJs</code>  （第 72~79 行左右），将其替换为</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token function-variable function">postFancybox</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token string">' .md img'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">vendorCss</span><span class="token punctuation">(</span><span class="token string">'justifiedGallery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">vendorJs</span><span class="token punctuation">(</span><span class="token string">'justifiedGallery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">vendorCss</span><span class="token punctuation">(</span><span class="token string">'fancybox'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">vendorJs</span><span class="token punctuation">(</span><span class="token string">'jquery'</span><span class="token punctuation">,</span><span class="token string">'fancybox'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token comment">// ...</span></pre></td></tr></table></figure><h1 id="tab-标签卡的红色线条"><a class="anchor" href="#tab-标签卡的红色线条">#</a> tab 标签卡的红色线条</h1><p>tab 标签卡中的标签名称下方没有显示红色线条</p><p>为显示下画线，可按以下步骤修改：</p><ul><li><p>打开  <code>shoka\source\css\_common\components\tags\tabs.styl</code></p></li><li><p>删掉第 6 行的  <code>overflow: hidden;</code></p></li></ul><p>效果：</p><div class="tab" data-id="TabBlock" data-title="标签卡 1"><p>修改前：</p><figure class="highlight css"><figcaption data-lang="CSS"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token selector">.nav</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token property">border-bottom</span><span class="token punctuation">:</span> .0625rem solid <span class="token function">var</span><span class="token punctuation">(</span>--grey-1-a7<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">height</span><span class="token punctuation">:</span> 2.6875rem<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    // ...</pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div><div class="tab" data-id="TabBlock" data-title="标签卡 2"><p>修改后：</p><figure class="highlight css"><figcaption data-lang="CSS"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token selector">.nav</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token property">border-bottom</span><span class="token punctuation">:</span> .0625rem solid <span class="token function">var</span><span class="token punctuation">(</span>--grey-1-a7<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token property">height</span><span class="token punctuation">:</span> 2.6875rem<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    // ...</pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div><h1 id="调整代码块的高度"><a class="anchor" href="#调整代码块的高度">#</a> 调整代码块的高度</h1><p>修改代码块折叠的阈值为 10 （即，超过 10 行代码即进行折叠），并将代码块（不包括 figcaption）的高度调整为 200px</p><ul><li><p>打开  <code>themes\shoka\source\js\_app\page.js</code></p></li><li><p>将  <code>code_container &amp;&amp; code_container.find(&quot;tr&quot;).length &gt; 15</code>  中的 15 替换为 10</p></li><li><p>将  <code>code_container.style.maxHeight = &quot;300px&quot;;</code>  中的 &quot;300px&quot; 替换为 &quot;200px&quot;</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra</title>
      <link href="/posts/72c3df1c/"/>
      <url>/posts/72c3df1c/</url>
      
        <content type="html"><![CDATA[<p>Dijkstra 算法是典型最短路算法，用于计算一个节点到其他所有节点的最短路径</p><p>定义：</p><ul><li>代价：<strong>F(n) = g(n)</strong></li><li>g (n) ：从起点到节点 n 的代价（距离）</li><li>open list ：存放 当前可到达、且未确定最小代价路径的节点</li><li>closed list ：存放 已经找到最小代价路径的节点</li></ul><p>流程：</p><ul><li>从起点开始逐步扩展，每一步为一个节点找到代价最小的路径，即：<ul><li>从 open list 选择代价最小的节点，将其收录到 closed list</li><li>遍历新收录节点的所有可访问邻节点，更新代价</li></ul></li></ul><p>最优性证明（为什么被收录的节点已经找到代价最小的路径？）：反证法</p><p>特性：</p><ul><li>完备性：如果在起始点和目标点之间有路径解存在，就一定可以得到解；如果得不到解，就一定说明没有解存在</li><li>最优性：对于某个评价指标（一般为路径的长度），规划得到的路径是最优的</li></ul><p>算法：</p><pre><code>将起点放入 open list执行循环：- 如果 open list 为空：搜索失败，结束- 取 open list 中代价（即，g(n)）最小的节点（记作 Node1），将其放入 closed list- 如果节点 Node1 为终点：找到目标路径，结束- 遍历节点 Node1 的（不在 closed list 中的）邻接节点    - 记当前遍历的邻接节点为 Node2    - 如果节点 Node2 在 open list 中：更新节点 Node2 的代价    - 如果节点 Node2 在 open list 中：计算节点 Node2 的代价，并将其加入 open list待循环结束，即得到从起点到终点的代价最小路径</code></pre><h1 id="朴素-dijkstra"><a class="anchor" href="#朴素-dijkstra">#</a> 朴素 Dijkstra</h1><h2 id="邻接矩阵法"><a class="anchor" href="#邻接矩阵法">#</a> 邻接矩阵法</h2><p>采用邻接矩阵 edges 存储边的有关信息，其中，edges [i][j] 表示 i 到 j 的代价，若 edges [i][j] == INT_MAX ，则表示不存在由节点 i 指向节点 j 的边</p><pre><code class="language-cpp">/*@param:    edges: 邻接矩阵    n: 节点数    start: 起始点@return:     起始点到其他点的最小代价*/vector&lt;int&gt; dijkstra(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int n, int start) &#123;    vector&lt;int&gt; dist(n, INT_MAX);     // dist[i] 表示 start 到 i 的最小代价    dist[start] = 0;                  // start 到自身的代价为 0    vector&lt;int&gt; closedlist(n, 0);     // closedlist[i] 表示 i 是否在 closed list 中    for (int i = 0; i &lt; n; ++i) &#123;     // 从起点开始逐步扩展，每一步为一个节点找到代价最小的路径        int idx = 0;                  // 不在 closed list 中的、代价最小的节点        for (int j = 0; j &lt; n; ++j) &#123;            if (!closedlist[j] &amp;&amp; dist[j] &lt;= dist[idx]) &#123;                idx = j;            &#125;        &#125;        closedlist[idx] = 1;          // 将代价最小的节点 idx 添加到 closed list        for (int j = 0; j &lt; n; ++j) &#123; // 更新 idx 邻居节点的代价            if (!closedlist[j] &amp;&amp; edges[idx][j] &lt; INT_MAX) &#123;                dist[j] = min(dist[j], dist[idx] + edges[idx][j]);            &#125;        &#125;    &#125;    return dist;&#125;</code></pre><h2 id="邻接表法"><a class="anchor" href="#邻接表法">#</a> 邻接表法</h2><p>采用 <a href="https://jiankychen.github.io/posts/ee040603">链式前向星</a>（用数组模拟实现的链表，也就是静态链表）作为邻接表</p><p>结构体数组 edges 存储所有边：edges [i] 表示第 i 条边</p><ul><li>edges [i].to 表示第 i 条边的终点</li><li>edges [i].next 表示与第 i 条边同起点的下一条边的编号</li><li>edges [i].w 表示第 i 条边的权值</li></ul><p>数组 head 存储顶点的第一条边：head [i] 表示以 i 为起点的第一条边（编号最大的边）的编号</p><pre><code class="language-cpp">/*@param:    edges: 静态链表    head: 节点数组    n: 节点数    start: 起始点@return:     起始点到其他点的最小代价*/vector&lt;int&gt; dijkstra(Edge&amp; edges[], vector&lt;int&gt;&amp; head, int n, int start) &#123;    vector&lt;int&gt; dist(n, INT_MAX);    dist[start] = 0;    vector&lt;int&gt; closedlist(n, 0);    for (int i = 0; i &lt; n; ++i) &#123;        int idx = 0;        for (int j = 0; j &lt; n; ++j) &#123;            if (!closedlist[j] &amp;&amp; dist[j] &lt;= dist[idx]) &#123;                idx = j;            &#125;        &#125;        closedlist[idx] = 1;        for (int j = head[idx]; j != -1; j = edges[j].next) &#123; // 遍历链式前向星            dist[edges[j].to] = min(dist[edges[j].to], dist[idx] + edges[j].w);        &#125;    &#125;    return dist;&#125;</code></pre><h1 id="堆优化-dijkstra"><a class="anchor" href="#堆优化-dijkstra">#</a> 堆优化 Dijkstra</h1><p>可以使用堆（优先级队列）来查找 open list 中的代价最小的节点 idx</p><p>定义一个小顶堆：由于  <code>pair&lt;typeA, typeB&gt;</code>  排序时会默认按照  <code>typeA</code>  排序，应将起点到节点的代价作为  <code>typeA</code>  、将节点的编号作为  <code>typeB</code>  ，以便每次可以从堆中取出代价最小的节点</p><pre><code class="language-cpp">typedef pair&lt;int, int&gt; pii; // 分别存储代价和节点编号priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq; // 小顶堆</code></pre><blockquote><p><code>priority_queue</code>  位于  <code>&lt;queue&gt;</code>  头文件， <code>pair</code>  位于  <code>&lt;utility&gt;</code>  头文件</p></blockquote><h2 id="邻接矩阵法-2"><a class="anchor" href="#邻接矩阵法-2">#</a> 邻接矩阵法</h2><p>当探索到一个代价最小的节点 idx 时，会遍历 idx 的邻居节点 i ，如果 dist [idx] + edges [idx][i] &lt; dist [i] ，则需更新节点 i 的代价为 dist [idx] + edges [idx][i]</p><p dist[idx]="" +="" edges[idx][i],="" i="">注意，即便堆中可能已经有 {xx, i} 存在，但由于无法对堆进行寻址访问，故而无法直接将堆中已有的 {xx, i} 更新为</p><p>因此，我们采用的策略是：</p><ul><li>更新 dist [i] 为 dist [idx] + edges [idx][i]</li><li>将 {dist [i], i} 添加到堆（此时，{dist [i], i} 与 {xx, i} 都存在于堆中，但由于 dist [i] &lt; xx ，{dist [i], i} 优先级高于 {xx, i}，因此该操作也等效于更新了堆中的 {xx, i} ）</li></ul><pre><code class="language-cpp">/*@param:    edges: 邻接矩阵    n: 节点数    start: 起始点@return:     起始点到其他点的最小代价*/vector&lt;int&gt; Dijkstra(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int n, int start) &#123;    vector&lt;int&gt; dist(n, INT_MAX);    typedef pair&lt;int, int&gt; pii;    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;        dist[start] = 0;    pq.emplace(make_pair(0, start));        while (!pq.empty()) &#123;        int idx = pq.top().second;        pq.pop();        for (int i = 0; i &lt; n; ++i) &#123;            if (edges[idx][i] &lt; INT_MAX) &#123;                int cost = dist[idx] + edges[idx][i];                if (cost &lt; dist[i]) &#123;                    dist[i] = cost;                 // 实时维护 dist 数组，记录当前搜索到的节点 i 的最小代价                    pq.emplace(make_pair(cost, i)); // 可能已经有 &#123;val, i&#125; 在堆中了，但是 val 必然大于 cost                &#125;            &#125;        &#125;    &#125;    return dist;&#125;</code></pre><h2 id="邻接表法-2"><a class="anchor" href="#邻接表法-2">#</a> 邻接表法</h2><p>堆优化也可以采用链式前向星结构</p><pre><code class="language-cpp">/*@param:    edges: 静态链表    head: 节点数组    n: 节点数    start: 起始点@return:     起始点到其他点的最小代价*/vector&lt;int&gt; dijkstra(Edge&amp; edges[], vector&lt;int&gt;&amp; head, int n, int start) &#123;    vector&lt;int&gt; dist(n, INT_MAX);    typedef pair&lt;int, int&gt; pii;    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;        dist[start] = 0;    pq.emplace(make_pair(0, start));        while (!pq.empty()) &#123;        int idx = pq.top().second;        pq.pop();        for (int i = head[idx]; i != -1; i = edges[i].next) &#123;            int cost = dist[idx] + edges[i].w;            if (cost &lt; dist[edges[i].to]) &#123;                dist[edges[i].to] = cost;                pq.emplace(make_pair(cost, edges[i].to));            &#125;        &#125;    &#125;    return dist;&#125;</code></pre><h1 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h1><p>设图中的节点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> ，边数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></p><p>时间复杂度：</p><ul><li>朴素 Dijkstra 算法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>堆优化的 Dijkstra 算法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n + m) \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：</p><ul><li>邻接矩阵法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>邻接表法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li></ul><p>堆优化的时间复杂度优于朴素算法</p><p>邻接表法的空间复杂度优于邻接矩阵法</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjkzNzM3NDA=">最短路径问题 — Dijkstra 算法最详解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTQzNzMyNTY=">Dijkstra 算法（附案例详解）</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE5NTYzNjcvYXJ0aWNsZS9kZXRhaWxzLzEyMTIyMjEzOQ==">Dijkstra 算法的 C++ 实现</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pY2hlYWxvdmVuL2FydGljbGUvZGV0YWlscy8xMTQwNDAxMzY=">Dijkstra 算法时间复杂度分析</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 函数</title>
      <link href="/posts/3d6d9e02/"/>
      <url>/posts/3d6d9e02/</url>
      
        <content type="html"><![CDATA[<h1 id="函数基础"><a class="anchor" href="#函数基础">#</a> 函数基础</h1><p>典型的函数（function）定义包括以下部分：</p><ul><li>返回类型（return type）</li><li>函数名字</li><li>由 0 个或多个形参（parameter）组成的列表，其中，形参以逗号隔开，形参的列表位于一对圆括号之内</li><li>函数体</li></ul><p>例如：定义一个函数用于求数 n 的阶乘，其中，返回类型为 int 型，函数名字为 fact，形参为 int n，函数体为一对花括号 {} 内的语句</p><pre><code class="language-cpp">int fact(int n) &#123;    int ret = 1;    while (n &gt; 1)        ret *= n--;    return ret;&#125;</code></pre><h2 id="调用函数"><a class="anchor" href="#调用函数">#</a> 调用函数</h2><p>通过 <strong>调用运算符</strong>（call operator）来执行函数</p><ul><li>调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的实参（argument）列表，我们用实参初始化函数的形参</li><li>调用表达式的类型就是函数的返回类型</li></ul><p>函数的调用完成两项工作：</p><ul><li>（隐式地）定义并用实参初始化函数对应的形参</li><li>将控制权转移给被调用函数</li></ul><p>此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行</p><p>当遇到一条 return 语句时，函数结束执行过程</p><p>return 语句也完成两项工作：</p><ul><li>返回 return 语句中的值（如果有的话）</li><li>将控制权从被调函数转移回主调函数</li></ul><h2 id="形参和实参"><a class="anchor" href="#形参和实参">#</a> 形参和实参</h2><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推</p><blockquote><p>尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值</p></blockquote><p>实参数量应与形参数量一致，并且，实参的类型必须与对应的形参类型匹配</p><h2 id="函数的形参列表"><a class="anchor" href="#函数的形参列表">#</a> 函数的形参列表</h2><p>函数的形参列表可以为空，但是不能省略</p><ul><li>要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表</li><li>为了与 C 语言兼容，也可以使用关键字 void 表示函数没有形参</li></ul><pre><code class="language-cpp">void f1() &#123; /* ... */ &#125;     // 隐式地定义空形参列表void f2(void) &#123; /* ... */ &#125; // 显式地定义空形参列表</code></pre><p>形参列表中的形参通常用逗号隔开，其中，每个形参都是含有一个声明符的声明（即使两个形参的类型一样，也必须把两个类型都写出来）</p><pre><code class="language-cpp">int f3(int v1, v2) &#123; /* ... */ &#125;     // 错误int f4(int v1, int v2) &#123; /* ... */ &#125; // 正确</code></pre><p>任意两个形参都不能同名，而且，函数最外层作用域中的局部变量也与函数形参同名</p><p>形参名是可选的。如果函数不会使用到个别形参，通常不命名该形参，以表示其不会在函数体内被使用</p><blockquote><p>注意：即使某个形参不被函数使用，也必须为它提供一个实参</p></blockquote><h2 id="函数返回类型"><a class="anchor" href="#函数返回类型">#</a> 函数返回类型</h2><blockquote><p>大多数类型都能用作函数的返回类型</p></blockquote><p>一种特殊的返回类型是 void ，它表示函数不返回任何值</p><p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针</p><h2 id="局部对象"><a class="anchor" href="#局部对象">#</a> 局部对象</h2><p>在 C++ 语言中，名字有作用域，对象有生命周期（lifetime）</p><ul><li>名字的作用域：程序文本的一部分，名字在其中可见</li><li>对象的生命周期：程序执行过程中该对象存在的一段时间</li></ul><p>形参和函数体内部定义的变量统称为局部变量（local variable）。它们对函数而言是 “局部” 的，仅在函数的作用域内可见</p><blockquote><p>Parameters and variables defined inside a function body are referred to as local variables. They are “local” to that function and hide declarations of the same name made in an outer scope.</p></blockquote><p>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁</p><p>局部变量的生命周期依赖于定义的方式。对于普通局部变量对应的对象，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它</p><h2 id="自动对象"><a class="anchor" href="#自动对象">#</a> 自动对象</h2><p>只存在于块执行期间的对象被称为 <strong>自动对象</strong>（automatic object）</p><p>当块的执行结束后，块中创建的自动对象的值就变成未定义的了</p><p>形参就是一种自动对象：函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁</p><p>自动对象的初始化：</p><ul><li>形参对应的自动对象：用传递给函数的实参初始化形参对应的自动对象</li><li>局部变量对应的自动对象：<ul><li>如果变量定义本身含有初始值，就用这个初始值进行初始化</li><li>否则，如果变量定义本身不含初始值，执行默认初始化</li></ul></li></ul><blockquote><p>内置类型的未初始化局部变量将产生未定义的值</p></blockquote><h2 id="局部静态对象"><a class="anchor" href="#局部静态对象">#</a> 局部静态对象</h2><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。此时，可以将局部变量定义成 <strong>static 类型</strong></p><p><strong>局部静态对象</strong>（local static object）在程序第一次经过对象定义语句时进行初始化，并且直到程序终止才被销毁。在此期间，即使对象所在的函数结束执行，也不会对它有影响</p><p>如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为 0</p><h2 id="函数声明"><a class="anchor" href="#函数声明">#</a> 函数声明</h2><p>类似于变量，函数只能定义一次，但可以声明多次</p><blockquote><p>唯一的例外是，如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义</p></blockquote><p>函数的声明和函数的定义非常类似，唯一的区别是，函数声明无须函数体，用一个分号替代即可</p><pre><code class="language-cpp">// 函数声明void print(vector&lt;int&gt;::const_iterator beg,           vector&lt;int&gt;::const_iterator end);</code></pre><p>函数的声明不包含函数体，所以也就无须形参的名字（事实上，在函数的声明中经常省略形参的名字）</p><p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息</p><p>函数声明也称作<strong>函数原型</strong>（function prototype）</p><h3 id="在头文件中进行函数声明"><a class="anchor" href="#在头文件中进行函数声明">#</a> 在头文件中进行函数声明</h3><p>类似于变量，函数也应该在头文件中声明而在源文件中定义</p><blockquote><p>允许把函数的声明直接放在使用该函数的源文件中，但是这么做可能会很烦琐而且容易出错。相反，如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且，一旦我们想改变函数的接口，只需改变一条声明即可</p></blockquote><p><strong>含有函数声明的头文件应该被包含到定义函数的源文件中</strong></p><h3 id="分离式编译"><a class="anchor" href="#分离式编译">#</a> 分离式编译</h3><p>为了允许编写程序时按照逻辑关系将其划分开来，C++ 语言支持所谓的分离式编译（separate compilation）</p><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译</p><p>如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件</p><p>大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是 .obj（Windows）或 .o（UNIX）的文件（该文件包含对象代码（object code））</p><h1 id="参数传递"><a class="anchor" href="#参数传递">#</a> 参数传递</h1><p>每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化</p><ul><li><p>当形参是引用类型时，它将绑定到对应的实参上。此时，我们说它对应的实参被 <strong>引用传递</strong>（passed by reference）或者函数被 <strong>传引用调用</strong>（called by reference）</p></li><li><p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被 <strong>值传递</strong>（passed by value）或者函数被 <strong>传值调用</strong>（called by value）</p></li></ul><h2 id="传值参数"><a class="anchor" href="#传值参数">#</a> 传值参数</h2><p>函数对形参做的所有操作都不会影响实参</p><pre><code class="language-cpp">int fact(int val) &#123;    int ret = 1;    while (val) &#123;        ret *= val--;    &#125;    return ret;&#125;</code></pre><h3 id="指针形参"><a class="anchor" href="#指针形参">#</a> 指针形参</h3><p>可以将指针作为函数的形参</p><ul><li>调用函数时，会将指针实参拷贝给形参（形参和实参是两个相互独立的对象）</li><li>由于形参和实参具有相同的值，可以通过形参间接地访问实参所指的对象，并且可以可以修改它所指对象的值</li><li>改变形参并不会影响实参</li></ul><pre><code class="language-cpp">// 该函数接受一个指针，然后将指针所指的值置 0void reset(int *ip) &#123; // 指针形参    *ip = 0;  // 改变指针 ip 所指对象的值    ip = 0;   // 只改变了 ip 的局部拷贝，实参并未被改变&#125;</code></pre><blockquote><p>熟悉 C 的程序员常常使用指针类型的形参访问函数外部的对象。在 C++ 语言中，建议使用引用类型的形参替代指针</p></blockquote><h2 id="传引用参数"><a class="anchor" href="#传引用参数">#</a> 传引用参数</h2><p>引用形参绑定到对应的实参上</p><pre><code class="language-cpp">// 该函数接受一个 int 对象的引用，然后将对象的值置为 0void reset(int &amp;i) &#123; // i 是传给 reset 函数的对象的另一个名字    i = 0; // 改变了 i 所引对象的值&#125;</code></pre><h3 id="使用引用避免拷贝"><a class="anchor" href="#使用引用避免拷贝">#</a> 使用引用避免拷贝</h3><p>拷贝大的类类型对象或者容器对象是比较低效的，此时可以通过引用传入参数</p><pre><code class="language-cpp">// 比较两个 string 对象的长度bool isShorter(const string &amp;s1, const string &amp;s2) &#123;    return s1.size() &lt; s2.size();&#125;</code></pre><p>甚至，有的类类型（包括 IO 类型在内）根本就不支持拷贝操作。此时，函数只能通过引用形参访问该类型的对象</p><blockquote><p>如果函数无须改变引用形参的值，最好将其声明为常量引用</p></blockquote><h3 id="使用引用形参返回额外信息"><a class="anchor" href="#使用引用形参返回额外信息">#</a> 使用引用形参返回额外信息</h3><p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，因此可以考虑通过引用形参获取多个结果</p><pre><code class="language-cpp">// 返回 s 中 c 第一次出现的位置索引// 引用形参 occurs 负责统计 c 出现的总次数string::size_type find_char(const string &amp;s, char c,                           string::size_type &amp;occurs) &#123;    auto ret = s.size();   // 第一次出现的位置（如果有的话）    occurs = 0;            // 出现次数置 0    for (decltype(ret) i = 0; i != s.size(); ++i) &#123;        if (s[i] == c) &#123;            if (ret == s.size())                ret = i;   // 记录 c 第一次出现的位置            ++occurs;      // 更新出现次数         &#125;    &#125;    return ret;            // c出现次数通过 occurs 隐式地返回&#125;</code></pre><h2 id="const-形参和实参"><a class="anchor" href="#const-形参和实参">#</a> const 形参和实参</h2><p>在用实参初始化形参时，会忽略掉形参的顶层 const</p><p>换而言之，当形参具有顶层 const 时，传给它常量对象或者非常量对象都是可以的（可参考 <strong>const 限定符</strong>）</p><pre><code class="language-cpp">void fcn (const int i) &#123;    /* fcn 可以读取 i ，但不能向 i 写值 */&#125;</code></pre><p>调用 fcn 函数时，既可以传入 const int ，也可以传入 int</p><p>在 C++ 语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别，例如：</p><pre><code class="language-cpp">void helper (string &amp;s, int start) &#123; /* 第一个 helper 函数 */ &#125;;void helper (int n) &#123; /* 第二个 helper 函数 */ &#125;;</code></pre><p>然而，由于形参的顶层 const 会被忽略，以下两个同名函数不能同时定义</p><pre><code class="language-cpp">void fcn (const int i) &#123; /* */ &#125;;void fcn (int i) &#123; /* */ &#125;; // 错误：重复定义了 fcn(int)</code></pre><p>因为顶层 const 被忽略掉了，所以在上面的代码中传入两个 fcn 函数的参数可以完全一样，因此第二个 fcn 是错误的</p><h3 id="const-与-指针或引用形参"><a class="anchor" href="#const-与-指针或引用形参">#</a> const 与 指针或引用形参</h3><p>形参的初始化方式和变量的初始化方式是一样的：</p><ul><li>可以使用非常量来初始化一个底层 const 对象，但是反过来不行</li><li>一个引用必须用同类型的对象初始化</li></ul><p>变量初始化：</p><pre><code class="language-cpp">int i = 42;const int *cp = &amp;i; // 正确：但是不能通过 cp 改变 iconst int &amp;r = i;   // 正确：但是不能通过 r 改变 iconst int &amp;r2 = 42; // 正确int *p = cp;        // 错误：p 的类型和 cp 的类型不匹配（存在通过 p 改变 cp 所指对象的风险）int &amp;r3 = r;        // 错误：r3 的类型和 r 的类型不匹配（存在通过 r3 改变 r 所引对象的风险）int &amp;r4 = 42;       // 错误：不能用字面值初始化一个非常量引用</code></pre><p>参数传递：</p><pre><code class="language-cpp">int i = 0;const int ci = i;string::size_type ctr = 0;reset(&amp;i);   // 调用形参类型是 int * 的 reset 函数reset(&amp;ci);  // 错误：不能用指向 const int 对象的指针初始化 int * 形参reset(i);    // 调用形参类型是 int &amp; 的 reset 函数reset(ci);   // 错误：不能将普通引用绑定到 const 对象 ci 上reset(42);   // 错误：不能将葡萄引用绑定到字面值上reset(ctr);  // 错误：类型不匹配，ctr 是无符号类型find_char(&quot;Hello World!&quot;, 'o', ctr); // 正确：find_char 的第一个形参是对常量的引用</code></pre><p>要想调用引用版本的 reset ，只能使用 int 类型的对象，而不能使用字面值、求值结果为 int 的表达式、需要转换的对象或者 const int 类型的对象。类似的，要想调用指针版本的 reset，只能使用 int* 类型的对象</p><p>我们能传递一个字符串字面值作为 find_char 的第一个实参，这是因为该函数的引用形参是常量引用，而 C++ 允许我们用字面值初始化常量引用</p><h3 id="尽量使用常量引用"><a class="anchor" href="#尽量使用常量引用">#</a> 尽量使用常量引用</h3><p>将函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做会给函数的调用者造成误导，即，函数可以修改它的实参的值</p><p>此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把 const 对象、字面值或者需要类型转换的对象传递给普通的引用形参</p><h2 id="数组形参"><a class="anchor" href="#数组形参">#</a> 数组形参</h2><p>数组 无法直接通过数组名进行拷贝，因此，无法以值传递的方式使用数组参数</p><p>由于 数组（通常）会被转换成指针，当我们为一个函数传递一个数组时，实际上传递的是指向数组首元素的指针</p><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p><pre><code class="language-cpp">// 尽管表现形式不同，但这三个 print 函数是等价的// 每个函数都有一个 const int* 类型的形参void print (const int*)void print (const int []) // 函数的意图是作用于一个数组void print (const int [10]) // 这里的维度表示我们期望的数组维度，实际不一定是这个维度</code></pre><p>当编译器处理对 print 函数的调用时，只检查传入的参数是否是 const int* 类型</p><pre><code class="language-cpp">int i = 0, j[2] = &#123;0, 1&#125;;print(&amp;i); // 正确：&amp;i 的类型是 int*print(j);  // 正确：j 转换成 int* 并指向 j[0]</code></pre><p>如果我们传给 print 函数的是一个数组，则实参自动地转换成指向数组首元素的指针。其中，数组的大小对函数的调用没有影响</p><blockquote><p>以数组作为形参的函数必须确保使用数组时不会越界</p></blockquote><h3 id="数组指针形参"><a class="anchor" href="#数组指针形参">#</a> 数组指针形参</h3><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息</p><p>管理指针形参有三种常用的技术：</p><ul><li>使用标记指定数组长度</li><li>使用标准库规范</li><li>显式传递一个表示数组大小的形参</li></ul><h4 id="使用标记指定数组长度"><a class="anchor" href="#使用标记指定数组长度">#</a> 使用标记指定数组长度</h4><ul><li>要求数组本身包含一个结束标记</li><li>这种方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况</li><li>典型示例：C 风格字符串，C 风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符</li></ul><pre><code class="language-cpp">// 遇到空字符停止void print(const char *cp) &#123;    if (cp)          // 若 cp 不是一个空指针        while (*cp)  // 只要指针所指的字符不是空字符            cout &lt;&lt; *cp++; // 输出当前字符并将指针向前移动一个位置&#125;</code></pre><h4 id="使用标准库规范"><a class="anchor" href="#使用标准库规范">#</a> 使用标准库规范</h4><p>传递指向数组首元素和尾后元素的指针</p><pre><code class="language-cpp">void print(const int *beg, const int *end) &#123; // 传入两个指针：一个指向首元素，另一个指向尾元素的下一位置    // 输出 beg 到 end 之间（不含 end ）的所有元素    while (beg != end)        cout &lt;&lt; *beg++ &lt;&lt; endl; // 输出当前元素并将指针向前移动一个位置&#125;int j[2] = &#123;0, 1&#125;;print(begin(j), end(j)); // begin 和 end 函数，分别得到指向数组 j 的首元素和尾后元素的指针</code></pre><h4 id="显式传递一个表示数组大小的形参"><a class="anchor" href="#显式传递一个表示数组大小的形参">#</a> 显式传递一个表示数组大小的形参</h4><p>即，专门定义一个形参表示数组大小</p><pre><code class="language-cpp">// const int ia[] 等价于 const int* ia// size 表示数组的大小，将它显式地传给函数，用于控制对 ia 的访问void print(const int ia[], size_t size) &#123;    for (size_t i = 0; i != size; ++i) &#123;        cout &lt;&lt; ia[i] &lt;&lt; endl;    &#125;&#125;int j[] = &#123;0, 1, 2&#125;; // 大小为 3 的整型数组print(j, end(j) - begin(j));</code></pre><p>正如之前所说，当函数不需要对数组元素执行写操作的时候，数组形参应该是指向 const 的指针（即，常量指针）。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针</p><h3 id="数组引用形参"><a class="anchor" href="#数组引用形参">#</a> 数组引用形参</h3><p>C++ 允许将变量定义成数组的引用（详见 <strong>数组</strong> ），同样地，也允许将形参定义成数组的引用，此时，引用形参绑定到对应的数组上</p><pre><code class="language-cpp">// 正确：形参是数组的引用，维度是类型的一部分void print(int (&amp;arr)[10]) &#123;    for (auto elem : arr)        cout &lt;&lt; elem &lt;&lt; endl;&#125;</code></pre><p>注意， <code>&amp;arr</code>  两端的括号必不可少：</p><pre><code class="language-cpp">f(int &amp;arr [10])   // 错误：将 arr 声明成了引用的数组f(int (&amp;arr) [10]) // 正确：arr 是具有 10 个整数的整型数组的引用</code></pre><p>数组大小是构成数组类型的一部分，只要不超过维度，就可以在函数体内放心地使用数组</p><p>然而，这一用法也在无形中限制了 print 函数的可用性，即，只能将函数作用于大小为 10 的数组：</p><pre><code class="language-cpp">int i = 0, j[2] = &#123;0, 1&#125;;int k[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;print(&amp;i);   // 错误：实参不是含有 10 个整数的数组print(j);    // 错误：实参不是含有 10 个整数的数组print(k);    // 正确：实参是含有 10 个整数的数组</code></pre><h3 id="传递多维数组"><a class="anchor" href="#传递多维数组">#</a> 传递多维数组</h3><p>将多维数组传递给函数时，真正传递的是指向数组首元素的指针</p><p>因为我们处理的是数组的数组，首元素本身就是一个数组，数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略</p><pre><code class="language-cpp">// matrix 指向数组的首元素，该数组的元素是由 10 个整数构成的数组void print(int (*matrix) [10], int rowSize) &#123; /* ... */ &#125; // matrix 是一个指向含有 10 个整数的数组的指针</code></pre><p>注意， <code>*matrix</code>  两端的括号必不可少</p><pre><code class="language-cpp">int *matrix[10];   // 10 个指针构成的数组int (*matrix)[10]; // 指向含有 10 个整数的数组的指针</code></pre><p>我们也可以使用数组的语法定义函数（此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内）</p><pre><code class="language-cpp">// matrix 看似是一个二维数组，实则是指向含有 10 个整数的数组的指针void print(int matrix[][10], int rowSize) &#123; /* ... */ &#125;</code></pre><h2 id="main-处理命令行选项"><a class="anchor" href="#main-处理命令行选项">#</a> main: 处理命令行选项</h2><p>到目前为止，我们定义的 main 函数都只有空形参列表：</p><pre><code class="language-cpp">int main() &#123; ...&#125;</code></pre><p>然而，有时我们确实需要给 main 传递实参。一种常见的情况是，用户通过设置一组选项来确定函数所要执行的操作。例如，假定 main 函数位于可执行文件 prog 之内，我们可以向程序传递下面的选项：</p><pre><code>prog -d -o ofile data0</code></pre><p>这些命令行选项通过两个（可选的）形参传递给 main 函数：</p><pre><code class="language-cpp">int main(int argc, char *argv[]) &#123; ... &#125;</code></pre><p>第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量</p><p>因为第二个形参是数组，所以 main 函数也可以定义成：</p><pre><code class="language-cpp">int main(int argc, char **argv) &#123; ... &#125; // argv 执指向 char*</code></pre><p>当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为 0</p><p>以上面提供的命令行  <code>prog -d -o ofile data0</code>  为例，argc 等于 5，argv 包含如下 C 风格字符串</p><pre><code class="language-cpp">argv[0] = &quot;prog&quot;;   // 或者 argv[0] 也可以指向一个空字符串argv[1] = &quot;-d&quot;;argv[2] = &quot;-o&quot;;argv[3] = &quot;ofile&quot;;argv[4] = &quot;data0&quot;;argv[5] = 0;</code></pre><blockquote><p>当使用  <code>argv</code>  中的实参时，一定要记得可选的实参从  <code>argv[1]</code>  开始； <code>argv[0]</code>  保存程序的名字，而非用户输入</p></blockquote><h2 id="含有可变形参的函数"><a class="anchor" href="#含有可变形参的函数">#</a> 含有可变形参的函数</h2><p>有时我们无法提前预知应该向函数传递几个实参。例如，我们想要编写代码输出程序产生的错误信息，此时最好用同一个函数实现该项功能，以便对所有错误的处理能够整齐划一。然而，错误信息的种类不同，所以调用错误输出函数时传递的实参也各不相同</p><p>为了编写能处理不同数量实参的函数，C++ 11 新标准提供了两种主要的方法：</p><ul><li>如果所有的实参类型相同，可以传递一个名为  <code>initializer_list</code>  的标准库类型</li><li>如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板</li></ul><p>C++ 还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参（这种功能<strong>一般只用于与 C 函数交互的接口程序</strong>）</p><h3 id="initializer_list-形参"><a class="anchor" href="#initializer_list-形参">#</a> initializer_list 形参</h3><p>如果函数的实参数量未知、但是全部实参的类型都相同，我们可以使用 initializer_list 类型的形参</p><p>initializer_list 是一种标准库类型，用于表示某种特定类型的值的数组</p><p>initializer_list 类型定义在同名的头文件中</p><p><img data-src="/posts/3d6d9e02/initializer_list.png" class=""></p><p>和 vector 一样，initializer_list 也是一种模板类型。定义 initializer_list 对象时，必须说明列表中所含元素的类型</p><pre><code class="language-cpp">initializer_list&lt;string&gt; ls; // initializer_list 的元素类型是 stringinitializer_list&lt;int&gt; li;    // initializer_list 的元素类型是 int</code></pre><p>和 vector 不一样的是，initializer_list 对象中的元素永远是常量值，我们无法改变 initializer_list 对象中元素的值</p><p>我们使用如下的形式编写输出错误信息的函数，使其可以作用于可变数量的实参：</p><pre><code class="language-cpp">void error_msg(initializer_list&lt;string&gt; il) &#123;    for (auto beg = il.begin(); beg != il.end(); ++beg)        cout &lt;&lt; *beg &lt;&lt; &quot; &quot; ;    cout &lt;&lt; endl;&#125;</code></pre><p>其中，作用于 initializer_list 对象的 begin 和 end 操作类似于 vector 对应的成员</p><ul><li>begin () 成员提供一个指向列表首元素的指针</li><li>end () 成员提供一个指向列表尾后元素的指针</li></ul><p>initializer_list 包含 begin 和 end 成员，因此可以使用 <strong>范围 for</strong> 循环处理其中的元素</p><p>如果想向 initializer_list 形参中传递一个值的序列，则必须把序列放在一对花括号内</p><pre><code class="language-cpp">// expected 和 actual 是 string 对象if (expected != actual)    error_msg(&#123;&quot;functionX&quot;, expected, actual&#125;);else    error_msg(&#123;&quot;functionX&quot;, &quot;okay&quot;&#125;);</code></pre><p>含有 initializer_list 形参的函数也可以同时拥有其他形参。例如，调试系统可能有个名为 ErrCode 的类，用来表示不同类型的错误，因此我们可以改写之前的程序，使其包含一个 initializer_list 形参和一个 ErrCode 形参</p><pre><code class="language-cpp">void error_msg(ErrCode e, initializer_list&lt;string&gt; il) &#123;    cout &lt;&lt; e.msg() &lt;&lt; &quot;: &quot;;    for (const auto &amp;elem : il)        cout &lt;&lt; elem &lt;&lt; &quot; &quot; ;    cout &lt;&lt; endl;&#125;</code></pre><p>为了调用这个版本的 error_msg 函数，需要额外传递一个 ErrCode 实参</p><pre><code class="language-cpp">if (expected != actual)    error_msg(ErrCode(42), &#123;&quot;functionX&quot;, expected, actual&#125;);else    error_msg(ErrCode(0), &#123;&quot;functionX&quot;, &quot;okay&quot;&#125;);</code></pre><h3 id="省略符形参"><a class="anchor" href="#省略符形参">#</a> 省略符形参</h3><p>省略符形参是为了便于 C++ 程序访问某些（使用了名为 varargs 的 C 标准库功能的）C 代码而设置的</p><p>通常，省略符形参不应用于其他目的</p><blockquote><p>省略符形参应该仅仅用于 C 和 C++ 通用的类型<br />特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝</p></blockquote><p><strong>省略符形参只能出现在形参列表的最后一个位置</strong>，它的形式无外乎以下两种:</p><pre><code class="language-cpp">void foo(parm_list, ...);void foo(...);</code></pre><p>第一种形式指定了 foo 函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查</p><p>省略符形参所对应的实参无须类型检查</p><p>在第一种形式中，形参声明后面的逗号是可选的</p><h1 id="返回类型和-return-语句"><a class="anchor" href="#返回类型和-return-语句">#</a> 返回类型和 return 语句</h1><p>return 语句：终止当前正在执行的函数，并将控制权返回到调用该函数的地方</p><p>return 语句的两种形式：</p><pre><code class="language-cpp">return; // 无返回值return expression; // 有返回值</code></pre><h2 id="无返回值函数"><a class="anchor" href="#无返回值函数">#</a> 无返回值函数</h2><p>没有返回值的 return 语句只能用在返回类型是 void 的函数中</p><p>返回 void 的函数并不一定要有 return 语句，因为这类函数最后会隐式地执行 return</p><p>一个返回类型是 void 的函数也能使用 return 语句的第二种形式，不过此时 return 语句的 expression 必须是另一个返回 void 的函数</p><p>强行令 void 函数返回其他类型的表达式将产生编译错误</p><h2 id="有返回值函数"><a class="anchor" href="#有返回值函数">#</a> 有返回值函数</h2><p>只要函数的返回类型不是 void ，该函数内的每条 return 语句就必须返回一个值</p><p>return 语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型</p><h3 id="值是如何被返回的"><a class="anchor" href="#值是如何被返回的">#</a> 值是如何被返回的</h3><p>返回一个值的方式：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果</p><p>如果函数返回的类型是局部变量，则会返回该变量的副本</p><p>例如，书写一个返回类型是 string 的函数 make_plural，由于该函数的返回类型是 string ，返回值将被拷贝到调用点。即，该函数将返回 word 的副本或者一个未命名的临时 string 对象</p><pre><code class="language-cpp">string make_plural(size_t ctr, const string &amp;word, const string ending) &#123;    return (ctr &gt; 1) ? word + ending : word;&#125;</code></pre><p>如果函数返回引用类型，则不需要拷贝其所引对象</p><p>例如：书写一个函数，其中形参和返回类型都是 const string 的引用，不管是调用函数还是返回结果都不会真正拷贝 string 对象</p><pre><code class="language-cpp">// 挑出两个 string 对象中较短的那个，返回其引用const string &amp;shorterString(const string &amp;s1, const string &amp;s2) &#123;    return s1.size() &lt;= s2.size() ? s1 : s2;&#125;</code></pre><h3 id="不要返回局部对象的引用或指针"><a class="anchor" href="#不要返回局部对象的引用或指针">#</a> 不要返回局部对象的引用或指针</h3><p>函数完成后，它所占用的存储空间也随之被释放掉，因此，不要返回局部对象的引用或指针</p><pre><code class="language-cpp">const string &amp;manip() &#123; // 严重错误：函数试图返回局部对象的引用    string ret;   if (!ret.empty())       return ret;      // 错误：返回局部对象的引用！   else       return &quot;Empty&quot;;  // 错误：&quot;Empty&quot; 是一个局部临时量&#125;</code></pre><h3 id="返回类类型的函数和调用运算符"><a class="anchor" href="#返回类类型的函数和调用运算符">#</a> 返回类类型的函数和调用运算符</h3><p>和其他运算符一样，调用运算符也有优先级和结合律</p><p><strong>调用运算符的优先级 与 点运算符和箭头运算符 相同，并且也符合左结合律</strong></p><p>如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员</p><p>例如，我们可以通过如下形式得到较短 string 对象的长度：</p><pre><code class="language-cpp">// 调用 string 对象的 size 成员，该 string 对象是由 shorterString 函数返回的auto sz = shorterString(s1, s2).size();</code></pre><h3 id="引用返回左值"><a class="anchor" href="#引用返回左值">#</a> 引用返回左值</h3><p>函数的返回类型决定函数调用是否是左值：调用一个返回引用的函数将会得到左值，其他返回类型将得到右值</p><p>因此，可以像使用其他左值那样来使用返回引用的函数，特别是，可以给返回类型为非常量引用的函数的结果赋值</p><p>例如：</p><pre><code class="language-cpp">char &amp;get_val(string &amp;str, string::size_type ix) &#123;    return str[ix]; // get_val 假定索引值是有效的&#125;int main() &#123;    string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl;   // 输出 a value    get_val(s, 0) = 'A'; // 将 s[0] 的值改为 'A'    cout &lt;&lt; s &lt;&lt; endl;   // 输出 A value    return 0;&#125;</code></pre><p>如果返回类型是常量引用，则不能给调用的结果赋值</p><pre><code class="language-cpp">shorterString(&quot;hi&quot;, &quot;bye&quot;) = &quot;X&quot;; // 错误：返回值是个常量</code></pre><h3 id="列表初始化返回值"><a class="anchor" href="#列表初始化返回值">#</a> 列表初始化返回值</h3><p>C++ 11 标准规定，函数可以返回花括号包围的值的列表，该列表用来初始化函数调用点处的临时量</p><ul><li>如果列表为空，临时量执行值初始化</li><li>否则，返回的值由函数的返回类型决定</li></ul><p>例如：定义一个返回 vector 对象的函数，其中，vector 对象用来存放表示错误信息的 string 对象</p><pre><code class="language-cpp">vector&lt;string&gt; process() &#123;    // . . .    // expected 和 actual 是 string 对象    if (expected.empty())        return &#123;&#125;;  // 返回一个空 vector 对象    else if (expected == actual)        return &#123;&quot;functionX&quot;, &quot;okay&quot;&#125;; // 返回列表初始化的 vector 对象    else        return &#123;&quot;functionX&quot;, expected, actual&#125;;&#125;</code></pre><p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间</p><p>如果函数返回的是类类型，由类本身来定义如何使用初始值</p><h3 id="主函数-main-的返回值"><a class="anchor" href="#主函数-main-的返回值">#</a> 主函数 main 的返回值</h3><p>之前介绍过，如果函数的返回类型不是 void ，那么它必须返回一个值。但是这条规则有个例外：允许 main 函数没有 return 语句而直接结束</p><p>这是因为，如果控制到达了 main 函数的结尾处而且没有 return 语句，编译器将隐式地插入一条返回 0 的 return 语句</p><h3 id="递归"><a class="anchor" href="#递归">#</a> 递归</h3><p>如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）</p><pre><code class="language-cpp">// 计算 val 的阶乘int factorial(int val) &#123;    if (val &gt; 1)        return factorial(val-1) * val;    return 1;&#125;</code></pre><blockquote><p>main 函数不能调用它自己</p></blockquote><h2 id="返回数组指针"><a class="anchor" href="#返回数组指针">#</a> 返回数组指针</h2><p>因此数组不能被拷贝，所以函数不能返回数组。但是，函数可以返回数组的指针或者引用</p><p>从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用 <strong>类型别名</strong></p><p>例如：func 函数返回一个指向包含 10 个整数的数组的指针，其中，arrT 是含有 10 个整数的数组的别名</p><pre><code class="language-cpp">typedef int arrT[10]; // arrT 是一个类型别名，它表示的类型是含有 10 个整数的数组using arrT = int[10]; // arrT 的等价声明arrT* func(int i);    // func 返回一个指向含有 10 个整数的数组的指针</code></pre><h3 id="声明一个返回数组指针的函数"><a class="anchor" href="#声明一个返回数组指针的函数">#</a> 声明一个返回数组指针的函数</h3><p>如果我们想定义一个返回数组指针的函数，并且不希望使用类型别名，则必须满足：</p><ul><li>数组的维度跟在函数名字之后</li><li>函数的形参列表也跟在函数名字后面，并且形参列表应该先于数组的维度</li></ul><p>因此，返回数组指针的函数形式如下所示：</p><pre><code>Type (*function(parameter_list))[dimension]</code></pre><p>其中，Type 表示元素的类型，dimension 表示数组的大小，(*function (parameter_list)) 两端的括号必须存在（如果没有这对括号，函数的返回类型将是指针的数组）</p><p>例如：</p><pre><code class="language-cpp">int (*func(int i))[10];</code></pre><p>可以按照以下的顺序来逐层理解该声明的含义：・</p><ul><li>func (int i) 表示调用 func 函数时需要一个 int 类型的实参</li><li>(*func (int i)) 意味着我们可以对函数调用的结果执行解引用操作</li><li>(*func (int i))[10] 表示解引用 func 的调用将得到一个大小为 10 的数组</li><li>int (*func (int i))[10] 表示数组中的元素是 int 类型</li></ul><h3 id="使用尾置返回类型"><a class="anchor" href="#使用尾置返回类型">#</a> 使用尾置返回类型</h3><p>在 C++ 11 标准中还有一种可以简化上述 func 声明的方法，就是使用<strong>尾置返回类型</strong>（trailing return type）</p><p><strong>任何函数的定义都能使用尾置返回</strong>，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用</p><p><strong>尾置返回类型跟在形参列表后面，并以一个  <code>-&gt;</code>  符号开头</strong>。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个  <code>auto</code></p><p>例如：</p><pre><code class="language-cpp">// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有 10 个整数的数组auto func(int i) -&gt; int(*)[10];</code></pre><p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到 func 函数返回的是一个指针，并且该指针指向了含有 10 个整数的数组</p><h3 id="使用-decltype"><a class="anchor" href="#使用-decltype">#</a> 使用 decltype</h3><p>如果我们知道函数返回的指针将指向哪个数组，可以使用  <code>decltype</code>  关键字声明返回类型</p><p>例如，下面的函数返回一个指针，该指针根据参数 i 的不同指向两个已知数组中的某一个</p><pre><code class="language-cpp">int odd[] = &#123;1,3,5,7,9&#125;;int even[] = &#123;0,2,4,6,8&#125;;// 返回一个指针，该指针指向含有 5 个整数的数组decltype(odd) *arrPtr(int i) &#123;    return (i % 2) ? &amp;odd : &amp;even; // 返回一个指向数组的指针&#125;</code></pre><p>arrPtr 使用关键字  <code>decltype</code>  表示它的返回类型是个指针，并且该指针所指对象的类型与 odd 一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有 5 个整数的数组的指针</p><p>注意：<strong> <code>decltype</code>  并不负责把数组类型转换成对应的指针</strong>，所以 decltype 的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个  <code>*</code>  符号</p><h1 id="函数重载"><a class="anchor" href="#函数重载">#</a> 函数重载</h1><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为 <strong>重载</strong>（overloaded）<strong>函数</strong></p><p>例如：</p><pre><code class="language-cpp">void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size);</code></pre><p>这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数</p><pre><code class="language-cpp">int j[2] = &#123;0,1&#125;;print(&quot;Hello World&quot;);        // 调用 print(const char*)print(j, end(j) - begin(j)); // 调用 print(const int*, size_t)print(begin(j), end(j));     // 调用 print(const int*, const int*)</code></pre><blockquote><p>main 函数不能重载</p></blockquote><h2 id="重载函数的定义与调用"><a class="anchor" href="#重载函数的定义与调用">#</a> 重载函数的定义与调用</h2><h3 id="定义重载函数"><a class="anchor" href="#定义重载函数">#</a> 定义重载函数</h3><p>重载的函数应该在形参数量或形参类型上有所不同</p><pre><code class="language-cpp">// 定义一组函数，分别根据名字、电话、账号等信息查找记录Record lookup(const Account&amp;); // 根据 Account 查找记录Record lookup(const Phone&amp;);   // 根据 Phone 查找记录Record lookup(const Name&amp;);    // 根据 Name 查找记录Account acct;Phone phone;Record r1 = lookup(acct);  // 调用接受 Account 的版本Record r2 = lookup(phone); // 调用接受 Phone 的版本</code></pre><p>不允许两个函数除了返回类型外其他所有要素都相同：假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的</p><pre><code class="language-cpp">Record lookup(const Account&amp;);bool lookup(const Account&amp;); // 错误：与上一个函数相比只有返回类型不同</code></pre><h3 id="判断两个形参的类型是否相异"><a class="anchor" href="#判断两个形参的类型是否相异">#</a> 判断两个形参的类型是否相异</h3><p>有时候两个形参列表看起来不一样，但实际上是相同的</p><pre><code class="language-cpp">// 每一对声明都是同一个函数Record lookup(const Account &amp;acct);Record lookup(const Account&amp;); // 省略了形参的名字typedef Phone Telno;Record lookup(const Phone&amp;);Record lookup(const Telno&amp;); // Telno 和 Phone 的类型相同（Telno 是 Phone 的别名）</code></pre><p>由于顶层 const 不影响传入函数的对象（详见 <strong>参数传递</strong> ），一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来</p><pre><code class="language-cpp">Record lookup(Phone);Record lookup(const Phone);   // 重复声明了 Record lookup(Phone)Record lookup(Phone*);Record lookup(Phone* const);  // 重复声明了 Record lookup(Phone*)</code></pre><p>如果形参是某种类型的指针或引用，则可区分其指向的是常量对象还是非常量对象（此时考虑的是底层 const ），以实现函数重载</p><pre><code class="language-cpp">// 对于接受引用或指针的函数而言，常量对象与非常量对象对应的形参不同// 定义了 4 个独立的重载函数Record lookup(Account&amp;);       // 函数作用于 Account 的引用Record lookup(const Account&amp;); // 新函数，作用于 Account 的常量引用Record lookup(Account*);       // 新函数，作用于 Account 的指针Record lookup(const Account*); // 新函数，作用于指向 Account 常量的指针</code></pre><p>在上面的例子中，编译器可以通过实参是否是常量来推断应该调用哪个函数</p><ul><li>因为 const 不能转换成其他类型，所以我们只能把 const 对象（或指向 const 的指针）传递给 const 形参</li><li>相反地，因为非常量可以转换成 const ，所以上面的 4 个函数都能作用于非常量对象或者指向非常量对象的指针</li><li>不过，当我们要传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数</li></ul><h3 id="建议何时不应该重载函数"><a class="anchor" href="#建议何时不应该重载函数">#</a> 建议：何时不应该重载函数</h3><p>尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好只重载那些确实非常相似的操作</p><p>有些情况下，给函数起不同的名字能使得程序更易理解</p><p>例如，以下是几个负责移动屏幕光标的函数</p><pre><code class="language-cpp">Screen&amp; moveHome();Screen&amp; moveAbs(int, int);Screen&amp; moveRel(int, int, string direction);</code></pre><p>乍看上去，似乎可以把这组函数统一命名为 move ，从而实现函数的重载。然而，重载之后这些函数失去了名字中本来拥有的信息（因为这些函数移动光标的具体方式各不相同）</p><p>一般来说，是否重载函数要看哪个更容易理解</p><h3 id="const_cast-和重载"><a class="anchor" href="#const_cast-和重载">#</a> const_cast 和重载</h3><p>const_cast 常常用于有函数重载的上下文中</p><p>考虑下面的 shorterString 函数，其参数和返回类型都是 const string 的引用，我们可以对两个非常量的 string 实参调用这个函数，但返回的仍然是 const string 的引用</p><pre><code class="language-cpp">// 无论实参是常量还是非常量，返回类型都是 const string &amp;const string &amp;shorterString(const string &amp;s1, const string &amp;s2) &#123; // 形参是 const string &amp; 类型    return s1.size() &lt;= s2.size() ? s1 : s2;&#125;</code></pre><p>为了实现 “当实参不是常量时，得到的结果是一个普通的引用，即 string &amp;”，可以使用 const_cast 定义一种新的 shorterString 函数：</p><pre><code class="language-cpp">string &amp;shorterString(string &amp;s1, string &amp;s2) &#123; // 形参是 string &amp; 类型    auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1),                            const_cast&lt;const string&amp;&gt;(s2)); // 调用形参为 const string &amp; 类型的 shorterString 函数    return const_cast&lt;string&amp;&gt;(r);&#125;</code></pre><p>在这个版本的函数中，首先将它的实参强制转换成对 const 的引用，然后调用了 shorterString 函数的 const 版本。const 版本返回对 const string 的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的 string &amp;</p><h3 id="调用重载的函数"><a class="anchor" href="#调用重载的函数">#</a> 调用重载的函数</h3><p><strong>函数匹配</strong>（function matching）：把函数调用与一组重载函数中的某一个关联起来。具体而言，编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数</p><p>函数匹配也叫做<strong>重载确定</strong>（overload resolution）</p><p>调用重载函数时，有三种可能的结果：</p><ul><li>编译器找到一个与实参<strong>最佳匹配</strong>（best match）的函数，并生成调用该函数的代码</li><li>找不到任何一个函数与调用的实参匹配，此时编译器发出<strong>无匹配</strong>（no match）的错误信息</li><li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用</strong>（ambiguous call）</li></ul><h2 id="重载与作用域"><a class="anchor" href="#重载与作用域">#</a> 重载与作用域</h2><blockquote><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。但是为了说明作用域和重载的相互关系，我们将暂时违反这一原则而使用局部函数声明</p></blockquote><p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体</p><p>因此，在不同的作用域中，无法重载函数名</p><pre><code class="language-cpp">string read();void print(const string &amp;);void print(double);   // 重载 print 函数void fooBar(int ival) &#123;    bool read = false; // 新作用域，隐藏了外层作用域中声明的 read    string s = read(); // 错误：read 是一个布尔对象，而不是函数（因为外层的 read 函数被隐藏了）    // 通常来说，在局部作用域中声明函数不是一个好的选择    void print(int);  // 新作用域，隐藏了外层作用域中的 print    print(&quot;Value: &quot;); // 错误：print(const string &amp;) 被隐藏掉了    print(ival);      // 正确：当前 print(int) 可见    print(3.14);      // 正确：调用 print(int) （外层的 print(double) 被隐藏了）&#125;</code></pre><p>当我们调用 print 函数时，编译器首先寻找对该函数名的声明，找到的是接受 int 值的那个局部声明。<strong>一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体</strong>。剩下的工作就是检查函数调用是否有效了</p><blockquote><p>在 C++ 语言中，名字查找发生在类型检查之前</p></blockquote><p>第一个调用 print (&quot;Value:&quot;) 传入一个字符串字面值，但是当前作用域内 print 函数唯一的声明要求参数是 int 类型，由于字符串字面值无法转换成 int 类型，这个调用是错误的（虽然外层作用域中的 print (const string&amp;) 函数与本次调用匹配，但是它已经被隐藏掉了，根本不会被考虑）</p><p>假设我们把 print (int) 和其他 print 函数声明放在同一个作用域中，则它将成为另一种重载形式：</p><pre><code class="language-cpp">void print(const string &amp;);void print(double); // print 函数的重载形式void print(int);    // print 函数的另一种重载形式void fooBar2(int ival) &#123;    print(&quot;Value: &quot;); // 调用 print(const string &amp;)    print(ival);      // 调用 print(int)    print(3.14);      // 调用 print(double)&#125;</code></pre><h1 id="特殊用途语言特性"><a class="anchor" href="#特殊用途语言特性">#</a> 特殊用途语言特性</h1><p>本节我们介绍函数相关的三种语言特性，这些特性对大多数程序都有用，它们分别是：默认实参、内联函数和 constexpr 函数，以及在程序调试过程中常用的一些功能</p><h2 id="默认实参"><a class="anchor" href="#默认实参">#</a> 默认实参</h2><p>有些函数的某个参数在大多数（但不是所有）调用中都被赋予了特定的值。此时，我们可以把这个特定值称为函数的<strong>默认实参</strong>（default argument）</p><p>默认实参作为形参的初始值出现在形参列表中</p><p>例如，我们使用 string 对象表示窗口的内容。一般情况下，我们希望该窗口的高、宽和背景字符都使用默认值，但是同时我们也应该允许用户为这几个参数自由指定与默认值不同的数值。因此，我们为每一个形参都提供了默认实参</p><pre><code class="language-cpp">typedef string::size_type sz;string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');</code></pre><p>我们可以为一个或多个形参定义默认值，不过需要注意的是，<strong>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</strong></p><p>调用含有默认实参的函数时，可以包含该实参，也可以省略该实参</p><h3 id="使用默认实参调用函数"><a class="anchor" href="#使用默认实参调用函数">#</a> 使用默认实参调用函数</h3><p>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了</p><p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）</p><pre><code class="language-cpp">string window;window = screen();              // 等价于 screen(24, 80, ' ')window = screen(66);            // 等价于 screen(66, 80, ' ')window = screen(66, 256);       // 等价于 screen(66, 256, ' ')window = screen(66, 256, '#');  // 等价于 screen(66, 256, '#')</code></pre><p>要想覆盖 backgrnd 的默认值，必须为 ht 和 wid 提供实参</p><pre><code class="language-cpp">window = screen(, , '?'); // 错误：只能省略尾部的实参window = screen('?');     // 调用 screen('?', 80, ' ')                          // char 型的 '?' 可以转换成 string::size_type 类型的值 63</code></pre><p>当设计含有默认实参的函数时，需要合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，让那些经常使用默认值的形参出现在后面</p><h3 id="默认实参声明"><a class="anchor" href="#默认实参声明">#</a> 默认实参声明</h3><p>对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的</p><p>不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值</p><p>假如给定</p><pre><code class="language-cpp">// 表示高度和宽度的形参没有默认值string screen(sz, sz, char = ' ');</code></pre><p>我们就不能再修改一个已经存在的默认值</p><pre><code class="language-cpp">string screen(sz, sz, char = '*'); // 错误：重复赋予默认实参</code></pre><p>但是可以按照如下形式添加默认实参</p><pre><code class="language-cpp">string screen(sz = 24, sz = 80, char); // 正确：添加默认实参</code></pre><blockquote><p>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中</p></blockquote><h3 id="默认实参初始值"><a class="anchor" href="#默认实参初始值">#</a> 默认实参初始值</h3><p>除了<strong>局部变量不能作为默认实参</strong>外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参</p><pre><code class="language-cpp">// wd、def 和 ht 的声明必须出现在函数之外sz wd = 80;char def = ' ';sz ht();string screen(sz = ht(), sz = wd, char = def);string window = screen(); // 调用 screen(ht(), 80, ' ')</code></pre><p>用作默认实参的名字（例如 ht () ）会在函数声明所在的作用域内解析，但是会在函数调用时才求值</p><pre><code class="language-cpp">void f2() &#123;    def = '*';          // 改变了默认实参的值    sz wd = 100;        // 隐藏了外层定义的 wd ，但是没有改变默认值    window = screen();  // 调用 screen(ht(), 80, '*')&#125;</code></pre><p>我们在函数 f2 内部改变了 def 的值，所以对 screen 的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的 wd ，但是该局部变量与传递给 screen 的默认实参没有任何关系</p><h2 id="内联函数和-constexpr-函数"><a class="anchor" href="#内联函数和-constexpr-函数">#</a> 内联函数和 constexpr 函数</h2><p>此前我们编写了一个函数 shroterString ，用于比较两个 string 形参的长度并返回长度较小的 string 的引用。将这种规模较小的操作定义成函数，具有以下优点：</p><ul><li>便于阅读</li><li>可以确保行为的统一</li><li>如果我们需要修改计算过程，修改函数要比修改所有等价表达式更容易</li><li>可以被其他应用重复利用</li></ul><p>然而，使用 shorterString 函数也存在一个潜在的缺点：调用函数一般比求等价表达式的值要慢一些</p><p>在大多数机器上，一次函数调用其实包含着一系列工作：</p><ul><li>调用前要先保存寄存器，并在返回时恢复</li><li>可能需要拷贝实参</li><li>程序转向一个新的位置继续执行</li></ul><h3 id="内联函数可以避免函数调用的开销"><a class="anchor" href="#内联函数可以避免函数调用的开销">#</a> 内联函数可以避免函数调用的开销</h3><p>将函数指定为<strong>内联函数</strong>（inline），通常就是将它在每个调用点上 “内联地” 展开</p><p>假设我们把 shorterString 函数定义成内联函数，则如下调用</p><pre><code class="language-cpp">cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl;</code></pre><p>将在编译过程中展开成类似于下面的形式</p><pre><code class="language-cpp">cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; endl;</code></pre><p>从而消除了 shorterString 函数的运行时开销</p><p><strong>在函数返回类型的前面加上加上关键字  <code>inline</code>  ，即可将其声明为内联函数</strong></p><pre><code class="language-cpp">// 内联版本：寻找两个 string 对象中较短的那个inline const string &amp; shorterString(const string &amp;s1, const string &amp;s2) &#123;        return s1.size() &lt;= s2.size() ? s1 : s2;&#125;</code></pre><blockquote><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求</p></blockquote><p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数</p><p>很多编译器都不支持内联递归函数，而且，一个太长的函数也不太可能在调用点 “内联地” 展开</p><h3 id="constexpr-函数"><a class="anchor" href="#constexpr-函数">#</a> constexpr 函数</h3><p><strong>constexpr 函数</strong>（constexpr function）是指能用于常量表达式的函数</p><p>constexpr 函数的定义：</p><ul><li>函数的返回类型及所有形参的类型都必须是字面值类型</li><li>函数体中必须有且只有一条 return 语句</li></ul><pre><code class="language-cpp">constexpr int new_sz() &#123; return 42; &#125;constexpr int foo = new_sz();  // 正确：foo 是一个常量表达式</code></pre><p>在上面的代码中，我们把 new_sz 定义成一个无参数的 constexpr 函数，于是，new_sz 函数返回的是常量表达式，因此可以用 new_sz 函数来初始化 constexpr 类型的变量 foo</p><p>执行该初始化任务时，编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，<strong>constexpr 函数被隐式地指定为内联函数</strong></p><blockquote><p>constexpr 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr 函数中可以有空语句、类型别名以及 using 声明</p></blockquote><p>constexpr 函数的返回值可以不是一个常量</p><p>例如：定义一个 constexpr 函数 scale 。当我们给 scale 函数传入一个形如字面值 2 的常量表达式时，它的返回类型也是常量表达式，此时，编译器用相应的结果值替换对 scale 函数的调用。相反，如果我们用一个非常量表达式调用 scale 函数，比如 int 类型的对象 i ，则返回值是一个非常量表达式</p><pre><code class="language-cpp">// 如果 arg 是常量表达式，则 scale(arg) 也是常量表达式constexpr size_t scale(size_t cnt) &#123; return new_sz() * cnt; &#125;// 当 scale 的实参是常量表达式时，它的返回值也是常量表达式；反之则不是int arr[scale(2)]; // 正确：scale(2) 是常量表达式int i = 2;         // i 不是常量表达式int a2[scale(i)];  // 错误：scale(i) 不是常量表达式</code></pre><p>当把 scale 函数用在需要常量表达式的上下文中时，编译器会负责检查函数的结果是否符合要求。如果结果恰好不是常量表达式，编译器将发出错误信息</p><blockquote><p>constexpr 函数不一定返回常量表达式</p></blockquote><h3 id="把内联函数和-constexpr-函数放在头文件内"><a class="anchor" href="#把内联函数和-constexpr-函数放在头文件内">#</a> 把内联函数和 constexpr 函数放在头文件内</h3><p>和其他函数不一样，内联函数和 constexpr 函数可以在程序中多次定义</p><p>不过，对于某个给定的内联函数或者 constexpr 函数来说，它的多个定义必须完全一致</p><p>因此，内联函数和 constexpr 函数通常定义在头文件中</p><h2 id="调试帮助"><a class="anchor" href="#调试帮助">#</a> 调试帮助</h2><p>C++ 程序员有时会用到一种类似于 <strong>头文件保护</strong> 的技术，以便有选择地执行调试代码</p><p>基本思想：程序可以包含一些用于调试的代码，这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码</p><p>这种方法用到两项预处理功能： <code>assert</code>  和  <code>NDEBUG</code></p><h3 id="assert-预处理宏"><a class="anchor" href="#assert-预处理宏">#</a> assert 预处理宏</h3><p>assert 是一种预处理宏（preprocessor marco）</p><p>预处理宏是一个行为类似于内联函数的预处理变量</p><p>assert 宏使用一个表达式作为它的条件：</p><pre><code class="language-cpp">assert(expr);</code></pre><p>其首先对 expr 求值，如果表达式为假（即，值为 0），assert 输出信息并终止程序的执行。如果表达式为真（即，值不为 0），assert 什么也不做</p><p>assert 宏定义在  <code>cassert</code>  头文件中，即：</p><pre><code class="language-cpp">#include&lt;cassert&gt;</code></pre><blockquote><p>预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字，即，直接使用 assert 而不是 std::assert，也不需要为 assert 提供 using 声明</p></blockquote><blockquote><p>和预处理变量一样，宏名字在程序内必须唯一。因此，含有 cassert 头文件的程序不能再定义名为 assert 的变量、函数或者其他实体</p></blockquote><p><strong>assert 宏常用于检查 “不能发生” 的条件</strong></p><p>例如，一个对输入文本进行操作的程序，可能要求所有给定单词的长度都大于某个阈值</p><pre><code class="language-cpp">assert(word.size() &gt; threshold);</code></pre><h3 id="ndebug-预处理变量"><a class="anchor" href="#ndebug-预处理变量">#</a> NDEBUG 预处理变量</h3><p>NDEBUG 是一个预处理变量，表示当前不处于调试状态（not debug），可用于控制 assert 的行为：</p><ul><li>如果没有定义 NDEBUG ，assert 将执行运行时检查</li><li>如果定义了 NDEBUG ，则 assert 什么也不做</li></ul><p>默认状态下，没有定义 NDEBUG</p><p>我们可以使用一个 #define 语句定义 NDEBUG ，从而关闭调试状态</p><pre><code class="language-cpp">#define NDEBUG // 关闭调试状态（必须定义在 cassert 头文件之前）#include &lt;cassert&gt;int main(void) &#123;    int x = 0;    assert(x);&#125;</code></pre><p>定义 NDEBUG 能避免检查各种条件所需的运行时开销（其实根本就不会执行运行时检查），因此，assert 应该仅用于验证那些确实不可能发生的事情</p><blockquote><p>我们可以把 assert 当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查</p></blockquote><p>除了用于 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码（详见 <strong>预处理变量</strong> ）</p><ul><li>如果 NDEBUG 未定义，将执行 #ifndef 和 #endif 之间的代码</li><li>如果定义了 NDEBUG ，则会忽略 #ifndef 和 #endif 之间的代码</li></ul><p>例如：</p><pre><code class="language-cpp">void print(const int ia[], size_t size) &#123;#ifndef NDEBUG// _ _func_ _ 是编译器定义的一个局部静态变量，用于存放函数的名字cerr &lt;&lt; _ _func_ _ &lt;&lt; &quot;: array size is &quot; &lt;&lt; size &lt;&lt; endl;#endif// ...</code></pre><p>在这段代码中，我们使用变量  <code>_ _func_ _</code>  输出当前调试的函数的名字（即 &quot;print&quot; ）</p><p>编译器为每个函数都定义了  <code>_ _func_ _</code>  ，它是  <code>const char</code>  的一个静态数组，用于存放函数的名字</p><p>除了 C++ 编译器定义的  <code>_ _func_ _</code>  之外，预处理器还定义了另外 4 个用于程序调试的名字：</p><ul><li><code>_ _FILE_ _</code>  ：存放文件名的字符串字面值</li><li><code>_ _LINE_ _</code>  ：存放当前行号的整型字面值</li><li><code>_ _LINE_ _</code>  ：存放当前行号的整型字面值</li><li><code>_ _DATE_ _</code>  ：存放文件编译日期的字符串字面值</li></ul><p>可以使用这些常量在错误消息中提供更多信息，例如：</p><pre><code class="language-cpp">if (word.size() &lt; threshold)    cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; _ _FILE_ _         &lt;&lt; &quot; : in function &quot; &lt;&lt; _ _func_ _         &lt;&lt; &quot; at line &quot; &lt;&lt; _ _LINE_ _ &lt;&lt; endl         &lt;&lt; &quot;       Compiled on &quot; &lt;&lt; _ _DATE_ _         &lt;&lt; &quot; at &quot; &lt;&lt; _ _TIME_ _ &lt;&lt; endl         &lt;&lt; &quot;       Word read was \&quot;&quot; &lt;&lt; word         &lt;&lt; &quot;\&quot;:  Length too short&quot; &lt;&lt; endl;</code></pre><p>如果我们给程序提供了一个长度小于 threshold 的 string 对象，将得到下面的错误消息：</p><pre><code>Error:wdebug.cc : in function main at line 27       Compiled on Jul 11 2012 at 20:50:03       Word read was &quot;foo&quot;: Length too short</code></pre><h1 id="函数匹配"><a class="anchor" href="#函数匹配">#</a> 函数匹配</h1><p>当重载函数的形参数量相等、并且某些形参的类型可以由其他类型转换得到时，不太容易确定某次调用应该选用哪个重载函数</p><h2 id="函数匹配-2"><a class="anchor" href="#函数匹配-2">#</a> 函数匹配</h2><p>函数匹配：从一组重载函数中选取最佳函数的过程</p><h3 id="函数匹配的步骤"><a class="anchor" href="#函数匹配的步骤">#</a> 函数匹配的步骤</h3><p>选定本次调用对应的重载函数集</p><ul><li>集合中的函数称为 <strong>候选函数</strong>（candidate function）</li><li>候选函数具备两个特征：<ul><li>与被调用的函数同名</li><li>其声明在调用点可见</li></ul></li></ul><p>考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数</p><ul><li>这些新选出的函数称为 <strong>可行函数</strong>（viable function）</li><li>可行函数具备两个特征：<ul><li>形参数量与本次调用提供的实参数量相等（如果函数含有默认实参，在调用该函数时，传入的实参数量可能少于它实际使用的实参数量）</li><li>每个实参的类型与对应的形参类型相同，或者能转换成形参的类型</li></ul></li><li>如果没找到可行函数，编译器将报告无匹配函数的错误</li></ul><p>逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数（即，寻找<strong>最佳匹配</strong>）</p><ul><li>如果有且只有一个函数满足下列条件，则匹配成功：<ul><li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配</li><li>至少有一个实参的匹配优于其他可行函数提供的匹配</li></ul></li><li>下一节将介绍到：实参类型与形参类型越接近，它们匹配得越好</li><li>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。此时，编译器将报告二义性调用的信息</li></ul><blockquote><p>调用重载函数时应尽量避免强制类型转换，如果在实际应用中确实需要强制类型转换，则说明我们设计的形参列表不合理</p></blockquote><h3 id="实例分析"><a class="anchor" href="#实例分析">#</a> 实例分析</h3><p>以下面这组函数及其调用为例：</p><pre><code class="language-cpp">void f();void f(int);void f(int, int);void f(double, double = 3.14);f(5.6); // 调用 f(double, double)</code></pre><p>第一步：可以确定上述 4 个名为 f 的函数均为候选函数</p><p>第二步：可以根据实参的数量排除 void f () 和 void f (int, int) ，选出  void f (int) 和 void f (double, double = 3.14) 两个可行函数</p><ul><li>排除的两个函数：我们的调用提供了一个实参，而 void f () 不使用形参，void f (int, int) 使用两个形参</li><li>可行的两个函数：void f (int) 使用一个 int 形参，而我们调用传入的 double 实参可以转换成形参类型 int ；void f (double, double = 3.14) 本应接受两个 double 实参，但因为它含有一个默认实参，所以可以只用一个实参来调用它</li></ul><p>第三步：逐一考察实参，寻找最佳匹配</p><ul><li>调用提供了一个（显式的）double 型实参，如果调用 f (int) ，实参将不得不从 double 转换成 int</li><li>相反，可行函数 void (double, double) 则与实参精确匹配</li><li><strong>精确匹配比需要类型转换的匹配更好</strong>，因此，编译器把 f (5.6) 解析成对函数 void (double, double) 的调用，并使用默认值填补我们未提供的第二个实参</li></ul><p>当实参的数量有两个或更多时，函数匹配就比较复杂了</p><p>例如，考察形如 f (42, 2.56) 的调用：</p><p>第一步：4 个名为 f 的函数均为候选函数</p><p>第二步：确定 void f (int, int) 和 void f (double, double) 为可行函数</p><p>第三步：逐一考察实参，寻找最佳匹配</p><ul><li>考虑第一个实参 42 ：函数 f (int, int) 能精确匹配，而函数 f (double, double) 需要先将 int 类型实参转换成 double 类型。此时，函数 f (int, int) 优于 函数 f (double, double)</li><li>接着考虑第二个实参 2.56 ：函数 f (double, double) 能精确匹配，而函数 f (int, int) 须将 2.56 从 double 类型转换成 int 型。此时，函数 f (double, double) 优于 函数 f (int, int)</li><li>由于每个可行函数各自在一个实参上实现了更好的匹配，无法从整体上判断孰优孰劣。编译器最终将因为这个调用具有二义性而拒绝其请求</li></ul><blockquote><p>看起来我们似乎可以通过强制类型转换其中的一个实参来实现函数的匹配，但是在设计良好的系统中，不应该对实参进行强制类型转换</p></blockquote><h2 id="实参类型转换"><a class="anchor" href="#实参类型转换">#</a> 实参类型转换</h2><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示（越靠前的，匹配程度越好）：</p><ul><li>精确匹配，其包括以下情况：<ul><li>实参类型和形参类型相同</li><li>实参从数组类型或函数类型转换成对应的指针类型</li><li>向实参添加顶层 const 或者从实参中删除顶层 const</li></ul></li><li>通过 const 转换实现的匹配</li><li>通过类型提升实现的匹配</li><li>通过算术类型转换或指针转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ul><h3 id="需要类型提升和算术类型转换的匹配"><a class="anchor" href="#需要类型提升和算术类型转换的匹配">#</a> 需要类型提升和算术类型转换的匹配</h3><p><strong>小整型一般都会提升到 int 类型或更大的整数类型</strong></p><p>例如，假设有两个函数，一个接受 int 、另一个接受 short ，则</p><ul><li>只有当调用提供的是 short 类型的值时才会选择 short 版本的函数</li><li>有时候，即使实参是一个很小的整数值，也会直接将它提升成 int 类型，此时使用 short 版本反而会导致类型转换</li></ul><pre><code class="language-cpp">void ff(int);void ff(short);ff('a'); // char 提升成 int ，调用 f(int)</code></pre><p><strong>所有算术类型转换的级别都一样</strong></p><p>例如，从 int 向 unsigned int 的转换并不比从 int 向 double 的转换级别高</p><pre><code class="language-cpp">void manip(long);void manip(float);manip(3.14); // 错误：二义性调用</code></pre><h3 id="函数匹配和-const-实参"><a class="anchor" href="#函数匹配和-const-实参">#</a> 函数匹配和 const 实参</h3><p><strong>如果重载函数的区别仅在于函数的引用类型的形参是否为常量引用（或者，指针类型的形参是否为常量指针），编译器将通过实参是否为常量来决定选择哪个函数</strong></p><blockquote><p>When we call an overloaded function that differs on whether a reference or pointer parameter refers or points to const, the compiler uses the constness of the argument to decide which function to call.</p></blockquote><p>例如：</p><pre><code class="language-cpp">Record lookup(Account&amp;);       // 函数的参数是 Account 的引用Record lookup(const Account&amp;); // 函数的参数是 Account 的常量引用const Account a;Account b;lookup(a);   // 调用 lookup(const Account&amp;)lookup(b);   // 调用 lookup(Account&amp;)</code></pre><p>第一个调用传入的是 const 对象 a ：因为不能把普通引用绑定到 const 对象上，唯一可行的函数是 以常量引用作为形参的函数 lookup (const Account&amp;) ，并且调用该函数与实参 a 精确匹配</p><p>第二个调用传入的是非常量对象 b ：对于该调用而言，两个函数都是可行的，因为 b 既可以用来初始化常量引用也可以用来初始化非常量引用。然而，用非常量对象来初始化常量引用需要类型转换，因此，应该选用非常量版本的函数 lookup (Account&amp;)</p><p>指针类型的形参也是类似的：如果两个函数的唯一区别是指针形参指向常量或非常量，编译器通过实参是否为常量来决定选用哪个函数</p><ul><li>如果实参是指向常量的指针，调用形参为 const* 的函数</li><li>如果实参是指向非常量的指针，调用形参是普通指针的函数</li></ul><h1 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针</h1><p>函数指针（function pointer）指向的是函数而非对象</p><p>类似于其他指针，函数指针也指向一个特定的类型（即，函数的类型）</p><p>函数的类型由它的返回类型和形参类型共同决定，与函数名无关</p><blockquote><p>A function pointer is just that—a pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function’s type is determined by its return type and the types of its parameters. The function’s name is not part of its type.</p></blockquote><p>例如，以下函数的类型是 bool (const string &amp;, const string &amp;)</p><pre><code class="language-cpp">// 比较两个 string 对象的长度bool lengthCompare(const string &amp;, const string &amp;);</code></pre><p>要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：</p><pre><code class="language-cpp">// pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool 类型bool (*pf)(const string &amp;, const string &amp;);</code></pre><p>针对 bool (*pf)(const string &amp;, const string &amp;) 的分析逻辑：</p><ul><li>pf 前面有个 * ，表示 pf 是指针</li><li>右侧是形参列表，表示 pf 指向的是函数</li><li>再观察左侧，发现函数的返回类型是布尔值</li><li>因此，pf 就是一个指向函数的指针，其中该函数的参数是两个 const string 的引用，返回值是 bool 类型</li></ul><blockquote><p>*pf 两端的括号必不可少，如果不写这对括号（即： <code>bool *pf(const string &amp;, const string &amp;);</code>  ），pf 将是一个返回类型为 bool * 的函数</p></blockquote><h2 id="使用函数指针"><a class="anchor" href="#使用函数指针">#</a> 使用函数指针</h2><p>当我们把函数名作为一个值使用时，该函数自动地转换成指针</p><p>例如，按照如下形式我们可以将函数 lengthCompare 的地址赋给 pf</p><pre><code class="language-cpp">pf = lengthCompare;  // pf 指向名为 lengthCompare 的函数pf = &amp;lengthCompare; // 等价的赋值语句（取地址符是可选的）</code></pre><p>我们可以直接使用指向函数的指针来调用该函数，而无须提前解引用指针</p><pre><code class="language-cpp">bool b1 = pf(&quot;hello&quot;, &quot;goodbye&quot;);    // 调用 lengthComparebool b2 = (*pf)(&quot;hello&quot;, &quot;goodbye&quot;); // 等价的调用bool b3 = lengthCompare(&quot;hello&quot;, &quot;goodbye&quot;); // 等价的调用</code></pre><p>指向不同函数类型的指针是不可以转换的，但是，我们可以为函数指针赋一个 nullptr 或者值为 0 的整型常量表达式，表示该指针没有指向任何一个函数</p><blockquote><p>There is no conversion between pointers to one function type and pointers to another function type. However, as usual, we can assign nullptr or a zero-valued integer constant expression to a function pointer to indicate that the pointer does not point to any function.</p></blockquote><pre><code class="language-cpp">bool (*pf)(const string &amp;, const string &amp;);string::size_type sumLength(const string&amp;, const string&amp;);bool cstringCompare(const char*, const char*);pf = 0;              // 正确：pf 不指向任何函数pf = sumLength;      // 错误：返回类型不匹配pf = cstringCompare; // 错误：形参类型不匹配pf = lengthCompare;  // 正确：函数和指针的类型精确匹配</code></pre><h2 id="重载函数的指针"><a class="anchor" href="#重载函数的指针">#</a> 重载函数的指针</h2><p>如果定义了指向重载函数的指针，编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配</p><pre><code class="language-cpp">void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff;  // pf1 指向 ff(unsigned)void (*pf2)(int) = ff;    // 错误：没有任何一个 ff 与该形参列表匹配double (*pf3)(int*) = ff; // 错误：ff 和 pf3 的返回类型不匹配</code></pre><h2 id="函数指针形参"><a class="anchor" href="#函数指针形参">#</a> 函数指针形参</h2><p>类似于数组，我们不能定义函数类型的形参，但是，<strong>可以将指向函数的指针作为形参</strong></p><p>我们可以定义一个类似于函数类型的形参，它会自动地转换成指向函数的指针（类似于 <strong>数组形参</strong> ）</p><pre><code class="language-cpp">// 第三个形参是函数类型，它会自动地转换成指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2,               bool pf(const string &amp;, const string &amp;));// 等价的声明：显式地将形参定义成指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2,               bool (*pf)(const string &amp;, const string &amp;));</code></pre><p>如果我们直接将函数作为实参使用，它会自动转换成指针</p><pre><code class="language-cpp">// 自动将函数 lengthCompare 转换成指向该函数的指针useBigger(s1, s2, lengthCompare);</code></pre><p>由于直接将函数指针类型作为形参（例如，useBigger 的声明语句中的第三个形参）会显得冗长，可以使用 类型别名 和 decltype 来简化函数指针的代码</p><p>例如：首先使用 typedef 和 decltype 来定义自己的函数类型和函数指针类型</p><pre><code class="language-cpp">// Func 和 Func2 是函数类型typedef bool Func(const string&amp;, const string&amp;); // 函数类型typedef decltype(lengthCompare) Func2; // 函数类型的等价声明// FuncP 和 FuncP2 是指向函数的指针typedef bool (*FuncP)(const string &amp;, const string&amp;); // 函数指针类型typedef decltype(lengthCompare) *FuncP2; // 函数指针类型的等价声明</code></pre><blockquote><p>注意：decltype 返回的是函数类型，不会将函数类型自动转换成指针类型，所以需要再加上  <code>*</code>  才能得到指针</p></blockquote><p>然后重新声明 useBigger 函数：</p><pre><code class="language-cpp">// useBigger 的等价声明，其中使用了类型别名void useBigger(const string&amp;, const string&amp;, Func);void useBigger(const string&amp;, const string&amp;, FuncP2);</code></pre><p>这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动地将 Func 表示的函数类型转换成指针</p><h2 id="返回指向函数的指针"><a class="anchor" href="#返回指向函数的指针">#</a> 返回指向函数的指针</h2><p>类似于数组，我们不能返回一个函数，但是，<strong>可以返回指向函数类型的指针</strong></p><p>由于编译器不会自动将函数返回类型当成对应的指针类型处理，我们必须显式地将返回类型写成指针形式</p><p>声明一个返回函数指针的函数，最直接的办法是（类似于 <strong>返回数组指针</strong> ）：</p><pre><code class="language-cpp">int (*f1 (int)) (int* , int);</code></pre><p>按照由内向外的顺序阅读这条声明语句：</p><ul><li>f1 有形参列表，所以 f1 是一个函数</li><li>f1 前面有 * ，所以 f1 返回的是一个指针</li><li>进一步观察发现，指针所指向的类型为 int (int*, int) ，其包含形参列表，因此，该指针指向的是一个返回类型为 int 的函数</li></ul><p>声明一个返回函数指针的函数，最简单的办法是使用类型别名：</p><pre><code class="language-cpp">using F = int(int*, int);     // F 是函数类型using PF = int(*)(int*, int); // PF 是函数指针类型</code></pre><p>必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针，因此，我们必须显式地将返回类型指定为指针</p><pre><code class="language-cpp">PF f1(int); // 正确：PF 是指向函数的指针，f1 返回指向函数的指针F f1(int);  // 错误：F 是函数类型，f1 不能返回一个函数F *f1(int); // 正确：将函数返回类型显式地指定为指向函数的指针</code></pre><p>此外，我们也可以使用尾置返回类型的方式来声明一个返回函数指针的函数（可参考 <strong>使用尾置返回类型</strong> ）：</p><pre><code class="language-cpp">auto f1(int) -&gt; int (*)(int*, int);</code></pre><h2 id="将-auto-和-decltype-用于函数指针类型"><a class="anchor" href="#将-auto-和-decltype-用于函数指针类型">#</a> 将 auto 和 decltype 用于函数指针类型</h2><p>如果我们明确知道返回的函数是哪一个，可以使用 decltype 关键字将返回类型声明为 函数指针类型</p><p>例如，假定有两个函数，它们的返回类型都是 string::size_type ，并且各有两个 const string&amp; 类型的形参</p><pre><code class="language-cpp">string::size_type sumLength(const string&amp;, const string&amp;);string::size_type largerLength(const string&amp;, const string&amp;);</code></pre><p>此时，我们可以编写第三个函数，它接受一个 string 类型的参数，返回一个指针，该指针指向前两个函数中的某一个</p><pre><code class="language-cpp">// 根据其形参的取值，getFcn 函数返回指向 sumLength 或者 largerLength 的指针decltype(sumLength) *getFcn(const string &amp;);</code></pre><p>注意：<strong> <code>decltype</code>  并不负责把函数类型转换成对应的指针</strong>，所以 decltype 的结果是个函数类型，因此，我们显式地加上  <code>*</code>  以表明我们需要返回指针而不是函数本身</p><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><strong>二义性调用（ambiguous call）</strong> ：是一种编译时发生的错误。造成二义性调用的原因：在函数匹配时，两个或多个函数提供的匹配一样好，编译器找不到唯一的最佳匹配</p><p><strong>实参（argument）</strong> ：函数调用时提供的值，用于初始化函数形参</p><p><strong>Assert</strong> ：是一个预处理宏，作用于一条表示条件的表达式</p><ul><li>当未定义预处理变量 NDEBUG 时，assert 对条件求值</li><li>如果 assert 的条件为假，输出一条错误信息并终止当前程序的执行</li></ul><p><strong>自动对象（automatic object）</strong> ：仅存在于函数执行过程中的对象</p><ul><li>当程序的控制流经过此类对象的定义语句时，创建该对象</li><li>当到达了定义所在的块的末尾时，销毁该对象</li></ul><p><strong>最佳匹配（best match）</strong> ：从一组重载函数中为调用选出的一个函数。最佳匹配（如果存在的话）至少在一个实参上比其他所有可行函数更优，同时，在其他实参的匹配上不会更差</p><p><strong>传引用调用（call by reference）</strong> ：对引用传递的函数的调用</p><p><strong>传值调用（call by value）</strong> ：对值传递的函数的调用</p><p><strong>候选函数（candidate function）</strong> ：解析某次函数调用时考虑的一组函数。候选函数的名字应该与函数调用使用的名字一致，并且在调用点候选函数的声明在作用域之内</p><p><strong>constexpr</strong> ：可以返回常量表达式的函数。一个 constexpr 函数被隐式地声明成内联函数</p><p><strong>默认实参（default argument）</strong> ：当调用缺少了某个实参时，为该实参指定的默认值</p><p><strong>可执行文件（executable file）</strong> ；是操作系统能够执行的文件，包含着与程序有关的代码</p><p><strong>函数（function）</strong> ：可调用的计算单元</p><p><strong>函数体（function body）</strong> ：是一个块，用于定义函数所执行的操作</p><p><strong>函数匹配（function matching）</strong> ：编译器解析重载函数调用的过程，在此过程中，实参与每个重载函数的形参列表逐一比较</p><p><strong>函数原型（function prototype）</strong> ：函数的声明，包含函数名字、返回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型</p><p><strong>隐藏名字（hidden name）</strong> ：某个作用域内声明的名字会隐藏掉外层作用域中声明的同名实体</p><p><strong>initializer_list</strong> ：是一个标准类，表示的是一组花括号包围的类型相同的对象，对象之间以逗号隔开</p><p><strong>内联函数（inline function）</strong> ：请求编译器在可能的情况下在调用点展开函数。内联函数可以避免常见的函数调用开销</p><p><strong>链接（link）</strong> ：是一个编译过程，负责把若干对象文件链接起来形成可执行程序</p><p><strong>局部静态对象（local static object）</strong> ：它的值在函数调用结束后仍然存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局部静态对象才被销毁</p><p><strong>局部变量（local variable）</strong> ：定义在块中的变量</p><p><strong>无匹配（no match）</strong> ：是一种编译时发生的错误，原因是在函数匹配过程中所有函数的形参都不能与调用提供的实参匹配</p><p><strong>对象代码（object code）</strong> ：编译器将我们的源代码转换成对象代码格式</p><p><strong>对象文件（object file）</strong> ：编译器根据给定的源文件生成的保存对象代码的文件。一个或多个对象文件经过链接生成可执行文件</p><p><strong>对象生命周期（object lifetime）</strong> ：每个对象都有相应的生命周期</p><ul><li>块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末尾为止</li><li>程序启动后创建全局对象</li><li>程序控制流经过局部静态对象的定义时创建该局部静态对象</li><li>当 main 函数结束时销毁全局对象和局部静态对象</li></ul><p><strong>重载确定（overload resolution）</strong> ：参见函数匹配</p><p><strong>重载函数（overloaded function）</strong> ：函数名与其他函数相同的函数。多个重载函数必须在形参数量或形参类型上有所区别</p><p><strong>形参（parameter）</strong> ：在函数的形参列表中声明的局部变量。用实参初始化形参</p><p><strong>引用传递（pass by reference）</strong> ：描述如何将实参传递给引用类型的形参。引用形参和其他形式的引用工作机理类似，形参被绑定到相应的实参上</p><p><strong>值传递（pass by value）</strong> ：描述如何将实参传递给非引用类型的形参。非引用类型的形参实际上是相应实参值的一个副本</p><p><strong>预处理宏（preprocessor macro）</strong> ：类似于内联函数的一种预处理功能。除了 assert 之外，现代 C++ 程序很少再使用预处理宏了</p><p><strong>递归循环（recursion loop）</strong> ：描述某个递归函数没有终止条件，因而不断调用自身直至耗尽程序栈空间的过程</p><p><strong>递归函数（recursive function）</strong> ：直接或间接调用自身的函数</p><p><strong>返回类型（return type）</strong> ：是函数声明的一部分，用于指定函数返回值的类型</p><p><strong>分离式编译（separate compilation）</strong> ：把一个程序分割成多个独立源文件的能力</p><p><strong>尾置返回类型（trailing return type）</strong> ：在参数列表后面指定的返回类型</p><p><strong>可行函数（viable function）</strong> ：是候选函数的子集。可行函数能匹配本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类型都能转换成相应的形参类型</p><p><strong>() 运算符（ () operator）</strong> ：调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）</p><p>参考：C++ Primer 中文版（第 5 版）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 399. 除法求值</title>
      <link href="/posts/c8de8ad/"/>
      <url>/posts/c8de8ad/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1kaXZpc2lvbi8=">399. Evaluate Division</span></p><p>给你一个变量对数组  <code>equations</code>  和一个实数值数组  <code>values</code>  作为已知条件，其中  <code>equations[i] = [Ai, Bi]</code>  和  <code>values[i]</code>  共同表示等式  <code>Ai / Bi = values[i]</code>  。每个  <code>Ai</code>  或  <code>Bi</code>  是一个表示单个变量的字符串。</p><p>另有一些以数组  <code>queries</code>  表示的问题，其中  <code>queries[j] = [Cj, Dj]</code>  表示第  <code>j</code>  个问题，请你根据已知条件找出  <code>Cj / Dj = ?</code>  的结果作为答案。</p><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用  <code>-1.0</code>  替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用  <code>-1.0</code>  替代这个答案。</p><p><strong>注意：</strong> 输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p><strong>示例 1：</strong></p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]解释：    条件：a / b = 2.0, b / c = 3.0    问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?    结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]输出：[3.75000,0.40000,5.00000,0.20000]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]输出：[0.50000,2.00000,-1.00000,-1.00000]</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= equations.length &lt;= 20</li><li>equations[i].length == 2</li><li>1 &lt;= Ai.length, Bi.length &lt;= 5</li><li>values.length == equations.length</li><li>0.0 &lt; values[i] &lt;= 20.0</li><li>1 &lt;= queries.length &lt;= 20</li><li>queries[i].length == 2</li><li>1 &lt;= Cj.length, Dj.length &lt;= 5</li><li>Ai, Bi, Cj, Dj 由小写英文字母与数字组成</li></ul><h1 id="method-1-广度优先搜索"><a class="anchor" href="#method-1-广度优先搜索">#</a> Method 1: 广度优先搜索</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>可以将整个问题建模成一个图：将变量字符串视为图的顶点，将两个变量的比值视为两顶点之间边的权值，试对任意两点（两个变量）求其路径长度（两个变量的比值）</p><p>首先遍历  <code>equations</code>  数组，将每个不同的变量字符串编号，并通过哈希表建立映射</p><p>然后，建立每个顶点的边集并将其存储到数组  <code>vector&lt;vector&lt;pair&lt;int, double&gt;&gt;&gt; edges</code>  中，其中， <code>edges[i]</code>  表示第 i 个顶点的边集， <code>edges[i][j].first</code>  表示顶点 i 的第 j 个邻居节点， <code>edges[i][j].second</code>  表示顶点 i 到其第 j 个邻居节点的路径长度（两个变量的比值）</p><p>于是，对于任何一个查询，可以从起点出发，通过广度优先搜索的方式，遍历图中的顶点，并更新起点到当前点的路径长度，直到遍历到终点为止</p><blockquote><p>由于每次查询都需要遍历图中的所有顶点，当查询数量较大时，效率就会非常低。因此，可以对图进行预处理，先计算出每个顶点到其他顶点的路径长度，然后再依次处理每一个查询</p></blockquote><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123;    // 给变量字符串编号    int varNum = 0;                  // 变量字符串的数量    unordered_map&lt;string, int&gt; vars; // 以变量字符串为 key ，以其编号为 value    for (int i = 0; i &lt; equations.size(); ++i) &#123;        if (vars.count(equations[i][0]) == 0) &#123;            vars[equations[i][0]] = varNum;            varNum++;        &#125;        if (vars.count(equations[i][1]) == 0) &#123;            vars[equations[i][1]] = varNum;            varNum++;        &#125;    &#125;    // 将变量视为图的顶点，将两个变量的比值视为两顶点之间边的权值    vector&lt;vector&lt;pair&lt;int, double&gt;&gt;&gt; edges(varNum); // 存储每个点的邻居及其对应的权值    for (int i = 0; i &lt; equations.size(); ++i) &#123;        int vertexA = vars[equations[i][0]];        int vertexB = vars[equations[i][1]];        edges[vertexA].push_back(&#123;vertexB, values[i]&#125;);        edges[vertexB].push_back(&#123;vertexA, 1.0 / values[i]&#125;);    &#125;    vector&lt;double&gt; res;    for (const auto&amp; q : queries) &#123; // 遍历每一个问题        // 已知条件中没有出现字符串 q[0] 或 q[1]        if (vars.count(q[0]) == 0 || vars.count(q[1]) == 0) &#123;            res.push_back(-1.0);    // 结果为 -1.0            continue;        &#125;        // q[0] 与 q[1] 均出现在已知条件中        // 采用广度优先搜索        int vertexA = vars[q[0]];   // 起点的编号        int vertexB = vars[q[1]];   // 终点的编号        queue&lt;int&gt; que;             // 队列，存放 待访问的顶点        que.push(vertexA);          // 将起点入队        vector&lt;double&gt; ratios(varNum, -1.0); // 存放起点 vertexA 到各顶点的路径长度        ratios[vertexA] = 1.0;      // vertexA 到其自身的路径长度为 1.0 （自身与自身的比值为 1.0 ）        while (!que.empty() &amp;&amp; ratios[vertexB] &lt; 0) &#123; // 未访问过终点 vertexB            int u = que.front();    // 当前访问的顶点            que.pop();              // 将当前顶点出队            for (const auto [v, val] : edges[u]) &#123; // 处理顶点 u 的每一条边                if (ratios[v] &lt; 0) &#123;// 未访问过顶点 v                     ratios[v] = ratios[u] * val;   // 起点 vertexA 到顶点 v 的路径长度（对应两个变量的比值）                    que.push(v);    // 将顶点 v 入队                &#125;            &#125;        &#125;        // 循环结束时，ratios[vertexB] 即为 vertexA 与 vertexB 对应变量的比值        // 若终点 vertexB 不可达（当队列为空时，仍未访问过 vertexB ），则结果为 -1.0        res.push_back(ratios[vertexB]);    &#125;    return res;&#125;</code></pre><p>其中， <code>ratios[u]</code>  表示 顶点  <code>vertexA</code>  与顶点  <code>u</code>  对应变量的比值， <code>val</code>  表示 顶点  <code>u</code>  与顶点  <code>v</code>  对应变量的比值，因此，顶点  <code>vertex A</code>  与顶点  <code>v</code>  对应变量的比值为  <code>ratios[u] * val</code>  ，即， <code>ratios[v] = ratios[u] * val</code></p><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>L</mi><mo>+</mo><mi>Q</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>L</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M L + Q \cdot (L + M))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 为 数组  <code>equations</code>  的长度（边的数量），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 为字符串的平均长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span></span></span></span> 为数组  <code>queries</code>  的长度（查询的数量）</p><ul><li>构建图时，需要处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 条边，每条边都涉及到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 的字符串比较，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></li><li>处理每次查询时都要进行一次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 的字符串比较、遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> 条边（最坏情况下），时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>L</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((L + M) \cdot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>L</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N L + M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为数组  <code>equations</code>  中的字符串的种类数（图的顶点个数）</p><ul><li>存储每个变量字符串的编号，需要的空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></li><li>存储图中所有的边及其权重，需要的空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></li><li>广度优先搜索过程中，存放待访问的顶点，需要的空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h1 id="method-2-带权并查集"><a class="anchor" href="#method-2-带权并查集">#</a> Method 2: 带权并查集</h1><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1kaXZpc2lvbi9zb2x1dGlvbi9jaHUtZmEtcWl1LXpoaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi04bnhiLw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 621. 任务调度器</title>
      <link href="/posts/1a3c8370/"/>
      <url>/posts/1a3c8370/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXNrLXNjaGVkdWxlci8=">621. Task Scheduler</span></p><p>给你一个用字符数组  <code>tasks</code>  表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数  <code>n</code>  的冷却时间，因此至少有连续  <code>n</code>  个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算 <strong>完成所有任务所需要的最短时间</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2输出：8解释：A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 0输出：6解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;][&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;][&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]...诸如此类</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n = 2输出：16解释：一种可能的解决方案：A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>task.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>tasks[i]</code>  是大写英文字母</li><li><code>n</code>  的取值范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li></ul><h1 id="method-桶思想"><a class="anchor" href="#method-桶思想">#</a> Method: 桶思想</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>使用一个宽为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的矩阵来展示任务执行方案，其中，任务按照逐行遍历的顺序执行，空白格子对应 CPU 的待命状态</p><p>于是，可以将具有最大数量的任务排布在矩阵的第一列，将其余任务依次排布成列。由于冷却时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，上述排列方案可以保证满足题目要求，并且总时间最小</p><ul><li><p cnt="">情况一：冷却时间长、任务种类和数量很少，假设所有任务种类中的最大数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>maxn</mtext></mrow><annotation encoding="application/x-tex">\textrm{maxn}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord textrm">maxn</span></span></span></span></span>（即，矩阵的行数），具有最大数量的任务的种类数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cnt</mtext></mrow><annotation encoding="application/x-tex">\textrm{cnt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord textrm">cnt</span></span></span></span></span>（即，矩阵最后一行的任务数量），则执行任务所需的时间为 (\textrm{maxn} - 1) \times (n + 1) + \textrm</p><ul><li>示例 1： <img data-src="/posts/1a3c8370/Example1.png" class=""></li><li>示例 3： <img data-src="/posts/1a3c8370/Example3.png" class=""></li></ul></li><li><p>情况二：冷却时间短、任务种类或数量很多，可以拓展矩阵的列数，并将任务排布在拓展的列中。此时，每个任务之间都不存在待命时间，因此，执行任务所需的时间就是任务的数量，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mtext>tasks</mtext><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \textrm{tasks} \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord text"><span class="mord textrm">tasks</span></span><span class="mord">∣</span></span></span></span></p><ul><li></li></ul></li></ul><p>因此，需要的最少时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mtext>tasks</mtext><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>maxn</mtext><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mtext>cnt</mtext><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\max{(\vert \textrm{tasks} \vert, (\textrm{maxn} - 1) \times (n + 1) + \textrm{cnt})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">∣</span><span class="mord text"><span class="mord textrm">tasks</span></span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord textrm">maxn</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord text"><span class="mord textrm">cnt</span></span><span class="mclose">)</span></span></span></span></span></p><p>具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXNrLXNjaGVkdWxlci9zb2x1dGlvbi90b25nLXppLWJ5LXBvcG9wb3Av">popopop</span></p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123;    vector&lt;int&gt; rec(26, 0);    for (auto c : tasks) // 记录每种任务的数量        ++rec[c - 'A'];    int maxn = 0;        // 任务的最大数量    int cnt = 0;         // 具有最大数量的任务种类数    for (int num : rec) &#123;        if (num &gt; maxn) &#123;            maxn = num;            cnt = 1;        &#125; else if (num == maxn) &#123;            ++cnt;        &#125;    &#125;    return max((int)tasks.size(), (maxn - 1) * (n + 1) + cnt);&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + \vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组 tasks 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 为数组 tasks 中可能出现的任务种类数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXNrLXNjaGVkdWxlci9zb2x1dGlvbi90b25nLXppLWJ5LXBvcG9wb3Av">popopop</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXNrLXNjaGVkdWxlci9zb2x1dGlvbi9yZW4td3UtZGlhby1kdS1xaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi11cjl3Lw==">leetcode-solution</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 581. 最短无序连续子数组</title>
      <link href="/posts/ba321226/"/>
      <url>/posts/ba321226/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaG9ydGVzdC11bnNvcnRlZC1jb250aW51b3VzLXN1YmFycmF5Lw==">581. Shortest Unsorted Continuous Subarray</span></p><p>给你一个整数数组  <code>nums</code>  ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,4]输出：0</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：你可以设计一个时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的解决方案吗？</p><h1 id="method-寻找左右边界"><a class="anchor" href="#method-寻找左右边界">#</a> Method: 寻找左右边界</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>从左往右遍历，找到比左边最大值还小的最右侧下标，即为无序子数组的右边界</p><p>从右往左遍历，找到比右边最小值还大的最左侧下标，即为无序子树组的左边界</p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;    int right = 0;      // 无序子数组的右边界    int maxx = INT_MIN; // 左边最大值    for (int i = 0; i &lt; nums.size(); ++i) &#123; // 寻找小于左边最大值的最右侧下标        if (nums[i] &lt; maxx) right = i;        else maxx = nums[i];    &#125;    int left = 0;       // 无序子数组的左边界    int minx = INT_MAX; // 右边最小值    for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; // 寻找大于右边最大值的最左侧下标        if (nums[i] &gt; minx) left = i;        else minx = nums[i];    &#125;    if (left == right) return 0;  // 数组 nums 有序，返回 0    else return right - left + 1; // 最短无序子数组的长度&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaG9ydGVzdC11bnNvcnRlZC1jb250aW51b3VzLXN1YmFycmF5L3NvbHV0aW9uL3p1aS1kdWFuLXd1LXh1LWxpYW4teHUtemktc2h1LXp1LWJ5LWxlZXQteWhsZi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 739. 每日温度</title>
      <link href="/posts/f97737f4/"/>
      <url>/posts/f97737f4/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kYWlseS10ZW1wZXJhdHVyZXMv">739. Daily Temperatures</span></p><p>给定一个整数数组  <code>temperatures</code>  ，表示每天的温度，返回一个数组  <code>answer</code>  ，其中  <code>answer[i]</code>  是指对于第  <code>i</code>  天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用  <code>0</code>  来代替。</p><p><strong>示例 1：</strong></p><pre><code>输入：temperatures = [73,74,75,71,69,72,76,73]输出：[1,1,4,2,1,1,0,0]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：temperatures = [30,40,50,60]输出：[1,1,1,0]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：temperatures = [30,60,90]输出：[1,1,0]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>temperatures.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">30 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>temperatures[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-单调栈实现一"><a class="anchor" href="#method-单调栈实现一">#</a> Method: 单调栈（实现一）</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>维护一个存储温度数组下标的单调栈  <code>stack&lt;int&gt; stk</code>  ：从栈底到栈顶，下标对应的温度依次递减</p><p>如果一个下标在单调栈里，则表示其尚未找到下一次温度更高的下标。换而言之，<strong>如果下标从单调栈内出栈，则说明其找到了下一个温度更高的下标</strong></p><p>从左往右遍历温度数组，对于温度数组中的每个元素 temperatures [i] ：</p><ul><li>如果栈为空，则直接将下标 i 入栈</li><li>如果栈不为空，则将当前温度 temperatures [i] 与栈顶元素 stk.top () 对应温度 temperatures [stk.top ()] 进行比较，如果 temperatures [i] 大于 temperatures [stk.top ()] ，则 temperatures [i] 就是第一个大于 temperatures [stk.top ()] 的温度，因此将 answer [stk.top ()] 赋为 i - stk.top () ，并将 stk.top () 出栈。重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 入栈</li></ul><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">// 从左往右遍历温度数组，单调栈内元素递增（从栈顶到栈底）vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;    int n = temperatures.size();    vector&lt;int&gt; answer(n, 0);    stack&lt;int&gt; stk;    for (int i = 0; i &lt; n; ++i) &#123;        while (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()]) &#123;            answer[stk.top()] = i - stk.top(); // i 是温度高于 stk.top() 的第一天            stk.pop();        &#125;        stk.push(i);    &#125;    return answer;&#125;</code></pre><h1 id="method-单调栈实现二"><a class="anchor" href="#method-单调栈实现二">#</a> Method: 单调栈（实现二）</h1><h2 id="算法思路-2"><a class="anchor" href="#算法思路-2">#</a> 算法思路</h2><p>维护一个存储温度数组下标的单调栈  <code>stack&lt;int&gt; stk</code>  ：从栈底到栈顶，下标对应的温度依次递减</p><p>如果一个下标可以入栈，其入栈前的栈顶元素 就是 第一个更高温度所对应的下标</p><p>从右往左遍历温度数组，对于温度数组中的每个元素 temperatures [i] ：</p><ul><li>如果栈为空，则直接将下标 i 入栈</li><li>如果栈不为空，则将当前温度 temperatures [i] 与栈顶元素 stk.top () 对应温度 temperatures [stk.top ()] 进行比较，如果 temperatures [i] 大于等于 temperatures [stk.top ()] ，则将 stk.top () 出栈。重复上述操作直到栈为空或者栈顶元素对应的温度小于当前温度，此时，栈顶元素对应的温度就是 第一个大于 temperatures [i] 的温度，因此，将 answer [i] 赋为 stk.top () - i ，然后将 i 入栈</li></ul><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">// 从右往左遍历温度数组，单调栈内元素递增（从栈顶到栈底）vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;    int n = temperatures.size();    vector&lt;int&gt; answer(n, 0);    stack&lt;int&gt; stk;    for (int i = n - 1; i &gt;= 0; --i) &#123;        while (!stk.empty() &amp;&amp; temperatures[i] &gt;= temperatures[stk.top()])            stk.pop();        if (stk.empty())            answer[i] = 0;        else            answer[i] = stk.top() - i; // stk.top 是温度高于 i 的第一天        stk.push(i);    &#125;    return answer;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 temperatures 的长度，数组的每个下标至多入栈、出栈一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 560. 和为 K 的子数组</title>
      <link href="/posts/5c7b75ba/"/>
      <url>/posts/5c7b75ba/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsv">560. Subarray Sum Equals K</span></p><p>给你一个整数数组  <code>nums</code>  和一个整数  <code>k</code>  ，请你统计并返回 该数组中和为  <code>k</code>  的连续子数组的个数 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,1], k = 2输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3], k = 3输出：2</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 * 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^7 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-前缀和"><a class="anchor" href="#method-前缀和">#</a> Method: 前缀和</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>定义一个前缀和数组 pre ，其中，pre [i] 为数组 nums 中第 0 位至第 i 位所有数的和</p><p>建立一个哈希表  <code>unordered_map&lt;int, int&gt; prefix</code>  ，将前缀和的值 pre [i] 作为哈希表的 key，将值为 pre [i] 的前缀和的出现次数作为哈希表的 value</p><p>于是，以 i 结尾的、和为 k 的连续子数组的个数 就是 值为 pre [i] - k 的前缀和的出现次数，即， <code>prefix[pre[i] - k]</code></p><p>遍历 i 并且累加  <code>prefix[pre[i] - k]</code>  ，即可得到和为 k 的连续子数组的总个数</p><blockquote><p>可用一个变量代替前缀和数组</p></blockquote><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;    unordered_map&lt;int, int&gt; prefix; // 记录前缀和的出现次数    prefix[0] = 1; // 初始化（值为 0 的前缀和出现一次）    int sum = 0;   // 前缀和    int res = 0;   // 和为 k 的连续子数组    for (auto num : nums) &#123;        sum += num;        res += prefix[sum - k];        ++prefix[sum];  // 在更新 res 之后才更新 prefix    &#125;    return res;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，在最坏情况下，可能有 n 个不同的哈希表键值，因此需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 543. 二叉树的直径</title>
      <link href="/posts/6b7b0cda/"/>
      <url>/posts/6b7b0cda/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaWFtZXRlci1vZi1iaW5hcnktdHJlZS8=">543. Diameter of Binary Tree</span></p><p>给定一棵二叉树，你需要计算它的直径长度。</p><p>一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>注意：</strong> 两结点之间的路径长度是以它们之间边的数目表示</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/6b7b0cda/Example.jpg" class=""></p><pre><code>输入：root = [1,2,3,4,5]输出：3解释：路径 [4,2,1,3] 或者 [5,2,1,3]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,2]输出：1</code></pre><p><strong>提示：</strong></p><ul><li>节点数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,  10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>定义一个递归函数  <code>int helper(TreeNode* root)</code>  ，用于计算 以 root 为起点、向下延伸的路径的最大长度（即，最大边数，因为两节点之间的路径长度是以它们之间边的数目表示的），即，以 root 为根的二叉树的最大深度减 1</p><p>任意节点 node 都有一条从其左子树到右子树的最长路径（记作 route ），其路径长度（边数）为左子树最大深度 + 右子树最大深度 - 2 ，即， <code>helper(node-&gt;left)</code>  +  <code>helper(node-&gt;right)</code></p><p>因此，遍历二叉树每一个节点并比较其对应的路径 route 的长度，即可得到整个二叉树中最长路径的长度</p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int ans = 0; // 路径的最大长度int helper(TreeNode* root) &#123;    if (root == nullptr) return 0;    int leftEdges = helper(root-&gt;left);     // 以左子节点为起点向下延伸的最长路径的长度（边数）    int rightEdges = helper(root-&gt;right);   // 以右子节点为起点向下延伸的最长路径的长度（边数）    ans = max(ans, leftEdges + rightEdges); // 从左子树深度最大的节点到右子树深度最大的节点    return max(leftEdges, rightEdges) + 1;  // 以 root 为起点向下延伸的最长路径的长度（边数）&#125;int diameterOfBinaryTree(TreeNode* root) &#123;    helper(root);    return ans;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数。每个节点均遍历一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 461. 汉明距离</title>
      <link href="/posts/bbdfe11c/"/>
      <url>/posts/bbdfe11c/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9oYW1taW5nLWRpc3RhbmNlLw==">461. Hamming Distance</span></p><p>两个整数之间的 <strong>汉明距离</strong> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数  <code>x</code>  和  <code>y</code> ，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><pre><code>输入：x = 1, y = 4输出：2解释：1   (0 0 0 1)4   (0 1 0 0)    ↑   ↑上面的箭头指出了对应二进制位不同的位置</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：x = 3, y = 1输出：1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>x</code> ,  <code>y</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="method-1-模拟"><a class="anchor" href="#method-1-模拟">#</a> Method 1: 模拟</h1><p>算法思路：</p><p>依次比较 x 与 y 的每一位</p><p>具体地，可以通过 x &amp; 1（或者 x % 2 ）来获取 x 的最低位，判断其是否等于 y 的最低位，然后将 x 与 y 分别右移一位。重复以上过程，直到 x 与 y 均为 0</p><p>代码实现：</p><pre><code class="language-cpp">int hammingDistance(int x, int y) &#123;    int ans = 0;    while (x != 0 || y != 0) &#123;        if ((x &amp; 1) != (y &amp; 1)) ++ans;        x = x &gt;&gt; 1;        y = y &gt;&gt; 1;    &#125;    return ans;&#125;</code></pre><h1 id="method-2-异或"><a class="anchor" href="#method-2-异或">#</a> Method 2: 异或</h1><p>算法思路：</p><p>先计算 x 与 y 的按位异或（记结果为 z ），然后统计 z 的二进制表示中的 1 的个数</p><p>其中，可使用移位操作实现位计数功能</p><p>代码实现：</p><pre><code class="language-cpp">int hammingDistance(int x, int y) &#123;    int z = x ^ y;    int ans = 0;    while (z) &#123;        if (z &amp; 1) ++ans;        z = z &gt;&gt; 1;    &#125;    return ans;&#125;</code></pre><h1 id="method-3-brian-kernighan-算法"><a class="anchor" href="#method-3-brian-kernighan-算法">#</a> Method 3: Brian Kernighan 算法</h1><p>算法思路：</p><p>可利用 Brian Kernighan 算法求 z 的二进制表示中 1 的个数：令 z = z &amp; (z - 1) ，可将 z 的二进制表示的最后一个 1 变成 0</p><p>因此，对 z 重复该操作，直到 z 变成 0，操作次数即为 z 的二进制表示中的 1 的数目</p><p>可参考 <a href="https://jiankychen.github.io/posts/38d980c0">LeetCode 338. 比特位计数</a></p><p>代码实现：</p><pre><code class="language-cpp">int hammingDistance(int x, int y) &#123;    int z = x ^ y;    int ans = 0;    while (z) &#123;        z = z &amp; (z - 1);        ++ans;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{C})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 是元素的数据范围（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\log{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span> 为数 x 与 y 的二进制表示的最大长度），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>C</mi><mo>=</mo><mi>log</mi><mo>⁡</mo><msup><mn>2</mn><mn>31</mn></msup><mo>=</mo><mn>31</mn></mrow><annotation encoding="application/x-tex">\log{C} = \log{2^{31}} = 31</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">1</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9oYW1taW5nLWRpc3RhbmNlL3NvbHV0aW9uL3lpLW1pbmctanUtY2hpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLXUxdzcv">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 448. 找到所有数组中消失的数字</title>
      <link href="/posts/8ae12f56/"/>
      <url>/posts/8ae12f56/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1udW1iZXJzLWRpc2FwcGVhcmVkLWluLWFuLWFycmF5Lw==">448. Find All Numbers Disappeared in an Array</span></p><p>给你一个含  <code>n</code>  个整数的数组  <code>nums</code>  ，其中  <code>nums[i]</code>  在区间  <code>[1, n]</code>  内。请你找出所有在  <code>[1, n]</code>  范围内但没有出现在  <code>nums</code>  中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,3,2,7,8,2,3,1]输出：[5,6]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,1]输出：[2]</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code></li></ul><p><strong>进阶</strong>：你能在不使用额外空间且时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的情况下解决这个问题吗？你可以假定返回的数组不算在额外空间内。</p><h1 id="method-原地交换"><a class="anchor" href="#method-原地交换">#</a> Method: 原地交换</h1><p><strong>基本思路：</strong></p><p>记数组长度为 n，由于数组的索引为 0 至 n - 1、数组元素的取值为 1 至 n，可考虑将数组重新排列，使得数字 x 位于索引为 x - 1 的位置（即，x 应等于 nums [x - 1] ）</p><p>遍历重新排列的数组，若位置 x - 1 上的元素不等于 x ，则说明 x 缺失</p><p><strong>算法流程：</strong></p><p>遍历数组 nums ，实现数组的重新排列：</p><ul><li><p>记当前遍历的位置索引为 i</p></li><li><p>若 nums [i] 等于 i + 1，说明 nums [i] 处于正确位置，执行 ++i 以处理下一个元素</p></li><li><p>若 nums [i] 不等于 i + 1，则需将 nums [i] 放到正确位置，即，nums [i] - 1，因此，执行 swap (nums [i], nums [nums [i] - 1]) ，交换位置 i 与位置 nums [i] - 1 上的元素</p><ul><li>注意，当 nums [i] 等于 nums [nums [i] - 1] 时，不必交换这两个元素</li><li>由于交换后的 nums [i]（即，交换前的 nums [nums [i] - 1] ）可能不在正确位置，需继续将 nums [i] 交换至正确位置</li></ul></li></ul><p>再次遍历数组 nums ，找出缺失的数字：</p><ul><li>记当前遍历的位置索引为 i</li><li>若 nums [i] 不等于 i + 1，则说明数字 i + 1 缺失，将其添加到答案数组</li></ul><p><strong>代码实现：</strong></p><pre><code class="language-cpp">vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;    for (int i = 0; i &lt; nums.size(); ++i) &#123;        while (nums[i] != i + 1 &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123;            swap(nums[i], nums[nums[i] - 1]);        &#125;    &#125;        vector&lt;int&gt; ans;    for (int i = 0; i &lt; nums.size(); ++i) &#123;        if (nums[i] != i + 1)            ans.push_back(i + 1);    &#125;        return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组 nums 的长度。每次交换都可以将一个数字放到正确位置，因此，一共执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 次交换</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑答案数组所需空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 438. 找到字符串中所有字母异位词</title>
      <link href="/posts/b97e9d80/"/>
      <url>/posts/b97e9d80/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy8=">438. Find All Anagrams in a String</span></p><p>给定两个字符串  <code>s</code>  和  <code>p</code>  ，找到  <code>s</code>  中所有  <code>p</code>  的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出：[0,6]解释：    起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。    起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;abab&quot;, p = &quot;ab&quot;输出：[0,1,2]解释：    起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。    起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。    起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code> ,  <code>p.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  和  <code>p</code>  仅包含小写字母</li></ul><h1 id="method-滑动窗口法"><a class="anchor" href="#method-滑动窗口法">#</a> Method: 滑动窗口法</h1><p>算法思路：</p><p>可以在字符串 s 中构造一个与字符串 p 长度相同的滑动窗口，并在滑动窗口过程中维护每种字母的数量。当每种字母在窗口中的数量等于其在字符串 p 中的数量时，窗口即为字符串 p 的异位词</p><p>特别地，可做以下考虑：</p><ul><li><p>用哈希表来统计滑动窗口与字符串 p 中每种字母的数量差。当某个字母对应的数量差为 0 时，字母在窗口中的数量等于其在字符串 p 中的数量</p></li><li><p>用变量 valid 来记录数量差为 0 的字母的种类数。当 valid 等于哈希表的长度时，窗口就是字符串 p 的字母异位词</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; findAnagrams(string s, string p) &#123;    vector&lt;int&gt; ans; // 结果数组    int sLen = s.size();    int pLen = p.size();    if (sLen &lt; pLen) return ans;    unordered_map&lt;char, int&gt; record;    for (auto c : p)        ++record[c]; // record[c] 表示需添加到窗口内的字符 c 的数量    int left = 0;    // 滑动窗口的左边界    int right = 0;   // 滑动窗口的右边界    int valid = 0;   // 窗口内已满足数量要求的字符种类数    while (right &lt; sLen) &#123;        char c = s[right];        // 更新窗口的相关数据        if (record.count(c)) &#123;            // 仅当 p 字符串包含的字符 c 时更新 record 和 valid            --record[c];                  // c 添加到窗口内，所需字符 c 的数量应减 1            if (record[c] == 0)           // 字符 c 的数量满足要求，有效字符数加 1                ++valid;        &#125;        // 判断是否需要收缩窗口        while (right - left + 1 &gt; pLen) &#123; // 窗口长度大于 pLen ，应收缩窗口            char d = s[left];            // 更新窗口的相关数据            if (record.count(d)) &#123;        // 仅当 p 字符串包含的字符 d 时更新 record 和 valid                if (record[d] == 0)       // 目前字符 d 满足数量要求，但其将被移出，故有效字符数减 1                    --valid;                ++record[d];              // d 从窗口内移出，所需字符 d 的数量应加 1            &#125;            ++left;                       // 窗口的左边界向右移动        &#125;        // 窗口符合条件时，将起始索引加入目标数组        if (right - left + 1 == pLen) &#123;   // 窗口长度等于字符串 p 长度            if (valid == record.size())   // 所有字符均满足数量要求，将索引添加到目标数组                ans.push_back(left);        &#125;        ++right;                          // 窗口的右边界向右移动    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串 s 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 为字符串 p 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 为字符串 p 中的字符种类数</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy9zb2x1dGlvbi9odWEtZG9uZy1jaHVhbmcta291LXRvbmcteW9uZy1zaS14aWFuZy1qaWUtanVlLXppLS8=">labuladong</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy9zb2x1dGlvbi96aGFvLWRhby16aS1mdS1jaHVhbi16aG9uZy1zdW8teW91LXppLW11LXh6aW4v">leetcode-solution</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 437. 路径总和 III</title>
      <link href="/posts/616e6c65/"/>
      <url>/posts/616e6c65/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkv">437. Path Sum III</span></p><p>给定一个二叉树的根节点  <code>root</code>  ，和一个整数  <code>targetSum</code>  ，求该二叉树里节点值之和等于  <code>targetSum</code>  的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/616e6c65/Example.jpg" class=""></p><pre><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8输出：3解释：和等于 8 的路径有 3 条，如图所示</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：3</code></pre><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 [0, 1000]</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>targetSum</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-1-深度优先搜索"><a class="anchor" href="#method-1-深度优先搜索">#</a> Method 1: 深度优先搜索</h1><p>算法思路：</p><p>访问每一个节点 node，检测以 node 为起始节点且和为 targetSum 的路径数目，即：</p><ul><li>定义 rootSum (root, sum) 表示以节点 root 为起点且满足路径总和为 val 的路径数目</li><li>递归遍历二叉树的每个节点 root，对每个节点 root 求 rootSum (root, sum)，累加每个节点所求值</li></ul><p>其中，rootSum (root, sum) 也是通过递归实现：</p><ul><li>假设当前节点 root 的值为 val，初始化返回值 res 为 0</li><li>检查 val 是否等于 sum，若等于，则已经存在一条路径（节点 root 单独作为一条路径），即，res = res + 1</li><li>递归到左子树，计算以 root-&gt;left 为起点且满足路径和为 sum - val 的路径数，记作 leftRes</li><li>递归到右子树，计算以 root-&gt;left 为起点且满足路径和为 sum - val 的路径数，记作 rightRes</li><li>计算以 root 为起点且满足路径和为 sum 的路径总数，即：res = res + leftRes + rightRes</li></ul><p>代码实现：</p><pre><code class="language-cpp">// 以 root 为起点的、和为 sum 的路径数int rootSum(TreeNode* root, long sum) &#123; // 注意这里是 long sum （因为有特殊样例）    if (root == nullptr) return 0;    int res = 0;    if (root-&gt;val == sum) ++res;    res += rootSum(root-&gt;left, sum - root-&gt;val);    res += rootSum(root-&gt;right, sum - root-&gt;val);    return res;&#125;// 在以 root 为根节点的二叉树中，计算和为 sum 的路径数int pathSum(TreeNode* root, int sum) &#123;    if (root == nullptr) return 0;    int ans = rootSum(root, sum);          // 以 root 为起点的、和为 sum 的路径数    int left = pathSum(root-&gt;left, sum);   // 递归到左子树，计算和为 sum 的路径数    int right = pathSum(root-&gt;right, sum); // 递归到右子树，计算和为 sum 的路径数    ans += left + right;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>遍历二叉树的每个节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每个节点都要计算以该节点为起点的路径数目，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p><h1 id="method-2-前缀和"><a class="anchor" href="#method-2-前缀和">#</a> Method 2: 前缀和</h1><p>算法思路：</p><p>定义节点的前缀和：从根节点到当前节点的路径上所有节点的和（不包含当前节点），并利用哈希表  <code>unordered_map&lt;long long, int&gt; prefix</code>  记录每一个前缀和的出现次数</p><p>定义递归函数 helper () ：在以 node 为根节点的二叉树中，计算 “ 以每个节点为路径终点、并且满足路径和为 targetSum” 的路径数，返回路径数总和</p><p>递归函数的参数：</p><ul><li><code>TreeNode* node</code>  ：当前节点</li><li><code>int targetSum</code>  ：目标和</li><li><code>long long curSum</code>  ：根节点到当前节点路径上所有节点之和（不包含当前节点）</li><li>返回值：路径和为 targetSum 的路径条数</li></ul><p>递归终止条件：node 为空节点，当前递归结束，返回 0</p><p>单层递归的逻辑：</p><ul><li>将当前节点值计入路径和 curSum</li><li>计算以 node 为路径终点且满足路径和为 targetSum 的路径数：prefix [curSum - targetSum]<ul><li>若存在节点 p<sub>i</sub> 使得根节点 root 到 p<sub>i</sub> 的路径和为 curSum - targetSum ，则节点 p<sub>i+1</sub> 到 node 的路径和一定为 targetSum</li><li>换言之，如果存在值为 curSum - targetSum 的前缀和，则一定存在 以 node 为终点且路径和为 targetSum 的路径，并且，前缀和的出现次数即为路径条数</li></ul></li><li>将当前路径和 curSum 作为前缀和计入哈希表（以 curSum 为 key ，将对应的 value 加 1），以便递归到子树时使用</li><li>递归到左子树，计算以 node-&gt;left 为路径终点且满足路径和为 targetSum 的路径数</li><li>递归到左子树，计算以 node-&gt;right 为路径终点且满足路径和为 targetSum 的路径数</li><li>回溯：将当前路径和 curSum 从哈希表中删除（以 curSum 为 key ，将对应的 value 减 1）</li><li>计算路径总数，并返回结果</li></ul><p>代码实现：</p><pre><code class="language-cpp">unordered_map&lt;long long, int&gt; prefix;int helper(TreeNode* node, int targetSum, long long curSum) &#123;    if (node == nullptr) return 0;    int ans = 0;    curSum += node-&gt;val;    ans += prefix[curSum - targetSum];    ++prefix[curSum];    ans += helper(node-&gt;left, targetSum, curSum);    ans += helper(node-&gt;right, targetSum, curSum);    --prefix[curSum]; // 回溯    return ans;&#125;int pathSum(TreeNode* root, int targetSum) &#123;    prefix[0] = 1;    return helper(root, targetSum, 0);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数。利用前缀和只需遍历一次二叉树</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间以及哈希表所需储存空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkvc29sdXRpb24vbHUtamluZy16b25nLWhlLWlpaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi16OXRkLw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 394. 字符串解码</title>
      <link href="/posts/767d00ca/"/>
      <url>/posts/767d00ca/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nLw==">394. Decode String</span></p><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为:  <code>k[encoded_string]</code> ，表示其中方括号内部的  <code>encoded_string</code>  正好重复  <code>k</code>  次。注意  <code>k</code>  保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数  <code>k</code>  ，例如不会出现像  <code>3a</code>  或  <code>2[4]</code>  的输入。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;3[a]2[bc]&quot;输出：&quot;aaabcbc&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;3[a2[c]]&quot;输出：&quot;accaccacc&quot;</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;输出：&quot;abcabccdcdcdef&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 30</code></li><li><code>s</code>  由小写英文字母、数字和方括号  <code>'[]'</code>  组成</li><li><code>s</code>  保证是一个 <strong>有效</strong> 的输入</li><li><code>s</code>  中所有整数的取值范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>300</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 300]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li></ul><h1 id="method-1-栈"><a class="anchor" href="#method-1-栈">#</a> Method 1: 栈</h1><p>算法思路：</p><p>利用一个栈来维护字符串中的字母、数字和括号</p><p>遍历字符串 s ：</p><ul><li>如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈</li><li>如果当前的字符为字母或者左括号，直接进栈</li><li>如果当前的字符为右括号，开始出栈，一直到左括号出栈，将出栈序列拼接成一个字符串；然后再取出栈顶的数字（即，字符串重复出现的次数），根据这个数字和字符串构造新字符串并进栈</li></ul><blockquote><p>为便于拼接目标字符串，可以用 vector 容器来模拟栈操作，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9uL3ppLWZ1LWNodWFuLWppZS1tYS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">string decodeString(string s) &#123;    string res = &quot;&quot;;    stack&lt;string&gt; stk;    int ptr = 0;    while (ptr &lt; s.size()) &#123;        char cur = s[ptr];        if (isdigit(cur)) &#123; // 将数字（重复次数）入栈            string digit = &quot;&quot;;            while (isdigit(s[ptr])) &#123; // 解析数字                digit.push_back(s[ptr]);                ++ptr;            &#125;            stk.push(digit);        &#125; else if (isalpha(cur) || cur == '[') &#123; // 将字母和左括号入栈            stk.push(string(1, cur));            ++ptr;        &#125; else &#123; // 遇到右括号，将与之匹配的左括号及括号中间的字符出栈            string tmp = &quot;&quot;;            while (stk.top() != &quot;[&quot;) &#123; // 解析当前括号对所包围的子串                tmp += stk.top();                stk.pop();            &#125;            stk.pop(); // 出栈：左括号            int repNum = stoi(stk.top()); // 子串的重复次数            stk.pop(); // 出栈：重复次数            string str = &quot;&quot;;            while (repNum--) // 根据重复次数 repNum 和子串 tmp 解码字符串（例如，由 3 和 a 得到 aaa）                str += tmp;            if (stk.empty()) &#123; // 无嵌套情形，可直接将 str 反转然后添加到目标字符串                reverse(str.begin(), str.end());                res += str;            &#125; else &#123; // 可能存在嵌套（例如 &quot;3[a2[c]]&quot;），或者前面有有效字符（例如 &quot;2[abc]ef3[cd]&quot;）                stk.push(str);            &#125;            ++ptr;        &#125;    &#125;    if (!stk.empty()) &#123; // 连接栈内剩余元素，将其反转后添加到目标字符串        string tmp = &quot;&quot;;        while (!stk.empty()) &#123;            tmp += stk.top();            stk.pop();        &#125;        reverse(tmp.begin(), tmp.end());        res += tmp;    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert + \vert S \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert s \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span> 是原字符串 s 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert S \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span> 是解码后得出的字符串 S 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-递归"><a class="anchor" href="#method-2-递归">#</a> Method 2: 递归</h1><p>算法思路：</p><p>定义递归函数，从左向右解析字符串 s ：</p><ul><li>如果当前位置为数字位，后面一定包含一个用方括号表示的字符串，此时可采取以下操作：<ul><li>先解析出一个数字 repNum</li><li>然后解析左括号</li><li>递归解析后面的内容，遇到对应的右括号就返回，得到字母序列 str</li><li>根据字母序列 str 以及重复的次数 repNum 构造新的字符串</li></ul></li><li>如果当前位置是字母位，可直接解析当前字母，然后递归解析后面内容</li></ul><p>代码实现：</p><pre><code class="language-cpp">int getDigits(string&amp; s, int&amp; ptr) &#123; // 从 ptr 位开始提取数字    int num = 0;    while (ptr &lt; s.size() &amp;&amp; isdigit(s[ptr])) &#123;        num = num * 10 + (s[ptr] - '0');        ++ptr;    &#125;    return num;&#125;string getString(string&amp; s, int&amp; ptr) &#123;    if (ptr == s.size() || s[ptr] == ']') return &quot;&quot;;    string res = &quot;&quot;;    if (isdigit(s[ptr])) &#123;        int repNum = getDigits(s, ptr); // 解析 Digits        ++ptr;                          // 过滤左括号        string str = getString(s, ptr); // 解析 String        ++ptr;                          // 过滤右括号        while (repNum--) res += str;    // 构造目标字符串    &#125; else if (isalpha(s[ptr])) &#123;        res = string(1, s[ptr]);        // 解析 Char        ++ptr;    &#125;    return res + getString(s, ptr);&#125;string decodeString(string s) &#123;    int ptr = 0;    string ans = getString(s, ptr);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert + \vert S \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert s \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span> 是原字符串 s 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert S \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span> 是解码后得出的字符串 S 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，只考虑递归使用的栈空间，不考虑答案所占空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9uL3ppLWZ1LWNodWFuLWppZS1tYS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 语句</title>
      <link href="/posts/ffed1eef/"/>
      <url>/posts/ffed1eef/</url>
      
        <content type="html"><![CDATA[<h1 id="语句与语句作用域"><a class="anchor" href="#语句与语句作用域">#</a> 语句与语句作用域</h1><h2 id="简单语句"><a class="anchor" href="#简单语句">#</a> 简单语句</h2><p>表达式语句（expression statement）：执行表达式并丢弃掉求值结果</p><p>空语句（null statement）：空语句中只含有一个单独的分号</p><p>例如：</p><pre><code class="language-cpp">// 重复读入数据直至到达文件末尾或某次输入的值等于 soughtwhile (cin &gt;&gt; s &amp;&amp; s != sought)    ; // 空语句</code></pre><blockquote><p>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的</p></blockquote><p><strong>别漏写分号，也别多写分号</strong>：</p><pre><code class="language-cpp">ival = v1 + v2;; // 正确：第二个分号表示一条多余的空语句while (iter != svec.end()) ; // while 循环体是那条空语句（无休止循环）    ++iter;                  // 递增运算不输于循环的一部分</code></pre><p><strong>复合语句</strong>（compound statement）是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作 <strong>块</strong>（block）</p><p>一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问</p><blockquote><p><strong>块不以分号作为结束</strong></p></blockquote><pre><code class="language-cpp">while (val &lt;= 10) &#123;    sum += val;    ++val;&#125;</code></pre><p>空块：是指内部没有任何语句的一对花括号。空块的作用等价于空语句</p><pre><code class="language-cpp">while (cin &gt;&gt; s &amp;&amp; s != sought)    &#123; &#125; // 空块</code></pre><h2 id="语句作用域"><a class="anchor" href="#语句作用域">#</a> 语句作用域</h2><p>可以在 if 、switch 、while 和 for 语句的控制结构内定义变量。但是需要注意，定义在控制结构中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了</p><pre><code class="language-cpp">while (int i = get_num()) // 每次迭代时创建并初始化 i    cout &lt;&lt; i &lt;&lt; endl;i = 0;  // 错误：在循环外部无法访问 i</code></pre><p>如果其他代码也需要访问控制变量，则变量必须定义在语句的外部</p><pre><code class="language-cpp">// 寻找第一个负值元素auto beg = v.begin(); // 注意要初始化while (beg != v.end() &amp;&amp; *beg &gt;= 0)    ++beg;if (beg == v.end())    // 此时我们知道 v 中的所有元素都大于等于 0</code></pre><h1 id="条件语句"><a class="anchor" href="#条件语句">#</a> 条件语句</h1><p>C++ 语言提供了两种按条件执行的语句</p><ul><li>if 语句：根据条件决定控制流</li><li>switch 语句：计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条</li></ul><h2 id="if-语句"><a class="anchor" href="#if-语句">#</a> if 语句</h2><p>简单 if 语句的语法形式：</p><pre><code>if (condition)    statement</code></pre><p>if else 语句的形式：</p><pre><code>if (condition)    statementelse    statement2</code></pre><p>如果 condition 为真，执行 statement 。当 statement 执行完成后，程序继续执行 if 语句后面的其他语句</p><p>如果 condition 为假，跳过 statement 。对于简单 if 语句来说，程序继续执行 if 语句后面的其他语句；对于 if else 语句来说，执行 statement2</p><p>注意：在这两个版本的 if 语句中，condition 都必须用圆括号包围起来</p><blockquote><p>condition 可以是一个表达式，也可以是一个初始化了的变量声明。不管是表达式还是变量，其类型都必须能转换成布尔类型</p></blockquote><h3 id="嵌套-if-语句"><a class="anchor" href="#嵌套-if-语句">#</a> 嵌套 if 语句</h3><p>例如：把数字形式表示的成绩转换成字母形式，并在合格的成绩后面添加一个加号或减号（如果成绩的末位是 8 或者 9 ，添加一个加号；如果末位是 0 、1 或 2 ，添加一个减号）</p><pre><code class="language-cpp">vector&lt;string&gt; scores = &#123;&quot;F&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A++&quot;&#125;;string lettergrade;if (grade &lt; 60) // 成绩不合格，对应的字母是 F    lettergrade = scores[0];else &#123;    lettergrade = scores[(grade - 50)/10]; // 获得字母形式的成绩    if (grade != 100)  // 只要不是 A++（100 分），就考虑添加加号或者减号        if (grade % 10 &gt; 7)            lettergrade += '+';  // 末尾是 8 或者 9 的成绩添加一个加号        else if (grade % 10 &lt; 3)            lettergrade += '-';  // 末尾是 0 、1 或者 2 的成绩添加一个减号&#125;</code></pre><blockquote><p>注意使用花括号</p></blockquote><h3 id="悬垂-else"><a class="anchor" href="#悬垂-else">#</a> 悬垂 else</h3><p>当一个 if 语句嵌套在另一个 if 语句内部时，很可能 if 分支会多于 else 分支。此时，我们怎么知道某个给定的 else 是和哪个 if 匹配呢？</p><p>这个问题通常称作 <strong>悬垂 else</strong>（dangling else）</p><p>C++ 规定 else 与离它最近的尚未匹配的 if 匹配</p><blockquote><p>In C++, the ambiguity is resolved by specifying that each  <code>else</code>  is matched with the closest preceding unmatched  <code>if</code> .</p></blockquote><h3 id="使用花括号控制执行路径"><a class="anchor" href="#使用花括号控制执行路径">#</a> 使用花括号控制执行路径</h3><p>要想使 else 分支和外层的 if 语句匹配起来，可以在内层 if 语句的两端加上花括号，使其成为一个块</p><pre><code class="language-cpp">// 末位是 8 或者 9 的成绩添加一个加号；如果末位是 0 、1 或 2 的成绩添加一个减号if (grade % 10 &gt;= 3) &#123;    if (grade % 10 &gt; 7)        lettergrade += '+';  // 末尾是 8 或者 9 的成绩添加一个加号&#125; else                  // 花括号强迫 else 与外层 if 匹配    lettergrade += '-'; // 末位是 0 、1 或 2 的成绩添加一个减号</code></pre><h2 id="switch-语句"><a class="anchor" href="#switch-语句">#</a> switch 语句</h2><p>switch 语句（switch statement）提供了一条便利的途径使得我们能够在若干固定选项中做出选择</p><p>例如，利用 switch 语句统计五个元音字母在文本中出现的次数</p><pre><code class="language-cpp">// 为每个元音字母初始化其计数值unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;char ch;while (cin &gt;&gt; ch) &#123;    // 如果 ch 是元音字母，将其对应的计数值加 1    switch (ch) &#123;        case 'a':            ++aCnt;            break;        case 'e':            ++eCnt;            break;        case 'i':            ++iCnt;            break;        case 'o':            ++oCnt;            break;        case 'u':            ++uCnt;            break;    &#125;&#125;// 打印结果cout &lt;&lt; &quot;Number of vowel a: \t&quot; &lt;&lt; aCnt &lt;&lt; '\n'     &lt;&lt; &quot;Number of vowel e: \t&quot; &lt;&lt; eCnt &lt;&lt; '\n'     &lt;&lt; &quot;Number of vowel i: \t&quot; &lt;&lt; iCnt &lt;&lt; '\n'     &lt;&lt; &quot;Number of vowel o: \t&quot; &lt;&lt; oCnt &lt;&lt; '\n'     &lt;&lt; &quot;Number of vowel u: \t&quot; &lt;&lt; uCnt &lt;&lt; endl;</code></pre><p>switch 语句首先对括号里的表达式求值，该表达式（可以是一个初始化的变量声明）紧跟在关键字 switch 的后面。表达式的值转换成整数类型，然后与每个 case 标签的值比较</p><p>如果表达式和某个 case 标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了 switch 的结尾或者是遇到一条 break 语句为止</p><blockquote><p>break 语句的作用是中断当前的控制流。此例中，break 语句将控制权转移到 switch 语句外面</p></blockquote><p>如果 switch 语句的表达式和所有 case 都没有匹配上，将直接跳转到 switch 结构之后的第一条语句</p><p>case 关键字和它对应的值一起被称为 <strong>case 标签</strong>（case label）</p><p>case 标签必须是整型常量表达式</p><pre><code class="language-cpp">char ch = getVal();int ival = 42;switch(ch) &#123;    case 3.14: // 错误：case 标签不是一个整数    case ival: // 错误：case 标签不是一个常量    // ...</code></pre><blockquote><p>任何两个 case 标签的值不能相同，否则就会引发错误</p></blockquote><p>default 也是一种特殊的 case 标签</p><h3 id="switch-内部的控制流"><a class="anchor" href="#switch-内部的控制流">#</a> switch 内部的控制流</h3><p>如果某个 case 标签匹配成功，将从该标签开始往后顺序执行所有 case 分支，除非程序显式地中断了这一过程，否则，执行到 switch 的结尾处才会停下来</p><p>要想避免执行后续 case 分支的代码，我们必须显式地告诉编译器终止执行过程。大多数情况下，在下一个 case 标签之前应该有一条 break 语句</p><p>然而，由于每个 case 标签只能对应一个值，有时候我们希望两个或更多个值共享同一组操作。此时，我们就故意省略掉 break 语句，使得程序能够连续执行若干个 case 标签</p><p>例如：统计所有元音字母出现的总次数</p><pre><code class="language-cpp">unsigned vowelCnt = 0;// ...switch (ch) &#123;    case 'a':    case 'e':    case 'i':    case 'o':    case 'u':       ++vowelCnt;       break;&#125;</code></pre><p>C++ 程序的形式比较自由，所以 case 标签之后不一定非得换行。把几个 case 标签写在一行里，强调这些 case 代表的是某个范围内的值</p><pre><code class="language-cpp">switch (ch) &#123;    // 另一种合法的书写形式    case 'a': case 'e': case 'i': case 'o': case 'u':       ++vowelCnt;       break;&#125;</code></pre><blockquote><p>一般不要省略 case 分支最后的 break 语句。如果没写 break 语句，最好加一段注释说清楚程序的逻辑</p></blockquote><blockquote><p>尽管 switch 语句不是非得在最后一个标签后面写上 break ，但是为了安全起见，最好这么做。因为这样的话，即使以后再增加新的 case 分支，也不用再在前面补充 break 语句了</p></blockquote><h3 id="default-标签"><a class="anchor" href="#default-标签">#</a> default 标签</h3><p>如果没有任何一个 case 标签能匹配上 switch 表达式的值，程序将执行紧跟在 <strong>default 标签</strong>（default label）后面的语句</p><p>例如，可以增加一个计数值来统计非元音字母的数量</p><pre><code class="language-cpp">switch (ch) &#123;    case 'a': case 'e': case 'i': case 'o': case 'u':        ++vowelCnt; // 元音字母的数量        break;    default:        ++otherCnt; // 非元音字母的数量        break;&#125;</code></pre><blockquote><p>即使不准备在 default 标签下做任何工作，定义一个 default 标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做</p></blockquote><p>标签不应该孤零零地出现，它后面必须跟一条语句或者另外一个 case 标签。如果 switch 结构以一个空的 default 标签作为结束，则该 default 标签后面必须跟一条空语句或一个空块</p><h1 id="迭代语句"><a class="anchor" href="#迭代语句">#</a> 迭代语句</h1><p>迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来</p><ul><li>while 和 for 语句在执行循环体之前检查条件</li><li>do while 语句先执行循环体，然后再检查条件</li></ul><h2 id="while-语句"><a class="anchor" href="#while-语句">#</a> while 语句</h2><p>只要条件为真，while 语句（while statement）就重复地执行循环体</p><p>语法形式为：</p><pre><code>while (condition)    statement</code></pre><p>condition 不能为空，如果 condition 第一次求值就得 false ， statement 一次都不执行</p><p>condition 可以是一个表达式或者是一个带初始化的变量声明</p><p><strong>定义在 while 条件部分或者 while 循环体内的变量，每次迭代都经历从创建到销毁的过程</strong></p><p>当不确定到底要迭代多少次时，使用 while 循环比较合适</p><p>例如：</p><pre><code class="language-cpp">vector&lt;int&gt; v;int i;// 重复读入数据，直至到达文件末尾或者遇到其他输入问题while (cin &gt;&gt; i)    v.push_back(i);// 寻找第一个负值元素auto beg = v.begin();while (beg != v.end() &amp;&amp; *beg &gt;= 0)    ++beg;if (beg == v.end())    // 此时我们知道 v 中的所有元素都大于等于 0</code></pre><h2 id="传统的-for-语句"><a class="anchor" href="#传统的-for-语句">#</a> 传统的 for 语句</h2><p>for 语句的语法形式：</p><pre><code>for (init-statement; condition; expression)    statement</code></pre><p>关键字 for 及括号里的部分称为 for 语句头</p><p>init-statement 必须是以下三种形式中的一种：声明语句、表达式语句或者空语句。因为这些语句都以分号作为结束，for 语句的语法形式也可以看作：</p><pre><code>for (initializer; condition; expression)    statement</code></pre><p>其中：</p><ul><li>init-statement 负责初始化一个值，这个值将随着循环的进行而改变</li><li>condition 作为循环控制的条件，只要 condition 为真，就执行一次 statement 。如果 condition 第一次的求值结果就是 false ，则 statement 一次也不会执行</li><li>expression 负责在每次循环迭代之后修改 init-statement 初始化的变量，这个变量正好就是 condition 检查的对象</li><li>statement 可以是一条单独的语句也可以是一条复合语句</li></ul><blockquote><p>for 语句头中定义的对象只在 for 循环体内可见</p></blockquote><h3 id="for-语句头中的多重定义"><a class="anchor" href="#for-语句头中的多重定义">#</a> for 语句头中的多重定义</h3><p>init-statement 可以定义多个对象，但只能有一条声明语句，因此，所有变量的基础类型必须相同</p><p>例如：下列代码在 init-statement 里同时定义了索引 i 和循环控制变量 sz</p><pre><code class="language-cpp">// 记录下 v 的大小，当到达原来的最后一个元素后结束循环for (decltype(v.size()) i = 0, sz = v.size(); i != sz; ++i)    v.push_back(v[i]);</code></pre><h3 id="省略-for-语句头的某些部分"><a class="anchor" href="#省略-for-语句头的某些部分">#</a> 省略 for 语句头的某些部分</h3><p>for 语句头能省略掉 init-statement 、condition 和 expression 中的任何一个（或者全部）</p><p>如果无须初始化，则我们可以使用一条空语句作为 init-statement ，例如</p><pre><code class="language-cpp">auto beg = v.begin();for ( /* 空语句 */; beg != v.end() &amp;&amp; *beg &gt;= 0; ++beg)    ; // 什么也不做</code></pre><p>注意，分号必须保留，以表明我们省略掉了 init-statement 。说得更准确一点，分号表示的是一个空的 init-statement</p><p>省略 condition 的效果等价于在条件部分写了一个 true 。因为条件的值永远是 true ，所以在循环体内必须有语句负责退出循环，否则循环就会无休止地执行下去</p><pre><code class="language-cpp">for (int i = 0; /* 条件为空 */ ; ++i) &#123;    // 对 i 进行处理，循环内部的代码必须能够终止迭代过程&#125;</code></pre><p>我们也能省略掉 for 语句头中的 expression ，但是在这样的循环中就要求条件部分或者循环体必须改变迭代变量的值</p><pre><code class="language-cpp">vector&lt;int&gt; v;for (int i; cin &gt;&gt; i; /* 表达式为空 */ )   v.push_back(i);</code></pre><p>因为条件部分能改变 i 的值，所以这个循环无须表达式部分。其中，条件部分不断检查输入流的内容，只要读取完所有的输入或者遇到一个输入错误就终止循环</p><h2 id="范围-for-语句"><a class="anchor" href="#范围-for-语句">#</a> 范围 for 语句</h2><p>C++ 11 新标准引入了一种更简单的 for 语句，这种语句可以遍历容器或其他序列的所有元素</p><p>范围 for 语句（range for statement）的语法形式：</p><pre><code>for (declaration : expression)    statement</code></pre><p>expression 表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者 vector 或 string 等类型的对象，这些类型的共同特点是拥有能返回迭代器的 begin 和 end 成员</p><p>declaration 定义一个变量，序列中的每个元素都得能转换成该变量的类型</p><ul><li>确保类型相容最简单的办法是使用 auto 类型说明符</li><li>如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型</li></ul><p>每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行 statement</p><p>statement 可以是一条单独的语句也可以是一个块</p><p>所有元素都处理完毕后循环终止</p><p>例如：把 vector 对象中的每个元素都翻倍</p><pre><code class="language-cpp">vector&lt;int&gt; v = &#123;0,1,2,3,4,5,6,7,8,9&#125;;// 范围变量必须是引用类型，这样才能对元素执行写操作for (auto &amp;r : v)   // 对于 v 中的每一个元素    r *= 2;         // 将 v 中每个元素的值翻倍</code></pre><p>其等价于</p><pre><code class="language-cpp">for (auto beg = v.begin(), end = v.end(); beg != end; ++beg) &#123;    auto &amp;r = *beg;    r *= 2;&#125;</code></pre><p>不能通过范围 for 语句增加 vector 对象（或者其他容器）的元素：因为在范围 for 语句中，预存了 end () 的值。一旦在序列中添加（删除）元素，end 函数的值就可能变得无效了</p><h2 id="do-while-语句"><a class="anchor" href="#do-while-语句">#</a> do while 语句</h2><p>do while 语句（do while statement）和 while 语句非常相似，唯一的区别是，do while 语句先执行循环体后检查条件</p><p>即，不管条件的值如何，do while 语句都至少执行一次循环</p><p>do while 语句的语法形式：</p><pre><code>do    statementwhile (condition);</code></pre><p><strong>do while 语句应该在后面用一个分号表示语句结束</strong></p><p>在 do while 语句中，首先执行一次 statement 然后才求 condition 的值（ condition 不能为空）。如果 condition 的值为假，循环终止；否则，重复循环过程</p><p>condition 使用的变量必须定义在循环体之外</p><p>例如，可以使用 do while 循环（不断地）执行加法运算</p><pre><code class="language-cpp">// 不断提示用户输入一对数，然后求其和string rsp;  // 作为循环的条件，不能定义在 do 的内部do &#123;    cout &lt;&lt; &quot;please enter two values: &quot;;    int val1 = 0, val2 = 0;    cin  &gt;&gt; val1 &gt;&gt; val2;    cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; val1 &lt;&lt; &quot; and &quot; &lt;&lt; val2         &lt;&lt; &quot; = &quot; &lt;&lt; val1 + val2 &lt;&lt; &quot;\n\n&quot;         &lt;&lt; &quot;More? Enter yes or no: &quot;;    cin  &gt;&gt; rsp;&#125; while (!rsp.empty() &amp;&amp; rsp[0] != 'n');</code></pre><p>因为 do while 先执行语句（或者块）后判断条件，所以不允许在条件部分定义变量</p><pre><code class="language-cpp">do &#123;    // . . .    mumble(foo);&#125; while (int foo = get_foo()); // 错误：将变量声明放在了 do while 的条件部分</code></pre><h1 id="跳转语句"><a class="anchor" href="#跳转语句">#</a> 跳转语句</h1><p>跳转语句用于中断当前的执行过程</p><p>C++ 语言提供了 4 种跳转语句：</p><ul><li>break</li><li>continue</li><li>goto</li><li>return</li></ul><h2 id="break-语句"><a class="anchor" href="#break-语句">#</a> break 语句</h2><p>break 语句（break statement）负责终止离它最近的 <strong>while 、do while 、for 或 switch 语句</strong>，并从这些语句之后的第一条语句开始继续执行</p><p>break 语句只能出现在迭代语句或者 switch 语句内部（包括嵌套在此类循环里的语句或块的内部）。<strong>break 语句的作用范围仅限于最近的循环或者 switch</strong></p><p>例如：</p><pre><code class="language-cpp">string buf;while (cin &gt;&gt; buf &amp;&amp; !buf.empty()) &#123;    switch(buf[0]) &#123;    case '-':        // 处理到第一个空白为止        for (auto it = buf.begin()+1; it != buf.end(); ++it) &#123;              if (*it == ' ')                   break; // #1，离开 for 循环              // . . .        &#125;        // break #1 将控制权转移到这里        // 剩余的 '-' 处理        break; // #2，离开 switch 语句    case '+':        // . . .    &#125; // 结束 switch   // break #2 将控制权转移到这里&#125; // 结束 while</code></pre><p>标记为 #1 的 break 语句负责终止连字符 case 标签后面的 for 循环。它不但不会终止 switch 语句，甚至连当前的 case 分支也终止不了。接下来，程序继续执行 for 循环之后的第一条语句，这条语句可能接着处理连字符的情况，也可能是另一条用于终止当前分支的 break 语句</p><p>标记为 #2 的 break 语句负责终止 switch 语句，但是不能终止 while 循环。执行完这个 break 后，程序继续执行 while 的条件部分</p><h2 id="continue-语句"><a class="anchor" href="#continue-语句">#</a> continue 语句</h2><p>continue 语句（continue statement）终止最近的循环中的当前迭代并立即开始下一次迭代</p><p><strong>continue 语句只能出现在 for 、while 和 do while 循环的内部</strong>，或者嵌套在此类循环里的语句或块的内部</p><p>和 break 语句类似的是，出现在嵌套循环中的 continue 语句也仅作用于离它最近的循环</p><p>和 break 语句不同的是，只有当 switch 语句嵌套在迭代语句内部时，才能在 switch 里使用 continue （即，continue 对循环起作用，而不对 switch 起作用）</p><p>continue 语句中断当前的迭代，但是仍然继续执行循环</p><ul><li>对于 while 或者 do while 语句来说，继续判断条件的值</li><li>对于传统的 for 循环来说，继续执行 for 语句头的 expression</li><li>对于范围 for 语句来说，用序列中的下一个元素初始化循环控制变量</li></ul><p>例如：从标准输入中读取单词并处理以下画线开头的单词</p><pre><code class="language-cpp">string buf;while (cin &gt;&gt; buf &amp;&amp; !buf.empty()) &#123;    if (buf[0] != '_')        continue; // get another input    // still here? the input starts with an underscore; process buf . . .&#125;</code></pre><h2 id="goto-语句"><a class="anchor" href="#goto-语句">#</a> goto 语句</h2><p>goto 语句（goto statement）的作用：从 goto 语句无条件跳转到同一函数内的另一条语句</p><blockquote><p>不要在程序中使用 goto 语句，因为它使得程序既难理解又难修改</p></blockquote><p>goto 语句的语法形式：</p><pre><code>goto label;</code></pre><p>其中，label 是用于标识一条语句的标示符</p><p>带标签语句（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号，例如：</p><pre><code class="language-cpp">end: return; // 带标签语句，可以作为 goto 的目标</code></pre><p>标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标识符使用同一个名字而不会相互干扰</p><p>goto 语句和控制权转向的那条带标签的语句必须位于同一个函数之内</p><p>和 switch 语句类似，goto 语句也不能将程序的控制权从变量的作用域之外转移到作用域之内：</p><pre><code class="language-cpp">    // . . .    goto end;    int ix = 10; // 错误：goto 语句绕过了一个带初始化的变量定义end:    // 错误：此处的代码需要 ix，但是 goto 语句绕过了它的声明    ix = 42;</code></pre><p>向后跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它。例如：</p><pre><code class="language-cpp">// backward jump over an initialized variable definition is okay  begin:    int sz = get_size();    if (sz &lt;= 0) &#123;        goto begin;    &#125;</code></pre><p>在上面的代码中，goto 语句执行后将销毁 sz 。因为跳回到 begin 的动作跨过了 sz 的定义语句，所以 sz 将重新定义并初始化</p><h1 id="try-语句块和异常处理"><a class="anchor" href="#try-语句块和异常处理">#</a> try 语句块和异常处理</h1><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围</p><p>典型的异常包括失去数据库连接以及遇到意外输入等</p><p>异常处理机制包括异常检测和异常处理两个部分</p><p>在 C++ 语言中，异常处理包括：</p><ul><li><strong>throw 表达式</strong>（throw expression）：异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。通常描述为：throw 引发（raise）了异常</li><li><strong>try 语句块</strong>（try block）：异常处理部分使用 try 语句块处理异常<ul><li>try 语句块以关键字 try 开始，并以一个或多个 <strong>catch 子句</strong>（catch clause）结束</li><li>try 语句块中代码抛出的异常通常会被某个 catch 子句处理。catch 子句通常也被称作 <strong>异常处理代码</strong>（exception handler）</li></ul></li><li>一套 <strong>异常类</strong>（exception class）：用于在 throw 表达式和相关的 catch 子句之间传递异常的具体信息</li></ul><h2 id="throw-表达式"><a class="anchor" href="#throw-表达式">#</a> throw 表达式</h2><p>throw 表达式包含关键字 throw 和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型</p><p>throw 表达式后面通常紧跟一个分号</p><p>例如：在执行两个 Sales_item 对象相加时，需要先检查它们是否是关于同一种书籍的</p><pre><code class="language-cpp">Sales_item item1, item2;cin &gt;&gt; item1 &gt;&gt; item2;// 首先检查两条数据是否是关于同一种书籍的if (item1.isbn() != item2.isbn())    throw runtime_error(&quot;Data must refer to same ISBN&quot;);// 如果程序执行到这里，则说明两个 ISBN 相同cout &lt;&lt; item1 + item2 &lt;&lt; endl;</code></pre><p>在这段代码中，如果 ISBN 不一样，就会抛出一个异常（该异常是类型 runtime_error 的对象）</p><blockquote><p>类型 runtime_error 是标准库异常类型的一种，定义在 stdexcept 头文件中</p></blockquote><p>抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码</p><h2 id="try-语句块"><a class="anchor" href="#try-语句块">#</a> try 语句块</h2><p>try 语句块包括关键字 try 以及紧随其后的一个块（花括号括起来的语句序列），其通用语法形式为：</p><pre><code class="language-cpp">try &#123;    program-statements&#125; catch (exception-declaration) &#123;    handler-statements&#125; catch (exception-declaration) &#123;    handler-statements&#125; // ...</code></pre><p>跟在 try 块之后的是一个或多个 catch 子句</p><p>catch 字句包括三部分：</p><ul><li>关键字 catch</li><li>括号内一个（可能未命名的）对象的声明（称作异常声明，exception declaration）</li><li>一个块（用于处理异常）</li></ul><p>当选中某个 catch 子句处理异常之后，就会执行与之对应的块</p><p>catch 一旦完成，程序将会跳转到 try 语句块对应的最后一个 catch 子句之后，以继续执行后续语句</p><p>try 语句块中的 program-statements 可以是任意 C++ 语句，包括声明在内的</p><blockquote><p>try 语句块内声明的变量在块外部无法访问，特别是，在 catch 子句内也无法访问</p></blockquote><h3 id="编写-handler-statements"><a class="anchor" href="#编写-handler-statements">#</a> 编写 handler-statements</h3><p>例如：可以将程序原本需要执行的任务放在 try 语句块中（这段代码可能会抛出一个 runtime_error 类型的异常），然后在 try 语句块之后跟一个 catch 字句（用于处理类型为 runtime_error 的异常）</p><pre><code class="language-cpp">while (cin &gt;&gt; item1 &gt;&gt; item2) &#123;    try &#123;        if (item1.isbn() != item2.isbn())            throw runtime_error(&quot;Data must refer to same ISBN&quot;);        cout &lt;&lt; item1 + item2 &lt;&lt; endl;    &#125; catch (runtime_error err) &#123; // 异常类型为 runtime_error ，异常命名为 err        // 提醒用户两个 ISBN 必须一致，询问是否重新输入        cout &lt;&lt; err.what()             &lt;&lt; &quot;\nTry Again?  Enter y or n&quot; &lt;&lt; endl;        char c;        cin &gt;&gt; c;        if (!cin || c == 'n')            break;      // 用户输入 'n'，跳出 while 循环        // 否则，程序控制权跳回到 while 条件部分，准备下一次迭代    &#125;&#125;</code></pre><p>其中，what 是 runtime-error 类的一个成员函数，返回的是（初始化一个具体对象时所用的）string 对象的副本</p><p>在上例中，如果 try 语句块中抛出异常，catch 子句将会输出：</p><pre><code>Data must refer to same ISBNTry Again? Enter y or n</code></pre><h3 id="函数在寻找处理代码的过程中退出"><a class="anchor" href="#函数在寻找处理代码的过程中退出">#</a> 函数在寻找处理代码的过程中退出</h3><p>程序在遇到抛出异常的代码前，可能已经经过了多个 try 语句块（例如，一个 try 语句块可能调用了包含另一个 try 语句块的函数）</p><p>此时，寻找 异常处理代码 的过程为：</p><ul><li>当异常被抛出时，首先搜索抛出该异常的函数</li><li>如果没找到匹配的 catch 子句，则终止该函数，并在调用该函数的函数中继续寻找</li><li>以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的 catch 子句为止</li></ul><p>如果最终还是没能找到任何匹配的 catch 子句，程序将会转到名为 <strong>terminate</strong> 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出</p><p>如果一段程序没有 try 语句块且发生了异常，系统也会调用 terminate 函数并终止当前程序的执行</p><h2 id="标准异常"><a class="anchor" href="#标准异常">#</a> 标准异常</h2><p>C++ 标准库定义了一组类，用于报告标准库函数遇到的问题</p><p>C++ 定义了 4 个包含异常类的头文件：</p><ul><li>exception 头文件定义了最通用的异常类 exception，它只报告异常的发生，不提供任何额外信息</li><li>stdexcept 头文件定义了几种常用的异常类（见表 5.1）<ul><li><img data-src="/posts/ffed1eef/stdexcept.png" class=""></li></ul></li><li>new 头文件定义了 bad_alloc 异常类型</li><li>type_info 头文件定义了 bad_cast 异常类型</li></ul><p>标准库异常类只定义了以下几种运算：</p><ul><li>创建或拷贝异常类型的对象</li><li>为异常类型的对象赋值</li></ul><p>对于 exception 、bad_alloc 和 bad_cast 异常类型，只能以默认初始化的方式来初始化这些类型的对象，而不允许为这些对象提供初始值</p><p>对于其他异常类型，则应该使用 string 对象或者 C 风格字符串来初始化这些类型的对象，而不允许使用默认初始化的方式</p><ul><li>当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息</li></ul><p>每个异常类型都只定义了一个名为 what 的成员函数：</p><ul><li>what 函数没有任何参数，返回值是一个指向 C 风格字符串的  <code>const char*</code> （该字符串的目的是提供关于异常的一些文本信息）</li><li>what 函数返回的 C 风格字符串的内容与异常对象的类型有关：如果异常类型有一个字符串初始值，则 what 返回该字符串；对于其他无初始值的异常类型，what 返回的内容由编译器决定</li></ul><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><strong>块（block）</strong>：包围在花括号内的由 0 条或多条语句组成的序列。块也是一条语句，所以只要是能使用语句的地方，就可以使用块</p><p><strong>break 语句（break statement）</strong>：终止离它最近的循环或 switch 语句。控制权转移到循环或 switch 之后的第一条语句</p><p><strong>case 标签（case label）</strong>：在 switch 语句中紧跟在 case 关键字之后的常量表达式。在同一个 switch 语句中任意两个 case 标签的值不能相同</p><p><strong>catch 子句（catch clause）</strong>：由 catch 关键字、括号里的异常声明以及语句块三部分组成。catch 子句的代码负责处理在异常声明中定义的异常</p><p><strong>复合语句（compound statement）</strong>：块</p><p><strong>continue 语句（continue statement）</strong>：终止离它最近的循环的当前迭代。控制权转移到 while 或 do while 语句的条件部分、或者范围 for 循环的下一次迭代、或者传统 for 循环头部的表达式</p><p><strong>悬垂 else（dangling else）</strong>：是一个俗语，指的是如何处理嵌套 if 语句中 if 分支多于 else 分支的情况</p><ul><li>C++ 语言规定，else 应该与前一个未匹配的 if 匹配在一起</li><li>使用花括号可以把位于内层的 if 语句隐藏起来，这样就能更好地控制 else 该与哪个 if 匹配</li></ul><p><strong>default 标签（default label）</strong>：是一种特殊的 case 标签，当 switch 表达式的值与所有 case 标签都无法匹配时，程序执行 default 标签下的内容</p><p><strong>do while 语句（do while statement）</strong>：与 while 语句类似，但 do while 语句先执行循环体，再判断条件。循环体代码至少会执行一次</p><p><strong>异常类（exception class）</strong>：标准库定义的一组类，用于表示程序发生的错误</p><p><strong>异常声明（exception declaration）</strong>：位于 catch 子句中的声明，指定了该 catch 子句能处理的异常类型</p><p><strong>异常处理代码（exception handler）</strong>：程序某处引发异常后，用于处理该异常的另一处代码。和 catch 子句是同义词</p><p><strong>异常安全（exception safe）</strong>：是一个术语，表示的含义是当抛出异常后，程序能执行正确的行为</p><p><strong>表达式语句（expression statement）</strong>：即一条表达式后面跟上一个分号，令表达式执行求值过程</p><p><strong>控制流（flow of control）</strong>：程序的执行路径</p><p><strong>for 语句（for statement）</strong>：提供迭代执行的迭代语句。常常用于遍历一个容器或者重复计算若干次</p><p><strong>goto 语句（goto statement）</strong>：令控制权无条件转移到同一函数中一个指定的带标签语句。goto 语句容易造成程序的控制流混乱，应禁止使用</p><p><strong>if else 语句（if else statement）</strong>：判断条件，根据其结果分别执行 if 分支或 else 分支的语句</p><p><strong>if 语句（if statement）</strong>：判断条件，根据其结果有选择地执行语句。如果条件为真，执行 if 分支的代码；如果条件为假，控制权转移到 if 结构之后的第一条语句</p><p><strong>带标签语句（labeled statement）</strong>：前面带有标签的语句。所谓标签是指一个标识符以及紧跟着的一个冒号。对于同一个标识符来说，用作标签的同时还能用于其他目的，互不干扰</p><p><strong>空语句（null statement）</strong>：只含有一个分号的语句</p><p><strong>引发（raise）</strong>：含义类似于 throw 。在 C++ 语言中既可以说抛出异常，也可以说引发异常</p><p><strong>范围 for 语句（range for statement）</strong>：在一个序列中进行迭代的语句</p><p><strong>switch 语句（switch statement）</strong>：一种条件语句</p><ul><li>首先求 switch 关键字后面表达式的值</li><li>如果某个 case 标签的值与表达式的值相等，程序直接跨过之前的代码从这个 case 标签开始执行</li><li>当所有 case 标签都无法匹配时，如果有 default 标签，从 default 标签继续执行；如果没有，结束 switch 语句</li></ul><p><strong>terminate</strong> ：是一个标准库函数，当异常没有被捕捉到时调用。terminate 终止当前程序的执行</p><p><strong>throw 表达式（throw expression）</strong>：一种中断当前执行路径的表达式。throw 表达式抛出一个异常并把控制权转移到能处理该异常的最近的 catch 子句</p><p><strong>try 语句块（try block）</strong>：跟在 try 关键字后面的块，以及一个或多个 catch 子句。如果 try 语句块的代码引发异常并且其中一个 catch 子句匹配该异常类型，则异常被该 catch 子句处理。否则，异常将由外围 try 语句块处理，或者程序终止</p><p><strong>while 语句（while statement）</strong>：只要指定的条件为真，就一直迭代执行目标语句</p><p>参考：C++ Primer 中文版（第 5 版）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 338. 比特位计数</title>
      <link href="/posts/38d980c0/"/>
      <url>/posts/38d980c0/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudGluZy1iaXRzLw==">338. Counting Bits</span></p><p>给你一个整数  <code>n</code>  ，对于  <code>0 &lt;= i &lt;= n</code>  中的每个  <code>i</code>  ，计算其二进制表示中 <strong> <code>1</code>  的个数</strong> ，返回一个长度为  <code>n + 1</code>  的数组  <code>ans</code>  作为答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：[0,1,1]解释：0 --&gt; 01 --&gt; 12 --&gt; 10</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 5输出：[0,1,1,2,1,2]解释：0 --&gt; 01 --&gt; 12 --&gt; 103 --&gt; 114 --&gt; 1005 --&gt; 101</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：</p><ul><li>很容易就能实现时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的解决方案，你可以在线性时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 内用一趟扫描解决此问题吗？</li><li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的  <code>__builtin_popcount</code>  ）</li></ul><h1 id="method-1-brian-kernighan-算法"><a class="anchor" href="#method-1-brian-kernighan-算法">#</a> Method 1: Brian Kernighan 算法</h1><p>算法思路：</p><p>对从 0 到 n 的每个整数直接计算二进制表示中的 1 的数目</p><p>其中，可利用 Brian Kernighan 算法对每个整数求二进制表示中 1 的个数：对于任意整数 x ，令 x = x &amp; (x - 1) ，可将 x 的二进制表示的最后一个 1 变成 0 。因此，对 x 重复该操作，直到 x 变成 0，操作次数即为 x 的二进制表示中的 1 的数目</p><p>代码实现：</p><pre><code class="language-cpp">int helper(int x) &#123; // 计算 x 的二进制表示中 1 的个数    int ones = 0;    while (x) &#123;        x = x &amp; (x - 1);        ++ones;    &#125;    return ones;&#125;vector&lt;int&gt; countBits(int n) &#123;    vector&lt;int&gt; ans(n + 1, 0);    for (int i = 1; i &lt;= n; ++i)        ans[i] = helper(i);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><ul><li>需要遍历 0 到 n，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>对每个整数计算二进制表示中 1 的个数的时间不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑答案数组</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudGluZy1iaXRzL3NvbHV0aW9uL2JpLXRlLXdlaS1qaS1zaHUtYnktbGVldGNvZGUtc29sdXRpb24tMHQxaS8=">leetcode-solution</span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：</p><p>定义 dp [i] 表示整数 i 对应二进制表示中的 1 的个数</p><p>递推公式：</p><ul><li>若 i 是奇数，则 i 对应二进制数中的 1 的个数一定比偶数 i - 1 对应的多一个 1（因为 i 对应二进制的最低位是 1），即： <code>dp[i] = dp[i - 1] + 1</code></li><li>若 i 是偶数，则 i 对应二进制数中的 1 的个数等于 i / 2 对应的 1 的个数（因为 i 对应二进制的最低位是 0 ），即： <code>dp[i] = dp[i / 2]</code></li></ul><p>初始化 dp 数组：dp [0] = 0</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; countBits(int n) &#123;    vector&lt;int&gt; dp(n + 1, 0);    dp[0] = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        if (i % 2) dp[i] = dp[i - 1] + 1; // i 为奇数        else dp[i] = dp[i / 2]; // i 为偶数    &#125;    return dp;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑答案数组</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudGluZy1iaXRzL3NvbHV0aW9uL2hlbi1xaW5nLXhpLWRlLXNpLWx1LWJ5LWR1YWR1YS8=">duadua</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 312. 戳气球</title>
      <link href="/posts/d81fafae/"/>
      <url>/posts/d81fafae/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy8=">312. Burst Balloons</span></p><p>有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums [i - 1] * nums [i] * nums [i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,5]输出：10</code></pre><p></p><p><strong>提示：</strong></p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 300</li><li>0 &lt;= nums[i] &lt;= 100</li></ul><h1 id="method-1-记忆化搜索"><a class="anchor" href="#method-1-记忆化搜索">#</a> Method 1: 记忆化搜索</h1><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy9zb2x1dGlvbi9jaHVvLXFpLXFpdS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：</p><p>题目告知 “i - 1 或者 i + 1 超出数组边界时相当于一个数字为 1 的气球”，因此，可以为数组的首尾分别添加元素 1，以便处理边界问题（定义辅助数组  <code>vector&lt;int&gt; val(nums.size() + 2)</code>  ）</p><p>定义 dp 数组：<strong>dp [i][j] 表示戳破区间 (i, j) 内所有气球所能获得的最高分数</strong></p><p>初始化 dp 数组：当 i &gt;= j 时，开区间 (i, j) 内没有气球，dp [i][j] = 0</p><p>递推公式：</p><ul><li>假设 <strong>区间 (i, j) 内最后一个被戳破的气球</strong> 为 k<ul><li>在戳破气球 k 前，区间 (i, k) 内的所有气球均已被戳破，其获得的分数为 dp [i][k] ，区间 (k, j) 内的所有气球也均已被戳破，其获得的分数为 dp [k][j]</li><li>气球 k 左侧为气球 i ，气球 k 右侧为气球 j ，即：戳破 k 获得的分数为 val [i] * val [k] * val [j]</li><li>此时，区间 (i, j) 能获得的总分数为 dp [i][k] + val [i] * val [k] * val [j] + dp [k][j]</li></ul></li><li>由于区间 (i, j) 具有多个可选的最后一个气球 k ，需要枚举 k 并选择总分数最高的，因此，递推公式为： <code>dp[i][j] = max(dp[i][j], dp[i][k] + val[i] * val[k] * val[j] + dp[k][j])</code>  ，其中， <code>i + 1 &lt;= k &lt;= j - 1</code></li></ul><p>遍历顺序：由递推公式可知，dp [i][j] 依赖于 dp [i][k] 和 dp [k][j] ，其中，i &lt; k 且 k &lt; j，因此，i 应按照从大到小的顺序遍历（为了获得 dp [k][j] ），j 应按照从小到大的顺序遍历（为了获得 dp [i][k] ）</p><blockquote><p>或者，也可以按照对角线从左到右的顺序斜着遍历 dp 数组</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int maxCoins(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; val(n + 2, 0); // 创建一个辅助数组（在首尾各添 1），处理边界情况    val[0] = val[n + 1] = 1;    for (int i = 1; i &lt;= n; ++i)        val[i] = nums[i - 1];    vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0));    for (int i = n; i &gt;= 0; --i) &#123; // 区间的左端点（开区间）        for (int j = i + 1; j &lt; n + 2; ++j) &#123; // 区间的右端点（开区间）            for (int k = i + 1; k &lt; j; ++k) &#123; // 区间内最后戳破的气球                int tmp = dp[i][k] + val[i] * val[k] * val[j] + dp[k][j];                dp[i][j] = max(dp[i][j], tmp); // 择优做选择            &#125;        &#125;    &#125;    return dp[0][n + 1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><ul><li>状态数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li><li>状态转移的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy9zb2x1dGlvbi90dS1qaWUtZG9uZy10YWktZ3VpLWh1YS1qaWUtanVlLWNodW8tcWktY3gxOGgv">angela：图解：动态规划解决戳气球问题，思路清晰简明，注释详细</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy9zb2x1dGlvbi96aGUtZ2UtY2FpLXB1LXppLWppLXphaS1qaWEteWUtbmVuZy16dW8tZ3Vhbi1qaWFuLS8=">xiao-yan-gou：关键思路解释</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见输入输出</title>
      <link href="/posts/f994a74a/"/>
      <url>/posts/f994a74a/</url>
      
        <content type="html"><![CDATA[<h2 id="场景一多组空格分隔的两个正整数"><a class="anchor" href="#场景一多组空格分隔的两个正整数">#</a> 场景一：多组空格分隔的两个正整数</h2><p>输入描述：</p><pre><code>输入包括两个正整数 a, b (1 &lt;= a, b &lt;= 1000)，输入数据包括多组</code></pre><p>输出描述：</p><pre><code>输出 a + b 的结果</code></pre><p>数据范围：</p><pre><code>数据组数 1 &lt;= t &lt;= 100</code></pre><p>输入示例：</p><pre><code>1 510 20</code></pre><p>输出示例：</p><pre><code>630</code></pre><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main() &#123;    int a = 0, b = 0;    while (cin &gt;&gt; a &gt;&gt; b) &#123;        cout &lt;&lt; a + b &lt;&lt; endl; // 64 位输出请用 printf(&quot;%lld&quot;)    &#125;    return 0;&#125;</code></pre><h2 id="场景二第一行组数接空格分隔的两个正整数"><a class="anchor" href="#场景二第一行组数接空格分隔的两个正整数">#</a> 场景二：第一行组数接空格分隔的两个正整数</h2><p>输入描述：</p><pre><code>输入第一行包括一个数据组数 t (1 &lt;= t &lt;= 100)接下来每行包括两个正整数 a, b (1 &lt;= a, b &lt;= 1000)</code></pre><p>输出描述：</p><pre><code>输出 a + b 的结果</code></pre><p>数据范围：</p><pre><code>数据组数 1 &lt;= t &lt;= 100</code></pre><p>输入示例：</p><pre><code>21 510 20</code></pre><p>输出示例：</p><pre><code>630</code></pre><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main() &#123;    int t = 0;    cin &gt;&gt; t;    int a = 0, b = 0;    for (int i = 0; i &lt; t; ++i) &#123;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; a + b &lt;&lt; endl;    &#125;&#125;</code></pre><h2 id="场景三空格分隔的两个正整数-以-0-0-结束"><a class="anchor" href="#场景三空格分隔的两个正整数-以-0-0-结束">#</a> 场景三：空格分隔的两个正整数 以 0 0 结束</h2><p>输入描述：</p><pre><code>输入包括两个正整数 a, b (1 &lt;= a, b &lt;= 10^9)，输入数据有多组，如果输入为 0 0 则结束输入</code></pre><p>输出描述：</p><pre><code>输出 a + b 的结果</code></pre><p>数据范围：</p><pre><code>数据组数 1 &lt;= t &lt;= 100</code></pre><p>输入示例：</p><pre><code>1 510 200 0</code></pre><p>输出示例：</p><pre><code>630</code></pre><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main() &#123;    int a = 0, b = 0;    while (cin &gt;&gt; a &gt;&gt; b) &#123;        if (a == 0 &amp;&amp; b == 0) break;        cout &lt;&lt; a + b &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h2 id="场景四每行第一个为个数后带空格分割整数-以-0-结束"><a class="anchor" href="#场景四每行第一个为个数后带空格分割整数-以-0-结束">#</a> 场景四：每行第一个为个数后带空格分割整数 以 0 结束</h2><p>输入描述：</p><pre><code>输入数据有多组，每行表示一组输入数据每行的第一个整数为整数的个数 n (1 &lt;= n &lt;= 100)接下来 n 个正整数，即需要求和的每个正整数</code></pre><p>输出描述：</p><pre><code>每组数据输出求和的结果</code></pre><p>数据范围：</p><pre><code>数据组数 1 &lt;= t &lt;= 100每组数据中整数个数满足 1 &lt;= n &lt;= 100每组数据中的值满足 1 &lt;= val &lt;= 100</code></pre><p>输入示例：</p><pre><code>4 1 2 3 45 1 2 3 4 5</code></pre><p>输出示例：</p><pre><code>1015</code></pre><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n = 0;    while (cin &gt;&gt; n) &#123;        if (n == 0) break;        int sum = 0;        int num = 0;        for (int i = 0; i &lt; n; ++i) &#123;            cin &gt;&gt; num;            sum += num;        &#125;        cout &lt;&lt; sum &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h2 id="场景五第一行组数接个数以及空格分隔的整数"><a class="anchor" href="#场景五第一行组数接个数以及空格分隔的整数">#</a> 场景五：第一行组数接个数以及空格分隔的整数</h2><p>输入描述：</p><pre><code>输入的第一行包括一个正整数 t (1 &lt;= t &lt;= 100)，表示数据组数接下来 t 行，每行一组数据每行的第一个整数为整数的个数 n (1 &lt;= n &lt;= 100)接下来 n 个正整数，即需要求和的每个正整数</code></pre><p>输出描述：</p><pre><code>每组数据输出求和的结果</code></pre><p>数据范围：</p><pre><code>数据组数 1 &lt;= t &lt;= 100每组数据中整数个数满足 1 &lt;= n &lt;= 100每组数据中的值满足 1 &lt;= val &lt;= 100</code></pre><p>输入示例：</p><pre><code>24 1 2 3 45 1 2 3 4 5</code></pre><p>输出示例：</p><pre><code>1015</code></pre><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main() &#123;    int t = 0;    cin &gt;&gt; t;    for (int i = 0; i &lt; t; ++i) &#123;        int n = 0;        cin &gt;&gt; n;        int sum = 0;        int num = 0;        for (int j = 0; j &lt; n; ++j) &#123;            cin &gt;&gt; num;            sum += num;        &#125;        cout &lt;&lt; sum &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h2 id="场景六多组未知数量的正整数"><a class="anchor" href="#场景六多组未知数量的正整数">#</a> 场景六：多组未知数量的正整数</h2><p>输入描述：</p><pre><code>输入数据有多组，每行表示一组输入数据每行不定有 n 个整数，空格隔开 (1 &lt;= n &lt;= 100)</code></pre><p>输出描述：</p><pre><code>每组数据输出求和的结果</code></pre><p>输入示例：</p><pre><code>1 2 34 50 0 0 0 0</code></pre><p>输出示例：</p><pre><code>690</code></pre><p>代码实现：</p><pre><code class="language-cpp">// 借助 stringstream，把每行数据输入到一个 string ，再转换成一个流#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main() &#123;    string str;    while (getline(cin, str)) &#123;        stringstream ss(str); // 将字符串 str 拷贝至 stringstream 流        int sum = 0;        int num = 0;        while (ss &gt;&gt; num) sum += num; // 等效于 while (getline(ss, t, ' ')) sum += stoi(t);        cout &lt;&lt; sum &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><p>其中， <code>getline (istream&amp; is, string&amp; str, char delim)</code>  ：（参考：<span class="exturl" data-url="aHR0cHM6Ly9jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdHJpbmcvc3RyaW5nL2dldGxpbmUv">std::getline</span> ）</p><ul><li>Extracts characters from  <code>is</code>  and stores them into  <code>str</code>  until the delimitation character  <code>delim</code>  is found.</li><li>If the delimiter is found, it is extracted and discarded (i.e. it is not stored and the next input operation will begin after it).</li><li>Note that any content in  <code>str</code>  before the call is replaced by the newly extracted sequence.</li></ul><blockquote><p><code>getline (istream&amp;  is, string&amp; str)</code>  ：Extracts characters from  <code>is</code>  and stores them into  <code>str</code>  until the newline character,  <code>'\n'</code> , is found.</p></blockquote><blockquote><p>注意：如果在使用  <code>getline()</code>  函数之前已经使用过  <code>cin</code>  ，则需使用  <code>cin.get()</code>  （或者， <code>cin.ignore()</code>  或  <code>getchar()</code>  ）读取缓冲区中的换行符  <code>\n</code>  ，然后再使用  <code>getline()</code>  （参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0NjY3Mi9hcnRpY2xlL2RldGFpbHMvMTA0Njc1NTIzP3NwbT0xMDAxLjIxMDEuMzAwMS42NjUwLjgmYW1wO3V0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19yZWxldmFudC5ub25lLXRhc2stYmxvZy0yJTdFZGVmYXVsdCU3RU9QRU5TRUFSQ0glN0VSYXRlLTgtMTA0Njc1NTIzLWJsb2ctMTE5NTE0MDE3LnBjX3JlbGV2YW50X211bHRpX3BsYXRmb3JtX2ZlYXR1cmVzc29ydHYyZHVwcmVwbGFjZSZhbXA7ZGVwdGhfMS11dG1fc291cmNlPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnQubm9uZS10YXNrLWJsb2ctMiU3RWRlZmF1bHQlN0VPUEVOU0VBUkNIJTdFUmF0ZS04LTEwNDY3NTUyMy1ibG9nLTExOTUxNDAxNy5wY19yZWxldmFudF9tdWx0aV9wbGF0Zm9ybV9mZWF0dXJlc3NvcnR2MmR1cHJlcGxhY2UmYW1wO3V0bV9yZWxldmFudF9pbmRleD04">C++ 中 cin 和 getline 使用出错的解决方法</span> ）</p><ul><li><code>cin.get()</code>  ：可以读入包括空格，跳格，回车符在内的空白字符</li><li><code>cin.ignore()</code>  ：丢弃输入的第一个字符。用来防止接收上次输入的回车符</li><li><code>getchar()</code>  ：读取一个字符，包括回车，空格</li></ul></blockquote><p>或者：</p><pre><code class="language-cpp">// 每次 cin &gt;&gt; 时判断下一位是不是换行符，即 cin.get() == '\n'#include &lt;iostream&gt;using namespace std;int main() &#123;    int sum = 0;    int num = 0;    while (cin &gt;&gt; num) &#123;        sum += num;        if (cin.get() == '\n') &#123;            cout &lt;&lt; sum &lt;&lt; endl;            sum = 0;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="场景七一行多个空格分隔的字符串"><a class="anchor" href="#场景七一行多个空格分隔的字符串">#</a> 场景七：一行多个空格分隔的字符串</h2><p>输入描述：</p><pre><code>输入有两行，第一行 n第二行是 n 个字符串，字符串之间用空格隔开</code></pre><p>输出描述：</p><pre><code>输出一行排序后的字符串，空格隔开，无结尾空格</code></pre><p>输入示例：</p><pre><code>5c d a bb e</code></pre><p>输出示例：</p><pre><code>a bb c d e</code></pre><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    int n = 0;    cin &gt;&gt; n;    vector&lt;string&gt; words(n, &quot;&quot;);    for (int i = 0; i &lt; n; ++i) &#123;        cin &gt;&gt; words[i];    &#125;    sort(words.begin(), words.end());    for (int i = 0; i &lt; n - 1; ++i) &#123;        cout &lt;&lt; words[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; words[n - 1] &lt;&lt; endl; // 无结尾空格    return 0;&#125;</code></pre><h2 id="场景八多行空格分隔的字符串"><a class="anchor" href="#场景八多行空格分隔的字符串">#</a> 场景八：多行空格分隔的字符串</h2><p>输入描述：</p><pre><code>多个测试用例，每个测试用例一行每行通过空格隔开，有 n 个字符，n &lt; 100</code></pre><p>输出描述：</p><pre><code>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</code></pre><p>输入示例：</p><pre><code>a c bbf ddddnowcoder</code></pre><p>输出示例：</p><pre><code>a bb cdddd fnowcoder</code></pre><p>代码实现：</p><pre><code class="language-cpp">// getline()#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    string str1, str2;    vector&lt;string&gt; words;    while (getline(cin, str1)) &#123;        stringstream ss(str1);        while (getline(ss, str2, ' ')) words.push_back(str2); // 等效于 while (ss &gt;&gt; str2) words.push_back(str2);        sort(words.begin(), words.end());        for (int i = 0; i &lt; words.size() - 1; ++i) &#123;            cout &lt;&lt; words[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; words[words.size() - 1] &lt;&lt; endl;        words.clear(); // 清空 words 数组    &#125;    return 0;&#125;</code></pre><p>或者：</p><pre><code class="language-cpp">// 判断换行符 cin.get() == '\n'#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    string word;    vector&lt;string&gt; words;    while (cin &gt;&gt; word) &#123;        words.push_back(word);        if (cin.get() == '\n') &#123; // 等效于 if(getchar() == '\n')            sort(words.begin(), words.end());            for (int i = 0; i &lt; words.size() - 1; ++i) &#123;                cout &lt;&lt; words[i] &lt;&lt; &quot; &quot;;            &#125;            cout &lt;&lt; words[words.size() - 1] &lt;&lt; endl;            words.clear();        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="场景九多行逗号分隔的字符串"><a class="anchor" href="#场景九多行逗号分隔的字符串">#</a> 场景九：多行逗号分隔的字符串</h2><p>输入描述：</p><pre><code>多个测试用例，每个测试用例一行每行通过 ',' 隔开，有 n 个字符，n &lt; 100</code></pre><p>输出描述：</p><pre><code>对于每组用例输出一行排序后的字符串，用 ',' 隔开，无结尾空格</code></pre><p>输入示例：</p><pre><code>a,c,bbf,ddddnowcoder</code></pre><p>输出示例：</p><pre><code>a,bb,cdddd,fnowcoder</code></pre><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    string str1, str2;    vector&lt;string&gt; words;    while (getline(cin, str1)) &#123;        stringstream ss(str1);        while (getline(ss, str2, ',')) words.push_back(str2);        sort(words.begin(), words.end());        for (int i = 0; i &lt; words.size() - 1; ++i) &#123;            cout &lt;&lt; words[i] &lt;&lt; &quot;,&quot;;        &#125;        cout &lt;&lt; words[words.size() - 1] &lt;&lt; endl;        words.clear();    &#125;    return 0;&#125;</code></pre><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvNTY1NyNxdWVzdGlvbg==">OJ 在线编程常见输入输出练习</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjk1MjIwL2FydGljbGUvZGV0YWlscy8xMTY3ODU1NTE/dXRtX3Rlcm09JUU3JTg5JTlCJUU1JUFFJUEyJUU3JUJEJTkxJUU2JTgwJThFJUU0JUI5JTg4JUU2JThDJTg5YWNtJUU2JUE4JUExJUU1JUJDJThGJUU3JUJCJTgzJUU5JUEyJTk4JmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfYWdncGFnZV9zZWFyY2hfcmVzdWx0Lm5vbmUtdGFzay1ibG9nLTJ+YWxsfnNvYmFpZHV3ZWJ+ZGVmYXVsdC0xLTExNjc4NTU1MSZhbXA7c3BtPTMwMDEuNDQzMC4=">ACM 模式输入输出案例总结</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 301. 删除无效的括号</title>
      <link href="/posts/7c57862a/"/>
      <url>/posts/7c57862a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtaW52YWxpZC1wYXJlbnRoZXNlcy8=">301. Remove Invalid Parentheses</span></p><p>给你一个由若干括号和字母组成的字符串  <code>s</code>  ，删除最小数量的无效括号，使得输入的字符串有效。</p><p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;()())()&quot;输出：[&quot;(())()&quot;,&quot;()()()&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;(a)())()&quot;输出：[&quot;(a())()&quot;,&quot;(a)()()&quot;]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;)(&quot;输出：[&quot;&quot;]</code></pre><p><strong>提示：</strong></p><ul><li>1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 25</li><li><code>s</code>  由小写英文字母以及括号  <code>'('</code>  和  <code>')'</code>  组成</li><li><code>s</code>  中至多含 20 个括号</li></ul><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><p>首先利用括号匹配的规则来计算最少需要删除的左括号数量 lremove 和右括号数量 rremove，即，遍历字符串 s：</p><ul><li>当遇到左括号时：llremove 加 1</li><li>当遇到右括号时：<ul><li>若 llremove 为 0，该右括号无法匹配，故而 rremove 加 1</li><li>若 llremove 不为 0，该右括号可以与之前的左括号匹配，故而 llremove 减 1</li></ul></li></ul><p>然后利用回溯算法遍历所有可能的删除非法括号的方案</p><ul><li>回溯函数的参数：字符串 string str，删除括号的起点 int start，所需删除的左括号数量 llremove，所需删除的右括号数量 rremove</li><li>回溯的终止条件：llremove 与 rremove 同时为 0，无需再删除括号，当前递归结束（在返回之前需要先调用 isValid 函数来检查当前字符串是否合法匹配，若合法匹配则将其记录下来）</li><li>单层搜索过程：遍历 字符串 str 的位置 i<ul><li>如果 i != start 且 str [i] == str [i - 1]，说明在这一层递归中遇到了连续相同的括号，此时我们不需要再重复搜索，故而跳过当前的 i，以此实现去重（比如当前遇到的字符串为 &quot;(((())&quot;，去掉前四个左括号中的任意一个，生成的字符串是一样的）</li><li>如果剩余字符串长度小于 lremove + rremove，当前的方案必然无法得到合法匹配的括号，因此，当前递归结束</li><li>如果 lremove 大于 0 且 str [i] 为左括号，可将当前左括号删除，然后递归到下一层（由于需要删除位置 i 的左括号，递归到下一层的字符串 str 应为 str.substr (0, i) + str.substr (i + 1)，并且起始位置 start 应为 i，lremove 应为 lremove - 1）</li><li>如果 rremove 大于 0 且 str [i] 为右括号，可将当前右括号删除，然后递归到下一层</li></ul></li></ul><p>其中，isValid 函数可按如下方式实现：</p><ul><li>定义 count 作为非法的左括号数量</li><li>遍历字符串 str<ul><li>若遇到左括号，count 加 1</li><li>若遇到右括号<ul><li>如果 count 等于 0，当前右括号无法匹配，返回 false</li><li>如果 count 不为 0，当前右括号可以匹配，count 减 1</li></ul></li></ul></li><li>判断 count 是否为 0，若为 0 则返回 true，否则返回 false</li></ul><blockquote><p>可考虑将 “计算 lremove、rremove” 与 “isValid 函数” 定义成一个可供复用的新函数</p></blockquote><p>代码实现：（本代码使用的是可复用的函数 check，函数返回 {0, 0} 时表示字符串合法）</p><pre><code class="language-cpp">vector&lt;string&gt; res;vector&lt;string&gt; removeInvalidParentheses(string s) &#123;    vector&lt;int&gt; remove(2, 0);    remove = check(s); // 计算需移除的左括号数量和右括号数量    helper(s, 0, remove[0], remove[1]);    return res;&#125;void helper(string str, int start, int lremove, int rremove) &#123;    if (lremove == 0 &amp;&amp; rremove == 0) &#123; // 已达到需要删除的最小括号数量        vector&lt;int&gt; tmp(2, 0);        tmp = check(str);               // 检查字符串内的括号是否完全匹配        if (tmp[0] == 0 &amp;&amp; tmp[1] == 0) // 字符串内的括号完全匹配            res.push_back(str);         // 记录当前方案        return;    &#125;    for (int i = start; i &lt; str.size(); ++i) &#123;        if (i &gt; start &amp;&amp; str[i] == str[i - 1]) continue; // 去重（连续相同的括号只需搜索一次）        if (lremove + rremove &gt; str.size() - i) return;  // 剪枝（剩余的字符数小于需删除的括号数）        if (lremove &gt; 0 &amp;&amp; str[i] == '(')                // 尝试删除一个左括号            helper(str.substr(0, i) + str.substr(i + 1), i, lremove - 1, rremove);        if (rremove &gt; 0 &amp;&amp; str[i] == ')')                // 尝试删除一个左括号            helper(str.substr(0, i) + str.substr(i + 1), i, lremove, rremove - 1);    &#125;&#125;vector&lt;int&gt; check(string&amp; s) &#123;    int lremove = 0; // 需移除的左括号数量（最小数量）    int rremove = 0; // 需移除的右括号数量（最小数量）    for (auto c : s) &#123;        if (c == '(') ++lremove;         // 左括号加一        else if (c == ')') &#123;            if (lremove == 0) ++rremove; // 右括号与左括号不匹配            else --lremove;              // 右括号与左括号匹配        &#125;    &#125;    return &#123;lremove, rremove&#125;;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times 2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串的长度</p><ul><li>一个长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的字符串最多可能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个子序列，遍历所有子序列需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 时间</li><li>每个子序列可能都需要进行一次合法性检测，需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，不考虑返回数组所需空间</p><ul><li>递归调用栈的最大深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次递归调用时都需要复制一次字符串 str，所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtaW52YWxpZC1wYXJlbnRoZXNlcy9zb2x1dGlvbi9zaGFuLWNodS13dS14aWFvLWRlLWd1YS1oYW8tYnktbGVldGNvZGUtOXc4YXUv">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 297. 二叉树的序列化与反序列化</title>
      <link href="/posts/f9871213/"/>
      <url>/posts/f9871213/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXJpYWxpemUtYW5kLWRlc2VyaWFsaXplLWJpbmFyeS10cmVlLw==">297. Serialize and Deserialize Binary Tree</span></p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9mYXEvI2JpbmFyeS10cmVl">LeetCode 序列化二叉树的格式</span> 。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例 1：</strong></p><p></p><pre><code>输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-前序遍历"><a class="anchor" href="#method-前序遍历">#</a> Method: 前序遍历</h1><p>算法思路：</p><p>序列化：按照前序遍历的顺序遍历二叉树，并将每个节点的数值转换成字符串记录下来。特别地，用 ',' 分隔每个节点的值，用 &quot;1001&quot; 标记空节点</p><p>反序列化：从字符串中提取出用 ',' 分隔的每一个数值，并按照前序遍历的顺序构造二叉树。特别地，如果遇到 &quot;1001&quot; ，则说明当前节点为空节点，无需继续构造其子树；如果遇到的不是 &quot;1001&quot; ，构造当前节点后还需递归构造其子树</p><p>代码实现：</p><pre><code class="language-cpp">class Codec &#123;public:    string serialize(TreeNode* root) &#123; // 序列化        string res = &quot;&quot;;        if (root == nullptr) &#123;            res += to_string(1001);            res.push_back(',');            return res;        &#125;        res += to_string(root-&gt;val);        res.push_back(',');        res += serialize(root-&gt;left);        res += serialize(root-&gt;right);        return res;    &#125;    TreeNode* deserialize(string data) &#123; // 反序列化        int start = 0;        return helper(data, start);    &#125;    TreeNode* helper(string&amp; data, int&amp; start) &#123; // 从 data 的第 start 位开始构造二叉树        TreeNode* root = nullptr;        int i = start;        while (i != data.size() &amp;&amp; data[i] != ',') ++i;        string str(data.begin() + start, data.begin() + i); // 获取 ',' 之间的字符        start = i + 1; // 更新起点        if (str != &quot;1001&quot;) &#123; // 非空节点            int num = stoi(str);            root = new TreeNode(num);            root-&gt;left = helper(data, start);            root-&gt;right = helper(data, start);        &#125;        return root;    &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec ser, deser;// TreeNode* ans = deser.deserialize(ser.serialize(root));</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 287. 寻找重复数</title>
      <link href="/posts/4b49476/"/>
      <url>/posts/4b49476/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1kdXBsaWNhdGUtbnVtYmVyLw==">287. Find the Duplicate Number</span></p><p>给定一个包含  <code>n + 1</code>  个整数的数组  <code>nums</code>  ，其数字都在  <code>[1, n]</code>  范围内（包括  <code>1</code>  和  <code>n</code> ），可知至少存在一个重复的整数。</p><p>假设  <code>nums</code>  只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组  <code>nums</code>  且只用常量级 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的额外空间。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,3,4,2,2]输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,1,3,4,2]输出：3</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>nums.length == n + 1</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code></li><li><code>nums</code>  中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 一次</li></ul><p><strong>进阶</strong>：</p><ul><li>如何证明  <code>nums</code>  中至少存在一个重复的数字？</li><li>你可以设计一个线性级时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的解决方案吗？</li></ul><h1 id="method-快慢指针"><a class="anchor" href="#method-快慢指针">#</a> Method: 快慢指针</h1><p>算法思路：</p><p>将数组视为一个链表，其中，数组的下标是一个指针，数组的元素也是一个指针，即，指针 0 指向 nums [0]，而 nums [0] 又指向 nums [nums [0]]</p><p>对于指针 i ，执行 i = nums [i] 即相当于将指针 i 右移一步，执行 i = nums [nums [i]] 即相当于将指针 i 右移两步</p><p>若数组中存在重复数字，则相当于（与数组等价的）链表存在环，重复数字即为环的入口，因此，可按 <a href="https://jiankychen.github.io/posts/fe4aea2">LeetCode 142. 环形链表 II</a> 进行求解</p><p>代码实现：</p><pre><code class="language-cpp">int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;    int fast = 0;    int slow = 0;    while (true) &#123;        fast = nums[nums[fast]];        slow = nums[slow];        if (fast == slow) &#123;            int index1 = 0;            int index2 = slow;            while (true) &#123;                index1 = nums[index1];                index2 = nums[index2];                if (index1 == index2)                    return index1; // 注意，重复数字是 index1，而不是 nums[index1]            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1kdXBsaWNhdGUtbnVtYmVyL3NvbHV0aW9uL2t1YWktbWFuLXpoaS16aGVuLWRlLWppZS1zaGktY29uZy1kYW1pZW5fdW5kb3hpZS1kLw==">zjczxz：快慢指针的解释</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX：跨 tex 文件的交叉引用</title>
      <link href="/posts/99cbc47e/"/>
      <url>/posts/99cbc47e/</url>
      
        <content type="html"><![CDATA[<h2 id="教程"><a class="anchor" href="#教程">#</a> 教程</h2><p>如果需要在 response.tex 中引用 revision.tex 的某一段文本，可通过以下步骤实现：</p><ol><li><p>在 revision.tex 中，将需要引用的文本放在  <code>%&lt;*tag&gt;</code>  和  <code>%&lt;/tag&gt;</code>  之间，即：</p><pre><code class="language-tex">%&lt;*tag&gt;Here is the text to be cited.%&lt;/tag&gt;</code></pre></li><li><p>在 response.tex 中，添加  <code>catchfilebetweentags</code>  这个包，即：</p><pre><code class="language-tex">\usepackage&#123;catchfilebetweentags&#125;</code></pre></li><li><p>在 response.tex 中，利用  <code>\ExecuteMetaData</code>  命令引用文本，即：</p><pre><code class="language-tex">\ExecuteMetaData[revision]&#123;tag&#125;</code></pre></li></ol><p>然而，如果需要引用的文本中包含了  <code>\ref</code>  、 <code>\eqref</code>  、 <code>\cite</code>  命令，response.tex 将无法正常编译以及显示编号</p><p>此时，还需要让 response.tex 获取 revision.tex 所生成的 labels 和 citations ，即，在  response.tex 中添加如下命令：</p><pre><code class="language-tex">% copy labels\usepackage&#123;xr&#125;\externaldocument&#123;revision&#125;% copy citations\usepackage&#123;xcite&#125;\externalcitedocument&#123;revision&#125;</code></pre><p>这是因为，revision.tex 生成的 labels 和 citations 全都保存在 revision.aux 文件中，而  <code>\externaldocument</code>  和  <code>\externalcitedocument</code>  可以分别读取 aux 文件中的 labels 和 citations</p><p>执行完以上操作，无论是 revision.tex 中的什么文本，都能在 response.tex 中正常编译并显示（测试使用的是 IEEE 的论文模板）</p><blockquote><p>可能不适用于其余期刊的论文模板，因为其他期刊论文模板可能修改了 aux 文件中 labels 和 citations 的格式（应该是都可以通过编译的，只不过显示效果依赖于期刊模板）</p></blockquote><h2 id="示例"><a class="anchor" href="#示例">#</a> 示例</h2><p>例如，在 revision.tex 中写到：</p><pre><code class="language-tex">%&lt;*lemma&gt;\blue&#123;The transmission energy consumption of an SN can be minimal when constraints \eqref&#123;eqn:power_low_energy_node&#125; - \eqref&#123;eqn:power_CH&#125; are met with equality.&#125;%&lt;/lemma&gt;</code></pre><p>在 response.tex 中引用 revision.tex 的内容：</p><pre><code class="language-tex">We have rewritten Lemma 1 as: ``\ExecuteMetaData[revision]&#123;lemma&#125;''</code></pre><p>编译得到的 response.pdf 显示：<br /><img data-src="/posts/99cbc47e/1.png" class=""><br /> 可以看到，revision.tex 对公式的引用，即，  <code>\eqref&#123;eqn:power_low_energy_node&#125; - \eqref&#123;eqn:power_CH&#125;</code>  ，也能在 response.tex 中正常编译（并且，response.pdf 显示出的公式编号与 revision.pdf 相同）</p><blockquote><p>为了使用  <code>\blue&#123;&#125;</code>  命令（使  <code>&#123;&#125;</code>  内的文字变蓝色），需要先在导言区定义： <code>\newcommand&#123;\blue&#125;[1]&#123;&#123;&#123;\color&#123;blue&#125; #1&#125;&#125;&#125;</code></p></blockquote><p>再例如，在 revision.tex 中写到：</p><pre><code class="language-tex">%&lt;*collection&gt;With CDG scheme \cite&#123;CDG2009&#125;, each SN sends the collected data along the data collection route to the CH, and the UAV flies to collect data along the trajectory obtained from the configuration phase.%&lt;/collection&gt;</code></pre><p>在 response.tex 中引用：</p><pre><code class="language-tex">To reveal the data collection mechanism, we have added the following sentence in Section IV: ``\blue&#123;\ExecuteMetaData[revision]&#123;collection&#125;&#125;''</code></pre><p>编译得到的 response.pdf 显示：<br /><img data-src="/posts/99cbc47e/2.png" class=""><br /> 可以看到，revision.tex 对参考文献的引用， <code>\cite&#123;CDG2009&#125;</code>  ，也能在 response.tex 中奏效</p><p>类似的，revision.tex 中关于表格（table）、算法（algorithm）、图片（figure）等的引用（通过 \label 命令打标签、通过 \ref 命令引用），也能采用以上方式在 response.tex 中正常编译并显示</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> LaTeX </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 240. 搜索二维矩阵 II</title>
      <link href="/posts/cf6f6c2f/"/>
      <url>/posts/cf6f6c2f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgtaWkv">240. Search a 2D Matrix II</span></p><p>编写一个高效的算法来搜索  <code>m x n</code>  矩阵  <code>matrix</code>  中的一个目标值  <code>target</code>  。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="/posts/cf6f6c2f/Example1.jpg" class=""></p><pre><code>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5输出：true</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/cf6f6c2f/Example2.jpg" class=""></p><pre><code>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code> ,  <code>m</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">\le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>matrix[i][j]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>每行的所有元素从左到右升序排列</li><li>每列的所有元素从上到下升序排列</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>注意，在本题中，每行的第一个整数不一定大于前一行的最后一个整数</p><p>本题有以下几种解法：</p><ol><li><p>暴力查找：遍历整个矩阵</p></li><li><p>变形的二分查找：找到矩阵的中心（记作 (midx, midy) ），通过比较 matrix [midx][midy] 与 target 的大小来排除一部分元素（见 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9zdWJtaXNzaW9ucy9kZXRhaWwvMzU1MDg3MTg0Lw==">LeetCode 提交记录</span> ）</p><ul><li>若 matrix [midx][midy] 等于 target，则已经找到 target，返回 true</li><li>若 matrix [midx][midy] 小于 target，对于任意 x &lt;= midx 且 y &lt;= midy 的 (x, y)，均有 matrix [x][y] &lt; target，故而可排除所有满足  x &lt;= midx 且 y &lt;= midy 的 (x, y)，然后对剩余区域继续搜索</li><li>若 matrix [midx][midy] 大于 target，对于任意 x &gt;= midx 且 y &gt;= midy 的 (x, y)，均有 matrix [x][y] &gt; target，故而可排除所有满足  x &gt;= midx 且 y &gt;= midy 的 (x, y)，然后对剩余区域继续搜索</li><li>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 表示当前矩阵的行数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 表示当前矩阵的列数，则可排除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>4</mn></mfrac><mi>m</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\frac{1}{4} m n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span></span></span></span> 个元素</li></ul></li><li><p>逐行二分查找：矩阵的每一行元素都按升序排列，可对每一行使用二分查找（可进一步优化：若当前行的第一个元素大于 target ，则当前行与后续行均不会含有 target，可直接返回 false ；若当前行的最后一个元素小于 target，同样可直接返回 false）</p></li><li><p>抽象二叉搜素树</p></li></ol><h1 id="method-抽象二叉搜索树"><a class="anchor" href="#method-抽象二叉搜索树">#</a> Method: 抽象二叉搜索树</h1><p>算法思路：</p><p>我们可以将二维矩阵中的每个元素视为一个树节点，将整个二维矩阵抽象成一棵以矩阵右上角元素为根的二叉搜索树，此时，每个节点的正左方元素即为它的左子树，正下方元素即为它的右子树</p><p>于是，从矩阵 matrix 的右上角（索引为 (0, matrix [0].size () - 1) ）开始搜索，假设当前搜索到的节点为 (x, y)</p><ul><li>若 matrix [x][y] 小于 target，则应搜索当前节点的右子树（即，当前矩阵位置的正下方元素），故而执行 ++x 。（也可以这样理解：x 这一行的左边元素都小于 target，应搜索下一行）</li><li>若 matrix [x][y] 大于 target，则应搜索当前节点的左子树（即，当前矩阵位置的正左方元素），故而执行 --y 。（也可以这样理解：y 这一列的下边元素都小于 target，应搜索左边一列）</li></ul><p>代码实现：</p><pre><code class="language-cpp">bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;    int x = 0;    int y = matrix[0].size() - 1;    while (x &lt;= matrix.size() - 1 &amp;&amp; y &gt;= 0) &#123;        if (matrix[x][y] == target) return true;        else if (matrix[x][y] &lt; target) ++x;        else --y;    &#125;    return false;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是矩阵 matrix 的行数与列数。从 (0, n - 1) 位置开始搜索，x 最多能被增加 m 次，y 最多能被减小 n 次，故而总搜索次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgtaWkvc29sdXRpb24vc291LXN1by1lci13ZWktanUtemhlbi1paS1ieS1sZWV0Y29kZS1zby05aGN4Lw==">leetcode-solution</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgtaWkvc29sdXRpb24vZ29uZy1zaHVpLXNhbi14aWUteWktdGktc2h1YW5nLWppZS1lci1mZS15MW5zLw==">宫水三叶</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 238. 除自身以外数组的乘积</title>
      <link href="/posts/5f7bf763/"/>
      <url>/posts/5f7bf763/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmLw==">238. Product of Array Except Self</span></p><p>给你一个整数数组  <code>nums</code> ，返回 数组  <code>answer</code>  ，其中  <code>answer[i]</code>  等于  <code>nums</code>  中除  <code>nums[i]</code>  之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组  <code>nums</code>  之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请<strong>不要使用除法</strong>，且在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度内完成此题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,4]输出：[24,12,8,6]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [-1,1,0,-3,3]输出：[0,0,9,0,0]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>30</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-30 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li>数组  <code>nums</code>  之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内</li></ul><p><strong>进阶</strong>：Can you solve the problem in  <code>O(1)</code>  extra space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p><h1 id="method-1-左右乘积列表"><a class="anchor" href="#method-1-左右乘积列表">#</a> Method 1: 左右乘积列表</h1><p>算法思路：</p><p>对于索引 i ，分别计算其左侧所有数字（前缀）的乘积和右侧所有数字（后缀）的乘积，将这两个乘积相乘即为 answer [i]</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;    // 计算索引 i 左侧所有元素的乘积，其中，left[1] 取值为 1    vector&lt;int&gt; left(nums.size(), 1);  // left[i] 表示区间 [0, i - 1] 内所有元素的乘积    for (int i = 1; i &lt; nums.size(); ++i) &#123;        left[i] = left[i - 1] * nums[i - 1];    &#125;    // 计算索引 i 右侧所有元素的乘积，其中，right[nums.size() - 1] 取值为 1    vector&lt;int&gt; right(nums.size(), 1); // right[i] 表示区间 [i + 1, nums.size() - 1] 内所有元素的乘积    for (int i = nums.size() - 2; i &gt;= 0; --i) &#123;        right[i] = right[i + 1] * nums[i + 1];    &#125;    // 计算 answer[i]    vector&lt;int&gt; answer(nums.size(), 1);    for (int i = 0; i &lt; nums.size(); ++i) &#123;        answer[i] = left[i] * right[i];    &#125;    return answer;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-利用答案数组实现-o1-空间复杂度"><a class="anchor" href="#method-2-利用答案数组实现-o1-空间复杂度">#</a> Method 2: 利用答案数组实现 O (1) 空间复杂度</h1><p>算法思路：</p><p>由于输出数组不被视为额外空间，可以利用输出数组来实现 O (1) 空间复杂度：</p><ul><li>先将输出数组视为 left 数组（即，先利用 answer [i] 表示索引 i 左侧所有元素的乘积）</li><li>然后利用临时变量 tmp 记录索引 i 右侧所有元素的乘积，并维护 answer 数组</li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; answer(nums.size(), 1);    for (int i = 1; i &lt; nums.size(); ++i) &#123;        answer[i] = answer[i - 1] * nums[i - 1]; // 索引 i 左侧所有元素的乘积    &#125;    int tmp = 1;    // 索引 i 右侧所有元素的乘积    for (int i = nums.size() - 1; i &gt;= 0; --i) &#123;        answer[i] = answer[i] * tmp; // 更新 answer 数组        tmp = tmp * nums[i];         // 更新 tmp    &#125;    return answer;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑输出数组所占空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmL3NvbHV0aW9uL2NodS16aS1zaGVuLXlpLXdhaS1zaHUtenUtZGUtY2hlbmctamktYnktbGVldGNvZGUtLw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 221. 最大正方形</title>
      <link href="/posts/1699b494/"/>
      <url>/posts/1699b494/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXNxdWFyZS8=">221. Maximal Square</span></p><p>在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/1699b494/Example1.jpg" class=""></p><pre><code>输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：4</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/1699b494/Example2.jpg" class=""></p><pre><code>输入：matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：matrix = [[&quot;0&quot;]]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>matrix[i][j]</code>  为  <code>'0'</code>  或  <code>'1'</code></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组：dp [i][j] 表示以 (i, j) 为右下角、只包含 '1' 的正方形的最大边长</p><p>确定递推公式：</p><ul><li>如果位置 (i, j) 的值是 '0' ，则 dp [i][j] = 0</li><li>如果位置 (i, j) 的值是 '1' ，则 dp [i][j] 依赖于其上方、左方和左上方这三个相邻位置的 dp 值，dp [i][j] = min ({dp [i - 1][j - 1], dp [i - 1][j], dp [i][j - 1]}) + 1</li></ul><blockquote><p>需结合具体实例来理解递推公式，其详细证明可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1zcXVhcmUtc3VibWF0cmljZXMtd2l0aC1hbGwtb25lcy9zb2x1dGlvbi90b25nLWppLXF1YW4td2VpLTEtZGUtemhlbmctZmFuZy14aW5nLXppLWp1LXpoZW4tMi8=">力扣官方题解：统计全为 1 的正方形子矩阵</span></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;    int m = matrix.size();    int n = matrix[0].size();    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));    int sideLength = 0; // 最大边长    for (int i = 0; i &lt; m; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            if (matrix[i][j] == '1') &#123;                if (i == 0 || j == 0)                    dp[i][j] = 1;                else                    dp[i][j] = min(&#123;dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]&#125;) + 1;                sideLength = max(sideLength, dp[i][j]);            &#125;        &#125;    &#125;    int ans = sideLength * sideLength; // 面积    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是矩阵的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXNxdWFyZS9zb2x1dGlvbi96dWktZGEtemhlbmctZmFuZy14aW5nLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 215. 数组中的第 K 个最大元素</title>
      <link href="/posts/2afe4d97/"/>
      <url>/posts/2afe4d97/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtbGFyZ2VzdC1lbGVtZW50LWluLWFuLWFycmF5Lw==">215. Kth Largest Element in an Array</span></p><p>给定整数数组  <code>nums</code>  和整数  <code>k</code> ，请返回数组中第  <code>k</code>  个最大的元素。</p><p>请注意，你需要找的是数组排序后的第  <code>k</code>  个最大的元素，而不是第  <code>k</code>  个不同的元素。</p><p>你必须设计并实现时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,2,1,5,6,4], k = 2输出：5</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,3,1,2,4,5,5,6], k = 4输出：4</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>数组第 k 个最大元素，即，数组降序排序后的第 k 个元素（或者，升序排序后的倒数第 k 个元素）</p><p>对整个数组排序的时间复杂度至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>有一种基于快速排序的算法，可以确定某一个元素在排序以后的位置，即，<strong>快速选择</strong> 算法</p><h1 id="method-1-基于快速排序的选择方法"><a class="anchor" href="#method-1-基于快速排序的选择方法">#</a> Method 1: 基于快速排序的选择方法</h1><p>算法思路：（以 寻找降序排序后的第 k 个元素 为例）</p><p>快速排序的划分操作：从区间 [left, right] 中选择任意一个元素作为基准，调整子数组，使得位置 p 左侧的元素都大于等于基准元素，位置 p 右侧的元素都小于基准元素，于是，基准元素的最终位置就是 p</p><p>即，nums [p] 左侧元素全都大于等于 nums [p]，nums [q] 右侧元素全都小于 nums [p]，于是，nums [p] 就是第 p + 1 个最大元素（数组索引从 0 开始）</p><p>因此，可按如下方案求解该问题：</p><ul><li><p>如果某次划分的 p 为 k - 1 时，即找到了第 k 个最大元素，可直接返回 nums [p]</p></li><li><p>如果 p 小于 k - 1，则需要查找值更小的元素，即，继续划分 p 右侧的子区间</p></li><li><p>如果 p 大于 k - 1，则需要查找值更大的元素，即，继续划分 p 左侧的子区间</p></li></ul><p>特别地，我们应随机选择基准元素，使得快速算法算法的时间代价的期望为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>代码实现：</p><pre><code class="language-cpp">// 划分子序列int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; // 随机选择基准，以该基准作为分界线    int x = left + rand() % (right - left + 1); // 随机生成一个位于区间 [left, right] 内的数    int pivot = nums[x];        // 划分子序列的基准    swap(nums[x], nums[right]); // 将基准移至最右侧    int pos = left - 1;         // 分界线 pos 及其左边的元素一定大于等于 pivot    for (int i = left; i &lt; right; ++i) &#123; // 划分子序列        if (nums[i] &gt;= pivot)            swap(nums[++pos], nums[i]);    &#125;    swap(nums[++pos], nums[right]); // 将 pivot 放到分界线位置    return pos; // 分界线&#125;// 快速选择int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int index) &#123; // 寻找降序排列后下标为 index 的元素    while (true) &#123; // 为降低空间复杂度，这里采用 while 循环，而不采用递归        int pos = partition(nums, left, right); // nums[pos] 为第 pos + 1 个最大元素（数组索引从 0 开始）        if (pos == index)     // 寻找到目标下标，该位置元素值即为第 k 个最大元素            return nums[pos];        else if (pos &lt; index) // 分界线在目标下标左侧            left = pos + 1;        else                  // 分界线在目标下标右侧            right = pos - 1;    &#125;&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    srand(time(0));    return quickSelect(nums, 0, nums.size() - 1, k - 1);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtbGFyZ2VzdC1lbGVtZW50LWluLWFuLWFycmF5L3NvbHV0aW9uL3NodS16dS16aG9uZy1kZS1kaS1rZ2UtenVpLWRhLXl1YW4tc3UtYnktbGVldGNvZGUtLw==">leetcode-solution</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtbGFyZ2VzdC1lbGVtZW50LWluLWFuLWFycmF5L3NvbHV0aW9uL3BhcnRpdGlvbmZlbi1lci16aGktemhpLXlvdS14aWFuLWR1aS1saWUtamF2YS1kYWktLw==">liweiwei1419</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 208. 实现 Trie (前缀树)</title>
      <link href="/posts/e9240da8/"/>
      <url>/posts/e9240da8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZS8=">208. Implement Trie (Prefix Tree)</span></p><p><strong>Trie</strong>（发音类似 &quot;try&quot;）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现  <code>Trie</code>  类：</p><ul><li><code>Trie()</code>  初始化前缀树对象。</li><li><code>void insert(String word)</code>  向前缀树中插入字符串  <code>word</code>  。</li><li><code>boolean search(String word)</code>  如果字符串  <code>word</code>  在前缀树中，返回  <code>true</code> （即，在检索之前已经插入）；否则，返回  <code>false</code>  。</li><li><code>boolean startsWith(String prefix)</code>  如果之前已经插入的字符串  <code>word</code>  的前缀之一为  <code>prefix</code>  ，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</li></ul><p><strong>示例：</strong></p><pre><code>输入:[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]输出：[null, null, true, false, true, null, true]解释：Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // 返回 Truetrie.search(&quot;app&quot;);     // 返回 Falsetrie.startsWith(&quot;app&quot;); // 返回 Truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;);     // 返回 True</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>word.length</code> ,  <code>prefix.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">\le 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>word</code>  和  <code>prefix</code>  仅由小写英文字母组成</li><li><code>insert</code> 、 <code>search</code>  和  <code>startsWith</code>  调用次数 总计 不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 次</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>Trie 又称前缀树或字典树，是一种用于快速查询 某个字符串 / 字符前缀 是否存在的数据结构</p><p>Trie 的每个节点包含以下字段：</p><ul><li>指向子节点的指针数组 children</li><li>布尔字段 isEnd，表示该节点是否为字符串的结尾</li></ul><p>例如：<br /></p><h1 id="method-字典树"><a class="anchor" href="#method-字典树">#</a> Method: 字典树</h1><p>算法思路：</p><p>本题的 children 数组的长度为 26，即小写英文字母的数量，其中，children [0] 对应 a，children [25] 对应 z</p><p>定义函数 Trie* searchPrefix (string prefix) 用于判断字典树是否存在前缀 prefix ：若搜索到了前缀的末尾，就说明字典树中存在该前缀，否则，字典树不存在该前缀</p><p>特别地，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串</p><p>代码实现：</p><pre><code class="language-cpp">class Trie &#123;private:    Trie* children[26];    bool isEnd;    Trie* searchPrefix(string prefix) &#123; // 判断字典树是否存在前缀 prefix        Trie* node = this;        for (auto c : prefix) &#123;            int tmp = c - 'a';            if (node-&gt;children[tmp] == nullptr) // 不存在 prefix，返回空指针                return nullptr;            node = node-&gt;children[tmp];        &#125;        return node; // 存在 prefix，则返回末尾指针    &#125;public:    Trie() &#123;        isEnd = false;        for(int i = 0; i &lt; 26; ++i)            children[i] = nullptr;    &#125;    ~Trie() &#123; // 析构函数，避免内存泄漏        for (int i = 0; i &lt; 26; ++i) &#123;            if (children[i] != nullptr)                delete children[i];        &#125;    &#125;        void insert(string word) &#123; // 插入字符串 word        Trie* node = this;        for (auto c : word) &#123;            int tmp = c - 'a';            if (node-&gt;children[tmp] == nullptr)                node-&gt;children[tmp] = new Trie();            node = node-&gt;children[tmp];        &#125;        node-&gt;isEnd = true;    &#125;        bool search(string word) &#123; // 判断字符串 word 是否存在        Trie* node = this-&gt;searchPrefix(word);        return node != nullptr &amp;&amp; node-&gt;isEnd;    &#125;        bool startsWith(string prefix) &#123; // 判断前缀 prefix 是否存在        return this-&gt;searchPrefix(prefix) != nullptr;    &#125;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); */</code></pre><p>时间复杂度：初始化所需时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其余操作所需时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert S \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert S \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span> 是每次插入或查询的字符串的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mo>⋅</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert T \vert \cdot \vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert T \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">∣</span></span></span></span> 是插入字典树中的所有字符串的长度之和，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 是字符集的大小（本题 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>26</mn></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert = 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span>）</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZS9zb2x1dGlvbi9zaGkteGlhbi10cmllLXFpYW4temh1aS1zaHUtYnktbGVldGNvZGUtdGk1MDAv">leetcode-solution</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZS9zb2x1dGlvbi9nb25nLXNodWktc2FuLXhpZS15aS10aS1zaHVhbmctamllLWVyLXdlLWVzbTkv">宫水三叶</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 207. 课程表</title>
      <link href="/posts/a888c0b0/"/>
      <url>/posts/a888c0b0/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Vyc2Utc2NoZWR1bGUv">207. Course Schedule</span></p><p>你这个学期必须选修  <code>numCourses</code>  门课程，记为  <code>0</code>  到  <code>numCourses - 1</code>  。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组  <code>prerequisites</code>  给出，其中  <code>prerequisites[i] = [ai, bi]</code>  ，表示如果要学习课程  <code>ai</code>  则 必须 先学习课程   <code>bi</code>  。</p><ul><li>例如，先修课程对  <code>[0, 1]</code>  表示：想要学习课程  <code>0</code>  ，你需要先完成课程  <code>1</code>  。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0]]输出：true解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>numCourses</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">\le 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prerequisites.length</code>  \le 5000$</li><li><code>prerequisites[i].length</code>  == 2</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>ai</code> ,  <code>bi</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span>  <code>numCourses</code></li><li><code>prerequisites[i]</code>  中的所有课程对 互不相同</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：</p><ul><li>对于图 G 中的任意一条有向边 (u, v)，u 在排列中都出现在 v 的前面</li></ul><p>那么称该排列是图 G 的 <strong>拓扑排序</strong></p><p>根据上述定义，有以下结论：</p><ul><li>如果图 G 中存在环（即图 G 不是 <strong>有向无环图</strong> ），图 G 不存在拓扑排序</li><li>如果图 G 是有向无环图，它的拓扑排序可能不止一种</li></ul><p>在本题中，我们可以将每一门课看成一个节点，如果学习课程 A 之前必须完成课程 B，则可以连接一条从 B 到 A 的有向边，然后判断该图是否存在拓扑排序（也就是判断该图是否为有向无环图）</p><h1 id="method-1-广度优先遍历"><a class="anchor" href="#method-1-广度优先遍历">#</a> Method 1: 广度优先遍历</h1><p>算法思路：</p><p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）</p><p>算法流程：</p><p>使用一个队列来进行广度优先搜索：初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且，它们之间的相对顺序是无关紧要的</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><ul><li><p>将 u 放入答案数组中</p></li><li><p>移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，就将 v 放入答案数组中</p></li></ul><p>在广度优先搜索的过程结束后，如果答案数组中包含了这 numCourses 个节点，那就说明我们找到了一种拓扑排序，否则，说明图中存在环，也就不存在拓扑排序了</p><blockquote><p>特别地，可以只用一个变量来记录入度为 0 的节点个数，而无需将节点实际放入答案数组中。在广度优先搜索结束后，判断该变量的值是否等于课程数，就能知道是否存在一种拓扑排序</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;    vector&lt;vector&lt;int&gt;&gt; edges; // 有向图的边（邻接表）    vector&lt;int&gt; indeg;         // 节点的入度    edges.resize(numCourses);    indeg.resize(numCourses);    for (auto info : prerequisites) &#123;        edges[info[1]].push_back(info[0]); // 建立一条从 info[1] 到 info[0] 的有向边        ++indeg[info[0]];                  // 更新节点 info[0] 的入度    &#125;    queue&lt;int&gt; que;  // 存放入度为 0 的节点    for (int i = 0; i &lt; numCourses; ++i) &#123;        if (indeg[i] == 0) que.push(i);    &#125;    int visited = 0; // 入度为 0 的节点个数（可选修的课程数）    while (!que.empty()) &#123;        ++visited;        int u = que.front();        que.pop();        for (int v : edges[u]) &#123; // 移除 u 的所有出边            --indeg[v];            if (indeg[v] == 0) que.push(v);        &#125;    &#125;        return visited == numCourses;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为课程数（即，numCourses），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 为先修课程的要求数（即，prerequisites 中一维数组的数量）</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中，邻接表所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，队列所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-深度优先搜索"><a class="anchor" href="#method-2-深度优先搜索">#</a> Method 2: 深度优先搜索</h1><p>算法思路：</p><p>借助一个标志列表 flags，用于判断每个节点 i （课程）的状态</p><ul><li>未被访问：flags [i] == 0</li><li>被其他节点启动的深度优先搜索访问过：flags [i] == -1</li><li>被当前节点启动的深度优先搜索访问过：flags [i] == 1</li></ul><p>对 numCourses 个节点依次执行深度优先搜索，判断以每个节点起步的深度优先搜索是否存在环，若存在环直接返回 false</p><ul><li>终止条件：<ul><li>当 flag [i] == -1，说明当前访问节点已被其他节点启动的深度优先搜索访问过，无需再重复搜索，直接返回 true</li><li>当 flag [i] == 1，说明在本轮深度优先搜索中节点 i 被第 2 次访问，即，有环存在，直接返回 false</li></ul></li><li>将当前访问节点 i 对应 flag [i] 置 1</li><li>递归访问当前节点 i 的所有邻接节点 j，若发现环则直接返回 false</li><li>当前节点所有邻接节点已被遍历，并没有发现环，将当前节点 flag 置为 -1 并返回 true</li></ul><p>待整个图的深度优先搜索结束，如果未发现环，返回 true</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; edges;vector&lt;int&gt; flags;bool DFS(int i) &#123; // 判断是否存在以 i 起始的拓扑排序    if (flags[i] == -1) return true;    if (flags[i] == 1) return false;    flags[i] = 1;    for (int j : edges[i]) &#123;        if (DFS(j) == false) return false;    &#125;    flags[i] = -1;    return true;&#125;bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;    edges.resize(numCourses);    flags.resize(numCourses);    for (auto info : prerequisites) &#123;        edges[info[1]].push_back(info[0]);    &#125;    for (int i = 0; i &lt; numCourses; ++i) &#123;        if (flags[i] == 0) &#123;            if (DFS(i) == false) return false;        &#125;    &#125;    return true;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Vyc2Utc2NoZWR1bGUvc29sdXRpb24va2UtY2hlbmctYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 234. 回文链表</title>
      <link href="/posts/8ec137cf/"/>
      <url>/posts/8ec137cf/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0Lw==">234. Palindrome Linked List</span></p><p>给你一个单链表的头节点  <code>head</code>  ，请你判断该链表是否为回文链表。如果是，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/8ec137cf/Example1.jpg" class=""></p><pre><code>输入：head = [1,2,2,1]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/8ec137cf/Example2.jpg" class=""></p><pre><code>输入：head = [1,2]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></li></ul><p><strong>进阶</strong>：你能否用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 空间复杂度解决此题？</p><h1 id="method-1-栈"><a class="anchor" href="#method-1-栈">#</a> Method 1: 栈</h1><p>算法思路：先将所有链表节点入栈（栈具有先进后出的特点），然后将栈顶元素的值与原链表的值进行比较，并依次出栈</p><p>代码实现：</p><pre><code class="language-cpp">bool isPalindrome(ListNode* head) &#123;    stack&lt;ListNode*&gt; stk;    ListNode* cur = head;    while (cur) &#123;        stk.push(cur);        cur = cur-&gt;next;    &#125;    cur = head;    ListNode* tmp = nullptr;    while (cur) &#123;        tmp = stk.top();        if (tmp-&gt;val != cur-&gt;val) return false;        stk.pop();        cur = cur-&gt;next;    &#125;    return true;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-双指针"><a class="anchor" href="#method-2-双指针">#</a> Method 2: 双指针</h1><p>算法思路：</p><p>首先利用快慢指针找出链表的中间节点，将链表分割成两个子链表（如果链表节点数为奇数，则将中间节点划入第一个子链表）</p><ul><li>若链表节点数为奇数，快慢指针的最终位置应为：慢指针应指向正中间的节点，快指针指向最后一个节点</li><li>若链表节点数为奇数，快慢指针的最终位置应为：慢指针应指向左侧的中间节点，快指针指向倒数第二个节点</li><li>由此可推断出，移动快慢指针的条件为： <code>fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr</code></li></ul><p>然后反转第二个子链表，将第一个子链表与反转后的第二个子链表进行比较，若对应节点值相等，则原链表为回文链表，否则，原链表不是回文链表</p><p>最后，需要将链表恢复原样</p><p>代码实现：</p><pre><code class="language-cpp">ListNode* findMidPoint(ListNode* head) &#123; // 寻找链表的中间节点    ListNode* fast = head;    ListNode* slow = head;    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; // 快指针移动到链表末尾，慢指针移动到链表中间        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;    &#125;    return slow;&#125;ListNode* reverseLinkedList(ListNode* head) &#123; // 反转链表    ListNode* pre = nullptr;    ListNode* cur = head;    ListNode* tmp = nullptr;    while (cur) &#123;        tmp = cur-&gt;next;        cur-&gt;next = pre;        pre = cur;        cur = tmp;    &#125;    return pre;&#125;bool isPalindrome(ListNode* head) &#123;    if (head == nullptr) return true;    ListNode* midpoint = findMidPoint(head); // 链表的中间节点    ListNode* temp1 = head; // 第一段子链表的头部    ListNode* head2 = reverseLinkedList(midpoint-&gt;next); // 第二段子链表的头部    ListNode* temp2 = head2;    while (temp2 != nullptr) &#123;        if (temp1-&gt;val != temp2-&gt;val) break;        temp1 = temp1-&gt;next;        temp2 = temp2-&gt;next;    &#125;    bool ans = (temp2 == nullptr);    midpoint-&gt;next = reverseLinkedList(head2); // 还原链表    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 200. 岛屿数量</title>
      <link href="/posts/9ee04cc9/"/>
      <url>/posts/9ee04cc9/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy8=">200. Number of Islands</span></p><p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和 / 或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><pre><code>输入：grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code>  的值为 '0' 或 '1'</li></ul><h1 id="method-1-深度优先搜索"><a class="anchor" href="#method-1-深度优先搜索">#</a> Method 1: 深度优先搜索</h1><p>算法思路：</p><p>扫描整个二维网格，如果某一个位置为 '1'，则表示查找到一个岛屿，此时需以其为起始位置开始进行深度优先搜索</p><p>深度优先搜索的具体操作：</p><ul><li>将搜索到的 '1' 重新标记为 '0'</li><li>从该位置出发，向 4 个方向探索与之相连的位置</li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;;void helper(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123;    int m = grid.size();    int n = grid[0].size();    grid[i][j] = '0'; // 标记 (i, j) 位置，表示已访问过该位置    for (int k = 0; k &lt; 4; ++k) &#123; // 向四个方向进行搜索        int newi = i + directions[k][0];        int newj = j + directions[k][1];        if (newi &gt;= 0 &amp;&amp; newi &lt; m &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; n) &#123;            if (grid[newi][newj] == '1')                helper(grid, newi, newj);        &#125;    &#125;&#125;int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;    int m = grid.size();    int n = grid[0].size();    int ans = 0;    for (int i = 0; i &lt; m; ++i) &#123;    // 遍历起点位置        for (int j = 0; j &lt; n; ++j) &#123;            if (grid[i][j] == '1') &#123; // 发现一座岛屿                helper(grid, i, j);  // 扫描整块岛屿                ++ans;               // 岛屿数量加 1            &#125;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二维网格的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，最坏情况下，递归的深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><h1 id="method-2-广度优先搜索"><a class="anchor" href="#method-2-广度优先搜索">#</a> Method 2: 广度优先搜索</h1><p>算法思路：</p><p>扫描整个二维网格，每发现一个位置为 '1'，就表示查找到一个岛屿，将该位置加入队列，针对该岛屿开始广度优先搜索，直到队列为空</p><ul><li>将搜索到的 '1' 重新标记为 '0'</li><li>从该位置出发，向 4 个方向探索与之相连的位置</li></ul><p>代码实现：</p><pre><code class="language-cpp">int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;    int m = grid.size();    int n = grid[0].size();    int ans = 0;    vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;&#125;;    for (int i = 0; i &lt; m; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            if (grid[i][j] == '1') &#123;                ++ans;                grid[i][j] = '0';                queue&lt;pair&lt;int, int&gt;&gt; que;                que.push(&#123;i, j&#125;);                while (!que.empty()) &#123;                    auto neighbor = que.front();                    que.pop();                    int x = neighbor.first;                    int y = neighbor.second;                    for (int k = 0; k &lt; 4; ++k) &#123;                        int newx = x + directions[k][0];                        int newy = y + directions[k][1];                        if (0 &lt;= newx &amp;&amp; newx &lt; m &amp;&amp; 0 &lt;= newy &amp;&amp; newy &lt; n) &#123;                            if (grid[newx][newy] == '1') &#123;                                que.push(&#123;newx, newy&#125;);                                grid[newx][newy] = '0';                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二维网格的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m \times n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，在最坏情况下，整个网格均为陆地，队列的大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min(m, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 169. 多数元素</title>
      <link href="/posts/7b7c8ac4/"/>
      <url>/posts/7b7c8ac4/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50Lw==">169. Majority Element</span></p><p>给定一个大小为  <code>n</code>  的数组  <code>nums</code>  ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong>  <code>⌊ n / 2 ⌋</code>  的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,2,3]输出：3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,2,1,1,1,2,2]输出：2</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶：</strong> 尝试设计时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>、空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的算法解决此问题。</p><h1 id="method-1-哈希表"><a class="anchor" href="#method-1-哈希表">#</a> Method 1: 哈希表</h1><p>算法思路：</p><p>使用哈希映射（HashMap）来存储每个元素以及出现的次数：对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数</p><p>遍历数组 nums 并统计数组中的每个元素的出现次数，若遇到出现次数大于 ⌊n / 2⌋ 的元素，直接返回</p><p>代码实现：</p><pre><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    unordered_map&lt;int, int&gt; hash;    int temp = nums.size() / 2;    int ans = 0;    for (int num : nums) &#123;        ++hash[num];        if (hash[num] &gt; temp) &#123;            ans = num;            break;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-排序"><a class="anchor" href="#method-2-排序">#</a> Method 2: 排序</h1><p>算法思路：</p><p>将数组 nums 中的所有元素按照单调递增（或单调递减）的顺序排序，下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \dfrac{n}{2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span> 的元素（下标从 0 开始）一定是众数</p><p>代码实现：</p><pre><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end());    return nums[nums.size() / 2];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><h1 id="method-3-boyer-moore-投票法"><a class="anchor" href="#method-3-boyer-moore-投票法">#</a> Method 3: Boyer-Moore 投票法</h1><p>算法思路：</p><p>维护一个候选众数 candidate 和它出现的次数 count，初始时 candidate 可以为任意值，count 为 0</p><p>遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p><ul><li><p>如果 x 与 candidate 相等，那么计数器 count 的值增加 1</p></li><li><p>如果 x 与 candidate 不等，那么计数器 count 的值减少 1</p></li></ul><p>在遍历完成后，candidate 即为整个数组的众数</p><p>代码实现：</p><pre><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int candidate = 0;    int count = 0;    for (int num : nums) &#123;        if (num == candidate) ++count;        else &#123;            --count;            if (count &lt; 0) &#123;                candidate = num;                count = 1;            &#125;        &#125;    &#125;    return candidate;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50L3NvbHV0aW9uL2R1by1zaHUteXVhbi1zdS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 155. 最小栈</title>
      <link href="/posts/a4f04f78/"/>
      <url>/posts/a4f04f78/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2sv">155. Min Stack</span></p><p>设计一个支持  <code>push</code>  ， <code>pop</code>  ， <code>top</code>  操作，并能在常数时间内检索到最小元素的栈。</p><p>实现  <code>MinStack</code>  类:</p><ul><li><code>MinStack()</code>  初始化堆栈对象。</li><li><code>void push(int val)</code>  将元素 val 推入堆栈。</li><li><code>void pop()</code>  删除堆栈顶部的元素。</li><li><code>int top()</code>  获取堆栈顶部的元素。</li><li><code>int getMin()</code>  获取堆栈中的最小元素。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li><code>pop</code> 、 <code>top</code>  和  <code>getMin</code>  操作总是在 非空栈 上调用</li><li><code>push</code> 、 <code>pop</code> 、 <code>top</code>  和  <code>getMin</code>  最多被调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 次</li></ul><h1 id="method-辅助栈"><a class="anchor" href="#method-辅助栈">#</a> Method: 辅助栈</h1><p>算法思路：</p><p>定义一个元素栈（记作 stk），用于存储每个元素</p><p>定义一个辅助栈（记作 minStk），用于存储与每个元素对应的最小值（与元素值同步插入与删除）</p><ul><li><p>当一个元素要入栈到 stk 时，我们取辅助栈 minStk 的栈顶元素与当前元素比较，将最小值插入辅助栈 minStk 中</p></li><li><p>当一个元素要从 stk 中弹出时，我们把辅助栈 minStk 的栈顶元素也相应弹出</p></li><li><p>在任意时刻，栈 stk 内的元素最小值就是辅助栈 minStk 的栈顶元素</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">class MinStack &#123;public:    stack&lt;int&gt; stk;    stack&lt;int&gt; minStk; // 辅助栈    MinStack() &#123;        minStk.push(INT_MAX); // 初始化辅助栈    &#125;        void push(int val) &#123;        stk.push(val);        minStk.push(min(val, minStk.top()));    &#125;        void pop() &#123;        stk.pop();        minStk.pop();    &#125;        int top() &#123;        return stk.top();    &#125;        int getMin() &#123;        return minStk.top();    &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(val); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */</code></pre><p>时间复杂度：入栈、出栈、获取栈顶元素、获取最小元素的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为元素个数，考虑了辅助栈所需的额外空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2svc29sdXRpb24venVpLXhpYW8temhhbi1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 152. 乘积最大子数组</title>
      <link href="/posts/4491e4cd/"/>
      <url>/posts/4491e4cd/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkv">152. Maximum Product Subarray</span></p><p>给你一个整数数组  <code>nums</code>  ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32 - 位</strong> 整数。</p><p><strong>子数组</strong> 是数组的连续子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,-2,4]输出：6解释：子数组 [2,3] 有最大乘积 6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [-2,0,-1]输出：0解释：结果不能为 2, 因为 [-2,-1] 不是子数组</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><code>nums</code>  的任何前缀或后缀的乘积都 保证 是一个 32 - 位 整数</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>由于数组 nums 存在负数，子数组的乘积可能会出现 “最大的正数变成最小的负数”、“ 最小的负数变成最大的正数 ” 这两种情况</p><p>因此，我们可以分别定义 maxValue 数组和 minValue 数组</p><ul><li>maxValue [i] 表示以 nums [i] 结尾的乘积最大子数组的乘积</li><li>minValue [i] 表示以 nums [i] 结尾的乘积最小子数组的乘积</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxProduct(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; maxValue(nums.size(), 0);    vector&lt;int&gt; minValue(nums.size(), 0);    int ans = nums[0];    maxValue[0] = nums[0];    minValue[0] = nums[0];    for (int i = 1; i &lt; nums.size(); ++i) &#123;        maxValue[i] = max(&#123;maxValue[i - 1] * nums[i], minValue[i - 1] * nums[i], nums[i]&#125;);        minValue[i] = min(&#123;maxValue[i - 1] * nums[i], minValue[i - 1] * nums[i], nums[i]&#125;);        ans = max(ans, maxValue[i]);    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以采用滚动数组的思想来优化空间复杂度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 148. 排序链表</title>
      <link href="/posts/73ef6296/"/>
      <url>/posts/73ef6296/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWxpc3Qv">148. Sort List</span></p><p>给你链表的头结点  <code>head</code>  ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p height="150px"><img data-src="/posts/73ef6296/Example1.jpg" class=""></p><pre><code>输入：head = [4,2,1,3]输出：[1,2,3,4]</code></pre><p><strong>示例 2：</strong></p><p height="150px"><img data-src="/posts/73ef6296/Example2.jpg" class=""></p><pre><code>输入：head = [-1,5,3,4,0]输出：[-1,0,3,4,5]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5 \times 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：你可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）。其中，最适合链表的排序算法是归并排序</p><ul><li>考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>自底向上归并排序的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h1 id="method-1-自顶向下归并排序"><a class="anchor" href="#method-1-自顶向下归并排序">#</a> Method 1: 自顶向下归并排序</h1><p>算法思路：</p><p>定义一个递归函数，用于实现对区间 [head, tail) 的归并排序</p><p>递归的终止条件：链表的节点个数小于或等于 1，无需再对链表进行拆分和排序，当前递归结束</p><ul><li>特别地，为便于后续进行归并，应将单个链表节点的 next 指针置为空（用于标记子链表的末尾）</li></ul><p>单层递归的逻辑：</p><ul><li>使用快慢指针找到链表的中点</li><li>以中点为分界，将链表拆分成两个子链表</li><li>对两个子链表分别排序</li><li>将两个排序后的子链表合并（归并）</li></ul><p>代码实现：</p><pre><code class="language-cpp">ListNode* sortList(ListNode* head) &#123;    return mergeSort(head, nullptr);&#125;ListNode* mergeSort(ListNode* head, ListNode* tail) &#123; // 对区间 [head, tail) 进行归并排序    if (head == nullptr) return nullptr;    if (head-&gt;next == tail) &#123;        head-&gt;next = nullptr;        return head;    &#125;    ListNode* fast = head;    ListNode* slow = head;    while (fast != tail &amp;&amp; fast-&gt;next != tail) &#123; // 快慢指针，找出区间 [head, tail) 中点        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;    &#125;    ListNode* list1 = mergeSort(head, slow); // 对区间 [head, slow) 进行归并排序    ListNode* list2 = mergeSort(slow, tail); // 对区间 [slow, tail) 进行归并排序    return merge(list1, list2); // 归并&#125;ListNode* merge(ListNode* head1, ListNode* head2) &#123; // 归并    ListNode* dummyHead = new ListNode();    ListNode* cur = dummyHead;    ListNode* temp1 = head1;    ListNode* temp2 = head2;    while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;        if (temp1-&gt;val &lt; temp2-&gt;val) &#123;            cur-&gt;next = temp1;            temp1 = temp1-&gt;next;        &#125; else &#123;            cur-&gt;next = temp2;            temp2 = temp2-&gt;next;        &#125;        cur = cur-&gt;next;    &#125;    cur-&gt;next = temp1 == nullptr ? temp2 : temp1;    return dummyHead-&gt;next;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，考虑了递归调用的栈空间</p><h1 id="method-2-自底向上归并排序"><a class="anchor" href="#method-2-自底向上归并排序">#</a> Method 2: 自底向上归并排序</h1><p>算法思路：</p><p>首先求得链表的长度 length，然后将链表拆分成子链表进行合并</p><ul><li>用 subLength 表示每次需要排序的子链表的长度，初始时 subLength = 1</li><li>将链表拆分成若干个长度为 subLength 的子链表（最后一个子链表的长度可以小于 subLength），按照每两个子链表一组进行归并</li><li>将 subLength 的值加倍，重复第 2 步，对更长的有序子链表进行归并，直到有序子链表的长度大于或等于 length，整个链表排序完毕</li></ul><p>代码实现：</p><pre><code class="language-cpp">ListNode* sortList(ListNode* head) &#123;    // 计算链表长度    int length = 0;    for (ListNode* tmp = head; tmp != nullptr; tmp = tmp-&gt;next)        ++length;        // 拆分链表    ListNode* dummyHead = new ListNode(0, head); // 虚拟头节点    for (int subLength = 1; subLength &lt; length; subLength = subLength &lt;&lt; 1) &#123; // 遍历每次排序的子链表的长度        ListNode* prev = dummyHead; // 指向已归并的子链表的末尾        ListNode* cur = dummyHead-&gt;next;        // 按照每两个子链表一组进行合并        while (cur != nullptr) &#123;            ListNode* head1 = cur;  // 第一段子链表的头部            for (int i = 1; i &lt; subLength &amp;&amp; cur-&gt;next != nullptr; ++i)                cur = cur-&gt;next;            ListNode* head2 = cur-&gt;next; // 第二段子链表的头部            cur-&gt;next = nullptr;    // 断开第一段子链表与第二段子链表            cur = head2;            for (int i = 1; i &lt; subLength &amp;&amp; cur != nullptr &amp;&amp; cur-&gt;next != nullptr; ++i)                cur = cur-&gt;next;            ListNode* node = nullptr;            if (cur != nullptr) &#123;                node = cur-&gt;next;    // 剩余链表的头部                cur-&gt;next = nullptr; // 断开第二段子链表与剩余链表            &#125;            ListNode* merged = merge(head1, head2); // 将第一段子链表与第二段子链表归并            prev-&gt;next = merged;     // 将归并完成的链表进行连接            while (prev-&gt;next != nullptr) // 更新 prev                prev = prev-&gt;next;            cur = node;              // 对剩余链表继续拆分（排序）        &#125;    &#125;    return dummyHead-&gt;next;&#125;ListNode* merge(ListNode* head1, ListNode* head2) &#123; // 归并    ListNode* dummyHead = new ListNode();    ListNode* cur = dummyHead;    ListNode* temp1 = head1;    ListNode* temp2 = head2;    while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;        if (temp1-&gt;val &lt; temp2-&gt;val) &#123;            cur-&gt;next = temp1;            temp1 = temp1-&gt;next;        &#125; else &#123;            cur-&gt;next = temp2;            temp2 = temp2-&gt;next;        &#125;        cur = cur-&gt;next;    &#125;    if (temp1 != nullptr) cur-&gt;next = temp1;    else cur-&gt;next = temp2;    return dummyHead-&gt;next;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWxpc3Qvc29sdXRpb24vcGFpLXh1LWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 146. LRU缓存</title>
      <link href="/posts/d10d41c5/"/>
      <url>/posts/d10d41c5/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUv">146. LRU Cache</span></p><p>请你设计并实现一个满足 <strong>LRU (最近最少使用) 缓存</strong> 约束的数据结构。</p><p>实现  <code>LRUCache</code>  类：</p><ul><li><p><code>LRUCache(int capacity)</code>  以 <strong>正整数</strong> 作为容量  <code>capacity</code>  初始化 LRU 缓存</p></li><li><p><code>int get(int key)</code>  如果关键字  <code>key</code>  存在于缓存中，则返回关键字的值，否则返回  <code>-1</code>  。</p></li><li><p><code>void put(int key, int value)</code>  如果关键字  <code>key</code>  已经存在，则变更其数据值  <code>value</code>  ；如果不存在，则向缓存中插入该组  <code>key-value</code>  。如果插入操作导致关键字数量超过  <code>capacity</code>  ，则应该 逐出 最久未使用的关键字。</p></li></ul><p>函数  <code>get</code>  和  <code>put</code>  必须以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的平均时间复杂度运行。</p><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出：[null, null, null, 1, null, -1, null, -1, 3, 4]解释：LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>capacity</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 3000$</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>key</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>value</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li>最多调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 次  <code>get</code>  和  <code>put</code></li></ul><h1 id="method-哈希表-双向链表"><a class="anchor" href="#method-哈希表-双向链表">#</a> Method: 哈希表 + 双向链表</h1><p>思路：</p><p>可以用一个哈希表和一个双向链表维护所有在 LRU 缓存中的键值对</p><ul><li><p>双向链表按照被使用的顺序存储键值对：靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的</p></li><li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的关键字 key 映射其在双向链表中的位置</p></li></ul><p>因此，我们可以先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在  <code>O(1)</code>  的时间内完成  <code>get</code>  或者  <code>put</code>  操作</p><p>特别地，在双向链表的实现中，可以添加一个虚拟头部（dummy head）和虚拟尾部（dummy tail）。于是，添加节点和删除节点时，不需要再检查相邻的节点是否存在</p><p>代码实现：</p><pre><code class="language-cpp">struct DLinkedNode &#123; // 双向链表    int key, value;    DLinkedNode* prev;    DLinkedNode* next;    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;    DLinkedNode(int _key, int _value) : key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;&#125;;class LRUCache &#123;private:    unordered_map&lt;int, DLinkedNode*&gt; hash;    DLinkedNode* head; // 虚拟头节点    DLinkedNode* tail; // 虚拟尾节点    int _capacity;     // 缓存的容量    int _size;         // 当前占用的缓存大小public:    LRUCache(int capacity) &#123; // 初始化        head = new DLinkedNode();        tail = new DLinkedNode();        head-&gt;next = tail;        tail-&gt;prev = head;        _size = 0;        _capacity = capacity;    &#125;        int get(int key) &#123;        if (!hash.count(key)) return -1; // key 不存在        DLinkedNode* node = hash[key];   // key 已存在，先通过哈希表定位，再移到头部        moveToHead(node);        return node-&gt;value;    &#125;        void put(int key, int value) &#123;        if (hash.count(key)) &#123; // key 已存在，通过哈希表定位，修改数据值，并移到头部            DLinkedNode* node = hash[key];            node-&gt;value = value;            moveToHead(node);        &#125; else &#123; // key 不存在，创建一个新的节点，添加到链表头部，并建立哈希表索引            DLinkedNode* node = new DLinkedNode(key, value);            addToHead(node);            hash[key] = node;            ++_size;            if (_size &gt; _capacity) &#123; // 超出容量，需删除最久未使用的关键字                DLinkedNode* removed = tail-&gt;prev; // 需移除的节点（即，虚拟尾节点的前一个节点）                removeNode(removed);      // 从链表中移除                hash.erase(removed-&gt;key); // 从哈希表中移除                delete removed;           // 从内存中删除                --_size;            &#125;        &#125;    &#125;    void removeNode(DLinkedNode* node) &#123; // 将 node 从链表中移除        node-&gt;prev-&gt;next = node-&gt;next;        node-&gt;next-&gt;prev = node-&gt;prev;    &#125;    void addToHead(DLinkedNode* node) &#123; // 将 node 添加到链表头部        node-&gt;prev = head;        node-&gt;next = head-&gt;next;        head-&gt;next-&gt;prev = node;        head-&gt;next = node;    &#125;    void moveToHead(DLinkedNode* node) &#123; // 将 node 移至链表头部        removeNode(node);        addToHead(node);    &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUvc29sdXRpb24vbHJ1aHVhbi1jdW4tamktemhpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 124. 二叉树中的最大路径和</title>
      <link href="/posts/a93709cb/"/>
      <url>/posts/a93709cb/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的最大路径和"><a class="anchor" href="#二叉树的最大路径和">#</a> 二叉树的最大路径和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtLw==">124. Binary Tree Maximum Path Sum</span></p><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点  <code>root</code>  ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 3 \times 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h2><p>算法思路：</p><p>定义一个递归函数  <code>int maxGain(TreeNode* root)</code>   ，用于计算 root 节点的最大贡献值，即：在以 root 为根节点的二叉树中，计算以 root 为起点的路径的最大和</p><p>定义一个全局变量  <code>maxSum</code>  ，用于存储二叉树的最大路径和</p><p>递归终止条件：遇到空节点，当前递归结束</p><p>单层递归的逻辑：</p><ul><li>递归到左子节点，在左子树中计算以左子节点为起点的最大路径和，记作 leftGain ，即 leftGain = maxGain (root-&gt;left)</li><li>递归到右子节点，在右子树中计算以右子节点为起点的最大路径和，记作 rightGain ，即 rightGain = maxGain (root-&gt;right)</li><li>在以 root 为根节点的二叉树中，包含 root 节点的路径的最大和为：sum = root-&gt;val + max (leftGain, 0) + max (rightGain, 0)<ul><li>这里实际计算的是 “左子树 - root - 右子树” 路径的最大和</li><li>当左子节点和右子节点的贡献值为负数时，不能将左子节点和右子节点计入 root 节点所对应的、具有最大和的路径（因为加上一个负数会使得和变小），所以，我们累加的是 max (leftGain, 0) 和 max (rightGain, 0)</li></ul></li><li>在以 root 为根节点的二叉树中，以 root 为起点的路径的最大和为：gain = max (root-&gt;val + max (leftGain, 0), root-&gt;val + max (rightGain, 0))<ul><li>root-&gt;val + max (leftGain, 0) 为 root 节点到左子树的最大路径和</li><li>root-&gt;val + max (rightGain, 0) 为 root 节点到右子树的最大路径和</li></ul></li><li>更新二叉树的最大路径和：maxSum = max (maxSum, sum)<ul><li>注意，sum 始终大于或等于 gain ，因此，这里需根据 sum 来更新 maxSum （可结合 示例 1 和 示例 2 进行理解）</li></ul></li><li>返回 root 节点的贡献值 gain</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxSum = INT_MIN; // 二叉树的最大路径和int maxPathSum(TreeNode* root) &#123;    maxGain(root);    return maxSum;&#125;int maxGain(TreeNode* root) &#123;    if (root == nullptr) return 0;    int leftGain = max(maxGain(root-&gt;left), 0);    int rightGain = max(maxGain(root-&gt;right), 0);    maxSum = max(maxSum, root-&gt;val + leftGain + rightGain);    return root-&gt;val + max(leftGain, rightGain);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtL3NvbHV0aW9uL2VyLWNoYS1zaHUtemhvbmctZGUtenVpLWRhLWx1LWppbmctaGUtYnktbGVldGNvZGUtLw==">leetcode-solution</span></p><h1 id="三叉树中的最大路径和"><a class="anchor" href="#三叉树中的最大路径和">#</a> 三叉树中的最大路径和</h1><p>华为 2022.10.12 第二道笔试题</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode &#123;    int val;    TreeNode* left;    TreeNode* mid;    TreeNode* right;    TreeNode (int _val) : val(_val), left(nullptr), mid(nullptr), right(nullptr) &#123;&#125;    // TreeNode () : val(0), left(nullptr), mid(nullptr), right(nullptr) &#123;&#125;    // TreeNode (int _val, TreeNode* _left, TreeNode* _mid, TreeNode* _right) : val(_val), left(_left), mid(_mid), right(_right) &#123;&#125;&#125;;TreeNode* buildTree(vector&lt;int&gt;&amp; nums) &#123; // 利用层序遍历数组 nums 构建三叉树    TreeNode* root = new TreeNode(nums[0]);    queue&lt;TreeNode*&gt; que;    que.push(root);    int idx = 1;    while (!que.empty() &amp;&amp; idx &lt; nums.size()) &#123;        int size = que.size();        for (int i = 0; i &lt; size; ++i) &#123;            TreeNode* node = que.front();            que.pop();                        if (idx &lt; nums.size() &amp;&amp; nums[idx] != -1) &#123; // left 子节点                node-&gt;left = new TreeNode(nums[idx]);                que.push(node-&gt;left);                // cout &lt;&lt; node-&gt;left-&gt;val &lt;&lt; endl;            &#125;            else node-&gt;left = nullptr;            ++idx;            if (idx &lt; nums.size() &amp;&amp; nums[idx] != -1) &#123; // mid 子节点                node-&gt;mid = new TreeNode(nums[idx]);                que.push(node-&gt;mid);                // cout &lt;&lt; node-&gt;mid-&gt;val &lt;&lt; endl;            &#125;            else node-&gt;mid = nullptr;            ++idx;                        if (idx &lt; nums.size() &amp;&amp; nums[idx] != -1) &#123; // right 子节点                node-&gt;right = new TreeNode(nums[idx]);                que.push(node-&gt;right);                // cout &lt;&lt; node-&gt;right-&gt;val &lt;&lt; endl;            &#125;            else node-&gt;right = nullptr;            ++idx;        &#125;    &#125;    return root;&#125;vector&lt;int&gt; order;void traversal(TreeNode* root) &#123; // 层序遍历三叉树    if (root == nullptr) return;    queue&lt;TreeNode*&gt; que;    que.push(root);    while (!que.empty()) &#123;        int size = que.size();        for (int i = 0; i &lt; size; ++i) &#123;            TreeNode* node = que.front();            que.pop();            order.push_back(node-&gt;val);            if (node-&gt;left) que.push(node-&gt;left);            if (node-&gt;mid) que.push(node-&gt;mid);            if (node-&gt;right) que.push(node-&gt;right);        &#125;    &#125;&#125;int ans = INT_MIN; // 最大路径和int gain(TreeNode* root) &#123; // 计算 以 root 为起点、向下延申的最大路径和    if (root == nullptr) return 0;    int left = gain(root-&gt;left);   // left 子树最大路径和    left = max(left, 0);    int mid = gain(root-&gt;mid);     // mid 子树最大路径和    mid = max(mid, 0);    int right = gain(root-&gt;right); // right 子树最大路径和    right = max(right, 0);    int maxgain = root-&gt;val + max(&#123;left + mid, left + right, mid + right&#125;); // 找出三条路径中的最大路径和：从 left 经 root 到 mid 、从 left 经 root 到 right 、从 mid 经 root 到 right    ans = max(ans, maxgain);       // 更新最大路径和    return root-&gt;val + max(&#123;left, mid, right&#125;); // 以 root 为起点、向下延申的最大路径和&#125;int main() &#123;    // 读取输入    int n = 0;    cin &gt;&gt; n;    vector&lt;int&gt; nums(n, 0); // 三叉树的层序遍历数组（其中，-1 表示空节点）    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; nums[i];    // int n = 19;    // vector&lt;int&gt; nums = &#123;20, 12, 30, 15, -1, -1, -1, -1, -1, -1, 15, 5, 25, -1, -1, -1, 16, -1, 22&#125;;        // 构建三叉树    TreeNode* root = buildTree(nums);        // // 遍历三叉树，检查三叉树构建是否正确    // traversal(root);    // for (int i = 0; i &lt; order.size(); ++i) cout &lt;&lt; order[i] &lt;&lt; &quot; &quot;;    // cout &lt;&lt; endl;        // 计算最大路径和    gain(root);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 128. 最长连续序列</title>
      <link href="/posts/eb9b92a9/"/>
      <url>/posts/eb9b92a9/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlLw==">128. Longest Consecutive Sequence</span></p><p>给定一个未排序的整数数组  <code>nums</code>  ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [100,4,200,1,3,2]输出：4解释：The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-哈希表"><a class="anchor" href="#method-哈希表">#</a> Method: 哈希表</h1><p>算法思路：</p><p>定义一个哈希表（记作 hash ，即  <code>unordered_map&lt;int&gt; hash</code>  ），将数组中的数字作为哈希表的键，将数字所在的连续序列的最大长度作为对应的哈希表值</p><p>遍历数组（记当前遍历到的数字为 num）：</p><ul><li><p>若数字 num 已在哈希表中，跳过</p></li><li><p>若数字 num 不在哈希表中：</p><ul><li><p>找出左侧相邻数 num - 1 所在的连续序列的最大长度，记作 left ，即 left = hash [num - 1]</p></li><li><p>找出右侧相邻数 num + 1 所在的连续序列的最大长度，记作 right ，即 right = hash [num + 1]</p></li><li><p>将 num 左右两侧的连续序列以及 num 进行拼接，计算新的连续序列的长度：len = left + right + 1</p></li><li><p>更新当前数字 num 对应的哈希表值，即 hash [num] = len</p></li><li><p>更新连续序列两个端点对应的哈希表值，即，hash [num - left] = len ，hash [num + right] = len</p></li><li><p>更新整个数组中的最长连续序列的长度，即 ans = max (ans, len)</p></li></ul></li></ul><p>上述算法中，拼接 num 及其左右两侧连续序列时，我们没有更新连续序列中每个数字对应的哈希表值，而只是更新两个端点对应的哈希表值。这是因为：区间 (num - left, num + right) 内数字对应的哈希表值不会被使用，只有 num -left 和 num + right 这两个端点对应的哈希表值可能被使用</p><ul><li>在之后的遍历中，如果遇到 [num - left, num + right] 区间内的数，会直接跳过，无需考察其左右两侧数字所在连续序列的长度</li><li>在之后的遍历中，如果遇到 num - left - 1（或 num + right + 1），由于 num - left（或 num + right）对应的连续序列长度已经更新，可以直接将 num - left - 1（或 num + right + 1）与 num - left（或 num + right）对应的连续序列进行拼接，无需担心结果出错</li></ul><blockquote><p>无论 num 左右两侧是否存在相应的连续序列，上述算法都能奏效（哈希表的值全都初始化为 0 ）</p><ul><li>当 num 左侧或右侧不存在连续序列时，left 或 right 为 0，num - left 或 num + right 就是 num 本身</li><li>当 num 左右两侧均不存在连续序列时，left 和 right 均为 0，num - left 和 num + right 都是 num 本身</li></ul></blockquote><p>代码实现：</p><pre><code class="language-cpp">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;    unordered_map&lt;int, int&gt; hash; // 哈希表，存储每个数字对应连续序列的长度    int left = 0;    int right = 0;    int len = 0;    int ans = 0;    for (int num : nums) &#123;        if (hash[num] == 0) &#123;            left = hash[num - 1];     // 左侧数字对应连续序列的长度            right = hash[num + 1];    // 右侧数字对应连续序列的长度            len = left + right + 1;   // 拼接左右连续序列            hash[num] = len;          // 数字 num 对应连续序列的长度            hash[num - left] = len;   // 更新左侧数字对应序列的端点的键值            hash[num + right] = len;  // 更新右侧数字对应序列的端点的键值                if (len &gt; ans) ans = len; // 更新最大长度             &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlL3NvbHV0aW9uL2RvbmctdGFpLWd1aS1odWEtcHl0aG9uLXRpLWppZS1ieS1qYWxhbi8=">jalan</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 141. 环形链表</title>
      <link href="/posts/a79a615b/"/>
      <url>/posts/a79a615b/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8=">141. Linked List Cycle</span></p><p>给你一个链表的头节点  <code>head</code>  ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪  <code>next</code>  指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数  <code>pos</code>  来表示链表尾连接到链表中的位置（索引从 0 开始）。注意： <code>pos</code>  不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回  <code>true</code>  。 否则，返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/a79a615b/Example1.png" class=""></p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/a79a615b/Example2.png" class=""></p><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点</code></pre><p><strong>示例 3：</strong></p><p><img data-src="/posts/a79a615b/Example3.png" class=""></p><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>pos</code>  为 -1 或者链表中的一个 有效索引</li></ul><p><strong>进阶</strong>：你能用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（即，常量）内存解决此问题吗？</p><h1 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h1><p>算法思路：</p><p>定义 fast 和 slow 指针，均从头结点出发</p><ul><li>fast 指针每次移动两个节点</li><li>slow 指针每次移动一个节点</li></ul><p>如果 fast 和 slow 指针在途中相遇，说明链表有环</p><p>代码实现：</p><pre><code class="language-cpp">bool hasCycle(ListNode *head) &#123;    ListNode* fast = head;    ListNode* slow = head;    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow) return true;    &#125;    return false;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 136. 只出现一次的数字</title>
      <link href="/posts/59ae1e23/"/>
      <url>/posts/59ae1e23/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW5nbGUtbnVtYmVyLw==">136. Single Number</span></p><p>给你一个 <strong>非空</strong> 整数数组  <code>nums</code>  ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,2,1]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [4,1,2,1,2]输出：4</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-3 \times 10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>除了某个元素只出现一次以外，其余每个元素均出现两次</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>如果不考虑时间复杂度和空间复杂度的限制，可考虑以下解法：</p><ul><li><p>使用哈希表（集合）存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字</p></li><li><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字</p></li><li><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此，可以计算集合中所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次、其余元素都出现两次，因此，用集合元素之和的两倍减去数组元素之和，所得的差即为数组中只出现一次的数字</p></li></ul><p>上述三种解法都需要额外使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的空间，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><h1 id="method-位运算"><a class="anchor" href="#method-位运算">#</a> Method: 位运算</h1><p>异或运算有以下三个性质：</p><ul><li>任何数和 0 做异或运算，结果仍然是原来的数，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \oplus 0 = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span></li><li>任何数和其自身做异或运算，结果是 0，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \oplus a = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li><li>异或运算满足交换律和结合律，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mi>a</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊕</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>⊕</mo><mn>0</mn><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \oplus b \oplus a = b \oplus a \oplus a = b \oplus (a \oplus a) = b \oplus0 = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span></li></ul><p>因此，对数组中全部元素进行异或运算，即可得到数组中只出现一次的数字</p><ul><li>根据异或运算的交换律和结合律，可以把相同数字组合到一起然后进行异或运算，所得结果即为 0 ，将 0 与只出现过一次的元素进行异或，所得结果就是只出现过一次的元素</li></ul><p>代码实现：</p><pre><code class="language-cpp">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;    int ans = 0;    for (int i = 0; i &lt; nums.size(); i++) &#123;        ans ^= nums[i];    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW5nbGUtbnVtYmVyL3NvbHV0aW9uL3poaS1jaHUteGlhbi15aS1jaS1kZS1zaHUtemktYnktbGVldGNvZGUtc29sdXRpb24v">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 114. 二叉树展开为链表</title>
      <link href="/posts/67d53c79/"/>
      <url>/posts/67d53c79/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGF0dGVuLWJpbmFyeS10cmVlLXRvLWxpbmtlZC1saXN0Lw==">114. Flatten Binary Tree to Linked List</span></p><p>给你二叉树的根结点  <code>root</code>  ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用  <code>TreeNode</code>  ，其中  <code>right</code>  子指针指向链表中下一个结点，而左子指针始终为  <code>null</code>  。</li><li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p height="150px"><img data-src="/posts/67d53c79/Example1.jpg" class=""></p><pre><code>输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>The number of nodes in the tree is in the range [0, 2000].</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><p><strong>进阶</strong>：Can you flatten the tree with  <code>O(1)</code>  extra space?</p><h1 id="method-1-暴力法"><a class="anchor" href="#method-1-暴力法">#</a> Method 1: 暴力法</h1><p>算法思路：</p><p>首先按照前序遍历顺序将二叉树节点依次存入队列中</p><p>队首到队尾的元素对应于所需构建的二叉树链表的首端和尾端（因为展开后的单链表与二叉树前序遍历顺序相同）</p><p>于是，依据队列中的元素重构二叉树即可：对于队列中的任意元素（记作 node ），其 left 指针应为空指针，right 指针应指向其在队列中的下一个元素</p><pre><code class="language-cpp">queue&lt;TreeNode*&gt; que; // 存放先序遍历结果void traverse(TreeNode* root) &#123; // 先序遍历    que.push(root);    if (root-&gt;left) traverse(root-&gt;left);    if (root-&gt;right) traverse(root-&gt;right);&#125;void flatten(TreeNode* root) &#123;    if (root == nullptr)return; // 二叉树为空    traverse(root);             // 获取先序遍历序列    root = que.front();    que.pop();    while (!que.empty()) &#123;      // 构造链表        root-&gt;left = nullptr;   // 注意这里需要将 left 指针置为空指针        root-&gt;right = que.front();        que.pop();        root = root-&gt;right;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了存放二叉树前序遍历结果所需空间，不考虑递归所需栈空间</p><h1 id="method-2-递归"><a class="anchor" href="#method-2-递归">#</a> Method 2: 递归</h1><p>算法思路：</p><p>定义一个递归函数，用于将以 root 为根节点的二叉树展开成链表</p><p>单层递归的具体逻辑为：</p><ul><li>将左子树展开成链表（为便于表述，记作 左子树链表）</li><li>将右子树展开成链表（为便于表述，记作 右子树链表）</li><li>拼接左子树链表与右子树链表</li><li>将拼接结果作为新的右子树，并将左子树置为空</li></ul><p>其中，题目要求展开所得的单链表与二叉树前序遍历顺序相同（即，根 - 左 - 右），因此，需要将右子树链表拼接在左子树链表的后面。即，需要找到左子树链表的尾端，令其 right 指针指向右子树链表的首端</p><p>代码实现：</p><pre><code class="language-cpp">void flatten(TreeNode* root) &#123;    if (root == nullptr) return;    flatten(root-&gt;left);         // 将左子树展开成链表    flatten(root-&gt;right);        // 将右子树展开成链表    TreeNode* tmp = root-&gt;right; // 备份右子树的根节点    root-&gt;right = root-&gt;left;    // 将 root 的左子树修改为 root 的右子树    root-&gt;left = nullptr;        // root 的左子节点置为空指针    TreeNode* node = root;       // root 左子树与 root 右子树的拼接点（即，左子树链表的尾端）    while (node-&gt;right != nullptr) &#123;        node = node-&gt;right;    &#125;    node-&gt;right = tmp;           // 将 root 右子树链表拼接在 root 左子树链表上&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归所需栈空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 85. 最大矩形</title>
      <link href="/posts/c5a6a467/"/>
      <url>/posts/c5a6a467/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXJlY3RhbmdsZS8=">85. Maximal Rectangle</span></p><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/c5a6a467/Example1.jpg" class=""></p><pre><code>输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：6解释：最大矩形如上图所示。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：matrix = [[&quot;0&quot;]]输出：0</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：matrix = [[&quot;1&quot;]]输出：1</code></pre><p><strong>提示：</strong></p><ul><li>rows == matrix.length</li><li>cols == matrix[i].length</li><li>1 &lt;= row, cols &lt;= 200</li><li>matrix [i][j] 为 '0' 或 '1'</li></ul><h1 id="method-栈"><a class="anchor" href="#method-栈">#</a> Method: 栈</h1><p>算法思路：</p><p>可以将矩阵拆分成一系列的柱状图，为了计算矩形的最大面积，我们需要计算每个柱状图中的最大矩形面积，并从所有柱状图中找到全局最大值</p><p>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别表示矩阵 matrix 的行数和列数，因此可将矩阵拆分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 个柱状图</p><p>特别地，第 i 个柱状图的范围为矩阵第 0 行至第 i 行，即，matrix [0] 至 matrix [i] ，在该柱状图中，第 j 个柱子的高度为 height [i][j]</p><ul><li>height [i][j] 表示从 (i, 0) 位置开始往下数、以 (i, j) 位置结尾的连续 1 的个数</li></ul><p>其中，某柱状图中的最大矩形面积，可按照 <a href="https://jiankychen.github.io/posts/">LeetCode 84. 柱状图中最大的矩形</a> 中的思路求解</p><p>通过遍历 i（即，遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 个柱状图），求出每一个柱状图的最大矩形面积，即可得出所有柱状图中的最大矩形（即，矩阵中的最大矩形面积）</p><p>代码实现：</p><pre><code class="language-cpp">int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;    int m = matrix.size();    int n =matrix[0].size();    // 预处理，计算每一个柱状图中的每一个柱子高度    vector&lt;vector&lt;int&gt;&gt; height(m, vector&lt;int&gt;(n, 0));    for (int i = 0; i &lt; m; i++) &#123;        for (int j = 0; j &lt; n; j++) &#123;            if (matrix[i][j] == '1') &#123;                height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;            &#125;        &#125;    &#125;    int ans = 0;      // 矩阵中的最大矩形面积    for (int i = 0; i &lt; m; i++) &#123; // 遍历 m 个柱状图，计算每个柱状图的最大矩形面积        vector&lt;int&gt; left(n, -1);  // left[j] 表示以 height[j] 为高的矩形的左边界        vector&lt;int&gt; right(n, n);  // right[j] 表示以 height[j] 为高的矩形的矩形的右边界        stack&lt;int&gt; stk;           // 单调栈        for (int j = 0; j &lt; n; j++) &#123; // 维护单调栈，并更新 left 和 right 数组            while (!stk.empty() &amp;&amp; height[i][stk.top()] &gt;= height[i][j]) &#123;                right[stk.top()] = j;                stk.pop();            &#125;            if (!stk.empty()) left[j] = stk.top();            stk.push(j);        &#125;        int area = 0; // 第 i 个柱形图的最大矩形面积        for (int j = 0; j &lt; n; j++) &#123;            area = max(area, height[i][j] * (right[j] - left[j] - 1));        &#125;        ans = max(ans, area); // 更新矩阵的最大矩形面积    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别为矩阵 matrix 的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXJlY3RhbmdsZS9zb2x1dGlvbi96dWktZGEtanUteGluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi1iamx1Lw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 84. 柱状图中最大的矩形</title>
      <link href="/posts/e6beed44/"/>
      <url>/posts/e6beed44/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0v">84. Largest Rectangle in Histogram</span></p><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1：</strong></p><p height="150px"><img data-src="/posts/e6beed44/Example1.jpg" class=""></p><pre><code>输入：heights = [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10</code></pre><p><strong>示例 2：</strong></p><p height="200px"><img data-src="/posts/e6beed44/Example2.jpg" class=""></p><pre><code>输入：heights = [2,4]输出：4</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= heights.length &lt;= 10<sup>5</sup></li><li>0 &lt;= heights[i] &lt;= 10<sup>4</sup></li></ul><h1 id="method-1-暴力法"><a class="anchor" href="#method-1-暴力法">#</a> Method 1: 暴力法</h1><p>可以考虑枚举矩形的宽或者高，即，有以下两种实现：</p><h2 id="实现一"><a class="anchor" href="#实现一">#</a> 实现一</h2><p>对于以 i 为左边界、j 为右边界的矩形，找出区间 [i, j] 范围内的最小高度（即，heights 数组在 [i, j] 区间内的最小值），记作 h ，则矩形的面积为 h * (j - i) + 1</p><p>枚举矩形的左右边界，计算出所有矩形的面积，找出最大面积</p><h2 id="实现二"><a class="anchor" href="#实现二">#</a> 实现二</h2><p>对于柱子 i ，可以将 heights [i] 固定为矩形的高度，然后向左右两侧拓展矩形的宽度：</p><ul><li>从 i - 1 开始向左查找，找出满足 heights [left] &lt; height [i] 的柱子 left</li><li>从 i + 1 开始向右查找，找出满足 heights [right] &lt; heights [i] 的第一个柱子 right</li><li>此时，left 和 right 就是矩形的左右边界，即，以 heights [i] 为高度的矩形的最大范围为 [left + 1, right - 1]</li></ul><p>因此，该矩形的宽度为 right - left - 1 ，面积为 heights [i] * (right - left - 1)</p><p>枚举矩形的高度 height [i] ，计算出所有矩形的面积，找出最大面积</p><blockquote><p>以上两种实现的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 heights 的长度</p><p>对于本题而言，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 会超时</p></blockquote><h1 id="method-2-栈"><a class="anchor" href="#method-2-栈">#</a> Method 2: 栈</h1><p>可以考虑按照如下方式维护一个栈：</p><ul><li><p>如果新的元素比栈顶元素大，将新元素入栈</p></li><li><p>如果新的元素较小，不断地将栈内元素弹出来，直到栈顶比新元素小</p></li></ul><blockquote><p>从栈底到栈顶，元素是递增的，所以可称该栈为 单调递增栈</p></blockquote><p>当需要执行出栈操作时，新元素就是出栈元素右侧的（相对于数组中的位置而言）、第一个小于出栈元素的元素</p><ul><li>换而言之，如果以出栈元素作为矩形的高，新元素对应的下标就是矩形的右边界（对应 Method 1 中的 right ）</li></ul><p>在执行出栈操作后，栈顶元素将会比新元素小，因此，栈顶元素就是新元素左侧的（相对于数组中的位置而言）、第一个小于新元素的元素</p><ul><li>换而言之，如果以新元素作为矩形的高，栈顶元素对应的下标就是矩形的左边界</li></ul><p>因此，我们可以定义 left 数组和 right 数组分别记录每一个矩形的左、右边界，通过 遍历 heights 数组、维护栈 来更新 left 和 right 数组</p><ul><li>由于 left 数组和 right 数组记录的是元素的下标，为方便起见，我们在栈内存放数组元素的下标，而不是数组元素值（即，实际存入栈的是数组元素的下标，判断是否出栈、入栈时需要找到下标对应的数组元素值）</li><li>将 left 数组初始化为 -1 ，以应对 “某元素左侧的元素全都不比它小” 的情况；将 right 数组初始化为 heights.size () ，以应对 “ 某元素右侧的元素全都不比它小 ” 的情况</li></ul><p>在更新完 left 和 right 数组以后，对于以 heights [i] 为高度的矩形，其最大面积为 heights [i] * (right [i] - left [i] - 1) 。因此，再遍历一次 heights 数组，即可得到最大矩阵面积</p><p>代码实现：</p><pre><code class="language-cpp">int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    int n = heights.size();    vector&lt;int&gt; left(n, -1); // left[i] 表示以 heights[i] 为高的矩形的左边界    vector&lt;int&gt; right(n, n); // right[i] 表示以 heights[i] 为高的矩形的右边界        stack&lt;int&gt; stk;    for (int i = 0; i &lt; n; i++) &#123;        while (!stk.empty() &amp;&amp; heights[stk.top()] &gt;= heights[i]) &#123;            right[stk.top()] = i;            stk.pop();        &#125;        if (!stk.empty()) left[i] = stk.top();        stk.push(i);    &#125;    int ans = 0;    for (int i = 0; i &lt; n; i++) &#123;        ans = max(ans, (right[i] - left[i] - 1) * heights[i]);    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 heights 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0vc29sdXRpb24vemh1LXpodWFuZy10dS16aG9uZy16dWktZGEtZGUtanUteGluZy1ieS1sZWV0Y29kZS0v">leetcode-solution</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0vc29sdXRpb24vYmFvLWxpLWppZS1mYS16aGFuLWJ5LWxpd2Vpd2VpMTQxOS8=">liweiwei1419</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0vc29sdXRpb24vODQtYnktaWthcnVnYS8=">ikaruga</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 79. 单词搜索</title>
      <link href="/posts/4c8f57fd/"/>
      <url>/posts/4c8f57fd/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC8=">79. Word Search</span></p><p>给定一个  <code>m x n</code>  二维字符网格  <code>board</code>  和一个字符串单词  <code>word</code>  。如果  <code>word</code>  存在于网格中，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p height="150px"><img data-src="/posts/4c8f57fd/Example1.jpg" class=""></p><pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><p height="150px"><img data-src="/posts/4c8f57fd/Example2.jpg" class=""></p><pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;输出：true</code></pre><p><strong>示例 3：</strong></p><p height="150px"><img data-src="/posts/4c8f57fd/Example3.jpg" class=""></p><pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code>  和  <code>word</code>  仅由大小写英文字母组成</li></ul><p><strong>进阶</strong>：你可以使用搜索剪枝的技术来优化解决方案，使其在  <code>board</code>  更大的情况下可以更快解决问题？</p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><p>遍历 grid 中的每一个位置 (i, j)，判断从该位置出发能否搜索到 word 。特别地，只要找到一个可行的出发点，就说明网格中能够找到 word ，即可返回 true ，否则，说明不能找到，返回 false</p><p>为检查从某位置出发能否搜索到 word ，可以定义一个回溯函数：</p><ul><li><p>从 grid 的 (starti, startj) 位置出发，判断能否搜索到字符串 word 的子串 word [startk, word.size () - 1] ，若能够搜索到，则返回 true ，否则，返回 false</p></li><li><p>其中，每个位置可能向上、下、左、右四个方向移动，因此，在回溯函数体内，需要遍历这四个方向</p></li><li><p>并且，由于同一个单元格内的字母只允许使用一次，在回溯时需要维护一个 visited 数组，用于标记每个位置是否已经被访问过</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; // 四个方向bool backTrcking(vector&lt;vector&lt;char&gt;&gt;&amp; board, int starti, int startj, string word, int startk, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) &#123;    if (board[starti][startj] != word[startk]) return false; // 不匹配，返回 false    if (startk == word.size() - 1) return true; // startk 已经是 word 的最后一个字符，返回 true    visited[starti][startj] = true; // 标记 (starti, startj) 位置已访问    for (auto &amp;dir : directions) &#123;  // 遍历 上 下 左 右 四个方向        int newi = starti + dir[0]; // 下一个访问位置为 (newi, newj)        int newj = startj + dir[1];        if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size()) &#123; // 位置 (newi, newj) 未越界            if (visited[newi][newj] == false) &#123; // 未被访问过                bool flag = backTrcking(board, newi, newj, word, startk + 1, visited); // 递归到下一层                if (flag) return true; // 从 (newi, newj) 位置出发，能够找到 word[startk + 1] 及其后续字符            &#125;        &#125;    &#125;    visited[starti][startj] = false;  // 未找到 word ，回溯，撤销对 (starti, startj) 位置的标记    return false; // 返回 false&#125;bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;    vector&lt;vector&lt;bool&gt;&gt; visited(board.size(), vector&lt;bool&gt;(board[0].size(), false));    for (int i = 0; i &lt; board.size(); i++) &#123;        for (int j = 0; j &lt; board[0].size(); j++) &#123; // 遍历每一个起点 (i, j)，判断能否从该位置出发找到 word            bool tag = backTrcking(board, i, j, word, 0, visited); // 回溯搜索            if (tag) return true;        &#125;    &#125;    return false;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo>×</mo><msup><mn>3</mn><mi>L</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N \times 3^L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 分别为网格 grid 的行数和列数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是字符串 word 的长度</p><ul><li>在  <code>exist</code>  函数内，需要遍历每一个出发位置，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>对于每一个出发位置 (i, j)，需要调用  <code>backTrackinig</code>  回溯函数进行搜索，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>3</mn><mi>L</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3^L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。这是因为，最多只有第一层递归中的 for 循环有 4 个方向可以搜索，其余每一层递归中的 for 循环最多只能向 3 个方向搜索（即，只能往新位置走，不能往回走）</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><ul><li>visited 数组所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>对于每一个出发位置 (i, j) ，递归所需的栈空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(L, MN))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC9zb2x1dGlvbi9kYW4tY2ktc291LXN1by1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 76. 最小覆盖子串</title>
      <link href="/posts/e9d7ca54/"/>
      <url>/posts/e9d7ca54/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv">76. Minimum Window Substring</span></p><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</p><p>注意：</p><ul><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;解释：The minimum window substring &quot;BANC&quot; includes 'A', 'B', and 'C' from string t.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;解释：The entire string s is the minimum window.</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;a&quot;, t = &quot;aa&quot;输出：&quot;&quot;解释：Both 'a's from t must be included in the window.Since the largest window of s only has one 'a', return empty string.</code></pre><p><strong>提示：</strong></p><ul><li>m == s.length</li><li>n == t.length</li><li>1 &lt;= m, n &lt;= 10<sup>5</sup></li><li>s 和 t 由英文字母组成</li></ul><p><strong>进阶</strong>：你能设计一个在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间内解决此问题的算法吗？</p><h1 id="method-1-滑动窗口法-哈希"><a class="anchor" href="#method-1-滑动窗口法-哈希">#</a> Method 1: 滑动窗口法 + 哈希</h1><p>算法思路：</p><p>本题要在字符串 s 中找到一个包含字符串 t 全部字符的最小窗口</p><p>为便于表述，我们做出以下规定：</p><ul><li>若窗口包含字符串 t 全部字符，则该窗口为「可行窗口」</li><li>若窗口内某个字符的数量 大于等于 字符串 t 中该字符的数量，则称该字符为「达标字符」</li></ul><p>可以用滑动窗口的思想来求解：</p><ul><li>移动窗口的右端点（ r 指针），不断扩张窗口</li><li>当窗口为「可行窗口」时，移动窗口的左端点（ l 指针），收缩窗口</li><li>通过在字符串 s 上移动窗口，获取长度最小的「可行窗口」</li></ul><p>为判断当前窗口是否为「可行窗口」，我们做以下考虑：</p><ul><li>定义一个哈希表，unordered_map&lt;char, int&gt; hash ，其中，以 t 中字符作为哈希表的键，以 窗口内该字符的数量 与 t 中该字符的数量 之差作为对应的值（例如，当窗口内字符 'a' 出现 1 次、t 中字符 'a' 出现 2 次时，对应哈希表的值 hash ['a'] 为 -1）</li><li>如果某个字符对应的哈希表键值等于 0 ，则说明这个字符为「达标字符」</li><li>定义 cnt 表示窗口内「达标字符」的个数，定义 k 表示字符串 t 中的字符种类数（即，k = hash.size () ）</li><li>若 cnt 等于 k ，说明当前窗口包含了字符串 t 中的全部字符，即，当前窗口为「可行窗口」</li></ul><p>代码实现：</p><pre><code class="language-cpp">string minWindow(string s, string t) &#123;    unordered_map&lt;char, int&gt; hash;    for (auto c : t) hash[c]--;     // hash[c] 表示 窗口中字符 c 的数量与 t 中字符 c 的数量之差    int k = hash.size();            // t 中字符的类别数    string ans;    int cnt = 0;                    // 在窗口内，满足 t 字符串所需数量要求的字符个数    for (int l = 0, r = 0; r &lt; s.size(); r++) &#123;        hash[s[r]]++;        if (hash[s[r]] == 0) cnt++; // s[r] 字符的数量已满足要求        while (hash[s[l]] &gt; 0) &#123;    // 在确保 s[l] 满足数量要求的前提下，收缩窗口            hash[s[l]]--;           // s[l] 字符数量减 1            l++;                    // l 右移        &#125;        if (cnt == k) &#123;             // 窗口包含 t 所有字符            if (ans.empty() || r - l + 1 &lt; ans.size()) &#123;                ans = s.substr(l, r - l + 1);            &#125;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串 s 和 t 的长度</p><ul><li>遍历字符串 t 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>遍历字符串 s 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中，最坏情况下，指针 l 和 r 各遍历一次字符串 s</li><li>哈希查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 为字符集的大小（即，字符串 t 中字符的种类数，对应于程序中的 k ）</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcvc29sdXRpb24venVpLXhpYW8tZnUtZ2FpLXppLWNodWFuLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">leetcode-solution</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcvc29sdXRpb24vbGVldGNvZGUtNzYtenVpLXhpYW8tZnUtZ2FpLXppLWNodWFuLWNqYS1sbXF6Lw==">林小鹿</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 75. 颜色分类</title>
      <link href="/posts/748f18ba/"/>
      <url>/posts/748f18ba/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWNvbG9ycy8=">75. Sort Colors</span></p><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,0,1]输出：[0,1,2]</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">\le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>nums[i]</code>  为  <code>0</code>  、  <code>1</code>  或  <code>2</code></li></ul><p><strong>进阶</strong>：你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>可以先统计数组中 0, 1, 2 的个数，再根据它们的数量修改整个数组</p><p>但是，这样需要遍历两次</p><p>为实现一次遍历，可定义双指针，实现原地交换</p><p>考虑以下两种方案：</p><ul><li>ptr0 指向 0 的填充位置，ptr1 指向 1 的填充位置</li><li>ptr0 指向 0 的填充位置，ptr2 指向 2 的填充位置</li></ul><h1 id="method-1双指针"><a class="anchor" href="#method-1双指针">#</a> Method 1：双指针</h1><p>算法思路：</p><p>定义指针 ptr0 指向 0 的填充位置，ptr1 指向 1 的填充位置</p><blockquote><p>[0, ptr0) 区间内的元素全为 0 ，[ptr0, ptr1) 区间内的元素全为 1</p></blockquote><p>初始化 ptr0 为 0 ，初始化 ptr1 为 0</p><p>从左往右遍历数组，记遍历到的位置为 i（i 从 0 开始）：</p><ul><li><p>如果 nums [i] == 0 ，交换 nums [i] 与 nums [ptr0] ，并做以下考虑：</p><ul><li>如果 ptr1 &gt; ptr0 ，交换前的 nums [ptr0] 必定为 1 ，即，交换后的 nums [i] 为 1 ，此时，还需将 nums [i] 与 nums [ptr1] 进行交换（因为 [ptr1, i) 区间对应的元素值全为 2 ）</li><li>无论 ptr1 &gt; ptr0 是否成立，都需将 ptr0 和 ptr1 向右移动一位、将 i 向右移动一位</li></ul></li><li><p>如果 nums [i] == 1 ，交换 nums [i] 与 nums [ptr1] ，并将 ptr1 向右移动一位、将 i 向右移动一位</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">void sortColors(vector&lt;int&gt;&amp; nums) &#123;    int ptr0 = 0;    int ptr1 = 0;    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (nums[i] == 0) &#123;            swap(nums[i], nums[ptr0]);            if (ptr0 &lt; ptr1) &#123;                swap(nums[i], nums[ptr1]);            &#125;            ptr0++;            ptr1++;        &#125; else if (nums[i] == 1) &#123;            swap(nums[i], nums[ptr1]);            ptr1++;        &#125;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2双指针"><a class="anchor" href="#method-2双指针">#</a> Method 2：双指针</h1><p>算法思路：</p><p>定义指针 ptr0 指向 0 的填充位置，ptr2 指向 2 的填充位置</p><blockquote><p>[0, ptr0) 区间内的元素全为 0 ，(ptr2, nums.size () - 1] 区间内的元素全为 2</p></blockquote><p>初始化 ptr0 为 0 ，初始化 ptr2 为 nums.size () - 1</p><p>从左往右遍历数组，记遍历到的位置为 i（i 从 0 开始），当 i 超过 ptr2 时，结束遍历：</p><ul><li><p>如果 nums [i] == 0 ，交换 nums [i] 与 nums [ptr0] ，并将 ptr0 向右移动一位、将 i 向右移动一位</p></li><li><p>如果 nums [i] == 2 ，交换 nums [i] 与 nums [ptr2] ，并将 ptr2 向左移动一位，但是，交换所得的 nums [i] 可能是 0 、1、2 中的任意值，需要继续对 nums [i] 进行判断和处理</p></li><li><p>如果 nums [i] == 1 ，无需进行任何交换，直接将 i 右移一位即可</p></li></ul><blockquote><p>当 nums [i] == 0 时，可以在交换 nums [i] 与 nums [ptr0] 以后直接将 i 右移，无需考虑交换后 nums [i] 的取值，这是因为：</p><ul><li>若 i == ptr0 ，实际并未进行交换，新的 nums [i] 就是 0</li><li>若 i &gt; ptr0 ，由于 i 是从左往右遍历的，区间 [ptr0, i - 1] 对应的元素值必定全为 1 ，在交换 nums [i] 与 nums [ptr0] 以后，区间 [0, ptr0] 对应的元素值全为 0 、区间 [ptr0 + 1, i] 对应的元素值全为 1 ，因此，可以直接考虑 i + 1 位置</li></ul></blockquote><p>特别地：当 nums [i] == 2 时，需要将其与 nums [ptr2] 进行交换，由于交换后的 nums [i] 可能是 0 ，即，需要再按照 nums [i] == 0 的情况进行处理。因此，在遍历 nums [i] 时， 我们可以先处理 nums [i] == 2 的情况，再处理 nums [i] == 0 的情况，以简化代码</p><p>代码实现：</p><pre><code class="language-cpp">void sortColors(vector&lt;int&gt;&amp; nums) &#123;    int ptr0 = 0;    int ptr2 = nums.size() - 1;    for (int i = 0; i &lt;= ptr2; i++) &#123;        while (i &lt;= ptr2 &amp;&amp; nums[i] == 2) &#123;            swap(nums[i], nums[ptr2]);            ptr2--;        &#125;        if (nums[i] == 0) &#123;            swap(nums[i], nums[ptr0]);            ptr0++;        &#125;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWNvbG9ycy9zb2x1dGlvbi95YW4tc2UtZmVuLWxlaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 64. 最小路径和</title>
      <link href="/posts/22de13ba/"/>
      <url>/posts/22de13ba/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXBhdGgtc3VtLw==">64. Minimum Path Sum</span></p><p>给定一个包含非负整数的  <code>m x n</code>  网格  <code>grid</code>  ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明</strong>：每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/22de13ba/Example1.jpg" class=""></p><pre><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[1,2,3],[4,5,6]]输出：12</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code> ,  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>grid[i][j]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>代码实现：</p><pre><code class="language-cpp">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        // 定义 dp 数组    int m = grid.size();    int n = grid[0].size();    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); // dp[i][j] 表示从左上角到达 (i, j) 位置的最小路径和        // 初始化    dp[0][0] = grid[0][0];    for (int i = 1; i &lt; m; i++)        dp[i][0] = dp[i - 1][0] + grid[i][0];    for (int j = 1; j &lt; n; j++)        dp[0][j] = dp[0][j - 1] + grid[0][j];        // 更新 dp 数组    for (int i = 1; i &lt; m; i++) &#123;        for (int j = 1; j &lt; n; j++) &#123;            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];        &#125;    &#125;        // 目标值    return dp[m - 1][n - 1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是网格的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以使用滚动数组来降低空间复杂度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 49. 字母异位词分组</title>
      <link href="/posts/c5b1c655/"/>
      <url>/posts/c5b1c655/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy8=">49. Group Anagrams</span></p><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>示例 1：</strong></p><pre><code>输入：strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]输出：[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：strs = [&quot;&quot;]输出：[[&quot;&quot;]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：strs = [&quot;a&quot;]输出：[[&quot;a&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>strs.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>strs[i].length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>strs[i]</code>  仅包含小写字母</li></ul><h1 id="method-1-排序-哈希"><a class="anchor" href="#method-1-排序-哈希">#</a> Method 1: 排序 + 哈希</h1><p>算法思路：</p><p>两个字符串互为字母异位词，当且仅当它们包含的字母相同，因此，对两个字母异位词分别进行排序，所得的字符串一定相同</p><p>可以将排序之后的字符串作为哈希表的键，哈希表的值存放每一组字母异位词</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;    unordered_map&lt;string, vector&lt;string&gt;&gt; hash;    for (auto &amp;s : strs) &#123;        string key = s;        sort(key.begin(), key.end());        hash[key].push_back(s);    &#125;    vector&lt;vector&lt;string&gt;&gt; ans;    for (auto it = hash.begin(); it != hash.end(); it++) &#123;        ans.push_back(it-&gt;second);    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n k \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是  <code>strs</code>  的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是 <code>strs</code>  中字符串的最大长度</p><ul><li>遍历  <code>strs</code>  的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>对  <code>strs</code>  中的每个字符串进行排序，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span></li><li>哈希查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，需要用哈希表存储所有字母异位词</p><h1 id="method-2-计数-哈希"><a class="anchor" href="#method-2-计数-哈希">#</a> Method 2: 计数 + 哈希</h1><p>算法思路：</p><p>两个字母异位词中的每一种字母的出现次数一定相同</p><p>可以使用字符串表示字母的出现次数，将其作为哈希表的键</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy9zb2x1dGlvbi96aS1tdS15aS13ZWktY2ktZmVuLXp1LWJ5LWxlZXRjb2RlLXNvbHV0LWd5b2Mv">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 48. 旋转图像</title>
      <link href="/posts/a46bcf58/"/>
      <url>/posts/a46bcf58/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uv">48. Rotate Image</span></p><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/a46bcf58/Example1.jpg" class=""></p><pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]]</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/a46bcf58/Example2.jpg" class=""></p><pre><code>输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code></pre><p><strong>提示：</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>matrix[i][j]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-1-原地旋转"><a class="anchor" href="#method-1-原地旋转">#</a> Method 1: 原地旋转</h1><p>经过观察，可以发现：</p><ul><li><p>原矩阵中的位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ，旋转后的目标位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[j][n - i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p></li><li><p>原矩阵中的位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[j][n - i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，旋转后的目标位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[n - i - 1][n - j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p></li><li><p>原矩阵中的位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[n - i - 1][n - j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，旋转后的目标位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[n - j - 1][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></p></li><li><p>原矩阵中的位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[n - j - 1][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，旋转后的目标位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p></li></ul><p>即，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[j][n - i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[n - i - 1][n - j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[n - j - 1][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 而言，每一项旋转后的位置就是下一项所在的位置</p><p>因此，可以引入一个临时变量  <code>tmp</code>  ，完成这四项的原地交换</p><pre><code class="language-cpp">int tmp = matrix[n - j - 1][i];matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];matrix[j][n - i - 1] = matrix[i][j];matrix[i][j] = tmp;</code></pre><p>那么，我们应该枚举哪些 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 呢？</p><p>每一次可以交换四个位置的元素：</p><ul height="150px"><li height="150px"><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为偶数时，此时需要枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n^2 / 4 = (n / 2) \times (n / 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 个位置。因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 分别遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个位置，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 矩阵为例</p><p><img data-src="/posts/a46bcf58/pic1.png" class=""></p></li><li><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为奇数时，由于中心位置始终不变，需要枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n^2 - 1) / 4 = ((n - 1) / 2) \times ((n + 1) / 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 个位置。因此，i 遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n - 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个位置、j 遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个位置，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5 \times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 矩阵为例</p><p><img data-src="/posts/a46bcf58/pic2.png" class=""></p></li></ul><p>因此，无论 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是奇数还是偶数，均可按照 “ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个位置、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个位置 ” 来处理，即， <code>i</code>  遍历  <code>[0, n / 2)</code>  ， <code>j</code>  遍历  <code>[0, (n + 1) / 2)</code></p><p>代码实现：</p><pre><code class="language-cpp">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    int n = matrix.size();    for (int i = 0; i &lt; n / 2; i++) &#123;        for (int j = 0; j &lt; (n + 1) / 2; j++) &#123;            int tmp = matrix[n - j - 1][i];            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];            matrix[j][n - i - 1] = matrix[i][j];            matrix[i][j] = tmp;        &#125;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-翻转"><a class="anchor" href="#method-2-翻转">#</a> Method 2: 翻转</h1><p>算法思路：</p><p>首先进行上下翻转，然后进行对角线翻转（即，转置）</p><p>理论推导：</p><p>对于上下翻转：只需要枚举矩阵上半部分的元素，并将其与下半部分对应位置的元素进行交换，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>⟷</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[i][j] \longleftrightarrow matrix[n - i - 1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟷</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p><p>对于对角线翻转：只需要枚举对角线左侧的元素，并将其与右侧对应位置的元素进行交换，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>⟷</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[i][j] \longleftrightarrow matrix[j][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟷</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>联立以上两式可得</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>⟶</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>⟶</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[i][j] \longrightarrow matrix[n - i - 1][j] \longrightarrow matrix[j][n - i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p><p>即，实现了将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 旋转 90 度、放到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[j][n - i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 位置</p><p>代码实现：</p><pre><code class="language-cpp">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    int n = matrix.size();    for (int i = 0; i &lt; n / 2; i++) &#123; // 上下翻转        for (int j = 0; j &lt; n; j++) &#123;            swap(matrix[i][j], matrix[n - i - 1][j]);        &#125;    &#125;    for (int i = 0; i &lt; n; i++) &#123;     // 对角线翻转        for (int j = 0; j &lt; i; j++) &#123;            swap(matrix[i][j], matrix[j][i]);        &#125;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uvc29sdXRpb24veHVhbi16aHVhbi10dS14aWFuZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi12dTNtLw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 42. 接雨水</title>
      <link href="/posts/6ce9cc69/"/>
      <url>/posts/6ce9cc69/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLw==">42.  Trapping Rain Water</span></p><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/6ce9cc69/Example1.png" class=""></p><pre><code>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：height = [4,2,0,3,2,5]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>height[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>对于数组中的每个位置，所能承接的最大雨水量 等于 该位置两侧最大高度的较小值减去当前高度的值</p><h1 id="method-1-动态规划"><a class="anchor" href="#method-1-动态规划">#</a> Method 1: 动态规划</h1><p>算法思路：</p><p>定义 leftMax [i] 表示 [0, i] 索引范围内的最大高度，rightMax [i] 表示 [i, height.size () - 1] 索引范围内的最大高度</p><p>初始化：</p><ul><li>leftMax[0] = height[0]</li><li>rightMax[n - 1] = height[n - 1]</li></ul><p>根据定义知</p><ul><li>leftMax[i] = max(leftMax[i - 1], height[i])</li><li>rightMax[i] = max(rightMax[i + 1], height[i])</li></ul><p>其中，应按 i 从小到大的顺序更新 leftMax 数组，按 i 从大到小的顺序更新 rightMax 数组</p><p>在更新完 leftMax 和 rightMax 数组后，任意位置 i 的接水量为 min (leftMax [i], rightMax [i]) - height [i] ，对其进行累加即为总的接水量</p><p>代码实现：</p><pre><code class="language-cpp">int trap(vector&lt;int&gt;&amp; height) &#123;    int n = height.size();    vector&lt;int&gt; leftMax(n, 0);    // leftMax[i] 表示 height[0, i] 区间内的最大值    leftMax[0] = height[0];    for (int i = 1; i &lt; n; i++) &#123; // 更新 leftMax 数组        leftMax[i] = max(leftMax[i - 1], height[i]);    &#125;    vector&lt;int&gt; rightMax(n, 0);   // rightMax[i] 表示 height[i, n - 1] 区间内的最大值    rightMax[n - 1] = height[n - 1];    for (int i = n - 2; i &gt;= 0; i--) &#123; // 更新 rightMax 数组        rightMax[i] = max(rightMax[i + 1], height[i]);    &#125;    int ans = 0;    for (int i = 1; i &lt; n; i++) &#123; // 计算接水量        ans += min(leftMax[i], rightMax[i]) - height[i];    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>height</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-双指针"><a class="anchor" href="#method-2-双指针">#</a> Method 2: 双指针</h1><p>由于 Method 1 中的数组 leftMax 是从左往右计算、数组 rightMax 是从右往左计算，可以使用左右指针和两个变量代替数组 leftMax 和 rightMax</p><p>算法思路：</p><p>定义指针 i 和指针 j ，以及变量 leftMax 和 rightMax ，初始时 i = 0 ，j = n − 1 ，leftMax = 0 ，rightMax = 0</p><ul><li>这里定义的 leftMax 等价于 Method 1 中的 leftMax [i]</li><li>这里定义的 rightMax 等价于 Method 1 中的 rightMax [j]</li></ul><p>当 i &lt; j 时，执行循环：</p><ul><li><p>更新 leftMax 和 rightMax</p><ul><li>leftMax = max(leftMax, height[i])</li><li>rightMax = max(rightMax, height[j])</li></ul></li><li><p>若 leftMax &lt;rightMax ，说明位置 i 接水时的短板为左侧的最高板块，即 leftMax （因为 i 右侧的最高板块必定大于等于 rightMax ），因此，位置 i 的接水量为 leftMax - height [i] ，执行以下操作：</p><ul><li>累加接水量：ans += leftMax - height [i]</li><li>i 右移一位：i++</li></ul><blockquote><p>对应于 Method 1 中的 leftMax [i] &lt; rightMax [j] ，由于 rightMax [j] &lt;= rightMax [i] 始终成立，所以有 leftMax [i] &lt; rightMax [j] &lt;= rightMax [i] ，因此， leftMax [i] 是短板</p></blockquote></li><li><p>否则（即 rightMax &lt;= leftMax ），说明位置 j 接水时的短板为右侧的最高板块，即 rightMax （因为 j 左侧的最高板块必定大于等于 leftMax ），因此，位置 j 的接水量为 rightMax - height [j] ，执行以下操作：</p><ul><li>累加接水量：ans += rightMax - height [j]</li><li>j 左移一位：j++</li></ul><blockquote><p>对应于 Method 1 中的 rightMax [j] &lt;= leftMax [i] ，由于 leftMax [i] &lt;= leftMax [j] 始终成立，所以有 rightMax [j] &lt;= leftMax [i] &lt;= leftMax [j] ，因此， rightMax [j] 是短板</p></blockquote></li></ul><p>代码实现：</p><pre><code class="language-cpp">int trap(vector&lt;int&gt;&amp; height) &#123;    int left = 0;    int right = height.size() - 1;    int leftMax = 0;    int rightMax = 0;    int ans = 0;    while (left &lt;= right) &#123;        leftMax = max(leftMax, height[left]);        rightMax = max(rightMax, height[right]);        if (leftMax &lt; rightMax) &#123;            ans += leftMax - height[left];            left++;        &#125; else &#123;            ans += rightMax - height[right];            right--;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>height</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyL3NvbHV0aW9uL2ppZS15dS1zaHVpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLXR1dmMv">LeetCode-Solution</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyL3NvbHV0aW9uL2ppZS15dS1zaHVpLWJ5LWxlZXRjb2RlLw==">LeetCode</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 33. 搜索旋转排序数组</title>
      <link href="/posts/e1a07bef/"/>
      <url>/posts/e1a07bef/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkv">33. Search in Rotated Sorted Array</span></p><p>整数数组  <code>nums</code>  按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前， <code>nums</code>  在预先未知的某个下标  <code>k</code> （ <code>0 &lt;= k &lt; nums.length</code> ）上进行了 旋转，使数组变为  <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> （下标 <strong>从 0 开始</strong> 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 <strong>旋转后</strong> 的数组  <code>nums</code>  和一个整数  <code>target</code>  ，如果  <code>nums</code>  中存在这个目标值  <code>target</code>  ，则返回它的下标，否则返回  <code>-1</code>  。</p><p>你必须设计一个时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,5,6,7,0,1,2], target = 0输出：4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1], target = 0输出：-1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>nums</code>  中的每个值都 独一无二</li><li>题目数据保证  <code>nums</code>  在预先未知的某个下标上进行了旋转</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span> target <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-二分查找"><a class="anchor" href="#method-二分查找">#</a> Method: 二分查找</h1><p>算法思路：在经过旋转后，数组  <code>nums</code>  可以分成两个有序的子数组，可首先找出这两个子数组的分界线，然后将  <code>target</code>  与子数组端点的大小进行比较，从而确定在哪个子数组中查找  <code>target</code></p><p>其中，确定两个子数组的分界线、在某一个子数组中查找  <code>target</code>  ，这两步都可以通过二分查找算法实现</p><p>代码实现：</p><pre><code class="language-cpp">int search(vector&lt;int&gt;&amp; nums, int target) &#123;    int n = nums.size();    if (n == 1) return nums[0] == target ? 0 : -1;        // 二分查找，寻找数组 nums 的分界线    int l = 0;    int r = n - 1;    while (l &lt; r) &#123;        int mid = (l + r + 1) &gt;&gt; 1;        if (nums[mid] &gt;= nums[0]) l = mid;        else r = mid - 1;    &#125;    // 确定搜索区间    if (target == nums[0]) return 0;    else if (target &gt; nums[0]) l = 0; // 上一次二分查找结束时，l == r    else if (target &lt; nums[0]) &#123;        l = l + 1;        r = n - 1;    &#125;    // 二分查找，确定 target 的位置    while (l &lt;= r) &#123;        int mid = (l + r) &gt;&gt; 1;        if (nums[mid] == target) return mid;        else if (nums[mid] &lt; target) l = mid + 1;        else if (nums[mid] &gt; target) r = mid - 1;    &#125;    return -1;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 32. 最长有效括号</title>
      <link href="/posts/d86ca4e7/"/>
      <url>/posts/d86ca4e7/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzLw==">32. Longest Valid Parentheses</span></p><p>给你一个只包含  <code>'('</code>  和  <code>')'</code>  的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;(()&quot;输出：2解释：最长有效括号子串是 &quot;()&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;)()())&quot;输出：4解释：最长有效括号子串是 &quot;()()&quot;</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;&quot;输出：0</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s[i]</code>  为  <code>'('</code>  或  <code>')'</code></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp [i] 表示以 s [i] 结尾的最长有效括号的长度</p><p>初始化 dp [i] ：全都初始化为 0</p><p>推导 dp [i] 的状态转移过程：</p><ul><li>若 s [i] == '(' ，无法形成以 s [i] 结尾的有效括号，则 dp [i] = 0</li><li>若 s [i] == ')' ，需要进一步分析前面的字符<ul><li>若 s [i - 1] == '(' ，则 s [i - 1] 可以与 s [i] 组成一对有效括号，因此：<ul><li>若 i - 2 &lt;0 ，即 s [0, i] = &quot;()&quot; ，有 dp [i] = 2</li><li>若 i - 2 &gt;= 0 ，以 s [i] 结尾的最长有效括号的长度为 dp [i - 2] + 2</li></ul></li><li>若 s [i - 1] == ')' ，以 s [i] 结尾的最长有效括号只能是形如 “((...))” 的括号对，此时需要找到与 s [i] 配对的位置，即，i - dp [i - 1] - 1<ul><li>若 i - dp [i - 1] - 1 &gt;= 0 且 s [i - dp [i - 1] - 1] == '(' ，则 s [i - dp [i - 1] - 1] 可以与 s [i] 组成有效括号，即，以 s [i] 结尾的最长有效括号的长度至少为 dp [i - 1] + 2<ul><li>需注意的是：可能存在以 s [i - dp [i - 1] - 2] 结尾的有效括号，即，可以将 “以 s [i - dp [i - 1] - 2] 结尾的有效括号” 与 “以 s [i - dp [i - 1] - 1] 起始的、以 s [i] 结尾的有效括号” 拼接</li><li>因此，如果 i - dp [i - 1] - 2 &gt;= 0 ，则以 s [i] 结尾的最长有效括号的长度为 dp [i - dp [i - 1] - 2] + dp [i - 1] + 2</li></ul></li></ul></li></ul></li></ul><p>确定遍历顺序：根据递推公式知，dp [i] 依赖于 dp [i - 1] 、dp [i - 2] 、dp [i - dp [i - 1] - 2] ，因此，应按照 i 从小到大的顺序遍历</p><p>遍历结束后，找出值最大的 dp [i] ，即为最长有效括号的长度</p><p>代码实现：</p><pre><code class="language-cpp">int longestValidParentheses(string s) &#123;    vector&lt;int&gt; dp(s.size(), 0);    int ans = 0;    for (int i = 1; i &lt; s.size(); i++) &#123;        if (s[i] == ')') &#123;            if (s[i - 1] == '(') &#123;                if (i &gt;= 2) dp[i] = dp[i - 2] + 2;                else dp[i] = 2;            &#125; else if (i - dp[i - 1] - 1 &gt;= 0 &amp;&amp; s[i - dp[i - 1] - 1] == '(') &#123;                dp[i] = dp[i - 1] + 2;                if (i - dp[i - 1] - 2 &gt;= 0) &#123;                    dp[i] = dp[i] + dp[i - dp[i - 1] - 2];                &#125;            &#125;            ans = max(ans, dp[i]);        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是  <code>s</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzL3NvbHV0aW9uL3p1aS1jaGFuZy15b3UteGlhby1ndWEtaGFvLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 31. 下一个排列</title>
      <link href="/posts/b6e7cff2/"/>
      <url>/posts/b6e7cff2/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LXBlcm11dGF0aW9uLw==">31. Next Permutation</span></p><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</li></ul><p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</li><li>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</li><li>arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组  <code>nums</code>  ，找出  <code>nums</code>  的下一个排列。</p><p>必须 <strong>原地</strong> 修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[1,3,2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,1]输出：[1,2,3]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,1,5]输出：[1,5,1]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>我们希望找到一个大于字典序更大的排列，并且使得变大的幅度尽可能小，即：</p><ul><li><p>需要将一个左边的「较小数」与一个右边的「较大数」交换，以使得字典序变大</p></li><li><p>同时，要让这个「较小数」尽量靠右，而「较大数」尽可能小。为此，在完成交换后，需要将「较大数」右边的数按照升序重新排列</p></li></ul><p>以 [4,5,2,6,3,1] 为例：</p><ul><li><p>我们能找到的符合条件的「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右、「较大数」尽可能小</p></li><li><p>当我们完成交换后，序列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列（即，[6,2,1] ），序列变为 [4,5,3,1,2,6]</p></li></ul><h1 id="method"><a class="anchor" href="#method">#</a> Method</h1><p>算法思路：</p><ol><li><p>从后向前遍历，查找第一个满足  <code>nums[i] &lt; nums[i + 1]</code>  的索引  <code>i</code>  ，此时， <code>nums[i]</code>  即为「较小数」，并且，可以证明  <code>[i + 1, n - 1]</code>  必然是下降序列，其中， <code>n</code>  为  <code>nums</code>  的长度</p></li><li><p>在区间  <code>[i + 1, n - 1]</code>  内从后向前遍历，查找第一个满足  <code>nums[i] &lt; nums[j]</code>  的索引  <code>j</code>  ，此时， <code>nums[j]</code>  即为「较大数」</p></li><li><p>交换  <code>nums[i]</code>  和  <code>nums[j]</code></p></li><li><p>反转区间  <code>[i + 1, n - 1]</code>  内的元素，使其变为升序</p></li></ol><p>如果在步骤 1 中无法找到满足条件的  <code>i</code>  ，说明当前序列已经是一个字典序最大的排列，直接执行步骤 4 即可得到字典序最小的排列</p><blockquote><p>该方法适用于序列存在重复元素的情况，并且已被 C++ 的标准库函数  <code>next_permutation</code>  采用</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;    int i = nums.size() - 2;    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;        i--;    &#125;    if (i &gt;= 0) &#123;        int j = nums.size() - 1;        while (j &gt; i &amp;&amp; nums[i] &gt;= nums[j]) &#123;            j--;        &#125;        swap(nums[i], nums[j]);    &#125;    reverse(nums.begin() + i + 1, nums.end());&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中  <code>n</code>  为序列  <code>nums</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 23. 合并 K 个升序链表</title>
      <link href="/posts/d2ca0889/"/>
      <url>/posts/d2ca0889/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy8=">23. Merge k Sorted Lists</span></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：    [    1-&gt;4-&gt;5,    1-&gt;3-&gt;4,    2-&gt;6    ]    将它们合并到一个有序链表中得到。    1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：lists = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：lists = [[]]输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>lists[i].length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>lists[i][j]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>lists[i]</code>  按 升序 排列</li><li><code>lists[i].length</code>  的总和不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-1-顺序合并"><a class="anchor" href="#method-1-顺序合并">#</a> Method 1: 顺序合并</h1><p>算法思路：首先将  <code>lists[0]</code>  和  <code>lists[1]</code>  合并，得到链表  <code>ans</code>  ，再依次将  <code>ans</code>  与  <code>lists[2]</code>  , ... ,  <code>lists[lists.size() - 1]</code>  合并</p><p>代码实现：</p><pre><code class="language-cpp">ListNode* merge2Lists(ListNode* l1, ListNode* l2) &#123; // 合并链表 l1 和 l2    ListNode* dummyHead = new ListNode();    ListNode* tail = dummyHead;    while (l1 &amp;&amp; l2) &#123;        if (l1-&gt;val &lt;= l2-&gt;val) &#123;            tail-&gt;next = l1;            l1 = l1-&gt;next;        &#125; else &#123;            tail-&gt;next = l2;            l2 = l2-&gt;next;        &#125;        tail = tail-&gt;next;    &#125;    tail-&gt;next = l1 ? l1 : l2;    ListNode* head = dummyHead-&gt;next;    delete dummyHead;    return head;&#125;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    if (lists.size() == 0) return nullptr;    ListNode* ans = lists[0];    for (int i = 1; i &lt; lists.size(); i++) &#123; // 顺序合并        ans = merge2Lists(ans, lists[i]);    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是 lists 中的链表条数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是 lists 中链表的最大长度</p><ul><li>将链表  <code>ans</code>  与链表  <code>lists[i]</code>  合并的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>i</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + (i - 1) \times n) = O(i \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>i</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sum\limits_{i = 1}^{n} (i \times n)) = O(k^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-分治"><a class="anchor" href="#method-2-分治">#</a> Method 2: 分治</h1><p>算法思路：可以用分治的思路来合并，即：</p><ul><li>首先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 条链表进行配对，将每一对链表进行合并，由此可得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 条链表（链表的最大长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">2 n / k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>）</li><li>继续将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 条链表进行配对，合并每一对链表，可得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">k / 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">4</span></span></span></span> 条链表（链表的最大长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">4 n / k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>）</li><li>重复该过程，直到所有链表均已合并完成</li></ul><p>代码实现：</p><pre><code class="language-cpp">ListNode* merge2Lists(ListNode* l1, ListNode* l2) &#123; // 合并链表 l1 和 l2    ListNode* dummyHead = new ListNode();    ListNode* tail = dummyHead;    while (l1 &amp;&amp; l2) &#123;        if (l1-&gt;val &lt;= l2-&gt;val) &#123;            tail-&gt;next = l1;            l1 = l1-&gt;next;        &#125; else &#123;            tail-&gt;next = l2;            l2 = l2-&gt;next;        &#125;        tail = tail-&gt;next;    &#125;    tail-&gt;next = l1 ? l1 : l2;    ListNode* head = dummyHead-&gt;next;    delete dummyHead;    return head;&#125;ListNode* merge(vector&lt;ListNode*&gt;&amp; lists, int left, int right) &#123; // 合并 [left, right] 索引范围内的链表    if (left == right) return lists[left];    if (left &gt; right) return nullptr;    int mid = (left + right) &gt;&gt; 1;    ListNode* l1 = merge(lists, left, mid);      // 合并 [left, mid] 索引范围内的链表    ListNode* l2 = merge(lists, mid + 1, right); // 合并 [mid + 1, right] 索引范围内的链表    return merge2Lists(l1, l2);                  // 合并成一条链表&#125;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    return merge(lists, 0, lists.size() - 1);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k n \times \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span></p><ul><li>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 轮合并 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">k / 2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span> 对链表，其中，合并每一对的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>i</mi></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^i n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><mfrac><mi>k</mi><msup><mn>2</mn><mi>i</mi></msup></mfrac><mo>×</mo><msup><mn>2</mn><mi>i</mi></msup><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sum\limits_{i = 1}^{n} (\frac{k}{2^i} \times 2^i n)) = O(k n \times \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7570857142857143em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span>，递归（  <code>merge</code>  函数）所需栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy9zb2x1dGlvbi9oZS1iaW5nLWtnZS1wYWkteHUtbGlhbi1iaWFvLWJ5LWxlZXRjb2RlLXNvbHV0aW8tMi8=">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 22. 括号生成</title>
      <link href="/posts/714a7a8a/"/>
      <url>/posts/714a7a8a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy8=">22. Generate Parentheses</span></p><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1输出：[&quot;()&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span></li></ul><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><p>回溯函数的参数：</p><ul><li><code>vector&lt;string&gt;&amp; ans</code>  ：存放所有可行的组合</li><li><code>string path</code>  ：当前遍历的组合</li><li><code>int open</code>  ：当前组合中的左括号数量</li><li><code>int close</code>  ：当前组合中的右括号数量</li><li><code>int n</code>  ：限定的括号对数</li></ul><p>终止条件：括号总数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> ，即，已经有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 对括号时，将当前组合添加到目标数组，当前递归结束</p><p>单层递归的逻辑：</p><ul><li>若左括号数量小于 n ，则可添加左括号，并递归到下一层</li><li>若右括号数量小于左括号数量，则可添加右括号，并递归到下一层</li></ul><p>代码实现：</p><pre><code class="language-cpp">void backTracking(vector&lt;string&gt;&amp; ans, string path, int open, int close, int n) &#123;    if (path.size() == n * 2) &#123;        ans.push_back(path);        return;    &#125;    if (open &lt; n) &#123;     // 添加左括号        path.push_back('(');        backTracking(ans, path, open + 1, close, n);        path.pop_back();    &#125;    if (close &lt; open) &#123; // 添加右括号        path.push_back(')');        backTracking(ans, path, open, close + 1, n);        path.pop_back();    &#125;&#125;vector&lt;string&gt; generateParenthesis(int n) &#123;    vector&lt;string&gt; ans;    backTracking(ans, &quot;&quot;, 0, 0, n);    return ans;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 21. 合并两个有序链表</title>
      <link href="/posts/13dd79c8/"/>
      <url>/posts/13dd79c8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzLw==">21. Merge Two Sorted Lists</span></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/13dd79c8/Example1.jpg" class=""></p><pre><code>输入：list1 = [1,2,4], list2 = [1,3,4]输出：[1,1,2,3,4,4]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：list1 = [], list2 = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：list1 = [], list2 = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>50</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 50]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span> Node.val <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>list1</code>  和  <code>list2</code>  均按 <strong>非递减顺序</strong> 排列</li></ul><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>单层递归的逻辑：</p><ul><li><p>若  <code>list1 == nullptr</code>  ，则可取  <code>list2</code>  作为目标链表</p></li><li><p>若  <code>list2 == nullptr</code>  ，则可取  <code>list1</code>  作为目标链表</p></li><li><p>若  <code>list1-&gt;val &lt;= list2-&gt;val</code>  ，则应将  <code>list1</code>  添加到目标链表，并递归调用  <code>mergeTwoLists(list1-&gt;next, list2)</code>  以确定目标链表中的下一个节点，即， <code>list1-&gt;next = mergeTwoLists(list1-&gt;next, list2)</code></p></li><li><p>若  <code>list1-&gt;val &gt; list2-&gt;val</code>  ，则应将  <code>list2</code>  添加到目标链表，并递归调用  <code>mergeTwoLists(list1, list2-&gt;next)</code>  以确定目标链表中的下一个节点，即， <code>list2-&gt;next = mergeTwoLists(list1, list2-&gt;next)</code></p></li></ul><p>代码实现：</p><pre><code class="language-cpp">ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;    if (list1 == nullptr) return list2;    else if (list2 == nullptr) return list1;    else if (list1-&gt;val &lt;= list2-&gt;val) &#123;        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);        return list1;    &#125; else &#123;        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);        return list2;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是链表  <code>list1</code>  和链表  <code>list2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p><h1 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h1><p>算法思路：</p><p>定义一个虚拟头节点（哑节点）  <code>dummyHead</code>  ，初始化为  <code>ListNode(0)</code> ，其  <code>next</code>  指针指向目标链表的头节点</p><p>定义一个指针  <code>prev</code>  指向目标链接的末尾，初始化  <code>prev</code>  为  <code>dummyHead</code> ，其  <code>next</code>  指针将指向新添加的节点</p><p>遍历链表  <code>list1</code>  和  <code>list2</code>  ，直到其中一个链表为空：</p><ul><li>若  <code>list1-&gt;val &lt;= list2-&gt;val</code>  ，则应将  <code>list1</code>  添加到目标链表，即  <code>prev-&gt;next = list1</code>  ，并将  <code>list1</code>  和  <code>prev</code>  分别向后移动一步</li><li>若  <code>list1-&gt;val &gt; list2-&gt;val</code>  ，则应将  <code>list2</code>  添加到目标链表，即  <code>prev-&gt;next = list2</code>  ，并将  <code>list2</code>  和  <code>prev</code>  分别向后移动一步</li></ul><p>循环结束后， <code>list1</code>  和  <code>list2</code>  最多只有一个非空，直接将目标链表的末尾指向非空链表即可</p><p>代码实现：</p><pre><code class="language-cpp">ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;    ListNode* dummyHead = new ListNode();    ListNode* prev = dummyHead;    while (list1 &amp;&amp; list2) &#123;        if (list1-&gt;val &lt;= list2-&gt;val) &#123;            prev-&gt;next = list1;            list1 = list1-&gt;next;        &#125; else &#123;            prev-&gt;next = list2;            list2 = list2-&gt;next;        &#125;        prev = prev-&gt;next;    &#125;    prev-&gt;next = list1 == nullptr ? list2 : list1;    ListNode* ans = dummyHead-&gt;next;    delete dummyHead;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是链表  <code>list1</code>  和链表  <code>list2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzL3NvbHV0aW9uL2hlLWJpbmctbGlhbmctZ2UteW91LXh1LWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1Lw==">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 11. 盛最多水的容器</title>
      <link href="/posts/af31d3c7/"/>
      <url>/posts/af31d3c7/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLw==">11. Container With Most Water</span></p><p>给定一个长度为  <code>n</code>  的整数数组  <code>height</code>  。有  <code>n</code>  条垂线，第  <code>i</code>  条线的两个端点是  <code>(i, 0)</code>  和  <code>(i, height[i])</code>  。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明</strong>：你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/af31d3c7/Example1.jpg" class=""></p><pre><code>输入：height = [1,8,6,2,5,4,8,3,7]输出：49解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：height = [1,1]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>height[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h1><p>算法思路：</p><p>定义指针  <code>i</code>  和  <code>j</code>  ，分别指向水槽的左右边界</p><p>水槽的容积由短板决定，即，水槽容积为  <code>(j - i) * min(height[i], height[j])</code></p><p>在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽的底边宽度变小：</p><ul><li>若将短板向内侧移动， <code>min(height[i], height[j])</code>  可能会变大，因此，下个水槽的容积可能会增大</li><li>若将长板向内侧移动， <code>min(height[i], height[j])</code> ​ 不变或者会变小，因此，下个水槽的容积一定变小</li></ul><p>因此，可以令双指针分别指向  <code>height</code>  的首尾，每次将短板向内侧移动一格，更新最大容积，直到两指针相遇时循环结束，即可获得最大容积</p><p>代码实现：</p><pre><code class="language-cpp">int maxArea(vector&lt;int&gt;&amp; height) &#123;    int i = 0;    int j = height.size() - 1;    int res = 0;    while (i &lt; j) &#123;        if (height[i] &lt;= height[j]) &#123;            res = max(res, (j - i) * height[i]);            i++;        &#125; else &#123;            res = max(res, (j - i) * height[j]);            j--;        &#125;    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>height</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 10. 正则表达式匹配</title>
      <link href="/posts/f95e67ed/"/>
      <url>/posts/f95e67ed/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcv">10. Regular Expression Matching</span></p><p>给你一个字符串  <code>s</code>  和一个字符规律  <code>p</code> ，请你来实现一个支持  <code>'.'</code>  和  <code>'*'</code>  的正则表达式匹配。</p><ul><li><code>'.'</code>  匹配任意单个字符</li><li><code>'*'</code>  匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串  <code>s</code>  的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;aa&quot;, p = &quot;a&quot;输出：false解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;aa&quot;, p = &quot;a*&quot;输出：true解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;ab&quot;, p = &quot;.*&quot;输出：true解释：&quot;.*&quot; 表示可匹配零个或多个（'*'）任意字符（'.'）。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>p.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li><code>s</code>  只包含小写字母</li><li><code>p</code>  只包含小写字母，以及  <code>'.'</code>  和  <code>'*'</code></li><li>保证每次出现字符  <code>'*'</code>  时，前面都匹配到有效的字符</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组 ： <code>dp[i][j]</code>  表示  <code>s[0, i - 1]</code>  是否与  <code>p[0, j - 1]</code>  匹配</p><p>初始化 dp 数组： <code>dp[0][0] = true</code>  ，其余全部初始化为  <code>false</code></p><blockquote><p>当字符串  <code>p</code>  以  <code>&quot;.*&quot;</code>  起始时，应有  <code>dp[0][2] = true</code>  ，因为  <code>&quot;.*&quot;</code>  可以匹配零个（ <code>'*'</code> ）任意字符（ <code>'.'</code> ）</p></blockquote><p>推导  <code>dp[i][j]</code>  的状态转移过程：</p><ul><li>当  <code>p[j - 1] == '*'</code>  时，可以考虑将  <code>p[j - 2]</code>  与字符串  <code>s</code>  匹配任意次<ul><li>若  <code>p[j - 2] == s[i - 1] || p[j - 2] == '.'</code>  ，则可以将  <code>p[j - 2]</code>  与  <code>s[i - 1]</code>  进行匹配。由于  <code>p[j - 2]</code>  +  <code>'*'</code>  这一组合可以匹配零次或多次，我们可以做以下考虑<ul><li>将其与  <code>s[i - 1]</code>  匹配、并考虑将其与  <code>s[i - 2]</code>  继续匹配（即，将  <code>s[i - 1]</code>  舍弃），此时， <code>dp[i][j] = dp[i - 1][j]</code></li><li>不与  <code>s[i - 1]</code>  匹配，将  <code>p[j - 2]</code>  +  <code>'*'</code>  这一组合直接舍弃，此时， <code>dp[i][j] = dp[i][j - 2]</code></li><li>综合两种情况可得， <code>dp[i][j] = dp[i - 1][j] || dp[i][j - 2]</code></li></ul></li><li>若  <code>p[j - 2] != s[i - 1] &amp;&amp; p[j - 2] != '.'</code>  ，则无法将  <code>p[j - 2]</code>  +  <code>'*'</code>  这一组合与  <code>s[i - 1]</code>  匹配，应舍弃这一组合，即， <code>dp[i][j] = dp[i][j - 2]</code></li></ul></li><li>当  <code>p[j - 1] != '*'</code>  时，考虑将  <code>p[j - 1]</code>  与  <code>s[i - 1]</code>  匹配<ul><li>若  <code>p[j - 1] == '.' || s[i - 1] == p[j - 1]</code>  ，则可以将  <code>p[j - 1]</code>  与  <code>s[i - 1]</code>  匹配，因此， <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>若  <code>p[j - 1] != '.' &amp;&amp; s[i - 1] != p[j - 1]</code>  ，无法将  <code>p[j - 1]</code>  与  <code>s[i - 1]</code>  匹配，此时， <code>dp[i][j] = false</code></li></ul></li></ul><p>确定遍历顺序：由递推公式知， <code>dp[i][j]</code>  依赖于  <code>dp[i][j - 2]</code>  、 <code>dp[i - 1][j]</code>  以及  <code>dp[i - 1][j - 1]</code>  ，因此，应按照从小到大的顺序遍历  <code>i</code>  、按照从小到大的顺序遍历  <code>j</code></p><p>特别地， <code>i</code>  应从 0 开始遍历，这是为了让  <code>s = &quot;&quot;</code>  与  <code>p = &quot;.*&quot;</code>  匹配，即，针对 示例 3 ，有  <code>dp[0][2] = true</code>  （因为当  <code>i = 0</code>  、 <code>j = 2</code>  时，会执行  <code>dp[i][j] = dp[i][j - 2]</code>  ），进一步地，才能推出  <code>dp[1][2] = true</code>  以及  <code>dp[2][2] = true</code>  （因为会执行  <code>dp[i][j] = dp[i][j - 2] || dp[i - 1][j]</code>  ）</p><p>代码实现：</p><pre><code class="language-cpp">bool isMatch(string s, string p) &#123;    vector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector&lt;bool&gt;(p.size() + 1, false));    dp[0][0] = true;    for (int i = 0; i &lt;= s.size(); i++) &#123;        for (int j = 1; j &lt;= p.size(); j++) &#123;            if (p[j - 1] == '*') &#123;                if (i &gt; 0 &amp;&amp; (p[j - 2] == '.' || s[i - 1] == p[j - 2]))                    dp[i][j] = dp[i][j - 2] || dp[i - 1][j];                else                    dp[i][j] = dp[i][j - 2];            &#125; else &#123;                if (i &gt; 0 &amp;&amp; (p[j - 1] == '.' || s[i - 1] == p[j - 1]))                    dp[i][j] = dp[i - 1][j - 1];            &#125;        &#125;    &#125;    return dp[s.size()][p.size()];&#125;</code></pre><p>其中，对情况  <code>p[j - 1] == '*'</code>  的处理，即</p><pre><code>if (i &gt; 0 &amp;&amp; (p[j - 2] == '.' || s[i - 1] == p[j - 2]))    dp[i][j] = dp[i][j - 2] || dp[i - 1][j];else    dp[i][j] = dp[i][j - 2];</code></pre><p>可改写为</p><pre><code>dp[i][j] = dp[i][j - 2];if (i &gt; 0 &amp;&amp; (p[j - 2] == '.' || s[i - 1] == p[j - 2]))    dp[i][j] = dp[i][j] || dp[i - 1][j];</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串  <code>s</code>  和  <code>p</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcvc29sdXRpb24vemhlbmctemUtYmlhby1kYS1zaGktcGktcGVpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5. 最长回文子串</title>
      <link href="/posts/42c47a1c/"/>
      <url>/posts/42c47a1c/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy8=">5. Longest Palindromic Substring</span></p><p>给你一个字符串  <code>s</code>  ，找到  <code>s</code>  中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;</code></pre><p><strong>提示：</strong></p><ul><li>1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 1000</li><li><code>s</code>  仅由数字和英文字母组成</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示  <code>[i, j]</code>  区间范围内的子串是否为回文子串，其中， <code>0 &lt;= i &lt;= s.size() - 1</code>  ， <code>i &lt;= j &lt;= s.size() - 1</code></p><p>初始化 dp 数组：全都初始化为  <code>false</code></p><p>推导状态转移过程：当  <code>s[i] == s[j]</code>  时，考虑以下情况：</p><ul><li><code>j - i == 0</code>  ：即，只有一个字符，此时一定为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i == 1</code>  ：即，只有  <code>s[i]</code>  和  <code>s[j]</code>  这两个相同的字符，此时也为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i &gt; 1</code>  ：此时， <code>s[i, j]</code>  多于两个字符，若  <code>s[i + 1, j - 1]</code>  是回文子串，则  <code>s[i, j]</code>  也是回文子串，因此， <code>dp[i][j] = dp[i + 1][j - 1]</code></li></ul><p>确定遍历顺序：根据递推公式知， <code>dp[i][j]</code>  依赖于  <code>dp[i + 1][j - 1]</code>  ，因此，应按照从大到小的顺序遍历  <code>i</code>  ，按照从小到大的顺序遍历  <code>j</code></p><p>由于本题要求的是最长回文子串，因此，在遍历 dp 数组时，还需要维护最长回文子串的起点和长度</p><p>代码实现：</p><pre><code class="language-cpp">string longestPalindrome(string s) &#123;    vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));    int len = 0;    // 最长回文子串的长度    int start = 0;  // 最长回文子串的起点    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;        for (int j = i; j &lt; s.size(); j++) &#123;            if (s[i] == s[j] &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123;                dp[i][j] = true;                if (j - i + 1 &gt; len) &#123; // 更新最长回文子串                    len = j - i + 1;                    start = i;                &#125;            &#125;        &#125;    &#125;    return s.substr(start, len); // 以 start 为起点的、长为 len 的回文子串&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串  <code>s</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 4. 寻找两个正序数组的中位数</title>
      <link href="/posts/392c26dc/"/>
      <url>/posts/392c26dc/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZWRpYW4tb2YtdHdvLXNvcnRlZC1hcnJheXMv">4. Median of Two Sorted Arrays</span></p><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组  <code>nums1</code>  和  <code>nums2</code> 。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{(m + n)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span>。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</code></pre><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m + n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">\le 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^6 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1[i]</code> ,  <code>nums2[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为奇数时，中位数即为两个数组中的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(m + n) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个元素；当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为偶数时，中位数应为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(m + n) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个元素与第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(m + n) / 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素的平均值</p><p>因此，本题相当于要在两个有序数组中找出第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的数，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(m + n) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(m + n) / 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><h1 id="method-二分查找"><a class="anchor" href="#method-二分查找">#</a> Method: 二分查找</h1><p>算法思路：</p><p>为找出第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的数，可比较  <code>nums1[k / 2 - 1]</code>  和  <code>nums2[k / 2 - 1]</code>  ：</p><ul><li>若  <code>nums1[k / 2 - 1] &lt;= nums2[k / 2 - 1]</code>  ，则最多有  <code>nums1[0, k / 2 - 2]</code>  和  <code>nums2[0, k / 2 - 2]</code>  （一共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个数）小于  <code>nums1[k / 2 - 1]</code>  ，即， <code>nums1[k / 2 - 1]</code>  不可能是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的数， <code>nums1[0, k / 2 - 2]</code>  更不可能是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的数，因此，可排除  <code>nums1[0, k / 2 - 1]</code></li><li>若  <code>nums1[k / 2 - 1] &gt; nums2[k / 2 - 1]</code>  ，类似地，则可排除  <code>nums2[0, k / 2 - 1]</code></li></ul><p>此时，已经排除了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个数，接下来，可以在剩余元素中继续进行二分查找，并根据排除数的个数，更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的值</p><blockquote><p>在代码实现中，我们用  <code>start1</code>  和  <code>start2</code>  分别表示  <code>nums1</code>  和  <code>nums2</code>  中的待考察元素的起点</p></blockquote><p>有以下三种边界情况：</p><ul><li>如果一个数组为空，即，该数组中的所有元素都被排除，此时，可以直接返回另一个数组中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的元素</li><li>如果  <code>nums1[k / 2 - 1]</code>  或者  <code>nums2[k / 2 - 1]</code>  越界，我们可以选取对应数组的最后一个元素。此时，须根据排除数的个数来更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，而不能直接将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 减去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span></li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，返回两个数组首元素的最小值即可</li></ul><p>代码实现：</p><pre><code class="language-cpp">// 在 nums1[start1, :] 和 nums2[start2, :] 中寻找第 k 小的数int getKthElement(vector&lt;int&gt;&amp; nums1, int start1, vector&lt;int&gt;&amp; nums2, int start2, int k) &#123;    int m = nums1.size();    int n = nums2.size();    if (start1 == m) return nums2[start2 + k - 1]; // nums1 元素已全部排除    if (start2 == n) return nums1[start1 + k - 1]; // nums2 元素已全部排除    if (k == 1) return min(nums1[start1], nums2[start2]);    int index1 = min(start1 + k / 2 - 1, m - 1); // nums1 中的第 k / 2 个剩余元素    int index2 = min(start2 + k / 2 - 1, n - 1); // nums2 中的第 k / 2 个剩余元素    if (nums1[index1] &lt;= nums2[index2]) &#123; // 排除 nums[start1, index1]        k = k - (index1 - start1 + 1);    // 更新 k        return getKthElement(nums1, index1 + 1, nums2, start2, k); // 递归，继续在剩余元素中查找    &#125; else &#123;                              // 排除 nums2[start2, index2]        k = k - (index2 - start2 + 1);    // 更新 k        return getKthElement(nums1, start1, nums2, index2 + 1, k); // 递归，继续在剩余元素中查找    &#125;&#125;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    int len = nums1.size() + nums2.size();    if (len % 2 == 1) &#123; // m + n 为奇数        return getKthElement(nums1, 0, nums2, 0, len / 2 + 1);      // 第 (m + n) / 2 + 1 个小的数    &#125; else &#123;            // m + n 为偶数        int temp1 = getKthElement(nums1, 0, nums2, 0, len / 2);     // 第 (m + n) / 2 个小的数        int temp2 = getKthElement(nums1, 0, nums2, 0, len / 2 + 1);        return (temp1 + temp2) / 2.0;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{(m + n)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span>，每次抵归将查找范围减少一半，因此，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\log k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(m + n) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(m + n) / 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZWRpYW4tb2YtdHdvLXNvcnRlZC1hcnJheXMvc29sdXRpb24veHVuLXpoYW8tbGlhbmctZ2UteW91LXh1LXNodS16dS1kZS16aG9uZy13ZWktcy0xMTQv">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZWRpYW4tb2YtdHdvLXNvcnRlZC1hcnJheXMvc29sdXRpb24veGlhbmcteGktdG9uZy1zdS1kZS1zaS1sdS1mZW4teGktZHVvLWppZS1mYS1ieS13LTIv">windliang</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 516. 最长回文子序列</title>
      <link href="/posts/4da38d24/"/>
      <url>/posts/4da38d24/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnNlcXVlbmNlLw==">516. Longest Palindromic Subsequence</span></p><p>给你一个字符串  <code>s</code>  ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;bbbab&quot;输出：4解释：One possible longest palindromic subsequence is &quot;bbbb&quot;.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;cbbd&quot;输出：2解释：One possible longest palindromic subsequence is &quot;bb&quot;.</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>s</code>  仅由小写英文字母组成</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示  <code>[i, j]</code>  区间范围内的最长回文子序列的长度，其中， <code>0 &lt;= i &lt;= s.size() - 1</code>  ， <code>i &lt;= j &lt;= s.size() - 1</code></p><p>初始化 dp 数组：任何一个长为 1 的子序列都是回文子序列，因此， <code>dp[i][i] == 1</code></p><p>推导  <code>dp[i][j]</code>  的状态转移过程：</p><ul><li>当  <code>s[i] == s[j]</code>  时，针对  <code>[i + 1, j - 1]</code>  区间内的最长回文子序列，可在其首端和尾端分别添加  <code>s[i]</code>  和 <code>s[j]</code>  ，以形成更长的回文子序列，因此，最大长度为  <code>dp[i][j] = dp[i + 1][j - 1] + 2</code></li><li>当  <code>s[i] != s[j]</code>  时，则  <code>s[i]</code>  和  <code>s[j]</code>  不能同时作为某一个回文子序列的首尾，因此：<ul><li>考虑  <code>[i, j - 1]</code>  区间内的最长回文子序列，最大长度为  <code>dp[i][j - 1]</code></li><li>考虑   <code>[i + 1, j]</code>  区间内的最长回文子序列，最大长度为  <code>dp[i + 1][j]</code></li><li>综合两种情况，取最大值，即， <code>dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])</code></li></ul></li></ul><p>确定遍历顺序：根据递推公式知， <code>dp[i][j]</code>  依赖于  <code>dp[i + 1][j - 1]</code>  ，因此，应按照从大到小的顺序遍历  <code>i</code>  ，按照从小到大的顺序遍历  <code>j</code></p><p>遍历结束后， <code>dp[0][s.size() - 1]</code>  即为字符串  <code>s</code>  的最长回文子序列的长度</p><p>代码实现：</p><pre><code class="language-cpp">int longestPalindromeSubseq(string s) &#123;    vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));    for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1;    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;        for (int j = i + 1; j &lt; s.size(); j++) &#123;            if (s[i] == s[j])                dp[i][j] = dp[i + 1][j - 1] + 2;            else                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);        &#125;    &#125;    return dp[0][s.size() - 1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串  <code>s</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 647. 回文子串</title>
      <link href="/posts/570b359b/"/>
      <url>/posts/570b359b/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21pYy1zdWJzdHJpbmdzLw==">647. Palindromic Substrings</span></p><p>给你一个字符串  <code>s</code>  ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abc&quot;输出：3解释：3 个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;aaa&quot;输出：6解释：6 个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>s</code>  由小写英文字母组成</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示  <code>[i, j]</code>  区间范围内的子串是否为回文子串，其中， <code>0 &lt;= i &lt;= s.size() - 1</code>  ， <code>i &lt;= j &lt;= s.size() - 1</code></p><p>初始化 dp 数组：全都初始化为  <code>false</code></p><p>推导状态转移过程：</p><ul><li>当  <code>s[i] != s[j]</code>  时， <code>s[i, j]</code>  不可能是回文子串， <code>dp[i][j] = false</code></li><li>当  <code>s[i] == s[j]</code>  时，考虑以下情况：<ul><li><code>j - i == 0</code>  ：即，只有一个字符，此时一定为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i == 1</code>  ：即，只有  <code>s[i]</code>  和  <code>s[j]</code>  这两个相同的字符，此时也为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i &gt; 1</code>  ：即， <code>s[i, j]</code>  多于两个字符，此时，还需判断  <code>s[i + 1, j - 1]</code>  是否为回文子串。若  <code>s[i + 1, j - 1]</code>  是回文子串，则  <code>s[i, j]</code>  也是回文子串，否则， <code>s[i, j]</code>  不是回文子串。即， <code>dp[i][j] = dp[i + 1][j - 1]</code></li></ul></li></ul><p>确定遍历顺序：根据递推公式知， <code>dp[i][j]</code>  依赖于  <code>dp[i + 1][j - 1]</code>  ，因此，应按照从大到小的顺序遍历  <code>i</code>  ，按照从小到大的顺序遍历  <code>j</code></p><p>遍历结束后，dp 数组值为  <code>true</code>  的元素个数，即为字符串  <code>s</code>  的回文子串个数</p><p>代码实现：</p><pre><code class="language-cpp">int countSubstrings(string s) &#123;    vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));    int ans = 0;    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;        for (int j = i; j &lt; s.size(); j++) &#123;            if (s[i] == s[j]) &#123;                if (j - i &lt;= 1 || dp[i + 1][j - 1]) &#123;                    dp[i][j] = true;                    ans++;                &#125;            &#125;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串  <code>s</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 72. 编辑距离</title>
      <link href="/posts/8134aa5e/"/>
      <url>/posts/8134aa5e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLw==">72. Edit Distance</span></p><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：    horse -&gt; rorse (将 'h' 替换为 'r')    rorse -&gt; rose (删除 'r')    rose -&gt; ros (删除 'e')</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：    intention -&gt; inention (删除 't')    inention -&gt; enention (将 'i' 替换为 'e')    enention -&gt; exention (将 'n' 替换为 'x')    exention -&gt; exection (将 'n' 替换为 'c')    exection -&gt; execution (插入 'u')</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>word1.length</code> ,  <code>word2.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>word1</code>  和  <code>word2</code>  由小写英文字母组成</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示将  <code>word1[0, i - 1]</code>  转换成  <code>word2[0, j - 1]</code>  所需的最少操作数</p><p>初始化  <code>dp[i][0]</code>  与  <code>dp[0][j]</code>  ：</p><ul><li><code>[dp][i][0]</code>  ：此时， <code>word2[0, j - 1]</code>  为空字符串，要将  <code>word1[0, i - 1]</code>  转换成空字符串，应将  <code>word1[0, i - 1]</code>  的全部字符都删除，即， <code>dp[i][0] = i</code></li><li><code>[dp][0][j]</code>  ：此时， <code>word1[0, i - 1]</code>  为空字符串，要将空字符串转换成  <code>word2[0, j - 1]</code>  ，应将  <code>word2[0, j - 1]</code>  的全部字符都插入到  <code>word1</code>  ，即， <code>dp[i][0] = j</code></li></ul><p>推导  <code>dp[i][j]</code>  的状态转移过程：<strong>（要注意围绕  <code>dp[i][j]</code>  的定义进行思考）</strong></p><ul><li>当  <code>word1[i - 1] == word2[j - 1]</code>  时，无需操作  <code>word1[i - 1]</code>  ，只需将  <code>word1[0, i - 2]</code>  转换成  <code>word2[0, j - 2]</code>  ，因此， <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>当  <code>word1[i - 1] != word2[j - 1]</code>  时，可针对  <code>word1[0, i - 1]</code>  进行 插入、删除、替换 三种操作：<ul><li><strong>插入字符</strong>：在  <code>word1[i - 2]</code>  与  <code>word1[i - 1]</code>  之间插入一个字符，使之与  <code>word2[j - 1]</code>  相同。该操作 <strong>等价于 删除  <code>word2[j - 1]</code> </strong> ，因为插入字符和删除  <code>word2[j - 1]</code>  都能将  <code>word1</code>  变成  <code>word2</code>  。因此，所需的操作数为  <code>1 + dp[i][j - 1]</code>  ，其中， <code>1</code>  表示删除  <code>word2[j - 1]</code>  所需的操作数， <code>dp[i][j - 1]</code>  表示将  <code>word1[0, i - 1]</code>  转换成  <code>word2[0, j - 2]</code>  所需的最少操作数</li><li><strong>删除字符</strong>：删除  <code>word1[i - 1]</code>  ，然后将  <code>word1[0, i - 2]</code>  转换成  <code>word2[0, j - 1]</code>  。所需的操作数为  <code>1 + dp[i - 1][j]</code></li><li><strong>替换字符</strong>：将  <code>word1[i - 1]</code>  替换成与  <code>word2[j - 1]</code>  相同的字符，然后将  <code>word1[0, i - 2]</code>  转换成  <code>word2[0, j - 2]</code>  。所需的操作数为  <code>1 + dp[i - 1][j - 1]</code></li><li>综合以上三种情况，应取最小的操作数，即， <code>dp[i][j] = min(&#123;1 + dp[i][j - 1], 1 + dp[i - 1][j], 1 + dp[i - 1][j - 1]&#125;)</code></li></ul></li></ul><p>遍历顺序：根据递推公式知， <code>dp[i][j]</code>  依赖于  <code>dp[i - 1][j - 1]</code>  、 <code>dp[i - 1][j]</code>  和  <code>dp[i][j - 1]</code>  ，因此，应按照从左到右、从上到下的顺序维护 dp 数组，即，按照从小到大的顺序分别遍历  <code>i</code>  和  <code>j</code></p><p>代码实现：</p><pre><code class="language-cpp">int minDistance(string word1, string word2) &#123;    int m = word1.size();    int n = word2.size();    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));    for (int i = 0; i &lt;= m; i++) dp[i][0] = i;    for (int j = 0; j &lt;= n; j++) dp[0][j] = j;    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (word1[i - 1] == word2[j - 1])                dp[i][j] = dp[i - 1][j - 1];            else                dp[i][j] = min(&#123;dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]&#125;) + 1;        &#125;    &#125;    return dp[m][n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是  <code>word1</code>  和  <code>word2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 583. 两个字符串的删除操作</title>
      <link href="/posts/5ad6a6fd/"/>
      <url>/posts/5ad6a6fd/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtb3BlcmF0aW9uLWZvci10d28tc3RyaW5ncy8=">583. Delete Operation for Two Strings</span></p><p>给定两个单词  <code>word1</code>  和  <code>word2</code>  ，返回使得  <code>word1</code>  和  <code>word2</code>  相同所需的最小步数。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><pre><code>输入：word1 = &quot;sea&quot;, word2 = &quot;eat&quot;输出：2解释：第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;输出：4</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>word1.length</code> ,  <code>word2.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>word1</code>  和  <code>word2</code>  只包含小写英文字母</li></ul><h1 id="method-1-最长公共子序列"><a class="anchor" href="#method-1-最长公共子序列">#</a> Method 1: 最长公共子序列</h1><p>要通过删除字符使得 word1 与 word2 相同，也就是要得到 word1 与 word2 的公共子序列</p><p>因此，本题可以通过 word1 与 word2 的最长公共子序列的长度来计算：</p><ul><li>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 表示 word1 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 表示 word2 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 表示 word1 与 word2 的最长公共子序列的长度</li><li>要使 word1 与 word2 相同，则应删除最长公共子序列以外的所有字符。即，word1 需要删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个字符，word2 需要删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个字符</li><li>因此，所需的最少步数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">m + n - 2 k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></li></ul><p>其中，最长公共子序列长度的计算可参考 <a href="https://jiankychen.github.io/posts/c261e90a">LeetCode 1143. 最长公共子序列</a></p><p>代码实现：</p><pre><code class="language-cpp">int minDistance(string word1, string word2) &#123;    int m = word1.size();    int n = word2.size();    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (word1[i - 1] == word2[j - 1])                dp[i][j] = dp[i - 1][j - 1] + 1;            else                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        &#125;    &#125;    int ans = m + n - (2 * dp[m][n]);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是  <code>word1</code>  和  <code>word2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示使得  <code>word1[0, i - 1]</code>  与  <code>word2[0, j - 1]</code>  相同所需的最少删除次数，其中， <code>1 &lt;= i &lt;= word1.size()</code>  ,  <code>1 &lt;= j &lt;= word2.size()</code></p><p>初始化  <code>dp[i][0]</code>  与  <code>dp[0][j]</code>  ：</p><ul><li><code>[dp][i][0]</code>  ：此时， <code>word2[0, j - 1]</code>  为空字符串，要使得  <code>word1[0, i - 1]</code>  与空字符串相等，应将  <code>word1[0, i - 1]</code>  中的全部字符都删除，即， <code>dp[i][0] = i</code></li><li><code>[dp][0][j]</code>  ：此时， <code>word1[0, i - 1]</code>  为空字符串，要使得  <code>word2[0, j - 1]</code>  与空字符串相等，应将  <code>word2[0, j - 1]</code>  中的全部字符都删除，即， <code>dp[i][0] = j</code></li></ul><p>推导  <code>dp[i][j]</code>  的状态转移过程：</p><ul><li>当  <code>word1[i - 1] == word2[j - 1]</code>  时，无需删除  <code>word1[i - 1]</code>  与  <code>word2[j - 1]</code>  ，计算使  <code>word1[0, i - 2]</code>  与  <code>word2[0, j - 2]</code>  相同所需的最少删除次数即可，即， <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>当  <code>word1[i - 1] != word2[j - 1]</code>  时，做以下考虑<ul><li>若删除  <code>word1[i - 1]</code>  ，则应使  <code>word1[0, i - 2]</code>  与  <code>word2[j - 1]</code>  相同，此时，所需的最少删除次数为  <code>1 + dp[i - 1][j]</code></li><li>若删除  <code>word2[j - 1]</code>  ，则应使  <code>word1[0, i - 1]</code>  与  <code>word2[0, j - 2]</code>  相同，此时，所需的最少删除次数为  <code>1 + dp[i][j - 1]</code></li><li>综合两种情况，取最小值，即， <code>dp[i][j] = min(1 + dp[i - 1][j], 1 + dp[i][j - 1])</code></li></ul></li></ul><p>确定遍历顺序：根据状态转移方程知， <code>dp[i][j]</code>  依赖于  <code>dp[i - 1][j - 1]</code>  ， <code>dp[i - 1][j]</code>  和  <code>dp[i][j - 1]</code>  ，因此，应按照从小到大的顺序遍历  <code>i</code>  和  <code>j</code></p><p>遍历结束后， <code>dp[word1.size()][word2.size()]</code>  即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int minDistance(string word1, string word2) &#123;    int m = word1.size();    int n = word2.size();    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));    for (int i = 0; i &lt;= m; i++) dp[i][0] = i;    for (int j = 0; j &lt;= n; j++) dp[0][j] = j;    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (word1[i - 1] == word2[j - 1])                dp[i][j] = dp[i - 1][j - 1];            else                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;        &#125;    &#125;    return dp[m][n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是  <code>word1</code>  和  <code>word2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtb3BlcmF0aW9uLWZvci10d28tc3RyaW5ncy9zb2x1dGlvbi9saWFuZy1nZS16aS1mdS1jaHVhbi1kZS1zaGFuLWNodS1jYW8tenVvLTE0dXcv">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 115. 不同的子序列</title>
      <link href="/posts/b8a7b240/"/>
      <url>/posts/b8a7b240/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXN0aW5jdC1zdWJzZXF1ZW5jZXMv">115. Distinct Subsequences</span></p><p>给你两个字符串  <code>s</code>  和  <code>t</code>  ，统计并返回在  <code>s</code>  的 <strong>子序列</strong> 中  <code>t</code>  出现的个数。</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;输出：3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;输出：5</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code> ,  <code>t.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>s</code>  和  <code>t</code>  由英文字母组成</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示在  <code>s[0, i - 1]</code>  中出现  <code>t[0, j - 1]</code>  子序列的个数</p><p>初始化  <code>dp[0][j]</code>  和  <code>dp[i][0]</code>  ：</p><ul><li>当  <code>j = 0</code>  时， <code>t[0, j - 1]</code>  为空字符串，由于空字符串是任何字符串的子序列，因此，对任意  <code>0 &lt;= i &lt;= s.size()</code>  ，有  <code>dp[i][0]  = 1</code></li><li>当  <code>i = 0</code>  时， <code>s[0, i - 1]</code>  为空字符串，由于非空字符串不是空字符串的子序列，因此，对任意  <code>1 &lt;= j &lt;= t.size()</code>  ，有  <code>dp[0][j] = 0</code></li></ul><p>考虑  <code>dp[i][j]</code>  的状态转移过程：</p><ul><li>当  <code>s[i - 1] == t[j - 1]</code>  时<ul><li>如果把  <code>s[i - 1]</code>  与  <code>t[j - 1]</code>  匹配，则需考察  <code>s[0, i - 2]</code>  中出现  <code>t[0, j - 2]</code>  的个数，即， <code>dp[i - 1][j - 1]</code></li><li>如果不把  <code>s[i - 1]</code>  与  <code>t[j - 1]</code>  匹配，则需考察  <code>s[0, i - 2]</code>  中出现  <code>t[0, j - 1]</code>  的个数，即，子序列个数为  <code>dp[i - 1][j]</code></li><li>以上两种情况都是可行的，因此， <code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></li></ul></li><li>当  <code>s[i - 1] != t[j - 1]</code>  时<ul><li>无法将  <code>s[i - 1]</code>  与  <code>t[j - 1]</code>  匹配，故而应考察  <code>s[0, i - 2]</code>  中出现  <code>t[0, j - 1]</code>  的个数，即， <code>dp[i][j] = dp[i - 1][j]</code></li></ul></li></ul><p>例如，当 s = &quot;babgbag&quot; 、t = &quot;bag&quot; 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 都可以与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配</p><ul><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0] = t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[1][1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[1] \neq t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[2][1] = dp[1][1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2] = t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[3][1] = dp[2][0] + dp[2][1] = 1 + 1 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ，即，可选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配，也可从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中选出字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配</li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[3] \neq t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[4][1] = dp[3][1] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[4] = t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">dp[4][1] = dp[3][0] + dp[3][1] = 1 + 2 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> ，即，可选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配，也可从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0, 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span> 中选出字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配</li></ul><p>遍历顺序：根据递推公式知， <code>dp[i][j]</code>  依赖于  <code>dp[i - 1][j - 1]</code>  和  <code>dp[i - 1][j]</code>  ，因此， <code>i</code>  和  <code>j</code>  都应按从小到大的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int numDistinct(string s, string t) &#123;        // dp 数组的定义及初始化    vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size() + 1, vector&lt;uint64_t&gt;(t.size() + 1, 0));    for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 1;        // 遍历    for (int i = 1; i &lt;= s.size(); i++) &#123;        for (int j = 1; j &lt;= t.size(); j++) &#123;            if (s[i - 1] == t[j - 1])                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];            else                dp[i][j] = dp[i - 1][j];        &#125;    &#125;    // 返回结果    return dp[s.size()][t.size()];    &#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串  <code>s</code>  和  <code>t</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 392. 判断子序列</title>
      <link href="/posts/3df0135c/"/>
      <url>/posts/3df0135c/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pcy1zdWJzZXF1ZW5jZS8=">392. Is Subsequence</span></p><p>给定字符串  <code>s</code>  和  <code>t</code>  ，判断  <code>s</code>  是否为  <code>t</code>  的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot; 是 &quot;abcde&quot; 的一个子序列，而 &quot;aec&quot; 不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S<sub>1</sub>, S<sub>2</sub>, ... , S<sub>k</sub> ，其中 k <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 10<sup>9</sup>，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>t.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  和  <code>t</code>  都只由小写字符组成</li></ul><h1 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h1><p>算法思路：如果能够在字符串  <code>t</code>  中依次找到字符串  <code>s</code>  的每个字符，则说明  <code>s</code>  是  <code>t</code>  的子序列</p><p>算法流程：</p><p>定义指针  <code>i</code>  指向字符串  <code>s</code>  ，指针  <code>j</code>  指向字符串  <code>t</code></p><p>遍历  <code>i</code>  与  <code>j</code>  ：</p><ul><li>若  <code>s[i] == t[j]</code>  ，说明在字符串  <code>t</code>  中找到了字符  <code>s[i]</code>  ，可以继续寻找下一个字符，因此，同时移动  <code>i</code>  和  <code>j</code>  ，</li><li>若  <code>s[i] != t[j]</code>  ，则需继续在字符串  <code>t</code>  中寻找  <code>s[i]</code>  ，因此，移动  <code>j</code></li></ul><p>遍历结束时，若  <code>i</code>  指向  <code>s</code>  的尾后，则说明  <code>s</code>  的所有字符都已在字符串  <code>t</code>  中找到，即，字符串  <code>s</code>  是字符串  <code>t</code>  的子序列</p><p>代码实现：</p><pre><code class="language-cpp">bool isSubsequence(string s, string t) &#123;    int i = 0;    int j = 0;    while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;        if (s[i] == t[j]) i++;      // 字符串 t 中包含字符 s[i]        j++;    &#125;    if (i == s.size()) return true; // 字符串 t 中包含 s 的所有字符    return false;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串  <code>s</code>  和字符串  <code>t</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：可以通过计算字符串  <code>s</code>  与字符串  <code>t</code>  的最长公共子序列长度来判断：若最长公共子序列长度等于字符串  <code>s</code>  的长度，则字符串  <code>s</code>  是字符串  <code>t</code>  的子序列；否则， <code>s</code>  不是  <code>t</code>  的子序列</p><p>可参考 <a href="https://jiankychen.github.io/posts/c261e90a">LeetCode 1143. 最长公共子序列</a></p><p>算法流程：</p><p>定义  <code>dp[i][j]</code>  表示子串  <code>s[0, i -1]</code>  与子串  <code>t[0, j - 1]</code>  的最长公共子序列的长度</p><p>若  <code>s[i - 1] == t[j - 1]</code>  ，则在  <code>s[0, i - 2]</code>  与  <code>t[0, j - 2]</code>  的基础上又找到了一个相同字符，因此， <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p><p>若  <code>s[i - 1] != t[j - 1]</code>  ，则  <code>s[0, i - 1]</code>  与  <code>t[0, j - 2]</code>  的最长公共子序列就是  <code>s[0, i - 1]</code>  与  <code>t[0, j - 1]</code>  的最长公共子序列，因此， <code>dp[i][j] = dp[i][j - 1]</code></p><p>代码实现：</p><pre><code class="language-cpp">bool isSubsequence(string s, string t) &#123;    vector&lt;vector&lt;int&gt;&gt; dp(s.size() + 1, vector&lt;int&gt;(t.size() + 1, 0)); // dp[i][j] 表示 s[0, i - 1] 与 t[0, j - 1] 的最长公共子序列的长度    for (int i = 1; i &lt;= s.size(); i++) &#123;        for (int j = 1; j &lt;= t.size(); j++) &#123;            if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;            else dp[i][j] = dp[i][j - 1];        &#125;    &#125;    return dp[s.size()][t.size()] == s.size();&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串  <code>s</code>  和字符串  <code>t</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="进阶"><a class="anchor" href="#进阶">#</a> 进阶</h2><p>在前面的双指针法中，有大量的时间用于在  <code>t</code>  中找到下一个匹配字符</p><p>因此，可对字符串  <code>t</code>  进行预处理，计算出 “字符串  <code>t</code>  中任意位置到某字符下次出现时的距离” ，例如， <code>i</code>  位置 与  <code>i</code>  右侧第一次出现字符  <code>j</code>  位置的距离</p><p>为此，可将 dp 数组定义为： <code>dp[i][j]</code>  表示在字符串  <code>t</code>  中的位置  <code>i</code>  以右（包含  <code>i</code>  ），字符  <code>j + 'a'</code>  第一次出现的位置</p><p>此时，对字符串  <code>t</code>  的预处理是与字符串  <code>s</code>  无关的，并且，在预处理完成后，可以利用 dp 数组信息计算出任意一个字符串  <code>s</code>  是否为  <code>t</code>  的子串，由此可解决 进阶 中的问题</p><p>具体可参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pcy1zdWJzZXF1ZW5jZS9zb2x1dGlvbi9wYW4tZHVhbi16aS14dS1saWUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1035. 不相交的线</title>
      <link href="/posts/2b9044b2/"/>
      <url>/posts/2b9044b2/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmNyb3NzZWQtbGluZXMv">1035. Uncrossed Lines</span></p><p>在两条独立的水平线上按给定的顺序写下  <code>nums1</code>  和  <code>nums2</code>  中的整数。</p><p>现在，可以绘制一些连接两个数字  <code>nums1[i]</code>  和  <code>nums2[j]</code>  的直线，这些直线需要同时满足满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/2b9044b2/Example.png" class=""></p><pre><code>输入：nums1 = [1,4,2], nums2 = [1,2,4]输出：2解释：可以画出两条不交叉的线，如上图所示。但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]输出：3</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]输出：2</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1.length</code> ,  <code>nums2.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1[i]</code> ,  <code>nums2[j]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">\le 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本质是求两个数组的最长公共子序列的长度，即，与 <a href="https://jiankychen.github.io/posts/c261e90a">LeetCode 1143. 最长公共子序列</a> 完全一致</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>定义  <code>dp[i][j]</code>  表示  <code>nums1[0, i - 1]</code>  与子串  <code>nums2[0, j - 1]</code>  的最长公共子序列的长度，其中， <code>1 &lt;= i &lt;= nums1.size()</code>  ,  <code>1 &lt;= j &lt;= nums2.size()</code></p><p>代码实现：</p><pre><code class="language-cpp">int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    int m = nums1.size();    int n = nums2.size();    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (nums1[i - 1] == nums2[j - 1])                dp[i][j] = dp[i - 1][j - 1] + 1;            else                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);        &#125;    &#125;    return dp[m][n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是数组  <code>nums1</code>  与数组  <code>nums2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1143. 最长公共子序列</title>
      <link href="/posts/c261e90a/"/>
      <url>/posts/c261e90a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1zdWJzZXF1ZW5jZS8=">1143. Longest Common Subsequence</span></p><p>给定两个字符串  <code>text1</code>  和  <code>text2</code>  ，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回  <code>0</code>  。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如， <code>&quot;ace&quot;</code>  是  <code>&quot;abcde&quot;</code>  的子序列，但  <code>&quot;aec&quot;</code>  不是  <code>&quot;abcde&quot;</code>  的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：The longest common subsequence is &quot;ace&quot; and its length is 3.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：The longest common subsequence is &quot;abc&quot; and its length is 3.</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：There is no such common subsequence, so the result is 0.</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>text1.length</code> ,  <code>text2.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>text1</code>  和  <code>text2</code>  仅由小写英文字符组成</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>dp 数组： <code>dp[i][j]</code>  表示子串  <code>text1[0, i - 1]</code>  与子串  <code>text2[0, j - 1]</code>  的最长公共子序列的长度，其中， <code>1 &lt;= i &lt;= text1.size()</code>  ,  <code>1 &lt;= j &lt;= text2.size()</code></p><p>递推公式：</p><ul><li>若  <code>text1[i - 1] == text2[j - 1]</code>  ，则  <code>text1[0, i - 1]</code>  和  <code>text2[0, j - 1]</code>  的最长公共子序列长度 应比  <code>text1[0, i - 2]</code>  和  <code>text2[0, j - 2]</code>  的最长公共子序列长度大 1，即， <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>若  <code>text1[i - 1] != text2[j - 1]</code>  ，则做以下考虑：<ul><li>确定  <code>text1[0, i - 2]</code>  和  <code>text2[0, j - 1]</code>  的最长公共子序列，即，计算  <code>dp[i - 1][j]</code></li><li>确定  <code>text1[0, i - 1]</code>  和  <code>text2[0, j - 2]</code>  的最长公共子序列，即，计算  <code>dp[i][j - 1]</code></li><li>综合两种情况，取最大值，即， <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li></ul></li></ul><p>初始化：根据递推公式知，应初始化  <code>dp[0][j]</code>  和  <code>dp[i][0]</code></p><ul><li><code>dp[0][j]</code>  ：此时考虑的  <code>text1</code>  子串为空串，与  <code>text2</code>  的公共子序列长度为 0 ，即， <code>dp[0][j] = 0</code></li><li><code>dp[i][0]</code>  ：此时考虑的  <code>text2</code>  子串为空串，与  <code>text1</code>  的公共子序列长度为 0 ，即， <code>dp[i][0] = 0</code></li></ul><p>遍历顺序：外层按从小到大顺序遍历  <code>i</code>  ，内层按从小到大顺序遍历  <code>j</code></p><p>遍历结束后， <code>dp[text1.size()][text2.size()]</code>  即为字符串  <code>text1</code>  与字符串  <code>text2</code>  的最长公共子序列的长度</p><p>代码实现：</p><pre><code class="language-cpp">int longestCommonSubsequence(string text1, string text2) &#123;    int m =text1.size();    int n =text2.size();    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (text1[i - 1] == text2[j - 1])                dp[i][j] = dp[i - 1][j - 1] + 1;            else                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        &#125;    &#125;    return dp[m][n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串  <code>text1</code>  与字符串  <code>text2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzExNDMuJUU2JTlDJTgwJUU5JTk1JUJGJUU1JTg1JUFDJUU1JTg1JUIxJUU1JUFEJTkwJUU1JUJBJThGJUU1JTg4JTk3Lmh0bWw=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 718. 最长重复子数组</title>
      <link href="/posts/340004fc/"/>
      <url>/posts/340004fc/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWxlbmd0aC1vZi1yZXBlYXRlZC1zdWJhcnJheS8=">718. Maximum Length of Repeated Subarray</span></p><p>给两个整数数组  <code>nums1</code>  和  <code>nums2</code>  ，返回 两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3,2,1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]输出：5</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1.length</code>  ,  <code>nums2.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1[i]</code>  ,  <code>nums2[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-1-动态规划"><a class="anchor" href="#method-1-动态规划">#</a> Method 1: 动态规划</h1><h2 id="实现一"><a class="anchor" href="#实现一">#</a> 实现一</h2><p>定义 dp 数组： <code>dp[i][j]</code>  表示以  <code>nums1[i]</code>  与  <code>nums2[j]</code>  为结尾的最长重复子数组的长度，其中， <code>0 &lt;= i &lt; nums1.size()</code>  ,  <code>0 &lt;= j &lt; nums2.size()</code></p><ul><li>若  <code>nums1[i] != nums2[j]</code>  ，则  <code>nums1[i]</code>  与  <code>nums2[j]</code>  不可能作为重复子数组的末尾，即， <code>dp[i][j] = 0</code></li><li>若  <code>nums1[i] == nums2[j]</code>  ，则  <code>nums1[i]</code>  与  <code>nums2[j]</code>  可以作为重复子数组的末尾，即，  <code>dp[i][j] &gt; 0</code></li></ul><p>确定递推公式：若  <code>num1[i] == nums2[j]</code>  ，则  <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p><p>初始化：根据递推公式知，应初始化  <code>dp[i][0]</code>  与  <code>dp[0][j]</code></p><ul><li><code>dp[i][0]</code>  ：若  <code>nums1[i] == nums2[0]</code>  ，则  <code>nums1[i]</code>  可以与  <code>nums2[0]</code>  作为重复子数组，即， <code>dp[i][0] = 1</code>  ；否则， <code>dp[i][0] = 0</code></li><li><code>dp[0][j]</code>  ：若  <code>nums1[0] == nums2[j]</code>  ，则  <code>nums1[0]</code>  可以与  <code>nums2[j]</code>  作为重复子数组，即， <code>dp[0][j] = 1</code>  ；否则， <code>dp[0][j] = 0</code></li></ul><p>遍历顺序：外层遍历  <code>i</code>  、内层遍历  <code>j</code>  （可以交换）； <code>i</code>  与  <code>j</code>  均按照从小到大的顺序遍历</p><p>最后，从 dp 数组中找到最大值，即为最长重复子数组的长度</p><p>代码实现：</p><pre><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    int m = nums1.size();    int n = nums2.size();    // 定义 dp 数组    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));    // 初始化 dp 数组    for (int i = 0; i &lt; m; i++) &#123;        if (nums1[i] == nums2[0]) dp[i][0] = 1;    &#125;    for (int j = 0; j &lt; n; j++) &#123;        if (nums1[0] == nums2[j]) dp[0][j] = 1;    &#125;    // 遍历    for (int i = 1; i &lt; m; i++) &#123;        for (int j = 1; j &lt; n; j++) &#123;            if (nums1[i] == nums2[j])                dp[i][j] = dp[i - 1][j - 1] + 1;        &#125;    &#125;    // 寻找 dp 数组的最大元素    int ans = 0;    for (int i = 0; i &lt; m; i++) &#123;        for (int j = 0; j &lt; n; j++) &#123;            if (dp[i][j] &gt; ans)                ans = dp[i][j];        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是数组  <code>nums1</code>  、 <code>nums2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="实现二"><a class="anchor" href="#实现二">#</a> 实现二</h2><p>可以将 dp 数组定义为： <code>dp[i][j]</code>  表示以  <code>nums1[i - 1]</code>  与  <code>nums2[j - 1]</code>  为结尾的最长重复子数组的长度，其中， <code>0 &lt;= i &lt;= nums1.size()</code>  ,  <code>0 &lt;= j &lt;= nums2.size()</code></p><p>dp 数组的元素全部初始化为  <code>0</code>  即可</p><p>递推公式为：若  <code>nums1[i - 1] == nums2[j - 1]</code>  ，则  <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p><p>遍历顺序：与上一种实现相同， <code>i</code>  从 1 遍历至  <code>nums1.size()</code>  ， <code>j</code>  从 1 遍历至  <code>nums2.size()</code></p><p>代码实现：</p><pre><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    int m = nums1.size();    int n = nums2.size();    int ans = 0;    // 定义 dp 数组及其初始化    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));    // 遍历    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (nums1[i - 1] == nums2[j - 1])                dp[i][j] = dp[i - 1][j - 1] + 1;            if (dp[i][j] &gt; ans)                ans = dp[i][j];        &#125;    &#125;    return ans;&#125;</code></pre><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>可以利用滚动数组的思想，将二维 dp 数组换成一维 dp 数组，即，一维数组的  <code>dp[j]</code>  对应上述二维数组的  <code>dp[i][j]</code>  （实现二）</p><p>代码实现：</p><pre><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    int m = nums1.size();    int n = nums2.size();    int ans = 0;    vector&lt;int&gt; dp(n + 1, 0);    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = n; j &gt;= 1; j--) &#123;            if (nums1[i - 1] == nums2[j - 1]) dp[j] = dp[j - 1] + 1;            else dp[j] = 0;           // nums1[i - 1] != nums2[j - 1] 时，dp[j] = 0            ans = max(ans, dp[j]);        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是数组  <code>nums1</code>  、 <code>nums2</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MTguJUU2JTlDJTgwJUU5JTk1JUJGJUU5JTg3JThEJUU1JUE0JThEJUU1JUFEJTkwJUU2JTk1JUIwJUU3JUJCJTg0Lmh0bWw=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 674. 最长连续递增序列</title>
      <link href="/posts/c64b2400/"/>
      <url>/posts/c64b2400/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnRpbnVvdXMtaW5jcmVhc2luZy1zdWJzZXF1ZW5jZS8=">674. Longest Continuous Increasing Subsequence</span></p><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong> ，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标  <code>l</code>  和  <code>r</code>  （ <code>l &lt; r</code> ）确定，如果对于每个  <code>l &lt;= i &lt; r</code> ，都有  <code>nums[i] &lt; nums[i + 1]</code>  ，那么子序列  <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code>  就是连续递增子序列。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5] , 长度为 3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2] , 长度为 1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-1-动态规划"><a class="anchor" href="#method-1-动态规划">#</a> Method 1: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i]</code>  表示在  <code>nums[0, i]</code>  区间内，以  <code>nums[i]</code>  结尾的最长连续递增序列的长度</p><p>本题要求递增序列连续，因此，维护  <code>dp[i]</code>  只需比较  <code>nums[i]</code>  与  <code>nums[i - 1]</code>  即可，递归公式为： <code>dp[i] = max(dp[i], dp[i - 1] + 1), i &gt;= 1 &amp;&amp; nums[i] &gt; nums[i - 1]</code></p><p>遍历结束后，dp 数组的最大元素即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; dp(n, 1); // dp[i] 表示以 nums[i] 结尾的最长连续递增序列的长度    for (int i = 1; i &lt; n; i++) &#123;        if (nums[i] &gt; nums[i - 1]) // 连续递增            dp[i] = max(dp[i], dp[i - 1] + 1);    &#125;    int ans = 0;    for (int i = 0; i &lt; n; i++)        ans = max(ans, dp[i]);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-贪心"><a class="anchor" href="#method-2-贪心">#</a> Method 2: 贪心</h1><p>代码实现：</p><pre><code class="language-cpp">int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    int ans = 0;    int count = 1;    for (int i = 1; i &lt; n; i++) &#123;        if (nums[i] &gt; nums[i - 1]) count++;        else &#123;            ans = max(ans, count);            count = 1;        &#125;    &#125;    ans = max(ans, count); // 处理 nums[n - 1] &gt; nums[n - 2] 的情况    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 300. 最长递增子序列</title>
      <link href="/posts/a598c519/"/>
      <url>/posts/a598c519/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2Uv">300. Longest Increasing Subsequence</span></p><p>给你一个整数数组  <code>nums</code>  ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如， <code>[3,6,2,7]</code>  是数组  <code>[0,3,1,6,2,2,7]</code>  的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2500</mn></mrow><annotation encoding="application/x-tex">\le 2500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：你能将算法的时间复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 吗？</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i]</code>  表示在  <code>[0, i]</code>  区间内，以  <code>nums[i]</code>  结尾的最长递增子序列的长度</p><p>确定递推公式：</p><ul><li><p>对任意一个满足条件  <code>0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code>  的  <code>nums[j]</code>  而言，可以在 以  <code>nums[j]</code>  结尾的最长递增子序列 之后再添加一个  <code>nums[i]</code>  ，形成更长的递增子序列，其中，新的序列长度即为  <code>dp[j] + 1</code></p></li><li><p>因此，要想得到以  <code>nums[i]</code>  结尾的最长递增子序列，应将  <code>nums[i]</code>  添加在 满足  <code>0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code>  条件、且具有最大  <code>dp[j]</code>  的  <code>nums[j]</code>  之后，即， <code>dp[i] = max(dp[j]) + 1</code> ，其中  <code>0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code></p></li></ul><p>初始化 dp 数组：对于任意  <code>i</code>  而言， <code>nums[i]</code>  自身就是一个长度为 1 的递增子序列，因此，任意的  <code>dp[i]</code>  都应初始化为 1</p><p>确定遍历顺序：按  <code>i</code>  从小到大的顺序遍历</p><p>最后，从所有的  <code>dp[i]</code>  中找出最大值，即为最长递增子序列的长度</p><p>代码实现：</p><pre><code class="language-cpp">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; dp(n, 1); // dp[i] 表示以 nums[i] 结尾的最长严格递增子序列的长度    for (int i = 1; i &lt; n; i++) &#123;        for (int j = 0; j &lt; i; j++) &#123;            if (nums[i] &gt; nums[j]) // nums[i] 可以接在 nums[j] 之后，形成新的递增子序列                dp[i] = max(dp[i], dp[j] + 1);        &#125;    &#125;    int ans = 0; // 最长递增子序列的长度    for (int i = 0; i &lt; n; i++) &#123;        ans = max(ans, dp[i]);    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-贪心-二分查找"><a class="anchor" href="#method-2-贪心-二分查找">#</a> Method 2: 贪心 + 二分查找</h1><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2Uvc29sdXRpb24venVpLWNoYW5nLXNoYW5nLXNoZW5nLXppLXh1LWxpZS1ieS1sZWV0Y29kZS1zb2x1dGkv">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 309. 最佳买卖股票时机含冷冻期</title>
      <link href="/posts/55c28bef/"/>
      <url>/posts/55c28bef/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtY29vbGRvd24v">309. Best Time to Buy and Sell Stock with Cooldown</span></p><p>给定一个整数数组  <code>prices</code>  ，其中第  <code>prices[i]</code>  表示第  <code>i</code>  天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [1,2,3,0,2]输出：3解释：对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2,0))</code></p><ul><li><code>dp[i][0]</code>  表示第  <code>i</code>  天结束时不持有股票的最大利润</li><li><code>dp[i][1]</code>  表示第  <code>i</code>  天结束时持有股票的最大利润</li></ul><p>确定递推公式：</p><ul><li>第  <code>i</code>  天结束时不持有股票，即， <code>dp[i][0]</code><ul><li>若第  <code>i - 1</code>  天不持有股票，此时的利润为  <code>dp[i - 1][0]</code></li><li>若第  <code>i - 1</code>  天持有股票、第  <code>i</code>  天卖出股票，此时的利润为  <code>dp[i - 1][1] + prices[i]</code></li><li>综合两种情况得  <code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code></li></ul></li><li>第  <code>i</code>  天结束时持有股票，即， <code>dp[i][1]</code><ul><li>若第  <code>i - 2</code>  天不持有股票、第  <code>i</code>  天买入股票，此时的利润为  <code>dp[i - 2][0] - prices[i]</code>  （购买股票具有 1 天的冷冻期，<strong>第  <code>i</code>  天买入股票要求第  <code>i - 2</code>  天已经卖出股票</strong>）</li><li>若第  <code>i - 1</code>  天持有股票，此时利润为  <code>dp[i - 1][1]</code></li><li>综合两种情况得  <code>dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i])</code></li></ul></li></ul><p>初始化 dp 数组：根据递推公式知，应初始化  <code>dp[0][]</code>  和  <code>dp[1][]</code></p><ul><li>第 0 天不持有股票：利润为 0 ，即  <code>dp[i][0] = 0</code></li><li>第 0 天持有股票：当前利润为  <code>- prices[0]</code>  ，即  <code>dp[0][1] = - prices[0]</code></li><li>第 1 天不持有股票：若第 0 天不持有股票，则利润为  <code>0</code>  ；若第 0 天持有股票、第 1 天卖出股票，则利润为  <code>prices[1] - prices[0]</code>  。因此， <code>dp[1][0] = max(0, prices[1] - prices[0])</code></li><li>第 1 天持有股票：若第 0 天买入股票，则利润为  <code>dp[0][1]</code>  ；若第 1 天买入股票，则利润为  <code>- prices[1]</code>  。因此， <code>dp[1][1] = max(dp[0][1], - prices[1])</code></li></ul><p>遍历顺序：按  <code>i</code>  从小到大遍历</p><p>最后的  <code>dp[n - 1][0]</code>  即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    if (n &lt;= 1) return 0;    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));    dp[0][0] = 0;           // 第 0 天不持有股票时的最大利润    dp[0][1] = - prices[0]; // 第 0 天持有股票时的最大利润    dp[1][0] = max(dp[0][1] + prices[1], dp[0][0]);    dp[1][1] = max(dp[0][0] - prices[1], dp[0][1]);    for (int i = 2; i &lt; n; i++) &#123;        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);        dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i]); // 具有冷冻期    &#125;    return dp[n - 1][0];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>prices</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 188. 买卖股票的最佳时机 IV</title>
      <link href="/posts/26a72e96/"/>
      <url>/posts/26a72e96/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWl2Lw==">188. Best Time to Buy and Sell Stock IV</span></p><p>给定一个整数数组  <code>prices</code>  ，它的第  <code>i</code>  个元素  <code>prices[i]</code>  是一支给定的股票在第  <code>i</code>  天的价格，和一个整型  <code>k</code>  。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成  <code>k</code>  笔交易。也就是说，你最多可以买  <code>k</code>  次，卖  <code>k</code>  次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code>输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><blockquote><p><a href="https://jiankychen.github.io/posts/">LeetCode 123. 买卖股票的最佳时机 III</a> 允许进行至多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次交易，而本题允许进行至多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次交易</p></blockquote><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示第  <code>i</code>  天状态为  <code>j</code>  时的最大利润，其中， <code>0 &lt;= i &lt;= prices.size() - 1</code>  ， <code>0 &lt;= j &lt;= 2 * k</code></p><ul><li><code>dp[i][0]</code>  ：没有任何操作</li><li><code>dp[i][1]</code>  ：持有第 1 支股票</li><li><code>dp[i][2]</code>  ：不再持有第 1 支股票</li><li>...</li><li><code>dp[i][2 * k - 1]</code>  ：持有第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 支股票</li><li><code>dp[i][2 * k]</code>  ：不再持有第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 支股票</li></ul><p>不难发现，对于  <code>dp[i][j]</code>  而言， <code>j</code>  为奇数时表示当前持有股票， <code>j</code>  为偶数（  <code>j &gt; 0</code>  ）时表示当前并不持有股票</p><p>因此，递推公式为：</p><ul><li>当  <code>j</code>  为奇数时，有  <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])</code></li><li>当  <code>j</code>  为偶数时，有  <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i])</code></li></ul><p>并且，dp 数组的初始值应为：</p><ul><li>当  <code>j</code>  为奇数时， <code>dp[0][j] = - prices[0]</code></li><li>当  <code>j</code>  为偶数时， <code>dp[0][j] = 0</code></li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;    if (prices.size() == 0) return 0;    if (k == 0) return 0;    vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2 * k + 1));    for (int j = 1; j &lt; 2 * k; j += 2) &#123;        dp[0][j] = - prices[0];    &#125;    for (int i = 1; i &lt; prices.size(); i++) &#123;        for (int j = 0; j &lt; 2 * k - 1; j += 2) &#123;            dp[i][j + 1] = max(dp[i - 1][j] - prices[i], dp[i - 1][j + 1]);            dp[i][j + 2] = max(dp[i - 1][j + 1] + prices[i], dp[i - 1][j + 2]);        &#125;    &#125;    return dp[prices.size() - 1][2 * k];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>prices</code>  的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是允许的交易次数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxODguJUU0JUI5JUIwJUU1JThEJTk2JUU4JTgyJUExJUU3JUE1JUE4JUU3JTlBJTg0JUU2JTlDJTgwJUU0JUJEJUIzJUU2JTk3JUI2JUU2JTlDJUJBSVYuaHRtbA==">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 123. 买卖股票的最佳时机 III</title>
      <link href="/posts/15ff7d07/"/>
      <url>/posts/15ff7d07/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpaS8=">123. Best Time to Buy and Sell Stock III</span></p><p>给定一个数组，它的第  <code>i</code>  个元素是一支给定的股票在第  <code>i</code>  天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：prices = [7,6,4,3,1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code>  表示第 i 天状态为 j 时的最大利润</p><ul><li><code>dp[i][0]</code>  ：第 i 天时，未曾买入过股票</li><li><code>dp[i][1]</code>  ：第 i 天时，持有第一支股票（已买入、未卖出，可能第 i 天以前就已买入）</li><li><code>dp[i][2]</code>  ：第 i 天时，不再持有第一支股票（可能是第 i 天以前就已经卖出）</li><li><code>dp[i][3]</code>  ：第 i 天时，持有第二支股票（卖出第一支股票后再次买入，可能第 i 天以前就已买入）</li><li><code>dp[i][4]</code>  ：第 i 天时，不再持有第二支股票（可能是第 i 天以前就已经卖出）</li></ul><p>推导递推公式：</p><ul><li><code>dp[i][0]</code>  ：第  <code>i - 1</code>  天必然也不曾买入过股票，故而  <code>dp[i][0] = dp[i - 1][0]</code> （事实上，对任意 i 均有  <code>dp[i][0] = 0</code>  ）</li><li><code>dp[i][1]</code>  ：若第  <code>i - 1</code>  天不曾买入股票，即，第  <code>i</code>  天买入股票，此时利润为  <code>dp[i - 1][0] - prices[i]</code>  ；若第  <code>i - 1</code>  天已持有股票，第  <code>i</code>  天时的利润为  <code>dp[i - 1][1]</code>  。综合两种情况，取最大利润，即， <code>dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])</code>  （由于  <code>dp[i - 1][0] = 0</code>  ， <code>dp[i][1]</code>  也可写为  <code>max( - prices[i], dp[i - 1][1])</code>  ）</li><li><code>dp[i][2]</code>  ：若第  <code>i - 1</code>  天不曾卖出股票，即，第  <code>i</code>  天卖出股票，此时利润为  <code>dp[i - 1][1] + prices[i]</code>  ；若第  <code>i - 1</code>  天已卖出股票，第  <code>i</code>  天时的利润为  <code>dp[i - 1][2]</code>  。综合两种情况得， <code>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code></li><li><code>dp[i][3]</code>  ：若第  <code>i - 1</code>  天不曾持有第二支股票，即，第  <code>i</code>  天买入第二支股票，此时利润为  <code>dp[i - 1][2] - prices[i]</code>  ；若第  <code>i - 1</code>  天已持有第二支股票，第  <code>i</code>  天时的利润为  <code>dp[i - 1][3]</code>  。综合两种情况得， <code>dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3])</code></li><li><code>dp[i][4]</code>  ：若第  <code>i - 1</code>  天持有第二支股票，即，第  <code>i</code>  天卖出第二支股票，此时利润为  <code>dp[i - 1][3] + prices[i]</code>  ；若第  <code>i - 1</code>  天已不再持有第二支股票，第  <code>i</code>  天时的利润为  <code>dp[i - 1][4]</code>  。综合两种情况得， <code>dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4])</code></li></ul><p>初始化 dp 数组：</p><ul><li><code>dp[0][0] = 0</code>  ，第 0 天不进行任何操作，利润为 0</li><li><code>dp[0][1] = - prices[0]</code>  ，第 0 天买入股票，利润为  <code>- prices[0]</code></li><li><code>dp[0][2] = 0</code>  ，当天买入股票并当天卖出，利润为 0</li><li><code>dp[0][3] = - prices[0]</code>  ，买入股票，利润为  <code>- prices[0]</code></li><li><code>dp[0][4] = 0</code>  ，当天买入股票并当天卖出，利润为 0</li></ul><p>遍历顺序：按  <code>i</code>  从小到大顺序遍历</p><p>最后的  <code>dp[prices.size() - 1][4]</code>  即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(5, 0));    dp[0][1] = - prices[0];    dp[0][3] = - prices[0];    for (int i = 1; i &lt; n; i++) &#123;        dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);        dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]);        dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3]);        dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4]);    &#125;    return dp[n - 1][4];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以采用滚动数组优化空间复杂度</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMjMuJUU0JUI5JUIwJUU1JThEJTk2JUU4JTgyJUExJUU3JUE1JUE4JUU3JTlBJTg0JUU2JTlDJTgwJUU0JUJEJUIzJUU2JTk3JUI2JUU2JTlDJUJBSUlJLmh0bWw=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 121. 买卖股票的最佳时机</title>
      <link href="/posts/7ef7bbd4/"/>
      <url>/posts/7ef7bbd4/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLw==">121. Best Time to Buy and Sell Stock</span></p><p>给定一个数组  <code>prices</code>  ，它的第  <code>i</code>  个元素  <code>prices[i]</code>  表示一支给定股票第  <code>i</code>  天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回  <code>0</code>  。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-1-贪心"><a class="anchor" href="#method-1-贪心">#</a> Method 1: 贪心</h1><p>算法思路：</p><ul><li><p>利用  <code>priceBuy</code>  表示买入价，并维护获得的最大利润  <code>maxProfit</code></p></li><li><p>如果遇到更低的价格，则更新买入价  <code>priceBuy</code>  ，后续按新的买入价计算所能得到的利润</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int priceBuy = prices[0]; // 买入价格    int maxProfit = 0;        // 最大利润    for (int i = 1; i &lt; prices.size(); i++) &#123;        priceBuy = min(priceBuy, prices[i]);                      maxProfit = max(maxProfit, prices[i] - priceBuy);    &#125;    return maxProfit;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中　<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2,0))</code></p><ul><li><code>dp[i][0]</code>  表示第  <code>i</code>  天持有股票时的最大利润</li><li><code>dp[i][1]</code>  表示第  <code>i</code>  天不持有股票时的最大利润</li></ul><p>确定递推公式：</p><ul><li>第  <code>i</code>  天持有股票，即， <code>dp[i][0]</code><ul><li>若第  <code>i - 1</code>  天持有股票，则最大利润为  <code>dp[i - 1][0]</code></li><li>若第  <code>i - 1</code>  天不持有股票，即，第  <code>i</code>  天买入股票，则最大利润为  <code>- prices[i]</code> （因为只能买入一次股票，第  <code>i - 1</code>  天不持有股票就说明此前并未买入过股票，因此第  <code>i - 1</code>  天的利润必定为 0 ）</li><li>综合两种情况得  <code>dp[i][0] = max(dp[i - 1][0], - prices[i]);</code></li></ul></li><li>第  <code>i</code>  天不持有股票，即， <code>dp[i][1]</code><ul><li>若第  <code>i - 1</code>  天持有股票，即，第  <code>i</code>  天卖出股票，则最大利润为  <code>dp[i - 1][0] + prices[i]</code></li><li>若第  <code>i - 1</code>  天不持有股票，则最大利润为  <code>dp[i - 1][1]</code></li><li>综合两种情况得  <code>dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1])</code></li></ul></li></ul><p>初始化 dp 数组：</p><ul><li>若第 0 天持有股票，当前利润应为  <code>- prices[0]</code>  ，即  <code>dp[0][0] = - prices[0]</code></li><li>若第 0 天不持有股票，利润为 0 ，即  <code>dp[i][1] = 0</code></li></ul><p>遍历顺序：按  <code>i</code>  从小到大遍历</p><p>最后的  <code>dp[n - 1][1]</code>  即为所求（卖出股票可以获得收益，因此， <code>dp[n - 1][1]</code>  一定不小于  <code>dp[n - 1][0]</code>  ）</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2,0));    dp[0][0] = - prices[0]; // 第 0 天持有股票时的最大利润    dp[0][1] = 0;           // 第 0 天不持有股票时的最大利润    for (int i = 1; i &lt; n; i++) &#123;        dp[i][0] = max(dp[i - 1][0], - prices[i]);              // 第 i 天持有股票时的最大利润        dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]); // 第 i 天不持有股票时的最大利润    &#125;    return dp[n - 1][1];    // 第 n - 1 天不持有股票时的最大利润&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中　<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMjEuJUU0JUI5JUIwJUU1JThEJTk2JUU4JTgyJUExJUU3JUE1JUE4JUU3JTlBJTg0JUU2JTlDJTgwJUU0JUJEJUIzJUU2JTk3JUI2JUU2JTlDJUJBLmh0bWw=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 337. 打家劫舍 III</title>
      <link href="/posts/8ba06b1/"/>
      <url>/posts/8ba06b1/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXItaWlpLw==">337. House Robber III</span></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为  <code>root</code>  。</p><p>除了  <code>root</code>  之外，每栋房子有且只有一个 “父 “房子与之相连。一番侦察之后，聪明的小偷意识到 “这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的  <code>root</code>  。返回 <strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p><p><strong>示例 1：</strong></p><pre><code>输入：root = [3,2,3,null,3,null,1]输出：7解释：小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [3,4,5,1,3,null,1]输出：9解释：小偷一晚能够盗取的最高金额 4 + 5 = 9</code></pre><p><strong>提示：</strong></p><ul><li>树的节点数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 范围内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-递归-动态规划"><a class="anchor" href="#method-递归-动态规划">#</a> Method: 递归 + 动态规划</h1><p>确定递归函数的参数和返回值：</p><ul><li>传入参数： <code>TreeNode* root</code></li><li>返回值： <code>vector&lt;int&gt;&#123;val1, val2&#125;</code><ul><li><code>val1</code>  表示不偷窃  <code>root</code>  节点时，从  <code>root</code>  的子树上偷窃所得的最大金额</li><li><code>val2</code>  表示偷窃  <code>root</code>  节点时，从  <code>root</code>  及其子树上偷窃所得的最大金额</li></ul></li></ul><p>确定递归的终止条件：遇到空节点，无论是否偷窃，所得金额均为 0 ，故而返回  <code>vector&lt;int&gt;(2, 0)</code></p><p>确定遍历顺序：采用后序遍历，因为需要根据子节点的返回值来处理当前节点</p><p>单层递归的逻辑：</p><ul><li>递归左子树，计算偷窃左子节点、不偷窃左子节点所能达到的金额，分别记为  <code>left[0]</code>  ,  <code>left[1]</code></li><li>递归右子树，计算偷窃右子节点、不偷窃右子节点所能达到的金额，分别记为  <code>right[0]</code>  ,  <code>right[1]</code></li><li>处理当前节点<ul><li>如果不偷窃当前节点，则可以考虑偷窃子节点（并不一定要偷窃子节点），从左子树上所能得到的最大金额为  <code>max(left[0], left[1])</code>  ，从右子树上所能得到的最大金额为  <code>max(right[0], right[1])</code>  ，因此，总金额为  <code>val1 = max(left[0], left[1]) + max(right[0], right[1])</code></li><li>如果偷窃当前节点，则不能偷窃子节点，从左子树上得到的最大金额为  <code>left[0]</code>  ，从右子树上得到的最大金额为  <code>right[0]</code>  ，因此，总金额为  <code>val2 = root-&gt;val + left[0] + right[0]</code></li></ul></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; dfs(TreeNode* root) &#123;    if (root == nullptr) return vector&lt;int&gt;&#123;0, 0&#125;;    vector&lt;int&gt; left = dfs(root-&gt;left);    vector&lt;int&gt; right = dfs(root-&gt;right);    int val1 = max(left[0], left[1]) + max(right[0], right[1]); // 偷窃 root 节点    int val2 = root-&gt;val + left[0] + right[0];                  // 不偷窃 root 节点    return vector&lt;int&gt;&#123;val1, val2&#125;;&#125;int rob(TreeNode* root) &#123;    vector&lt;int&gt; result = dfs(root);    int ans = max(result[0], result[1]); // 处理根节点    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 213. 打家劫舍 II</title>
      <link href="/posts/46ac943d/"/>
      <url>/posts/46ac943d/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXItaWkv">213. House Robber II</span></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,2]输出：3解释：只能偷窃 2 号房屋（金额 = 3）。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,2,3]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>与 <a href="https://jiankychen.github.io/posts/be158ab">LeetCode 198. 打家劫舍</a> 有所不同，本题的房屋是首尾相连的，因此，第一间房屋和最后一间房屋不能在同一晚上偷窃</p><p>当只有一间房屋时，偷窃的最高金额就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></p><p>当房屋数量大于等于 2 时，考虑两种情况：</p><ul><li>可以偷窃第一间房屋、但不可以偷窃最后一间房屋，即，考虑偷窃 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, nums.size() - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 这一区间内的房屋</li><li>不可以偷窃第一间房屋、但可以偷窃最后一间房屋，即，考虑偷窃 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, nums.size() - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 这一区间内的房屋</li></ul><p>其中，每一种情况都可以按照 <a href="https://jiankychen.github.io/posts/be158ab">LeetCode 198. 打家劫舍</a> 中的方法求解</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>代码实现：</p><pre><code class="language-cpp">int robRange(vector&lt;int&gt;&amp; nums, int left, int right) &#123; // 打家劫舍，区间 nums[left, right]    if (left == right) return nums[left];    vector&lt;int&gt; dp(nums.size(), 0);    dp[left] = nums[left];    dp[left + 1] = max(nums[left], nums[left + 1]);    for (int i = left + 2; i &lt;= right; i++)        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);    return dp[right];&#125;int rob(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() == 1) return nums[0];    int result1 = robRange(nums, 0, nums.size() - 2); // 不考虑尾元素    int result2 = robRange(nums, 1, nums.size() - 1); // 不考虑首元素    return max(result1, result2);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 198. 打家劫舍</title>
      <link href="/posts/be158ab/"/>
      <url>/posts/be158ab/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXIv">198. House Robber</span></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>400</mn></mrow><annotation encoding="application/x-tex">\le 400</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 间房屋（即，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ）能偷窃到的最高总金额</p><p>递推公式：当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p><ul><li>偷窃第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 间房屋，能达到的最高总金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 2] + nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></li><li>不偷窃第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 间房屋，可考虑偷窃第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 间房屋，能达到的最高总金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li><li>综合两种情况，取其中最大的，即，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li></ul><p>初始化 dp 数组：根据递推公式知，应初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><ul><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，能偷窃的最高金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，故而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[0] = nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，能偷窃的最高金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(nums[0], nums[1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> ，故而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[1] = max(nums[0], nums[1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li></ul><p>遍历顺序：按从小到大的顺序遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span></p><p>代码实现：</p><pre><code class="language-cpp">int rob(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if (n == 0) return 0;    if (n == 1) return nums[0];    vector&lt;int&gt; dp(n, 0);    dp[0] = nums[0];    dp[1] = max(nums[0], nums[1]);    for (int i = 2; i &lt; n; i++) &#123;        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);    &#125;    return dp[n - 1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 139. 单词拆分</title>
      <link href="/posts/6dd7981d/"/>
      <url>/posts/6dd7981d/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWJyZWFrLw==">139. Word Break</span></p><p>给你一个字符串  <code>s</code>  和一个字符串列表  <code>wordDict</code>  作为字典。请你判断是否可以利用字典中出现的单词拼接出  <code>s</code>  。</p><p><strong>注意</strong>：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]输出：true解释：&quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]输出：true解释：&quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]输出：false</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">\le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>wordDict.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>wordDict[i].length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><code>s</code>  和  <code>wordDict[i]</code>  仅有小写英文字母组成</li><li><code>wordDict</code>  中的所有字符串 互不相同</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>可以把字典  <code>wordDict</code>  中的单词看成物品，把字符串  <code>s</code>  看成背包，要判断  <code>wordDict</code>  中的单词是否能组成字符串  <code>s</code>  ，也就是要判断物品是否能装满背包</p><p>算法思路：</p><ol><li><p>定义 dp 数组： <code>dp[j]</code>  表示字符串  <code>s</code>  前  <code>j</code>  个字符组成的子串是否能由字典  <code>wordDict</code>  中的单词拼接成，其中， <code>1 &lt;= j &lt;= s.size()</code></p></li><li><p>确定递推公式：对于任意  <code>j</code>  ，需要枚举  <code>s[0, ..., j - 1]</code>  中的分割点  <code>i</code>  ，看  <code>s[0, ..., i - 1]</code>  组成的字符串（默认 j = 0 时为空串）和  <code>s[i, ..., j - 1]</code>  组成的字符串是否都合法，如果两个字符串都合法，则组成的  <code>s[0, ..., j - 1]</code>  也合法。因此，递推公式为： <code>dp[j] = dp[i] &amp;&amp; check(s[i, ..., j - 1])</code>  ，其中， <code>check(s[i, ..., j - 1])</code>  表示子串  <code>s[i, ..., j - 1]</code>  是否为字典中的单词</p></li><li><p>初始化 dp 数组：定义  <code>dp[0] = true</code>  表示空串是合法的，对任意  <code>j &gt; 0</code>  均有  <code>dp[j] = false</code></p></li><li><p>确定遍历顺序：由于字典  <code>wordDict</code>  中的单词可以重复出现（即，完全背包问题），并且单词出现的顺序并不确定，因此，应该外层  <code>for</code>  循环遍历背包，内层  <code>for</code>  循环遍历物品，其中，内循环须按从小到大顺序遍历</p></li></ol><p>其中，检查子串  <code>s[i, ..., j - 1]</code>  是否为字典中的单词可以通过哈希表实现</p><p>代码实现：</p><pre><code class="language-cpp">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;    unordered_set&lt;string&gt; hash(wordDict.begin(), wordDict.end());    vector&lt;bool&gt; dp(s.size() + 1, false); // dp[j] 表示 s[0, j - 1] 是否可由 wordDict 拼接得到    dp[0] = true;    for (int j = 1; j &lt;= s.size(); j++) &#123; // 遍历背包        for (int i = 0; i &lt; j; i++) &#123;     // 遍历物品            string word = s.substr(i, j - i);               // 截取 s[i, j - 1] 子串            if (dp[i] &amp;&amp; (hash.find(word) != hash.end())) &#123; // s[0, i - 1] 可拼接，s[i, j - 1] 也可拼接                dp[j] = true;                               // 故而 s[0, j - 1] 可拼接                break;            &#125;        &#125;    &#125;    return dp[s.size()];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串  <code>s</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>也可以做一些简单的剪枝，枚举分割点的时候倒着枚举，如果分割点  <code>i</code>  到  <code>j</code>  的长度已经大于字典列表里最长的单词的长度，那么就结束枚举</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWJyZWFrL3NvbHV0aW9uL2Rhbi1jaS1jaGFpLWZlbi1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 279. 完全平方数</title>
      <link href="/posts/42243142/"/>
      <url>/posts/42243142/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJmZWN0LXNxdWFyZXMv">279. Perfect Squares</span></p><p>给你一个整数  <code>n</code>  ，返回 和为  <code>n</code>  的完全平方数的最少数量 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 12输出：3解释：12 = 4 + 4 + 4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 13输出：2解释：13 = 4 + 9</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>可以将完全平方数视为背包问题中的物品，所需凑成的整数 n 即为背包最大容量，求解装满背包所需物品的最小数量</p><p>其中，物品可以重复选取，因此，本题是一个完全背包问题</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[j]</code>  表示凑成  <code>j</code>  所需完全平方数的最少数量，其中  <code>0 &lt;= j &lt;= n</code></p><p>递推公式：当  <code>j &gt;= i * i</code>  时，可选取  <code>i * i</code>  ，也可不选取  <code>i * i</code>  ，因此  <code>dp[j] = min(dp[j], 1 + dp[j - i * i])</code></p><p>初始化 dp 数组：如果和为 0 ，最少需要 0 个完全平方数，即  <code>dp[0] = 0</code>  ，为确保递推公式的更新，应将任意  <code>j &gt; 0</code>  的  <code>dp[j]</code>  初始化为一个比较大的数值，例如  <code>INT_MAX</code></p><p>遍历顺序：完全平方数的选取顺序不影响最终结果，可以采用外层遍历物品、内层遍历背包容量，其中，物品、背包容量均需按照从小到大的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int numSquares(int n) &#123;    vector&lt;int&gt; dp(n + 1, INT_MAX);    dp[0] = 0;    for (int i = 1; i * i &lt;= n; i++) &#123; // 遍历物品        for (int j = 1; j &lt;= n; j++) &#123; // 遍历背包容量            if (j &gt;= i * i)                dp[j] = min(dp[j], 1 + dp[j - i * i]);        &#125;    &#125;    return dp[n];&#125;</code></pre><p>或者</p><pre><code class="language-cpp">int numSquares(int n) &#123;    vector&lt;int&gt; dp(n + 1, INT_MAX);    dp[0] = 0;    for (int j = 1; j &lt;= n; j++) &#123;         // 遍历背包容量        for (int i = 1; i * i &lt;= j; i++) &#123; // 遍历物品            dp[j] = min(dp[j], 1 + dp[j - i * i]);        &#125;    &#125;    return dp[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times \sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 322. 零钱兑换</title>
      <link href="/posts/ff7c5482/"/>
      <url>/posts/ff7c5482/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS8=">322. Coin Change</span></p><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><pre><code>输入：coins = [1,2,5], amount = 11输出：3解释：11 = 5 + 5 + 1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：coins = [2], amount = 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：coins = [1], amount = 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>coins.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">\le 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>coins[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>amount</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>每种面额的硬币可以重复选取，因此，本题属于完全背包问题，可以采用动态规划方法求解</p><p>其中，选取硬币的顺序并不影响结果，因此，外层遍历物品、内层遍历背包容量，或者，外层遍历背包容量、内层遍历物品，这两种遍历方案都可以</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[j]</code>  表示凑成金额  <code>j</code>  所需的最少硬币个数，其中  <code>0 &lt;= j &lt;= amount</code></p><p>递推公式：当  <code>coins[i] &lt;= j &lt;= amount</code>  时，若  <code>dp[j - coins[i]] != INT_MAX</code>  ， <code>dp[j] = min(dp[j], 1 + dp[j - coins[i]])</code></p><ul><li>当  <code>j &lt; coins[i]</code>  时，不能选取  <code>coins[i]</code>  ， <code>dp[j]</code>  保持不变</li><li>当  <code>coins[i] &lt;= j &lt;= amount</code>  时，若选取  <code>coins[i]</code>  ，所需的最少硬币数为  <code>1 + dp[j - coins[i]]</code>  （注意，此时要求金额  <code>j - coins[i]</code>  是可以被凑出来的，即， <code>dp[j - coins[i]]</code>  不等于初始值），若不选取  <code>coins[i]</code>  ，所需的最少硬币数为  <code>dp[j]</code>  ，综合可得， <code>dp[j] = min(dp[j], 1 + dp[j - coins[i]])</code></li></ul><p>初始化 dp 数组：凑成金额 0 的硬币个数一定为 0 ，即， <code>dp[0] = 0</code>  。考虑到递推公式的特性， <code>dp[j]</code>  必须初始化为一个比较大的数值，以便在执行  <code>dp[j] = min(dp[j], 1 + dp[j - coins[i]])</code>  时能够更新 dp 数组，因此，对任意  <code>j &gt; 0</code>  均有  <code>dp[j] = INT_MAX</code></p><p>遍历顺序：硬币的选取顺序不影响所需的最少硬币个数，可以采用外层遍历硬币面额（物品）、内层遍历金额之和（背包容量）</p><p>遍历结束后，若  <code>dp[amount]</code>  等于初始值  <code>INT_MAX</code>  ，则说明任何一种硬币组合都无法组成金额  <code>amount</code>  ，故而返回  <code>-1</code>  ，否则， <code>dp[amount]</code>  表示的就是所需的最少硬币个数</p><p>代码实现：</p><pre><code class="language-cpp">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;    vector&lt;int&gt; dp(amount + 1, INT_MAX);    dp[0] = 0;    for (int i = 0; i &lt; coins.size(); i++) &#123;        for (int j = coins[i]; j &lt;= amount; j++) &#123;            if (dp[j - coins[i]] != INT_MAX) // 方案可行                dp[j] = min(dp[j], 1 + dp[j - coins[i]]);        &#125;    &#125;    if (dp[amount] == INT_MAX) return -1;    // 不存在可行的方案    return dp[amount];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzMjIuJUU5JTlCJUI2JUU5JTkyJUIxJUU1JTg1JTkxJUU2JThEJUEyLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 377. 组合总和 IV</title>
      <link href="/posts/bed222b7/"/>
      <url>/posts/bed222b7/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taXYv">377. Combination Sum IV</span></p><p>给你一个由 <strong>不同</strong> 整数组成的数组  <code>nums</code>  ，和一个目标整数  <code>target</code>  。请你从  <code>nums</code>  中找出并返回总和为  <code>target</code>  的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [9], target = 3输出：0</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>nums</code>  中的所有元素 互不相同</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶：</strong> 如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p><code>nums</code>  的每个元素可以选取多次，且需要考虑选取元素的顺序，因此本题计算的是选取元素的 <strong>排列</strong> 数</p><p>可以通过动态规划方法求解</p><p>其中，遍历顺序应为：外层 for 循环遍历背包容量，内层 for 循环遍历物品</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路</p><p>定义 dp 数组： <code>dp[j]</code>  表示选取元素之和等于  <code>j</code>  的硬币组合数，其中， <code>0 &lt;= j &lt;= target</code></p><p>递推公式： <code>dp[j] += dp[j - nums[i]], nums[i] &lt;= j &lt;= target</code></p><ul><li>若  <code>j &lt; nums[i]</code>  ，不能选取  <code>nums[i]</code>  ，因此， <code>dp[j]</code>  保持不变</li><li>若  <code>j &gt;= nums[i]</code>  ，如果选取  <code>nums[i]</code>  ，方案数应为  <code>dp[j - nums[i]]</code>  ，如果不选取  <code>nums[i]</code>  ，方案数应为  <code>dp[j]</code>  ，综合两种情况，总的方案数为  <code>dp[j] = dp[j] + dp[j - nums[i]]</code></li></ul><p>初始化 dp 数组：不选取任何元素，元素之和才为 0 ，即， <code>dp[0] = 1</code></p><p>遍历顺序：<strong>由于所求的是排列数，外层 for 循环应遍历元素之和（背包容量），内层 for 循环应遍历数组元素（物品），并且，均按照从小到大的顺序遍历</strong></p><p>C++ 测试用例有两个数相加超过  <code>int</code>  的数据，因此需要加上  <code>dp[j] + dp[j - nums[i]] &lt; INT_MAX</code>  这一限制</p><p>代码实现：</p><pre><code class="language-cpp">int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;    vector&lt;int&gt; dp(target + 1, 0);    dp[0] = 1;    for (int j = 0; j &lt;= target; j++) &#123;        for (int i = 0; i &lt; nums.size(); i++) &#123;            if (j &gt;= nums[i] &amp;&amp; dp[j] + dp[j - nums[i]] &lt; INT_MAX)                dp[j] += dp[j - nums[i]];        &#125;    &#125;    return dp[target];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><h1 id="进阶"><a class="anchor" href="#进阶">#</a> 进阶</h1><p>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p>如果给定的数组中含有负数，则会导致出现无限长度的排列</p><p>例如，假设数组中含有正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>−</mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">−b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal">b</span></span></span></span>（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ），则对于任意一个元素之和等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 的排列，都可以在该排列的后面添加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>−</mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">−b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal">b</span></span></span></span> ，使得新排列的元素之和依然等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 。换而言之，只要存在一种符合条件的排列，就能构造出无限长度的排列</p><p>因此，必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taXYvc29sdXRpb24venUtaGUtem9uZy1oZS1pdi1ieS1sZWV0Y29kZS1zb2x1dGlvbi1xOHp2Lw==">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 518. 零钱兑换 II</title>
      <link href="/posts/b992262f/"/>
      <url>/posts/b992262f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS1paS8=">518. Coin Change 2</span></p><p>给你一个整数数组  <code>coins</code>  表示不同面额的硬币，另给一个整数  <code>amount</code>  表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><pre><code>输入：amount = 5, coins = [1,2,5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：amount = 3, coins = [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：amount = 10, coins = [10]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>coins.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">\le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>coins[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>coins</code>  中的所有值 <strong>互不相同</strong></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>amount</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p><code>coins</code>  的每个元素可以选取多次，且不考虑选取元素的顺序，因此本题计算的是选取硬币的 <strong>组合</strong> 数</p><p>本题是一个完全背包问题，可以通过动态规划方法求解</p><p>完全背包问题的遍历顺序：</p><ul><li>如果求的是组合数，外层 for 遍历物品，内层 for 遍历背包</li><li>如果求的是排列数，外层 for 遍历背包，内层 for 遍历物品</li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>dp[j]</code>  表示凑成金额  <code>j</code>  的硬币组合数，其中， <code>0 &lt;= j &lt;= amount</code></p><p>递推公式： <code>dp[j] += dp[j - coins[i]], coins[i] &lt;= j &lt;= amount</code></p><ul><li>若  <code>j &lt; coins[i]</code>  ，不能选取  <code>coins[i]</code>  ，因此， <code>dp[j]</code>  保持不变</li><li>若  <code>j &gt;= coins[i]</code>  ，如果选取  <code>coins[i]</code>  ，凑成金额  <code>j</code>  的方案数应为  <code>dp[j - coins[i]]</code>  ，如果不选取  <code>coins[i]</code>  ，凑成  <code>j</code>  的方案数应为  <code>dp[j]</code>  ，综合两种情况，总的方案数为  <code>dp[j] = dp[j] + dp[j - coins[i]]</code></li></ul><p>初始化 dp 数组：只有不选取任何硬币时，金额之和才为 0 ，即，金额 0 只对应 1 种硬币组合，因此， <code>dp[0] = 1</code></p><p>遍历顺序：<strong>外层遍历硬币面额，内层遍历金额总和，并且，均按照从小到大的顺序遍历</strong></p><ul><li>不同于 <a href="https://jiankychen.github.io/posts/a80d0031">动态规划</a> 中的纯完全背包问题（要求的是能否凑成某个金额、凑成的最大金额是多少），纯完全背包可以改变两个 for 循环的嵌套方式，本题（要求的是凑成某金额的方案个数）只能外层遍历物品（硬币面额），内层遍历背包容量（金额总和）</li><li>外层遍历硬币面额，内层遍历金额总和：只可能出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i],\ coins[i + 1]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> 这种情况，而不会出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i + 1],\ coins[i]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> 的情况，即，硬币面额的出现顺序是确定的，因此，只会计算组合数，而不会计算排列数</li><li>外层遍历金额总和，内层遍历硬币面额：可能会既出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i],\ coins[i + 1]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> ，又出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i + 1],\ coins[i]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> ，即，硬币面额的出现顺序并不确定，因此，这里会计算排列数</li></ul><p>例如  <code>coins = [1,2]</code>  ，对于  <code>dp[3]</code>  的计算，一定是先遍历硬币面额 1 然后才遍历硬币面额 2，故而只会统计  <code>3 = 1 + 1 + 1</code>  和  <code>3 = 1 + 2</code>  这两种情况。硬币面额 2 不可能出现在硬币面额 1 之前，即，不会重复计算  <code>3 = 2 + 1</code>  的情况</p><blockquote><p>建议把这两种方案的 dp 数组打印出来，对比一下</p></blockquote><p>最后的  <code>dp[amount]</code>  即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int change(int amount, vector&lt;int&gt;&amp; coins) &#123;    vector&lt;int&gt; dp(amount + 1, 0);    dp[0] = 1;    for (int i = 0; i &lt; coins.size(); i++) &#123;        for (int j = coins[i]; j &lt;= amount; j++) &#123;            dp[j] += dp[j - coins[i]];        &#125;    &#125;    return dp[amount];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">amount</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span> 是总金额</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MTguJUU5JTlCJUI2JUU5JTkyJUIxJUU1JTg1JTkxJUU2JThEJUEySUkuaHRtbA==">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS0yL3NvbHV0aW9uL2xpbmctcWlhbi1kdWktaHVhbi1paS1ieS1sZWV0Y29kZS1zb2x1dGktZjd1aC8=">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 474. 一和零</title>
      <link href="/posts/d75bfa3f/"/>
      <url>/posts/d75bfa3f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vbmVzLWFuZC16ZXJvZXMv">474. Ones and Zeroes</span></p><p>给你一个二进制字符串数组  <code>strs</code>  和两个整数  <code>m</code>  和  <code>n</code>  。</p><p>请你找出并返回  <code>strs</code>  的最大子集的长度，该子集中 <strong>最多</strong> 有  <code>m</code>  个  <code>0</code>  和  <code>n</code>  个  <code>1</code>  。</p><p>如果  <code>x</code>  的所有元素也是  <code>y</code>  的元素，集合  <code>x</code>  是集合  <code>y</code>  的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：strs = [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：strs = [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m = 1, n = 1输出：2解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>strs.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>600</mn></mrow><annotation encoding="application/x-tex">\le 600</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>strs[i].length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>strs[i]</code>  仅由  <code>'0'</code>  和  <code>'1'</code>  组成</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code> ,  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题和 0-1 背包问题非常相似，但是本题的背包有两种容量，即选取的字符串子集中的 0 和 1 的数量上限</p><p>因此，动态规划需要遍历三个维度：字符串、0 的容量、1 的容量</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><ol><li><p><code>dp</code>  数组</p><ul><li><code>dp[i][j][k]</code>  ：在确保 0 的个数不超过  <code>i</code>  、1 的个数不超过  <code>j</code>  的情况下，从索引  <code>[0, i]</code>  范围内选出字符串，所能达到的最大子集的长度</li><li>其中， <code>0 &lt;= i &lt;= strs.size() - 1</code>  ， <code>0 &lt;= j &lt;= m</code>  ， <code>0 &lt;= k &lt;= n</code></li></ul></li><li><p>递推公式：当  <code>1 &lt;= i &lt; strs.size()</code>  时，计算  <code>strs[i]</code>  中 0 和 1 的个数，分别记作  <code>num0</code>  和  <code>num1</code></p><ul><li>若  <code>j &lt; num0</code>  或  <code>k &lt; num1</code>  ：不能选取  <code>strs[i]</code>  这一字符串，此时， <code>dp[i][j][k] = dp[i - 1][j][k]</code></li><li>若  <code>j &gt;= num0</code>  且  <code>k &gt;= num1</code>  ：如果选取  <code>strs[i]</code>  ，最大子集的长度为  <code>1 + dp[i - 1][j - num0][k - num1]</code>  ，如果不选取  <code>strs[i]</code>  ，最大子集的长度为  <code>dp[i - 1][j][k]</code>  ，因此， <code>dp[i][j][k] = max(1 + dp[i - 1][j - num0][k - num1], dp[i - 1][j][k])</code></li></ul></li><li><p>初始化  <code>dp</code>  数组：当  <code>i = 0</code>  时，对满足  <code>j &gt;= num0 &amp;&amp; k &gt;= num1</code>  的任意  <code>j</code>  和  <code>k</code>  ，都应选取  <code>strs[0]</code>  这一字符串，即， <code>dp[0][j][k] = 1</code></p></li><li><p>遍历顺序</p><ul><li>最外层遍历  <code>i</code>  ，按从小到大顺序遍历</li><li>中层遍历  <code>j</code>  ，按从小到大顺序遍历</li><li>内层遍历  <code>k</code>  ，按从小到大顺序遍历</li></ul></li></ol><blockquote><p>也可以中层遍历  <code>k</code>  ，内层遍历  <code>j</code></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int numberOfZero(string s) &#123; // 统计字符串 s 中的 0 的个数    int count = 0;    for (auto c : s)        if (c == '0') count++;    return count;&#125;int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;        // 定义 dp 数组    int size = strs.size();    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(size, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(n + 1, 0)));        // 初始化    int num0 = numberOfZero(strs[0]);    int num1 = strs[0].size() - num0;    for (int j = num0; j &lt;= m; j++) &#123;        for (int k = num1; k &lt;= n; k++) &#123;            dp[0][j][k] = 1;        &#125;    &#125;    // 遍历    for (int i = 1; i &lt; size; i++) &#123;        num0 = numberOfZero(strs[i]);        num1 = strs[i].size() - num0;        for (int j = 0; j &lt;= m; j++) &#123;            for (int k = 0; k &lt;= n; k++) &#123;                if (num0 &lt;= j &amp;&amp; num1 &lt;= k)                    dp[i][j][k] = max(dp[i - 1][j][k], 1 + dp[i - 1][j - num0][k - num1]);                else                    dp[i][j][k] = dp[i - 1][j][k];            &#125;        &#125;    &#125;    // 返回目标值    return dp[size - 1][m][n];    &#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n + L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 是数组  <code>strs</code>  的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是数组  <code>strs</code>  中所有字符串的长度之和</p><ul><li>动态规划需要分别遍历  <code>i</code>  、 <code>j</code>  、 <code>k</code>  ，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>需要计算  <code>strs</code>  中每个字符串的 0 和 1 的数量，因此需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 的时间来遍历所有的字符串</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，三维  <code>dp</code>  数组所需空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vbmVzLWFuZC16ZXJvZXMvc29sdXRpb24veWktaGUtbGluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi11MnoyLw==">力扣官方题解</span></p><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>可定义二维  <code>dp</code>  数组，降低空间复杂度</p><p>其中， <code>dp[j][k]</code>  ：最多  <code>j</code>  个 0 、 <code>k</code>  个 1 时，所能达到的最大子集的长度</p><p>此时， <code>j</code>  和  <code>k</code>  都要按从大到小的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int numberOfZero(string s) &#123; // 统计字符串 s 中的 0 的个数    int count = 0;    for (auto c : s)        if (c == '0') count++;    return count;&#125;int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;    // 定义 dp 数组    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));    // 遍历    for (int i = 0; i &lt; strs.size(); i++) &#123;        int num0 = numberOfZero(strs[i]);        int num1 = strs[i].size() - num0;        for (int j = m; j &gt;= num0; j--) &#123;            for (int k = n; k &gt;= num1; k--) &#123;                dp[j][k] = max(dp[j][k], 1 + dp[j - num0][k - num1]);            &#125;        &#125;    &#125;    // 返回目标值    return dp[m][n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n + L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 是数组  <code>strs</code>  的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是数组  <code>strs</code>  中所有字符串的长度之和</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，二维  <code>dp</code>  数组所需空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 494. 目标和</title>
      <link href="/posts/68eb68e8/"/>
      <url>/posts/68eb68e8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXJnZXQtc3VtLw==">494. Target Sum</span></p><p>给你一个整数数组  <code>nums</code>  和一个整数  <code>target</code>  。</p><p>向数组中的每个整数前添加  <code>'+'</code>  或  <code>'-'</code>  ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如， <code>nums = [2, 1]</code>  ，可以在  <code>2</code>  之前添加  <code>'+'</code>  ，在  <code>1</code>  之前添加  <code>'-'</code>  ，然后串联起来得到表达式  <code>&quot;+2-1&quot;</code>  。</li></ul><p>返回可以通过上述方法构造的、运算结果等于  <code>target</code>  的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1], target = 1输出：1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>sum(nums[i])</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-1-深度优先搜索"><a class="anchor" href="#method-1-深度优先搜索">#</a> Method 1: 深度优先搜索</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>遍历所有的表达式，即，为每个数字分别添加符号  <code>+</code>  或  <code>-</code>  ，判断表达式的结果是否等于 target</p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int ans = 0;void DFS(vector&lt;int&gt;&amp; nums, int start, int sum, int target) &#123;    if (start == nums.size()) &#123;        if (sum == target) ++ans;        return;    &#125;    DFS(nums, start + 1, sum + nums[start], target);    DFS(nums, start + 1, sum - nums[start], target);&#125;int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;    DFS(nums, 0, 0, target);    return ans;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度，一共需要遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种表达式</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><h2 id="算法思路-2"><a class="anchor" href="#算法思路-2">#</a> 算法思路</h2><p>记数组的元素和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> ，添加  <code>-</code>  的元素之和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> ，添加  <code>+</code>  的元素之和则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mtext>−</mtext><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">sum − neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord">−</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></p><p>所得的表达式为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false">)</mo><mo>−</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>2</mn><mo>×</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(sum - neg) - neg = sum - 2 \times neg = target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>由此可得</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi><mo>=</mo><mfrac><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">neg = \frac{sum - target}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9780799999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.29208em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由于  <code>nums</code>  数组中的元素均为非负整数，其组成的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 也必定为非负整数，因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sum - target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 应为 非负偶数。否则， <code>nums</code>  数组元素无法组成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> ，也无法得到值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 的表达式，直接返回 0</p><p>若上式成立，问题转化为：从数组  <code>nums</code>  中选取若干元素，使得这些元素之和等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> ，计算选取元素的方案数</p><p>即，0-1 背包问题，可采用动态规划方法求解，类似于 <a href="https://jiankychen.github.io/posts/31559997">LeetCode 416. 分割等和子集</a> 和 <a href="https://jiankychen.github.io/posts/51a8dea1">LeetCode 1049. 最后一块石头的重量 II</a></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXJnZXQtc3VtL3NvbHV0aW9uL211LWJpYW8taGUtYnktbGVldGNvZGUtc29sdXRpb24tbzBjcC8=">力扣官方题解</span></p><h2 id="算法流程"><a class="anchor" href="#算法流程">#</a> 算法流程</h2><p>定义  <code>dp</code>  数组： <code>dp[j]</code>  表示元素和为  <code>j</code>  的方案数，其中， <code>0 &lt;= j &lt;= neg</code></p><p>确定递推公式： <code>dp[j] = dp[j] + dp[j - nums[j]], nums[i] &lt;= j &lt;= neg</code></p><ul><li>当  <code>j &lt; nums[i]</code>  时，不能选择  <code>nums[i]</code>  ， <code>dp[j]</code>  应保持不变</li><li>当  <code>j &gt;= nums[i]</code>  时，若选取  <code>nums[i]</code>  ，则元素和等于  <code>j</code>  的方案数为  <code>dp[j - nums[j]]</code>  ，若不选取  <code>nums[j]</code>  ，则方案数为  <code>dp[j]</code>  ，综合两种情况可得  <code>dp[j] = dp[j] + dp[j - nums[j]]</code></li></ul><p>初始化  <code>dp</code>  数组： <code>dp[0] = 1</code></p><ul><li>当  <code>j</code>  为  <code>0</code>  时，任意  <code>nums[i]</code>  均不可被选择，对应的方案数为 1，即  <code>dp[0] = 1</code></li></ul><p>确定遍历顺序：</p><ul><li>外层遍历  <code>i</code>  ，内层遍历  <code>j</code></li><li><code>i</code>  按从小到大顺序遍历， <code>j</code>  按从大到小顺序遍历</li></ul><p>最终得到  <code>dp[neg]</code>  即为所求</p><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;    int n = nums.size();    int sum = 0;    for (int a : nums)        sum += a;        int diff = sum - target;    if (diff &lt; 0 || diff % 2) return 0;    int neg = diff / 2;    vector&lt;int&gt; dp(neg + 1, 0);    dp[0] = 1;    for (int i = 0; i &lt; n; i++) &#123;        for (int j = neg; j &gt;= nums[i]; j--) &#123;            dp[j] += dp[j - nums[i]];        &#125;    &#125;    return dp[neg];&#125;</code></pre><h2 id="复杂度分析-2"><a class="anchor" href="#复杂度分析-2">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times neg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 为添加  <code>-</code>  的元素之和</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(neg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>，dp 数组所需空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1049. 最后一块石头的重量II</title>
      <link href="/posts/51a8dea1/"/>
      <url>/posts/51a8dea1/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXN0LXN0b25lLXdlaWdodC1paS8=">1049. Last Stone Weight II</span></p><p>有一堆石头，用整数数组  <code>stones</code>  表示。其中  <code>stones[i]</code>  表示第 i 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为  <code>x</code>  和  <code>y</code> ，且  <code>x &lt;= y</code> 。那么粉碎的可能结果如下：</p><ul><li>如果  <code>x == y</code> ，那么两块石头都会被完全粉碎；</li><li>如果  <code>x != y</code> ，那么重量为  <code>x</code>  的石头将会完全粉碎，而重量为  <code>y</code>  的石头新重量为  <code>y-x</code> 。</li></ul><p>最后，<strong>最多只会剩下一块石头</strong> 。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回  <code>0</code>  。</p><p><strong>示例 1：</strong></p><pre><code>输入：stones = [2,7,4,1,8,1]输出：1解释：    组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，    组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，    组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，    组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：stones = [31,26,33,21,40]输出：5</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>stones.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>stones[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题要求最后剩余的石头重量尽可能小，也就相当于，尽可能将石头分成重量相同的两堆，以使得相撞之后剩下的石头最小</p><p>因此，本题类似于 <a href="https://jiankychen.github.io/posts/31559997">LeetCode 416. 分割等和子集</a> ，可按照 0-1 背包问题来求解</p><p>即，物品  <code>i</code>  的重量为  <code>stones[i]</code>  ，价值为  <code>stones[i]</code>  ，对于最大容量为  <code>target</code>  的背包，选出若干物品，使背包中的物品总价值最大，其中， <code>target</code>  是  <code>stones</code>  数组元素和的一半</p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><p>首先应计算整个数组的元素之和  <code>sum</code>  ，并进一步计算背包的最大容量，即， <code>target = sum / 2</code></p><p>然后利用动态规划算法，得到容量为  <code>target</code>  的背包所能实现的最大重量</p><ol><li><p>定义  <code>dp</code>  数组：对于容量为  <code>j</code>  的背包，其物品最大价值为  <code>dp[j]</code>  ，其中， <code>0 &lt;= j &lt; = target</code></p></li><li><p>确定递推公式：当  <code>stones[i] &lt;= j &lt;= target</code>  时， <code>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</code></p><ul><li>若  <code>j &lt; stones[i]</code>  ，即，背包放不下物品  <code>i</code>  ，此时， <code>i</code>  不可能被选取， <code>dp[j]</code>  保持不变</li><li>若  <code>stones[i] &lt;= j &lt;= target</code>  ，可以选择物品  <code>i</code> （最大价值为  <code>dp[j - stones[i]] + stones[i]</code>  ），也可以不选物品  <code>i</code>  （最大价值为  <code>dp[j]</code>  ），综合所得的最大价值为  <code>max(dp[j], dp[j - stones[i]] + stones[i])</code></li></ul></li><li><p>初始化  <code>dp</code>  数组：对任意  <code>j</code>  ，初始的  <code>dp[j]</code>  均为  <code>0</code></p></li><li><p>确定遍历顺序：</p><ul><li>外层遍历物品  <code>i</code>  ，内层遍历背包容量  <code>j</code></li><li><code>i</code>  按从小到大顺序遍历， <code>j</code>  按从大到小顺序遍历</li></ul></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>当遍历结束时， <code>dp[target]</code>  即为 最大容量为  <code>target</code>  的背包所能实现的最大重量</p><p>此时，一堆石头的重量为  <code>dp[target]</code>  ，另一堆的重量为  <code>sum - dp[target]</code></p><p>由于  <code>target = sum / 2</code>  是向下取整，即， <code>dp[target] &lt;= target &lt;= sum / 2</code>  ，故而  <code>dp[target] &lt;= sum - dp[target]</code></p><p>因此，相撞之后，剩余石头的最小重量为  <code>(sum - dp[target]) - dp[target]</code></p><p>代码实现：</p><pre><code class="language-cpp">int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        // 计算背包最大容量    int n = stones.size();    int sum = 0;    for (int a : stones) sum += a;    int target = sum / 2;        // 0-1 背包    vector&lt;int&gt; dp(target + 1, 0);    for (int i = 0; i &lt; n; i++) &#123;        for (int j = target; j &gt;= stones[i]; j--) &#123;            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);        &#125;    &#125;    return (sum - dp[target]) - dp[target];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span>  是数组元素和的一半</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 416. 分割等和子集</title>
      <link href="/posts/31559997/"/>
      <url>/posts/31559997/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tZXF1YWwtc3Vic2V0LXN1bS8=">416. Partition Equal Subset Sum</span></p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组  <code>nums</code>  。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>传统的 0-1 背包问题要求选取的物品的重量之和不超过背包的总容量，本题则要求选取的数字的和恰好等于数组元素和的一半（记作  <code>target</code>  ）</p><h2 id="思路一"><a class="anchor" href="#思路一">#</a> 思路一</h2><p>首先判断数组是否可拆分：</p><ul><li>若数组长度小于 2，不可能将将数组分成元素和相等的两个子集</li><li>若数组元素和为奇数，不可能将数组分成符合条件的两个子集</li><li>若 数组最大元素 超过  <code>target</code>  ，也不可能将数组分成符合条件的两个子集</li></ul><p>定义  <code>dp</code>  数组： <code>dp[i][j]</code>  表示 是否能从下标  <code>[0, i]</code>  的数组元素中选取若干正整数，使得被选取的元素之和等于  <code>j</code>  ，其中， <code>0 &lt;= 0 &lt;= nums.size() - 1</code>  ， <code>0 &lt;= j &lt;= target</code></p><p>确定递推公式：</p><ul><li>若  <code>j &gt;= nums[i]</code>  ，做以下考虑<ul><li>选取  <code>nums[i]</code>  ，则  <code>dp[i][j] = dp[i - 1][j - nums[i]]</code></li><li>不选取  <code>nums[i]</code>  ，则  <code>dp[i][j] = dp[i  - 1][j]</code></li><li>两种情况只要有一个为  <code>true</code>  就会有  <code>dp[i][j]</code>  为  <code>true</code>  ，因此， <code>dp[i][j] = dp[i  - 1][j] || dp[i - 1][j - nums[i]]</code></li></ul></li><li>若  <code>j &lt; nums[i]</code>  ，则  <code>nums[i]</code>  必不可能选取，因此有  <code>dp[i][j] = dp[i - 1][j]</code></li></ul><p>初始化  <code>dp</code>  数组：</p><ul><li>当  <code>i</code>  为 0 时，只有  <code>nums[0]</code>  可被选取，故而  <code>dp[0][nums[0]] = true</code>  且  <code>dp[0][0] = true</code>  （这一步要求  <code>nums[0]</code>  不大于  <code>target</code>  ，而我们此前判断了数组最大元素是否超过  <code>target</code>  ）</li><li>当  <code>j</code>  为 0 时，对任意  <code>i</code>  均有  <code>dp[i][0] = true</code>  ，即，不选取任何数</li></ul><p>代码实现：</p><pre><code class="language-cpp">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();        // 判断数组是否可拆分    if (n &lt; 2) return false;    int sum = 0;    int maxValue = 0;    for (auto a : nums) &#123;        sum += a;        maxValue = max(maxValue, a);    &#125;    if (sum % 2 == 1) return false; // sum 为奇数，不可分割    int target = sum / 2;    if (maxValue &gt; target) return false;    // 定义 dp 数组及其初始化    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(target + 1, false));    for (int i = 0; i &lt; n; i++)        dp[i][0] = true;    dp[0][nums[0]] = true;    // 遍历    for (int i = 1; i &lt; n; i++) &#123;        for (int j = 1; j &lt;= target; j++) &#123;            if (j &lt; nums[i])                dp[i][j] = dp[i - 1][j];            else                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];        &#125;    &#125;    return dp[n - 1][target];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span>  是数组元素和的一半</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>可采用一维  <code>dp</code>  数组实现，以优化算法空间复杂度</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tZXF1YWwtc3Vic2V0LXN1bS9zb2x1dGlvbi9mZW4tZ2UtZGVuZy1oZS16aS1qaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解</span></p><h2 id="思路二"><a class="anchor" href="#思路二">#</a> 思路二</h2><p>本题可以将  <code>target</code>  当成背包的最大容量，并将  <code>nums[i]</code>  同时当成物品的重量和物品的价值。当背包内物品的总价值恰好等于  <code>target</code>  时，说明可以将  <code>nums</code>  数组分割成元素和相等的两个子集</p><p>首先判断数组是否可拆分：</p><ul><li>若数组长度小于 2，不可能将将数组分成元素和相等的两个子集</li><li>若数组元素和为奇数，不可能将数组分成符合条件的两个子集</li></ul><p>定义  <code>dp</code>  数组：在  <code>[0, i]</code>  范围内选择物品，放进容量为  <code>j</code>  的背包内，其最大价值为  <code>dp[i][j]</code>  ，其中， <code>0 &lt;= 0 &lt;= nums.size() - 1</code>  ， <code>0 &lt;= j &lt;= target</code></p><p>确定递推公式：当  <code>j &gt;= nums[i]</code>  时， <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i])</code></p><ul><li>若  <code>j &gt;= nums[i]</code>  ，做以下考虑<ul><li>选取  <code>nums[i]</code>  ，此时，背包最大价值为  <code>dp[i - 1][j - nums[i]] + nums[i]</code></li><li>不选取  <code>nums[i]</code>  ，此时，背包最大价值为  <code>dp[i  - 1][j]</code></li><li>综合两种情况，应选择价值最大的，即  <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i])</code></li></ul></li><li>若  <code>j &lt; nums[i]</code>  ，则  <code>nums[i]</code>  必不可能选取，因此有  <code>dp[i][j] = dp[i - 1][j]</code></li></ul><p>初始化  <code>dp</code>  数组：</p><ul><li>当  <code>i = 0</code>  时，若  <code>j &lt; nums[0]</code>  ，背包放不下物品 0 ，则  <code>dp[0][j] = 0</code>  ，若  <code>j &gt;= nums[0]</code>  ，应选取物品 0 使得背包价值最大，即  <code>dp[0][j] = nums[0]</code></li><li>当背包容量为 0 时， <code>dp[i][0] = 0</code></li></ul><p>其代码实现类似于思路一，这里不再给出具体代码</p><p>鉴于空间复杂度较高，下面给出一维  <code>dp</code>  数组的代码实现：</p><pre><code class="language-cpp">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if (n &lt; 2) return false;    int sum = 0;    for (int i = 0; i &lt; n; i++)        sum += nums[i];    if (sum % 2) return false;    int target = sum / 2;    // 0-1 背包    vector&lt;int&gt; dp(target + 1, 0);    for (int i = 0; i &lt; n; i++)        for (int j = target; j &gt;= nums[i]; j--)            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);    return dp[target] == target ? true : false; // 判断背包最大价值是否恰好为 target&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span>  是数组元素和的一半</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0MTYuJUU1JTg4JTg2JUU1JTg5JUIyJUU3JUFEJTg5JUU1JTkyJThDJUU1JUFEJTkwJUU5JTlCJTg2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 96. 不同的二叉搜索树</title>
      <link href="/posts/1eae8d8/"/>
      <url>/posts/1eae8d8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy8=">96. Unique Binary Search Trees</span></p><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/1eae8d8/example.jpg" class=""></p><pre><code>输入：n = 3输出：5</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1输出：1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span> n <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>19</mn></mrow><annotation encoding="application/x-tex">\le 19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>定义以下两个函数：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ：长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的序列所能构成的二叉搜索树的个数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(i, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ：长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的序列所能构成的以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 为根节点的二叉搜索树的个数</li></ul><p>对于长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的序列而言，可以遍历每个数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> ：将数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 作为根节点，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1, \cdots, (i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 序列作为左子树，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">(i+1), \cdots, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span> 序列作为右子树。因此，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n) = \sum_{i = 1}^n F(i, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p>注意，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 只依赖于序列的长度，而与序列中的内容无关。因此，将数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 作为根节点时，有：</p><ul><li>利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1, \cdots, (i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 序列构造左子树，序列长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，能构造出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(i - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 棵不同的左子树（二叉搜索树）</li><li>利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">(i+1), \cdots, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span> 序列构造右子树，序列长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> ，能构造出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 棵不同的右子树（二叉搜索树）</li></ul><p>左子树与右子树的构造是相互独立的，因此，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 为根节点的二叉搜索树个数，应为 可构造的左子树个数 与 可构造的右子树个数 之积，即，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>G</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(i, n) = G(i - 1) \times G(n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span></p><p>因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的递推公式为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>G</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n) = \sum_{i = 1}^n G(i - 1) \times G(n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span></p><p>当序列长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，只能构造出一棵树，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G(0) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy9zb2x1dGlvbi9idS10b25nLWRlLWVyLWNoYS1zb3Utc3VvLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwOTYuJUU0JUI4JThEJUU1JTkwJThDJUU3JTlBJTg0JUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>代码实现：</p><pre><code class="language-cpp">int numTrees(int n) &#123;    vector&lt;int&gt; dp(n + 1, 0);    dp[0] = 1;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= i; j++) &#123;            dp[i] += dp[j - 1] * dp[i - j];        &#125;    &#125;    return dp[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 343. 整数拆分</title>
      <link href="/posts/f552429c/"/>
      <url>/posts/f552429c/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlZ2VyLWJyZWFrLw==">343. Integer Break</span></p><p>给定一个正整数  <code>n</code>  ，将其拆分为  <code>k</code>  个 正整数 的和（  <code>k &gt;= 2</code>  ），并使这些整数的乘积最大化。</p><p>返回 可以获得的最大乘积 。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：1解释：2 = 1 + 1, 1 × 1 = 1.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 10输出：36解释：10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>58</mn></mrow><annotation encoding="application/x-tex">\le 58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><ol><li><p>确定  <code>dp</code>  数组及其含义： <code>dp[i]</code>  表示将正整数  <code>i</code>  拆分后所能得到的最大乘积</p></li><li><p>确定递推公式：</p><ul><li>假设拆分  <code>i</code> （  <code>i &gt;= 2</code>  ）所得的第一个数为  <code>j</code> （  <code>1 &lt;= j &lt; i</code>  ），还剩  <code>i - j</code>  ，做以下考虑<ul><li>不再拆分  <code>i - j</code>  ，此时的乘积为  <code>j * (i - j)</code></li><li>继续将  <code>i - j</code>  拆成多个整数的和，此时的最大乘积为  <code>j * dp[i - j]</code></li><li>因此，对给定的  <code>j</code>  ，最大乘积为  <code>max(j * (i - j), j * dp[i - j])</code></li></ul></li><li>由于  <code>j</code>  可取  <code>[1, i - 1]</code>  区间内任意值，应遍历  <code>j</code>  才能得到  <code>dp[i]</code>  ，即， <code>dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</code></li></ul></li><li><p>初始化  <code>dp</code>  数组：可拆分的最小正整数为 2，而拆分 2 所得的最大乘积为 1 ，故而应初始化  <code>dp[2] = 1</code></p></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code>  依赖于  <code>dp[i - j]</code>  ，故而应按  <code>i</code>  从小到大的顺序遍历；至于  <code>j</code>  ，按从小到大顺序或从大到小顺序遍历均可</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int integerBreak(int n) &#123;    vector&lt;int&gt; dp(n + 1, 0);    dp[2] = 1;    for (int i = 3; i &lt;= n; i++) &#123;        for (int j = 1; j &lt; i; j++) &#123;            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));        &#125;    &#125;    return dp[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzNDMuJUU2JTk1JUI0JUU2JTk1JUIwJUU2JThCJTg2JUU1JTg4JTg2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 63. 不同路径 II</title>
      <link href="/posts/8b9f7566/"/>
      <url>/posts/8b9f7566/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMtaWkv">63. Unique Paths II</span></p><p>一个机器人位于一个  <code>m x n</code>  网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用  <code>1</code>  和  <code>0</code>  来表示。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/8b9f7566/example1.jpg" class=""></p><pre><code>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：  1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下  2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/8b9f7566/example2.jpg" class=""></p><pre><code>输入：obstacleGrid = [[0,1],[0,0]]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code> ,  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>obstacleGrid[i][j]</code>  为  <code>0</code>  或  <code>1</code></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><ol><li><p>确定  <code>dp</code>  数组及其含义： <code>dp[i][j]</code>  表示从  <code>(0, 0)</code>  到达  <code>(i, j)</code>  位置的路径条数，其中， <code>0 &lt;= i &lt;= m - 1</code>  ， <code>0 &lt;= j &lt;= n - 1</code></p></li><li><p>确定递推公式</p><ul><li>对任意  <code>(i, j)</code>  ，若  <code>(i, j)</code>  有障碍物，则无法到达  <code>(i, j)</code>  ，即， <code>dp[i][j] = 0</code></li><li>否则， <code>(i, j)</code>  可由  <code>(i - 1, j)</code>  向下移动到达，也可由  <code>(i, j - 1)</code>  向右移动到达，即， <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></li></ul></li><li><p>初始化  <code>dp</code>  数组：</p><ul><li>到达  <code>(i, 0)</code>  的路径只有一条，即  <code>dp[i][0]  = 1</code>  ，但如果某个  <code>(i0, 0)</code>  存在障碍物，则对任意  <code>i &gt;= i0</code>  均有  <code>dp[i][0] = 0</code></li><li>到达  <code>(0, j)</code>  的路径只有一条，即  <code>dp[0][j]  = 1</code>  ，但如果某个  <code>(0, j0)</code>  存在障碍物，则对任意  <code>j &gt;= j0</code>  均有  <code>dp[0][j] = 0</code></li></ul><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) // 遇到障碍物则停止赋 1    dp[i][0] = 1;for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) // 遇到障碍物则停止赋 1    dp[0][j] = 1;</code></pre></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i][j]</code>  依赖于  <code>dp[i - 1][j]</code>  和  <code>dp[i][j - 1]</code>  ，因此，应按  <code>i</code>  从小到大、 <code>j</code>  从小到大顺序遍历</p></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;    int m = obstacleGrid.size();    int n = obstacleGrid[0].size();    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));    for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) // 注意这里要从 i = 0 开始，因为 (0, 0) 可能有障碍物        dp[i][0] = 1;    for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) // 注意这里要从 j = 0 开始，因为 (0, 0) 可能有障碍物        dp[0][j] = 1;    for (int i = 1; i &lt; m; i++) &#123;        for (int j = 1; j &lt; n; j++) &#123;            if (obstacleGrid[i][j] == 1) continue; // (i,j) 处有障碍物，无法到达            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        &#125;    &#125;    return dp[m - 1][n - 1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNjMuJUU0JUI4JThEJUU1JTkwJThDJUU4JUI3JUFGJUU1JUJFJTg0SUkuaHRtbCMlRTYlODAlOUQlRTglQjclQUY=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 62. 不同路径</title>
      <link href="/posts/4134dbbf/"/>
      <url>/posts/4134dbbf/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMv">62. Unique Paths</span></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/4134dbbf/example.png" class=""></p><pre><code>输入：m = 3, n = 7输出：28</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。  1. 向右 -&gt; 向下 -&gt; 向下  2. 向下 -&gt; 向下 -&gt; 向右  3. 向下 -&gt; 向右 -&gt; 向下</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：m = 3, n = 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code> ,  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li>题目数据保证答案小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><ol><li><p>确定  <code>dp</code>  数组及其含义： <code>dp[i][j]</code>  表示从  <code>(0, 0)</code>  到达  <code>(i, j)</code>  位置的路径条数，其中， <code>0 &lt;= i &lt;= m - 1</code>  ， <code>0 &lt;= j &lt;= n - 1</code></p></li><li><p>确定递推公式</p><ul><li><code>(0, j)</code>  只能由  <code>(0, j - 1)</code>  向右移动一步到达，故而  <code>dp[0][j] = 1</code></li><li><code>(i, 0)</code>  只能由  <code>(i - 1, 0)</code>  向下移动一步到达，故而  <code>dp[i][0] = 1</code></li><li>对任意  <code>i &gt; 0</code>  且  <code>j &gt; 0</code>  ， <code>(i, j)</code>  可由  <code>(i - 1, j)</code>  向下移动到达，也可由  <code>(i, j - 1)</code>  向右移动到达，故而  <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></li></ul></li><li><p>初始化  <code>dp</code>  数组： <code>dp[0][j] = 1</code>  ， <code>dp[i][0] = 1</code></p></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i][j]</code>  依赖于  <code>dp[i - 1][j]</code>  和  <code>dp[i][j - 1]</code>  ，因此，应按  <code>i</code>  从小到大、 <code>j</code>  从小到大顺序遍历</p></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int uniquePaths(int m, int n) &#123;    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); // 从 (0, 0) 到 (i, j) 的路径条数    for (int i = 0; i &lt; m; i++) dp[i][0] = 1;    for (int j = 1; j &lt; n; j++) dp[0][j] = 1;    for (int i = 1; i &lt; m; i++) &#123;        for (int j = 1; j &lt; n; j++) &#123;            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        &#125;    &#125;    return dp[m - 1][n - 1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 746. 使用最小花费爬楼梯</title>
      <link href="/posts/86b082df/"/>
      <url>/posts/86b082df/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tY29zdC1jbGltYmluZy1zdGFpcnMv">LeetCode 746. Min Cost Climbing Stairs</span></p><p>给你一个整数数组  <code>cost</code>  ，其中  <code>cost[i]</code>  是从楼梯第  <code>i</code>  个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为  <code>0</code>  或下标为  <code>1</code>  的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><pre><code>输入：cost = [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。      - 支付 15 ，向上爬两个台阶，到达楼梯顶部。      总花费为 15 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：cost = [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。      - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。      - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。      - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。      - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。      - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。      - 支付 1 ，向上爬一个台阶，到达楼梯顶部。      总花费为 6 。</code></pre><p><strong>提示：</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>cost.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>cost[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>999</mn></mrow><annotation encoding="application/x-tex">\le 999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span></p><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>注意，楼梯顶部对应的是第  <code>cost.size()</code>  个台阶</p><p>算法思路：</p><ol><li><p>确定  <code>dp</code>  数组及其含义： <code>vector&lt;int&gt; dp(cost.size() + 1, 0)</code> ，其中， <code>dp[i]</code>  表示到达第  <code>i</code>  个台阶的最低费用</p></li><li><p>确定递推公式： <code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></p><ul><li>可以从第  <code>i - 1</code>  阶爬 1 个台阶到达第  <code>i</code>  阶，费用为  <code>dp[i - 1] + cost[i - 1]</code></li><li>也可以从第  <code>i - 2</code>  阶爬 2 个台阶到达第  <code>i</code>  阶，费用为  <code>dp[i - 2] + cost[i - 2]</code></li><li>综合两种情况，从中选择费用最低的，即， <code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></li></ul></li><li><p>初始化  <code>dp</code>  数组： <code>dp[0] = 0</code>  ， <code>dp[1] = 0</code></p><ul><li>第 0 个台阶和第 1 个台阶可以作为起点，因此，到达第 0 个台阶和第 1 个台阶的费用均为 0 ，即  <code>dp[0] = dp[1] = 0</code></li></ul></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code>  依赖于  <code>dp[i - 1]</code>  和  <code>dp[i - 2]</code>  ，因此，应按  <code>i</code>  从小到大遍历</p></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>最后， <code>dp[cost.size()]</code>  就是到达楼梯顶部的最低费用</p><p>代码实现：</p><pre><code class="language-cpp">int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;    int n = cost.size();    vector&lt;int&gt; dp(n + 1, 0); // dp[i] 表示到达下标 i 的最低费用    for (int i = 2; i &lt;= n; i++) &#123;        dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);    &#125;    return dp[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 70. 爬楼梯</title>
      <link href="/posts/bb39abea/"/>
      <url>/posts/bb39abea/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMv">LeetCode 70. Climbing Stairs</span></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：2解释：有两种方法可以爬到楼顶。      1. 1 阶 + 1 阶      2. 2 阶</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 3输出：3解释：有三种方法可以爬到楼顶。      1. 1 阶 + 1 阶 + 1 阶      2. 1 阶 + 2 阶      3. 2 阶 + 1 阶</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>45</mn></mrow><annotation encoding="application/x-tex">\le 45</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">5</span></span></span></span></li></ul><h1 id="method-1-动态规划"><a class="anchor" href="#method-1-动态规划">#</a> Method 1: 动态规划</h1><p>算法思路：</p><ol><li><p>确定  <code>dp</code>  数组及其含义： <code>dp[i]</code>  表示爬到第  <code>i</code>  阶的方案数</p></li><li><p>确定递推公式：当  <code>i &gt;= 2</code>  时， <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p><ul><li>可以从第  <code>i - 1</code>  阶爬 1 个台阶，到达第  <code>i</code>  阶，方案数为  <code>dp[i - 1]</code></li><li>也可以从第  <code>i - 2</code>  阶爬 2 个台阶，到达第  <code>i</code>  阶，方案数为  <code>dp[i - 2]</code></li></ul></li><li><p>初始化  <code>dp</code>  数组： <code>dp[1] = 1</code>  ， <code>dp[2] = 2</code></p><ul><li>爬到第 1 阶只有一种方案，因此， <code>dp[1] = 1</code></li><li>爬到第 2 阶有两种方案，因此， <code>dp[2] = 2</code></li></ul></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code>  依赖于  <code>dp[i - 1]</code>  和  <code>dp[i - 2]</code>  ，因此，应按  <code>i</code>  从小到大遍历</p></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><blockquote><p>这里不考虑  <code>dp[0]</code>  的初始化，因为  <code>dp[0]</code>  并不具有实际含义</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int climbStairs(int n) &#123;    if (n &lt;= 1) return n;    vector&lt;int&gt; dp(n + 1, 0);    dp[1] = 1;    dp[2] = 2;    for (int i = 3; i &lt;= n; i++)        dp[i] = dp[i - 1] + dp[i - 2];    return dp[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>类似地，也可以利用滚动数组法来优化空间复杂度</p></blockquote><h1 id="method-2-完全背包"><a class="anchor" href="#method-2-完全背包">#</a> Method 2: 完全背包</h1><p>算法思路：</p><p>每一步爬一个台阶，或者，每一步爬两个台阶，可以视为背包问题中的物品；楼梯的台阶数，可以视为背包问题中的背包容量</p><p>因此，问题可改写为：从  <code>nums = &#123;1, 2&#125;</code>  中选取若干个元素（每个元素可以重复选择），使得元素之和为  <code>n</code>  ，一共有多少种方案？</p><p>即，问题是一个完全背包问题，并且，所要求的是选取元素的 <strong>排列</strong> 数</p><p>采用动态规划方法求解，其中，外层 for 循环遍历元素之和（背包容量），内层 for 循环遍历元素（物品），并且均按照从小到大的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int climbStairs(int n) &#123;    vector&lt;int&gt; nums = &#123;1, 2&#125;;    vector&lt;int&gt; dp(n + 1, 0);    dp[0] = 1;    for (int j = 1; j &lt;= n; j++) &#123;        for (int num : nums) &#123;            if (j &gt;= num)                dp[j] += dp[j - num];        &#125;    &#125;    return dp[n];&#125;</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNzAuJUU3JTg4JUFDJUU2JUE1JUJDJUU2JUEyJUFGJUU1JUFFJThDJUU1JTg1JUE4JUU4JTgzJThDJUU1JThDJTg1JUU3JTg5JTg4JUU2JTlDJUFDLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 509. 斐波那契数</title>
      <link href="/posts/b2ace7fe/"/>
      <url>/posts/b2ace7fe/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maWJvbmFjY2ktbnVtYmVyLw==">LeetCode 509. Fibonacci Number</span></p><p><strong>斐波那契数</strong>（通常用  <code>F(n)</code>  表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre><code>F(0) = 0, F(1) = 1F(n) = F(n - 1) + F(n - 2), for n &gt; 1.</code></pre><p>给定  <code>n</code>  ，请计算  <code>F(n)</code>  。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：n = 4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h1><p>算法思路：</p><ol><li><p>确定  <code>dp</code>  数组及其含义： <code>dp[i]</code>  表示第  <code>i</code>  个斐波那契数，即， <code>F(i)</code></p></li><li><p>确定递推公式：当  <code>i &gt;= 2</code>  时， <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p></li><li><p>初始化  <code>dp</code>  数组： <code>dp[0] = 0</code>  ， <code>dp[1] = 1</code></p></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code>  依赖于  <code>dp[i - 1]</code>  和  <code>dp[i - 2]</code>  ，因此，应按  <code>i</code>  从小到大遍历</p></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>最后的  <code>dp[n]</code>  就是所求的斐波那契数</p><p>代码实现：</p><pre><code class="language-cpp">int fib(int n) &#123;    if (n == 0) return 0;    if (n == 1) return 1;    vector&lt;int&gt; dp(n + 1, 0);    dp[1] = 1;    for (int i = 2; i &lt;= n; i++) &#123;        dp[i] = dp[i - 2] + dp[i - 1];    &#125;    return dp[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>由于  <code>dp[i]</code>  仅依赖于  <code>dp[i - 1]</code>  和  <code>dp[i - 2]</code>  ，也可以只维护  <code>dp[0]</code>  和  <code>dp[1]</code>  ，而不需要记录整个  <code>dp</code>  数组</p><ul><li>当  <code>i</code>  是奇数时，斐波那契数  <code>F(i)</code>  存放在  <code>dp[1]</code>  中</li><li>当  <code>i</code>  是偶数时，斐波那契数  <code>F(i)</code>  存放在  <code>dp[0]</code>  中</li></ul><p>最后的  <code>dp[n &amp; 1]</code>  就是所求的斐波那契数</p><p>代码实现：</p><pre><code class="language-cpp">int fib(int n) &#123;    if (n &lt;= 1) return n;    vector&lt;int&gt; dp = &#123;0, 1&#125;;    for (int i = 2; i &lt;= n; i++) &#123;        dp[i &amp; 1] = dp[(i - 2) &amp; 1] + dp[(i - 1) &amp; 1];    &#125;    return dp[n &amp; 1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 714. 买卖股票的最佳时机含手续费</title>
      <link href="/posts/7ede3731/"/>
      <url>/posts/7ede3731/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtdHJhbnNhY3Rpb24tZmVlLw==">714. Best Time to Buy and Sell Stock with Transaction Fee</span></p><p>给定一个整数数组  <code>prices</code>  ，其中  <code>prices[i]</code>  表示第  <code>i</code>  天的股票价格 ；整数  <code>fee</code>  代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意</strong>：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [1,3,2,8,4,9], fee = 2输出：8解释：能够达到的最大利润:      在此处买入 prices[0] = 1    在此处卖出 prices[3] = 8    在此处买入 prices[4] = 4    在此处卖出 prices[5] = 9    总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1,3,7,5,10,3], fee = 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">&lt; 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>fee</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">&lt; 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-1-贪心"><a class="anchor" href="#method-1-贪心">#</a> Method 1: 贪心</h1><p>算法思路：</p><p>定义  <code>buy</code>  表示当前所持股票的最低成本（买入价与手续费之和），初始化为  <code>prices[0] + fee</code>  。定义  <code>result</code>  表示总利润，初始化为 0</p><p>遍历  <code>prices</code>  数组（以  <code>i</code>  为下标索引）：</p><ul><li>情况一：如果当前股票价格  <code>price[i]</code>  与  <code>fee</code>  之和小于  <code>buy</code> ，说明我们能够以更低的成本买入当前股票，更新  <code>buy</code>  为  <code>prices[i] + fee</code>  （相当于 撤销之前的买入、以当前价格买入）</li><li>情况二：如果当前股票价格  <code>prices[i]</code>  大于  <code>buy</code>  ，可以考虑卖出当前股票并收获  <code>prices[i] - buy</code>  的利润<ul><li>之后的股票价格可能会持续上升，此时，应继续持有当前股票，以继续获取后续利润</li><li>之后的股票价格也可能先降后升，此时，应卖出当前股票，之后再重新买入</li><li>为综合处理以上两种情况，我们可以直接计算当前的利润，即  <code>result += prices[i] - buy</code>  ，并将  <code>buy</code>  更新为  <code>prices[i]</code>  。如果之后的股票价格持续上升，则可以继续按  <code>result += prices[i] - buy</code>  更新利润（视为继续持有股票）；如果之后的股票价格先降后升，则可以在  <code>prices[i] + fee &lt; buy</code>  条件下，将  <code>buy</code>  更新为  <code>prices[i] + fee</code>  （视为当前股票已经卖出，并在股票下降过程中重新买入股票，对应于情况一）</li></ul></li><li>情况三：股票价格  <code>prices[i]</code>  介于  <code>buy - fee</code>  与  <code>buy</code>  之间，不予操作（因为此时买入不便宜，卖出则会亏本）</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;    int result = 0;    int buy = prices[0] + fee;    for (int i = 1; i &lt; prices.size(); i++) &#123;        if (prices[i] + fee &lt; buy)     // 能够以更低的价格买入            buy = prices[i] + fee;     // 更新 买入价与手续费之和        else if (prices[i] &gt; buy) &#123;    // 当前价格 高于 买入价与手续费之和            result += prices[i] - buy; // 计算利润            buy = prices[i];           // 以当前价格重新买入股票（免手续费），因为可能出现更高价格        &#125;    &#125;    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtdHJhbnNhY3Rpb24tZmVlL3NvbHV0aW9uL21haS1tYWktZ3UtcGlhby1kZS16dWktamlhLXNoaS1qaS1oYW4tc2gtcnpsei8=">力扣官方题解</span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：与 <a href="https://jiankychen.github.io/posts/1cc8aec1">LeetCode 122. 买卖股票的最佳时机 II</a> 基本相同，只需在买入股票（或者，卖出股票）时扣除手续费</p><p>这里考虑在卖出股票时扣除手续费</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;    int n = prices.size();    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));    dp[0][0] = 0;           // 第 0 天不持有股票    dp[0][1] = - prices[0]; // 第 0 天持有股票    for (int i = 1; i &lt; n; i++) &#123;        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee); // 第 i 天不持有股票        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);       // 第 i 天持有股票    &#125;    return dp[n - 1][0];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 738. 单调递增的数字</title>
      <link href="/posts/6f2fbbf2/"/>
      <url>/posts/6f2fbbf2/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb25vdG9uZS1pbmNyZWFzaW5nLWRpZ2l0cy8=">738. Monotone Increasing Digits</span></p><p>当且仅当每个相邻位数上的数字  <code>x</code>  和  <code>y</code>  满足  <code>x &lt;= y</code>  时，我们称这个整数是单调递增的。</p><p>给定一个整数  <code>n</code>  ，返回 小于或等于  <code>n</code>  的最大数字，且数字呈 <strong>单调递增</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 10输出：9</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1234输出：1234</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：n = 332输出：299</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-贪心"><a class="anchor" href="#method-贪心">#</a> Method: 贪心</h1><p>算法思路：</p><p>首先应将  <code>n</code>  转换为字符串类型的对象  <code>strNum</code>  ，如果出现  <code>strNum[i - 1] &gt; strNum[i]</code>  的情况，说明  <code>strNum</code>  并不是单调递增</p><p>此时，可将  <code>strNum[i - 1]</code>  自减 1 ，并考虑将  <code>strNum[i]</code>  置为 9 ，即确保第  <code>i - 1</code>  位和第  <code>i</code>  位组成最大的、单调递增的整数（贪心策略中的局部最优）</p><p>按上述操作处理  <code>strNum[i - 1]</code>  和  <code>strNum[i]</code>  时，还需做以下考虑：</p><ul><li>将  <code>strNum[i - 1]</code>  减 1 后，可能导致  <code>strNum[i - 2] &gt; strNum[i - 1]</code>  ，即，需对  <code>strNum[i - 2]</code>  进行判断和处理。因此，应按照从右往左的顺序遍历  <code>i</code></li><li>将  <code>strNum[i]</code>  置为 9 后，也应将第  <code>i + 1</code>  位、第  <code>i + 2</code>  位、 <code>...</code>  、第  <code>strNum.size() - 1</code>  位也全都置为 9 ，以得到最大的、单调递增的整数。因此，需找到满足  <code>strNum[i - 1] &gt; strNum[i]</code>  的最小的  <code>i</code> （不妨将其记作  <code>start</code>  ），将  <code>start</code>  及其以后所有位上的数字均置为 9</li></ul><p>代码实现：</p><pre><code class="language-cpp">int monotoneIncreasingDigits(int n) &#123;    string strNum = to_string(n);        // 将 n 转换为字符串    int start = strNum.size();           // 赋数字 9 的起点    for (int i = strNum.size() - 1; i &gt; 0; i--) &#123; // 从右往左遍历        if (strNum[i - 1] &gt; strNum[i]) &#123; // 高位数大于低位数，高位数应减 1，并更新赋 9 的起点            strNum[i - 1]--;            start = i;        &#125;    &#125;    for (int i = start; i &lt; strNum.size(); i++) &#123; // start 及其以后位置都需赋 9        strNum[i] = '9';    &#125;    int ans = stoi(strNum);    return ans;&#125;</code></pre><p>注意：需先找到  <code>start</code>  ，然后再将  <code>start</code>  及其以后所有位上的数字均置为 9 。不能一边判断  <code>if(strNum[i - 1] &gt; strNum[i])</code>  条件是否成立、一边处理  <code>strNum[i]</code></p><ul><li>尤其是，不能将  <code>strNum[i] = '9'</code>  放在  <code>if(strNum[i - 1] &gt; strNum[i])</code>  的语句块内执行</li><li>因为其并不一定会将  <code>start</code>  及其以后的每一位均置为 9 ，以  <code>n = 6352</code>  为例，若将  <code>strNum[i] = '9'</code>  放在  <code>if(strNum[i - 1] &gt; strNum[i])</code>  的语句块内执行，得到的最终结果将会是 5949 ，而不是 5999</li></ul><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是数字  <code>n</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，考虑了存储数字  <code>n</code>  的字符串</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MzguJUU1JThEJTk1JUU4JUIwJTgzJUU5JTgwJTkyJUU1JUEyJTlFJUU3JTlBJTg0JUU2JTk1JUIwJUU1JUFEJTk3Lmh0bWwjJUU4JUI0JUFBJUU1JUJGJTgzJUU3JUFFJTk3JUU2JUIzJTk1">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 56. 合并区间</title>
      <link href="/posts/2f540b31/"/>
      <url>/posts/2f540b31/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMv">56. Merge Intervals</span></p><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals [i] = [<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>start</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textrm{start}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord textrm">start</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>end</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textrm{end}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord textrm">end</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p>示例 1：</p><pre><code>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]</code></pre><p>示例 2：</p><pre><code>输入：intervals = [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>intervals.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>intervals[i].length == 2</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>starti</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>endi</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-排序-贪心"><a class="anchor" href="#method-排序-贪心">#</a> Method: 排序 + 贪心</h1><p>算法思路</p><ol><li><p>按第一维度（区间的左边界）排序</p></li><li><p>合并区间：每遇到两个重叠区间时，取两区间中的最小的左边界作为新区间的左边界，取两区间中的最大的右边界作为新区间的右边界</p><ul><li>由于  <code>intervals</code>  按区间左边界升序排列，前一个区间的左边界就是合并所得区间的左边界</li><li>注意，合并后的区间可能会跟后续区间重叠，此时，需要继续合并</li></ul></li></ol><p>为解决区间的连续合并问题，可以采用以下方案：</p><ul><li>首先将第一个区间（即， <code>intervals[0]</code>  ）加入到结果数组  <code>result</code></li><li>考虑第二个区间，看其是否与结果数组中的区间（即，区间  <code>result.back()</code>  ）重叠（即，判断  <code>intervals[1][0]</code>  是否小于  <code>result.back()[1]</code>  ）<ul><li>若重叠，修改结果数组中的区间的右边界，即，将  <code>result.back()[1]</code>  修改为  <code>max(result.back()[1], intervals[1][1])</code></li><li>若不重叠，将第二个区间加入到结果数组，即， <code>result.push_back(intervals[1])</code></li></ul></li><li>继续考虑下一区间，看其是否与区间  <code>result.back()</code>  重叠，处理方式与上一步相同</li></ul><p>代码实现：</p><pre><code class="language-cpp">static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;    return a[0] &lt; b[0];&#125;vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;    sort(intervals.begin(), intervals.end(), cmp); // 按第一维度升序排序    vector&lt;vector&lt;int&gt;&gt; result;                    // 结果数组    result.push_back(intervals[0]);                // 将第一个区间加入到结果数组    for (int i = 1; i &lt; intervals.size(); i++) &#123;        if (intervals[i][0] &lt;= result.back()[1])   // 区间重叠，合并两区间            result.back()[1] = max(result.back()[1], intervals[i][1]);        else                                       // 区间不重叠，将其加入到结果数组            result.push_back(intervals[i]);    &#125;    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是区间的个数</p><ul><li>排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，遍历  <code>intervals</code>  的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，排序所需空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNTYuJUU1JTkwJTg4JUU1JUI5JUI2JUU1JThDJUJBJUU5JTk3JUI0Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 763. 划分字母区间</title>
      <link href="/posts/c4b10462/"/>
      <url>/posts/c4b10462/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tbGFiZWxzLw==">763. Partition Labels</span></p><p>给你一个字符串  <code>s</code>  。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是  <code>s</code>  。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释：    划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。    每个字母最多出现在一个片段中。    像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;eccbbbbdec&quot;输出：[10]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>s</code>  仅由小写英文字母组成</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>同一个字母只能出现在同一个片段，因此，需要遍历字符串，得到每个字母最后一次出现的位置</p><p>寻找每个片段可能的最小结束位置，以将字符串划分为尽可能多的片段（贪心策略）</p><h1 id="method-贪心"><a class="anchor" href="#method-贪心">#</a> Method: 贪心</h1><p>算法思路：</p><ol><li><p>利用数组  <code>hash</code>  中的元素  <code>hash[s[i] - 'a']</code>  来记录字母  <code>s[i]</code>  最后一次出现的位置</p></li><li><p>从左到右遍历字符串，在遍历的同时，维护当前片段的长度  <code>count</code>  以及当前片段的边界  <code>boundary</code>  ，初始时  <code>count = 0</code>  、 <code>boundary = 0</code></p><ul><li>对于每个字母  <code>s[i]</code>  ，其最后一次出现的位置一定在当前片段的边界以内，故而，应按照  <code>boundary = max(boundary, hash[s[i] - 'a'])</code>  更新片段的边界。此外，片段长度应加 1，即， <code>count = count + 1</code></li><li>当遍历到边界  <code>boundary</code> （即， <code>i == boundary</code>  ）时，片段涵盖的字母也仅出现在当前的  <code>boundary</code>  以左，即，当前片段结束。然后重置  <code>count</code>  ，继续确定下一片段</li></ul></li></ol><p height="200px"><img data-src="/posts/c4b10462/example.png" class=""></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; partitionLabels(string s) &#123;    vector&lt;int&gt; hash(26, 0);    for (int i = 0; i &lt; s.size(); i++) // 统计每一个字符最后出现的位置        hash[s[i] - 'a'] = i;    vector&lt;int&gt; result; // 目标数组    int count = 0;      // 当前片段的长度    int boundary = 0;   // 当前片段的边界    for (int i = 0; i &lt; s.size(); i++) &#123;        boundary = max(boundary, hash[s[i] - 'a']); // 更新边界        count++;        // 更新片段长度        if (i == boundary) &#123;         // 当前片段结束            result.push_back(count); // 将片段长度添加到目标数组            count = 0;  // 重置，以统计下一个片段的长度        &#125;    &#125;    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，本题使用的哈希数组是固定大小的（不考虑存储答案的数组）</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tbGFiZWxzL3NvbHV0aW9uL2h1YS1mZW4temktbXUtcXUtamlhbi1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3NjMuJUU1JTg4JTkyJUU1JTg4JTg2JUU1JUFEJTk3JUU2JUFGJThEJUU1JThDJUJBJUU5JTk3JUI0Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 435. 无重叠区间</title>
      <link href="/posts/6f5fa844/"/>
      <url>/posts/6f5fa844/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ub24tb3ZlcmxhcHBpbmctaW50ZXJ2YWxzLw==">435. Non-overlapping Intervals</span></p><p>给定一个区间的集合  <code>intervals</code>  ，其中  <code>intervals[i] = [starti, endi]</code>  。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><p><strong>示例 1：</strong></p><pre><code>输入：intervals = [[1,2],[2,3],[3,4],[1,3]]输出：1解释：移除 [1,3] 后，剩下的区间没有重叠</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：intervals = [[1,2],[1,2],[1,2]]输出：2解释：你需要移除两个 [1,2] 来使剩下的区间没有重叠</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：intervals = [[1,2],[2,3]]输出：0解释：你不需要移除任何区间，因为它们已经是无重叠的了</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>intervals.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>intervals[i].length == 2</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-5 \times 10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>starti</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span>  <code>endi</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-排序-贪心"><a class="anchor" href="#method-排序-贪心">#</a> Method: 排序 + 贪心</h1><p>算法思路：</p><ul><li><p>可以按照右边界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>n</mi><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">end_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行排序，然后从左往右遍历数组、记录非重叠区间的个数，最后用总区间数减去非重叠区间数，即为所需移除的区间数</p></li><li><p>其中，记录非重叠区间个数时，应尽量保留右边界较小的区间  <code>intervals[i]</code>  ，从而避免重叠。这是因为，前一个区间的右边界越小，留给下一个区间的空间就越大，从而保留更多的区间（即，移除更少的区间）</p></li></ul><p>如下图所示（已按右边界升序排列），每次都是取最左侧的右边界作为分割点，来选取非重叠区间。首先，以区间 1 的右边界为分割点（保留区间 1）时，区间 2 和 3 均与 1 重叠（故而移除区间 2 和 3），找到的第一个不重叠区间是区间 4（故而保留区间 4），接着以区间 4 的右边界作为新的分割点，以此往复。最终，保留的区间为 1、4、6，非重叠区间的个数是 3，需移除的区间数为 6 - 3 = 3</p><p height="200px"><img data-src="/posts/6f5fa844/example.png" class=""></p><p>代码实现：</p><pre><code class="language-cpp">static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;    return a[1] &lt; b[1];&#125;int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;    sort(intervals.begin(), intervals.end(), cmp); // 按右边界升序排列    int count = 1;                         // 非重叠区间的个数    int position = intervals[0][1];        // 分割点（非重叠区间的右边界）    for (int i = 1; i &lt; intervals.size(); i++) &#123;        if (intervals[i][0] &gt;= position) &#123; // 遇到非重叠区间            count++;            position = intervals[i][1];    // 更新分割点        &#125;    &#125;    int ans = intervals.size() - count;    // 需移除的区间个数    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><ul><li>排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>遍历数组的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n} + n) = O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，排序所需空间（平均情况下）</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0MzUuJUU2JTk3JUEwJUU5JTg3JThEJUU1JThGJUEwJUU1JThDJUJBJUU5JTk3JUI0Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 452. 用最少数量的箭引爆气球</title>
      <link href="/posts/74cc4150/"/>
      <url>/posts/74cc4150/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW51bWJlci1vZi1hcnJvd3MtdG8tYnVyc3QtYmFsbG9vbnMv">452. Minimum Number of Arrows to Burst Balloons</span></p><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组  <code>points</code>  ，其中  <code>points[i] = [xstart, xend]</code>  表示水平直径在  <code>xstart</code>  和  <code>xend</code>  之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为  <code>xstart</code> ， <code>xend</code> ，且满足  <code>xstart ≤ x ≤ xend</code>  ，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组  <code>points</code>  ，返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数 。</p><p><strong>示例 1：</strong></p><pre><code>输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：气球可以用 2 支箭来爆破:    在 x = 6 处射出箭，击破气球 [2,8] 和 [1,6] 。    在 x = 11 处发射箭，击破气球 [10,16] 和 [7,12] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4解释：每个气球需要射出一支箭，总共需要 4 支箭。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2解释：气球可以用 2 支箭来爆破:    在 x = 2 处发射箭，击破气球 [1,2] 和 [2,3] 。    在 x = 4 处射出箭，击破气球 [3,4] 和 [4,5] 。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>points.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>points[i].length == 2</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>xstart</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span>  <code>xend</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>每支箭应尽量多引爆气球，以使得所需箭的数量最小（贪心策略）</p><p height="200px"><img data-src="/posts/74cc4150/example.png" class=""></p><p>由图可知，应选择「最左侧的右边界」作为箭的发射点（如上图中的 1-3 所示），以尽可能多地引爆气球</p><blockquote><p>也可以选择「最右侧的左边界」作为箭的发射点</p></blockquote><h1 id="method-排序-贪心"><a class="anchor" href="#method-排序-贪心">#</a> Method: 排序 + 贪心</h1><p>算法思路：</p><ol><li><p>先对数组  <code>points</code>  排序：按照第二个维度（气球的右边界位置）从小到大进行排序</p></li><li><p>遍历数组  <code>points</code>  ，确定箭的发射点，并计算箭的数量</p><ul><li><p>最初时， <code>points[0]</code>  的右边界（即， <code>points[0][1]</code>  ）就是第一支箭的发射点，并且，气球左边界在发射点左侧（即，满足  <code>points[i][0] &lt;= points[0][1]</code>  条件）的所有气球  <code>i</code>  均会被这一箭引爆（因为发射点在气球  <code>i</code>  的左右边界以内）</p></li><li><p>若出现  <code>points[j][0] &gt; points[0][1]</code>  ，即，气球  <code>j</code>  的左边界在发射点右侧，气球  <code>j</code>  不会被引爆，故而需要下一支箭。下一支箭的发射点就是  <code>points[j][1]</code>  ，因为  <code>points[j][1]</code>  就是剩余气球中的右边界最小值，即，「最左侧的右边界」</p></li><li><p>依此类推</p></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt; &amp; b) &#123;    return a[1] &lt; b[1];&#125;int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;    sort(points.begin(), points.end(), cmp); // 按 xend 升序排列    int ans = 1;   // 至少需要 1 支箭    int position = points[0][1];    // 第一支箭的发射点    for (const vector&lt;int&gt;&amp; ballon : points) &#123;        if (ballon[0] &gt; position) &#123; // 无法引爆 ballon            ans++; // 需要多加 1 支箭            position = ballon[1];   // 下一支箭的发射点        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><ul><li>排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>遍历数组的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，排序所需空间（平均情况下）</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW51bWJlci1vZi1hcnJvd3MtdG8tYnVyc3QtYmFsbG9vbnMvc29sdXRpb24veW9uZy16dWktc2hhby1zaHUtbGlhbmctZGUtamlhbi15aW4tYmFvLXFpLXFpdS0xLTIv">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 406. 根据身高重建队列</title>
      <link href="/posts/75b6f5e4/"/>
      <url>/posts/75b6f5e4/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9xdWV1ZS1yZWNvbnN0cnVjdGlvbi1ieS1oZWlnaHQv">406. Queue Reconstruction by Height</span></p><p>假设有打乱顺序的一群人站成一个队列，数组  <code>people</code>  表示队列中一些人的属性（不一定按顺序）。每个  <code>people[i]</code>  = [h<sub>i</sub>, k<sub>i</sub>] 表示第 i 个人的身高为 h<sub>i</sub> ，前面 <strong>正好</strong> 有 k<sub>i</sub> 个身高大于或等于 h<sub>i</sub> 的人。</p><p>请你重新构造并返回输入数组  <code>people</code>  所表示的队列。返回的队列应该格式化为数组  <code>queue</code>  ，其中  <code>queue[j]</code>  = [h<sub>j</sub>, k<sub>j</sub>] 是队列中第 j 个人的属性（ <code>queue[0]</code>  是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><pre><code>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：    编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。    编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。    编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。    编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。    编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。    编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。    因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>people.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">\le 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>h</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">0 \le h_i \le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>k</mi><mi>i</mi></msub><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">0 \le k_i &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span></span></span>  <code>people.length</code></li><li>题目数据确保队列可以被重建</li></ul><h1 id="method"><a class="anchor" href="#method">#</a> Method</h1><p>算法思路：</p><p>类似于 <a href="https://jiankychen.github.io/posts/d4035162">LeetCode 135. 分发糖果</a> ，有两个维度需要处理，此时，可以先确定其中一个维度，再去确定另一个维度</p><p>本题应首先对身高  <code>h</code>  进行排序（将身高作为队列重建的第一依据），然后，针对相同的身高，按  <code>k</code>  进行排序</p><blockquote><p>一般地，涉及数对的排序，可以先根据第一个元素正向排序、再根据第二个元素反向排序，或者，根据第一个元素反向排序、再根据第二个元素正向排序</p></blockquote><p>这里首先按身高  <code>h</code>  从大到小排序，然后针对相同的身高按  <code>k</code>  从小到大排序，即</p><pre><code class="language-cpp">sort(people.begin(), people.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;    return a[0] &gt; b[0] || (a[0] == b[0] &amp;&amp; a[1] &lt; b[1]);&#125;);</code></pre><p>以 示例 1 为例，排序所得结果：</p><pre><code>people = [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</code></pre><p>排序完，可以开始重建队列：将  <code>i</code>  插入到队列的位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （优先处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 值较大的  <code>i</code> ）</p><blockquote><p>当我们放入第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个人时，只需要将其插入队列中，使得他的前面恰好有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个人即可。这是因为后面的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个人不会对第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个人造成影响（他们都比第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个人矮）</p></blockquote><p>插入的过程：</p><pre><code>ans = [[7,0]]ans = [[7,0],[7,1]]ans = [[7,0],[6,1],[7,1]]ans = [[5,0],[7,0],[6,1],[7,1]]ans = [[5,0],[7,0],[5,2],[6,1],[7,1]]ans = [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</code></pre><p>代码实现：</p><pre><code class="language-cpp">static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; // sort 的比较函数    if (a[0] == b[0]) return a[1] &lt; b[1];    return a[0] &gt; b[0];&#125;vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;    sort(people.begin(), people.end(), cmp);  // 排序    vector&lt;vector&lt;int&gt;&gt; ans;    for (int i = 0; i &lt; people.size(); i++) &#123; // 重建队列        vector&lt;int&gt; person = people[i];        ans.insert(ans.begin() + person[1], person); // 将 person 插入到 person[i] 位置    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><ul><li>排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>重建队列的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n} + n^2) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，排序所需空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0MDYuJUU2JUEwJUI5JUU2JThEJUFFJUU4JUJBJUFCJUU5JUFCJTk4JUU5JTg3JThEJUU1JUJCJUJBJUU5JTk4JTlGJUU1JTg4JTk3Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 860. 柠檬水找零</title>
      <link href="/posts/bf1fd3eb/"/>
      <url>/posts/bf1fd3eb/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZW1vbmFkZS1jaGFuZ2Uv">860. Lemonade Change</span></p><p>在柠檬水摊上，每一杯柠檬水的售价为  <code>5</code>  美元。顾客排队购买你的产品，（按账单  <code>bills</code>  支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付  <code>5</code>  美元、 <code>10</code>  美元或  <code>20</code>  美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付  <code>5</code>  美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组  <code>bills</code>  ，其中  <code>bills[i]</code>  是第  <code>i</code>  位顾客付的账。如果你能给每位顾客正确找零，返回  <code>true</code>  ，否则返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><pre><code>输入：bills = [5,5,5,10,20]输出：true解释：    前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。    第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。    第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。    由于所有客户都得到了正确的找零，所以我们输出 true。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：bills = [5,5,10,10,20]输出：false解释：    前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。    对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。    对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。    由于不是每位顾客都得到了正确的找零，所以答案是 false。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>bills.length </code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>bills[i]</code>  不是  <code>5</code>  就是  <code>10</code>  或是  <code>20</code></li></ul><h1 id="method-模拟-贪心"><a class="anchor" href="#method-模拟-贪心">#</a> Method: 模拟 + 贪心</h1><p>算法思路：按顺序处理顾客的订单（模拟）</p><ul><li>若顾客支付的是 5 美元，直接收银，无需找零</li><li>若顾客支付的是 10 美元，需找零 5 美元</li><li>若顾客支付的是 20 美元，有两种找零方式<ul><li>方式一：找零一张 5 美元、一张 10 美元</li><li>方式二：找零三张 5 美元</li><li>应优先采用方式一找零，即，尽量保留 5 美元，以便之后遇到 10 美元、20 美元时也能找零（贪心）</li></ul></li></ul><p>代码实现：</p><pre><code class="language-cpp">bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;    int five = 0; // 现有的 5 美元数量    int ten = 0;  // 现有的 10 美元数量    for (auto i : bills) &#123;        if (i == 5) five++;  // 顾客支付 5 美元        if (i == 10) &#123;       // 顾客支付 10 美元            if (five &gt;= 1) &#123; // 找零 5 美元                ten++;                five--;            &#125;            else return false; // 无法找零        &#125;        if (i == 20) &#123;       // 顾客支付 20 美元            if (five &gt;= 1 &amp;&amp; ten &gt;= 1) &#123; // 找零一张 5 美元、一张 10 美元                five--;                ten--;            &#125;            else if (five &gt;= 3) &#123; // 找零三张 5 美元                five -= 3;            &#125;            else return false; // 无法找零        &#125;    &#125;    return true; // 所有顾客均可找零&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 135. 分发糖果</title>
      <link href="/posts/d4035162/"/>
      <url>/posts/d4035162/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW5keS8=">135. Candy</span></p><p><code>n</code>  个孩子站成一排。给你一个整数数组  <code>ratings</code>  表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：ratings = [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</code></pre><p></p><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>ratings[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>考虑以下两个规则：</p><ul><li>左规则：右边评分大于左边时，右边孩子的糖果应比左边孩子多</li><li>右规则：左边评分大于右边时，左边孩子的糖果应比右边孩子多</li></ul><p>可以遍历数组两次，分别处理「左规则」和「右规则」，求出每个孩子最少需要被分得的糖果数量，最终每个孩子分得的糖果数量应为两种规则下的最大值</p><blockquote><p>如果两种规则同时考虑，很可能会顾此失彼</p></blockquote><h1 id="method-贪心"><a class="anchor" href="#method-贪心">#</a> Method: 贪心</h1><p>算法思路：</p><ol><li><p>定义数组  <code>nums</code>  记录每个孩子应得糖果的数量</p></li><li><p>处理「左规则」：从左往右遍历（只能是从左往右遍历，因为右边孩子的糖果数需要根据左边孩子糖果数的变化而变化）：</p><ul><li>若  <code>ratings[i] &gt; ratings[i - 1]</code>  ，则  <code>i</code>  应比  <code>i - 1</code>  多得一颗糖果，即  <code>nums[i] = nums[i - 1] + 1</code></li></ul></li><li><p>处理「右规则」：从右往左遍历（只能是从右往左遍历，因为左边孩子的糖果数需要根据右边孩子糖果数的变化而变化）</p><ul><li>若  <code>ratings[i] &gt; ratings[i + 1]</code>  ，此时需作以下考虑：<ul><li>由于  <code>i</code>  的评分高于  <code>i + 1</code>  ，分给  <code>i</code>  的糖果数应至少为  <code>nums[i + 1] + 1</code></li><li>处理完「左规则」后，分给  <code>i</code>  的糖果数应至少为  <code>nums[i]</code></li><li>为确保两种规则同时满足，分给  <code>i</code>  的糖果数应为  <code>nums[i + 1] + 1</code>  与  <code>nums[i]</code>  中的较大值，即  <code>nums[i] = max(nums[i], nums[i + 1] + 1)</code></li></ul></li></ul></li><li><p>计算糖果总数：求数组  <code>nums</code>  的元素和</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int candy(vector&lt;int&gt;&amp; ratings) &#123;    int n = ratings.size();    vector&lt;int&gt; nums(n, 1);     // 分配给每个孩子的糖果数    // 处理左规则    for (int i = 1; i &lt; n; i++) &#123;        if (ratings[i] &gt; ratings[i - 1])            nums[i] = nums[i - 1] + 1;    &#125;    // 处理右规则    for (int i = n - 1; i &gt;= 1; i--) &#123;        if (ratings[i - 1] &gt; ratings[i])            nums[i - 1] = max(nums[i - 1], nums[i] + 1); // 注意这里要取两种规则下的最大值    &#125;    int ans = 0; // 最少糖果数目    for (int i = 0; i &lt; n; i++) &#123;        ans += nums[i];    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>ratings</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMzUuJUU1JTg4JTg2JUU1JThGJTkxJUU3JUIzJTk2JUU2JTlFJTlDLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW5keS9zb2x1dGlvbi9mZW4tZmEtdGFuZy1ndW8tYnktbGVldGNvZGUtc29sdXRpb24tZjAxcC8=">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 134. 加油站</title>
      <link href="/posts/72c6f482/"/>
      <url>/posts/72c6f482/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi8=">134. Gas Station</span></p><p>在一条环路上有  <code>n</code>  个加油站，其中第  <code>i</code>  个加油站有汽油  <code>gas[i]</code>  升。</p><p>你有一辆油箱容量无限的的汽车，从第  <code>i</code>  个加油站开往第  <code>i+1</code>  个加油站需要消耗汽油  <code>cost[i]</code>  升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组  <code>gas</code>  和  <code>cost</code>  ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回  <code>-1</code>  。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出：3解释：    从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油    开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油    开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油    开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油    开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油    开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。    因此，3 可为起始索引。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：gas = [2,3,4], cost = [3,4,3]输出：-1解释：    你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。    我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油    开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油    开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油    你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。    因此，无论怎样，你都不可能绕环路行驶一周。</code></pre><p></p><p><strong>提示：</strong></p><ul><li><code>n == gas.length == cost.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>gas[i]</code> ,  <code>cost[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>如果从站点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 出发，最远能到达站点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> ，则：从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 区间内任意一个站点出发，都无法回到该站点</p><blockquote><p>证明如下：假设可以从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k \in [i, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 出发并回到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，此时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 必然能够到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ；由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 能够到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 能够到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，与已知条件矛盾，故而无法从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 出发并回到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p></blockquote><p>即，如果存在一个可行的出发站点，则必然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 及其以后站点中的某一个</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi9zb2x1dGlvbi94aWFuZy14aS10b25nLXN1LWRlLXNpLWx1LWZlbi14aS1kdW8tamllLWZhLWJ5LS0zMC8=">windliang：详细通俗的思路分析</span></p><h1 id="method-1"><a class="anchor" href="#method-1">#</a> Method 1</h1><p>算法思路：首先检查站点  <code>i = 0</code>  是否为可行的出发站点：如果不是，记录其能到达的最远站点，将其更新为  <code>i</code> ，检查新的  <code>i</code>  是否为可行的出发站点</p><p>代码实现：</p><pre><code class="language-cpp">int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;    int n = gas.size();    int i = 0;    while (i &lt; n) &#123;     // 判断 i 是否为可行的出发站点        int sumGas = 0, sumCost = 0;        int cnt = 0;    // 从 i 出发时，所能经过的站点数        while (cnt &lt; n) &#123;            int j = (i + cnt) % n;            sumGas += gas[j];            sumCost += cost[j];            if (sumCost &gt; sumGas) break; // 无法到达第 j + 1 个站点            cnt++;        &#125;        if (cnt == n) &#123; // 从 i 出发，能经过 n 个站点，i 即为所求             return i;        &#125; else &#123;        // [i, i + cnt] 区间内任一站点都不是可行的出发站点            i = i + cnt + 1;        &#125;    &#125;    return -1;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi9zb2x1dGlvbi9qaWEteW91LXpoYW4tYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解</span></p><h1 id="method-2"><a class="anchor" href="#method-2">#</a> Method 2</h1><p>算法思路：</p><ol><li><p>定义  <code>totalSum</code>  ，用于累计每个站点的剩余油量，以判断是否存在一个可行的出发站点</p></li><li><p>定义  <code>curSum</code>  ，用于累计从某个站点出发至今的剩余油量（最初从站点  <code>0</code>  开始累计）</p></li><li><p>定义  <code>start</code>  ，作为当前考虑的出发站点</p></li><li><p>从左往右遍历站点  <code>i</code></p><ul><li>计算  <code>totalSum = totalSum + gas[i] - cost[i]</code></li><li>计算  <code>curSum = curSum + gas[i] - cost[i]</code></li><li>判断  <code>curSum</code>  是否小于 0<ul><li>若不小于 0 ，说明从  <code>start</code>  出发能到达站点  <code>i + 1</code>  ，继续遍历</li><li>若小于 0 ，说明从  <code>start</code>  出发最远只能到达站点  <code>i</code>  ，而不能到达站点  <code>i + 1</code><ul><li>更新  <code>start</code>  为  <code>i + 1</code>  ，判断  <code>i + 1</code>  是否为可行的出发点</li><li>重置  <code>curSum</code>  ，累计从站点  <code>i + 1</code>  出发的剩余油量</li></ul></li></ul></li></ul></li><li><p>遍历结束，判断  <code>totalSum</code>  是否小于 0</p><ul><li>若小于 0 ，说明  <code>gas</code>  之和小于  <code>cost</code>  之和，不存在可行的出发站点，返回  <code>-1</code></li><li>若不小于 0 ，说明存在一个可行的出发站点，并且，该出发站点即为  <code>start</code></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;    int start = 0;    int curSum = 0;        // 从 start 出发，当前的剩余油量    int totalSum = 0;      // 累计 gas 与 cost 的差值    for (int i = 0; i &lt; gas.size(); i++) &#123;        curSum += gas[i] - cost[i];        totalSum += gas[i] - cost[i];        if (curSum &lt; 0) &#123;  // 从 start 出发最多能到达 i ，无法到达 i + 1            start = i + 1; // 考虑 i + 1 是否能作为出发站点            curSum = 0;    // 重新累计剩余油量        &#125;    &#125;    if (totalSum &lt; 0) return -1; // gas 总和小于 cost 总和，任一站点出发均无法返回    return start;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMzQuJUU1JThBJUEwJUU2JUIyJUI5JUU3JUFCJTk5Lmh0bWwjJUU4JUI0JUFBJUU1JUJGJTgzJUU3JUFFJTk3JUU2JUIzJTk1LSVFNiU5NiVCOSVFNiVCMyU5NSVFNCVCQSU4Qw==">代码随想录</span></p><p>附：</p><p>为什么 “当可行的出发站点存在时， <code>start</code>  就是该可行站点” ？</p><p>这是因为，除了遍历过程中的最后一个  <code>start</code>  （不妨记作  <code>ans</code>  ）以外，其余所有  <code>start</code>  对应的  <code>curSum</code>  均小于 0 ，其累加值  <code>totalSum</code>  也同样小于 0， 即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>g</mi><mi>a</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum_{i = 0}^{ans - 1} {(gas[i] - cost[i])} &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">s</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>由于存在可行的出发站点，可得</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>g</mi><mi>a</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi></mrow><mrow><mi>g</mi><mi>a</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>g</mi><mi>a</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum_{i = 0}^{ans - 1} {(gas[i] - cost[i])} + \sum_{i = ans}^{gas.size() - 1} {(gas[i] - cost[i])} &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">s</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.2386740000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span><span class="mopen mtight">(</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi></mrow><mrow><mi>g</mi><mi>a</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>g</mi><mi>a</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><mo>&gt;</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>g</mi><mi>a</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i = ans}^{gas.size() - 1} {(gas[i] - cost[i])} &gt; \sum_{i = 0}^{ans - 1} {(cost[i] - gas[i])}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.2386740000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span><span class="mopen mtight">(</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">s</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></span></p><p>因此，从  <code>ans</code>  出发到达站点  <code>gas.size() - 1</code>  时，其剩余油量足以继续前往站点  <code>0</code> ,  <code>1</code> , ...,  <code>ans</code></p><p>即， <code>ans</code>  是可行的出发站点</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1005. K 次取反后最大化的数组和</title>
      <link href="/posts/e072609b/"/>
      <url>/posts/e072609b/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWl6ZS1zdW0tb2YtYXJyYXktYWZ0ZXItay1uZWdhdGlvbnMv">1005. Maximize Sum Of Array After K Negations</span></p><p>给你一个整数数组  <code>nums</code>  和一个整数  <code>k</code>  ，按以下方法修改该数组：</p><ul><li>选择某个下标  <code>i</code>  并将  <code>nums[i]</code>  替换为  <code>-nums[i]</code>  。</li><li>重复这个过程恰好  <code>k</code>  次。可以多次选择同一个下标  <code>i</code>  。</li></ul><p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,2,3], k = 1输出：5解释：选择下标 1 ，nums 变为 [4,-2,3]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,-1,0,2], k = 3输出：6解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [2,-3,-1,5,-4], k = 2输出：13解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li>$1 \le $  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>为使得数组和最大，每次的取反操作应尽可能针对负数进行，并且，应优先将值最小的负数取反（以获得值较大的正数）</p><p>特别地，如果  <code>K</code>  大于数组中负数的个数，意味着我们在将所有负数取反之后，必须继续进行取反操作，此时有两种情况：</p><ul><li>如果剩余修改次数为偶数，可将这些修改施加于任意一个数，并不会影响数组和</li><li>如果剩余修改次数为奇数，应将这些修改施加于值最小的非负数，以使得数组和最大</li></ul><p>注意，在将负数修改为正数的过程中，可能产生了新的、值更小的非负数（相比于原数组而言）</p><h1 id="method-贪心"><a class="anchor" href="#method-贪心">#</a> Method: 贪心</h1><p>贪心策略：</p><ul><li>局部最优：将绝对值大的负数修改为正数，使得当前元素值最大</li><li>整体最优：整个数组的和最大（数组中的负数和最小）</li></ul><p>算法思路：</p><ol><li><p>将数组 <strong>按照绝对值的大小从大到小排序</strong></p></li><li><p><strong>从左往右遍历</strong> 数组，在修改次数限制下，将遇到的每一个负数修改为相反数，并更新剩余修改次数（即，执行  <code>k--</code>  ）</p></li><li><p>如果剩余修改次数为奇数，将绝对值最小的数修改为相反数</p></li><li><p>计算数组和</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">class Solution &#123;static bool cmp(int a, int b) &#123;    return abs(a) &gt; abs(b);&#125;public:    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(), nums.end(), cmp);    // 按照绝对值从大到小进行排序        for (int i = 0; i &lt; nums.size(); i++) &#123; // 在修改次数限制下，将绝对值大的负数修改为相反数            if (nums[i] &lt; 0 &amp;&amp; k &gt; 0) &#123;                nums[i] = - nums[i];                k--;            &#125;        &#125;        if (k % 2 == 1) nums[nums.size() - 1] = - nums[nums.size() - 1]; // 将绝对值最小的数修改为相反数        int ans = 0;        for (int i = 0; i &lt; nums.size(); i++) &#123;            ans += nums[i];        &#125;        return ans;    &#125;&#125;;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度</p><ul><li>排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，这里不予考虑</li><li>修改数组、计算数组和的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzEwMDUuSyVFNiVBQyVBMSVFNSU4RiU5NiVFNSU4RiU4RCVFNSU5MCU4RSVFNiU5QyU4MCVFNSVBNCVBNyVFNSU4QyU5NiVFNyU5QSU4NCVFNiU5NSVCMCVFNyVCQiU4NCVFNSU5MiU4Qy5odG1sIyVFNiU4MCU5RCVFOCVCNyVBRg==">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 45. 跳跃游戏 II</title>
      <link href="/posts/13c5205f/"/>
      <url>/posts/13c5205f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtaWkv">45. Jump Game II</span></p><p>给定一个长度为  <code>n</code>  的 整数数组  <code>nums</code>  ，初始位置为  <code>nums[0]</code> 。</p><p>每个元素  <code>nums[i]</code>  表示从索引  <code>i</code>  向前跳转的最大长度。换句话说，如果你在  <code>nums[i]</code>  处，你可以跳转到任意  <code>nums[i + j]</code>  处：</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达  <code>nums[n - 1]</code>  的最小跳跃次数。生成的测试用例可以到达  <code>nums[n - 1]</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,1,1,4]输出：2解释：跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,3,0,1,4]输出：2</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li>题目保证可以到达  <code>nums[n-1]</code></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>贪心策略：</p><ul><li>局部最优：尽可能往更远处跳跃</li><li>整体最远：每一步跳跃的距离尽可能大，从而减少跳跃次数</li></ul><p>在具体实现上，我们不需要考虑每一步具体跳到哪里，只需关注每一步最远能跳到哪里即可</p><p>从左到右遍历数组，如果数组下标  <code>i</code>  到达当前这一步的最大覆盖位置、但还没有到达终点，即需要再跳跃一次（更新跳跃次数，并更新最大覆盖位置），直到终点在最大覆盖位置以内</p><p height="200px"><img data-src="/posts/13c5205f/example.png" class=""></p><h1 id="method-贪心"><a class="anchor" href="#method-贪心">#</a> Method: 贪心</h1><p>算法思路：</p><ol><li><p>定义跳跃的步数  <code>ans</code></p></li><li><p>定义两个覆盖范围：当前这一步的最大覆盖位置  <code>curMaxPosition</code>   和 下一步最大覆盖位置  <code>nextMaxPosition</code></p></li><li><p>遍历数组下标  <code>i</code>  ，其中， <code>i</code>  最多移动到  <code>nums.size() - 2</code>  位置</p><ul><li>更新下一步最大覆盖位置  <code>nextMaxPosition</code></li><li>若下标  <code>i</code>  等于当前最大覆盖位置，说明从当前位置无法一步到达终点，至少需要多走一步<ul><li>更新跳跃的步数： <code>ans++</code></li><li>更新当前这一步的最大覆盖位置： <code>curMaxPosition = nextMaxPosition;</code></li></ul></li></ul></li></ol><p>其中， <code>i</code>  最大只能取  <code>nums.size() - 2</code>  ，是为了简化代码。特别地，当  <code>i == nums.size() - 2</code>  时，有以下两种情况</p><ul><li>若  <code>i</code>  等于当前最大覆盖位置（即， <code>curMaxPosition == nums.size() - 2</code>  ），说明当前这一步无法到达终点，还需要再走一步才能到达终点（执行  <code>ans++</code>  ，遍历结束）</li><li>若  <code>i</code>  不等于当前最大覆盖位置（即， <code>curMaxPosition &gt; nums.size() - 2</code>  ），说明当前这一步可以直接到达终点，无需再跳下一步（遍历结束，无需执行  <code>ans++</code>  ）</li></ul><p>这两种情况可直接通过上述算法思路进行处理，无需再做额外的判定</p><p>代码实现：</p><pre><code class="language-cpp">int jump(vector&lt;int&gt;&amp; nums) &#123;    int ans = 0;             // 步数    int curMaxPosition = 0;  // 当前这一步可达的最远位置    int nextMaxPosition = 0; // 下一步可到达的最远位置    for (int i = 0; i &lt; nums.size() - 1; i++) &#123; // 注意这里是小于 nums.size() - 1        nextMaxPosition = max(nextMaxPosition, i + nums[i]); // 更新 nextMaxPosition        if (i == curMaxPosition) &#123; // 到达当前这一步所能到达的最远位置             ans++;            curMaxPosition = nextMaxPosition;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNDUuJUU4JUI3JUIzJUU4JUI3JTgzJUU2JUI4JUI4JUU2JTg4JThGSUkuaHRtbCMlRTYlOTYlQjklRTYlQjMlOTUlRTQlQkElOEM=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtaWkvc29sdXRpb24vdGlhby15dWUteW91LXhpLWlpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 55. 跳跃游戏</title>
      <link href="/posts/8e9df849/"/>
      <url>/posts/8e9df849/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUv">55. Jump Game</span></p><p>给定一个非负整数数组  <code>nums</code>  ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-贪心"><a class="anchor" href="#method-贪心">#</a> Method: 贪心</h1><p>如果能够从当前位置到达  <code>index</code>  位置，也就能够从当前位置到达  <code>index</code>  左侧任意位置</p><p>因此，我们可以遍历数组中的每一个位置，计算「从当前位置出发所能到达的最远位置」，简称为 <strong>可到达的最远位置</strong></p><p>如果 <strong>可到达的最远位置</strong> 在数组尾端以右，则数组尾端在可到达范围内</p><h2 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h2><p>算法思路：</p><ol><li><p>遍历当前位置  <code>i</code>  ，其中， <code>i</code>  只能在可到达的位置范围内移动</p><ul><li>更新可到达的最远位置</li><li>如果可到达的最远位置在数组尾端以右，返回  <code>true</code></li></ul></li><li><p>如果遍历结束时，数组尾端仍不在可到达范围内，返回  <code>false</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool canJump(vector&lt;int&gt;&amp; nums) &#123;    int rightMost = 0;                     // 可到达的最远位置    for (int i = 0; i &lt;= rightMost; i++) &#123; // i 只能在可到达范围内移动        rightMost = max(i + nums[i], rightMost);       // 更新可到达的最远位置        if (rightMost &gt;= nums.size() - 1) return true; // 终点在可到达范围内    &#125;    return false; // 终点不在可到达范围内&#125;</code></pre><h2 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h2><p>算法思路：</p><ol><li><p>遍历当前位置  <code>i</code>  ，其中， <code>i</code>  可以在数组范围中移动</p><ul><li>如果位置  <code>i</code>  超出可到达范围，位置  <code>i</code>  不可达，返回  <code>false</code></li><li>否则，更新可到达范围</li></ul></li><li><p>如果遍历结束，说明数组尾端是可到达的，返回  <code>true</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool canJump(vector&lt;int&gt;&amp; nums) &#123;    int rightMost = 0; // 可到达的最远位置    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (i &gt; rightMost) return false;         // 位置 i 不可达        rightMost = max(rightMost, i + nums[i]); // 更新可到达的最远位置    &#125;    return true;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>prices</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUvc29sdXRpb24vdGlhby15dWUteW91LXhpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUvc29sdXRpb24vNTUtYnktaWthcnVnYS8=">Ikaruga：别想那么多，就挨着跳吧</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 122. 买卖股票的最佳时机 II</title>
      <link href="/posts/1cc8aec1/"/>
      <url>/posts/1cc8aec1/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpLw==">122. Best Time to Buy and Sell Stock II</span></p><p>给你一个整数数组  <code>prices</code>  ，其中  <code>prices[i]</code>  表示某支股票第  <code>i</code>  天的价格。</p><p>在每一天，你可以决定是否购买和 / 或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 你能获得的 <strong>最大</strong> 利润 。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。总利润为 4 + 3 = 7 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>prices[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p><a href="https://jiankychen.github.io/posts/7ef7bbd4">LeetCode 121. 买卖股票的最佳时机</a> 只能进行一次交易，而本题可以进行多次交易</p><p>在某种程度上，可以理解为：两题都可以进行多次交易，但 <a href="https://jiankychen.github.io/posts/7ef7bbd4">LeetCode 121. 买卖股票的最佳时机</a> 求的是所有交易中的最大收益，本题求的是所有交易的收益和（正收益之和）</p><h1 id="method-1-贪心"><a class="anchor" href="#method-1-贪心">#</a> Method 1: 贪心</h1><p>贪心策略：每天至多持有一只股票，要想获得最大利润，则需低点买入、高点卖出：即，在第一个「谷」买入，在第一个「峰」卖出，然后在下一个「谷」买入，再在下一个「峰」卖出，以此往复</p><p>算法思路：按天计算利润，仅收集每天的正利润，以获得最大利润（该过程并未模拟股票交易过程）</p><p>详细说明可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpL3NvbHV0aW9uL21haS1tYWktZ3UtcGlhby1kZS16dWktamlhLXNoaS1qaS1paS1ieS1sZWV0Y29kZS1zLw==">力扣官方题解：买卖股票的最佳时机 II</span></p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int result = 0;    for (int i = 1; i &lt; prices.size(); i++) &#123; // 只记录每天的正收益        result += max(prices[i] - prices[i - 1], 0);    &#125;    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>prices</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：</p><p>定义 dp 数组： <code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2,0))</code></p><ul><li><code>dp[i][0]</code>  表示第  <code>i</code>  天持有股票时的最大利润</li><li><code>dp[i][1]</code>  表示第  <code>i</code>  天不持有股票时的最大利润</li></ul><p>确定递推公式：</p><ul><li>第  <code>i</code>  天持有股票，即， <code>dp[i][0]</code><ul><li>若第  <code>i - 1</code>  天持有股票，则最大利润为  <code>dp[i - 1][0]</code></li><li>若第  <code>i - 1</code>  天不持有股票，即，第  <code>i</code>  天买入股票，则最大利润为  <code>dp[i - 1][1] - prices[i]</code> （虽然第  <code>i - 1</code>  天不持有股票，但此前可能进行过完整交易，因此，第  <code>i</code>  天的利润应为  <code>dp[i - 1][1]</code>  减去  <code>prices[i]</code>  ，而这也就是与 <a href="https://jiankychen.github.io/posts/7ef7bbd4">LeetCode 121. 买卖股票的最佳时机</a> 的差异所在）</li><li>综合两种情况得  <code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</code></li></ul></li><li>第  <code>i</code>  天不持有股票，即， <code>dp[i][1]</code><ul><li>若第  <code>i - 1</code>  天持有股票，即，第  <code>i</code>  天卖出股票，则最大利润为  <code>dp[i - 1][0] + prices[i]</code></li><li>若第  <code>i - 1</code>  天不持有股票，则最大利润为  <code>dp[i - 1][1]</code></li><li>综合两种情况得  <code>dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1])</code></li></ul></li></ul><p>初始化 dp 数组：</p><ul><li>若第 0 天持有股票，当前利润应为  <code>- prices[0]</code>  ，即  <code>dp[0][0] = - prices[0]</code></li><li>若第 0 天不持有股票，利润为 0 ，即  <code>dp[i][1] = 0</code></li></ul><p>遍历顺序：按  <code>i</code>  从小到大遍历</p><p>最后的  <code>dp[n - 1][1]</code>  即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;    int n = prices.size();    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2,0));    dp[0][0] = - prices[0];    dp[0][1] = 0;    for (int i = 1; i &lt; n; i++) &#123;        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);        dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);    &#125;    return dp[n - 1][1];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>prices</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以采用滚动数组优化空间复杂度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 53. 最大子数组和</title>
      <link href="/posts/37be6a99/"/>
      <url>/posts/37be6a99/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5Lw==">53. Maximum Subarray</span></p><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [5,4,-1,7,8]输出：23</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：如果你已经实现复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的解法，尝试使用更为精妙的 分治法 求解。</p><h1 id="method-1-贪心"><a class="anchor" href="#method-1-贪心">#</a> Method 1: 贪心</h1><p>贪心策略：</p><ul><li><p>局部最优：当「连续子数组和」为负数时，放弃当前的连续子数组，从下一位元素重新开始新的连续子数组，即，需从下一个元素重新计算「连续子数组和」。这是因为：负的「连续子数组和」与下一个元素之和 必定小于 下一个元素本身</p></li><li><p>全局最优：选取最大的「连续子数组和」</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int count = 0;    int result = INT_MIN;    for (int i = 0; i &lt; nums.size(); i++) &#123;        count += nums[i];            // 连续子数组和        result = max(result, count); // 连续子数组和的最大值        if (count &lt; 0) count = 0;    // 子数组和为负数，重新开始子数组    &#125;    return result;&#125;</code></pre><p>须注意，因为  <code>nums[i]</code>  可能为负数， <code>result</code>  需初始化为  <code>INT_MIN</code></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>nums</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNTMuJUU2JTlDJTgwJUU1JUE0JUE3JUU1JUFEJTkwJUU1JUJBJThGJUU1JTkyJThDLmh0bWw=">代码随想录</span></p><h1 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h1><p>算法思路：</p><p>定义  <code>dp[i]</code>  表示以  <code>nums[i]</code>  结尾的连续子数组的最大和</p><p>对于任意  <code>nums[i]</code>  而言，可以将  <code>nums[i]</code>  添加到当前的连续子数组，此时的最大和为  <code>dp[i - 1] + nums[i]</code>  ，也可以重新开始一个连续子数组，此时的最大和为  <code>nums[i]</code>  。综合两种情况取最大值，即，递推公式为  <code>dp[i] = max(dp[i - 1] + nums[i], nums[i])</code></p><p>初始化： <code>dp[0] = nums[0]</code></p><p>按  <code>i</code>  从小到大顺序遍历即可</p><p>遍历结束后，从 dp 数组中找到最大值，即为最大的连续子数组的和</p><p>代码实现：</p><pre><code class="language-cpp">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; dp(nums.size(), 0);    dp[0] = nums[0];    for (int i = 1; i &lt; nums.size(); i++) &#123;        dp[i] = max(dp[i - 1] + nums[i], nums[i]);    &#125;    int ans = INT_MIN; // 最大连续子数组的和    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (dp[i] &gt; ans) ans = dp[i];    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>nums</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>可以采用滚动数组的思想降低空间复杂度，即：</p><pre><code class="language-cpp">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    int dp = 0;    int ans = INT_MIN;    for (int i = 0; i &lt; nums.size(); i++) &#123;        dp = max(dp + nums[i], nums[i]);        ans = max(ans, dp);    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>nums</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 376. 摆动序列</title>
      <link href="/posts/f6882869/"/>
      <url>/posts/f6882869/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93aWdnbGUtc3Vic2VxdWVuY2Uv">376. Wiggle Subsequence</span></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列</strong> 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li><p>例如， <code>[1, 7, 4, 9, 2, 5]</code>  是一个 <strong>摆动序列</strong> ，因为差值  <code>(6, -3, 5, -7, 3)</code>  是正负交替出现的。</p></li><li><p>相反， <code>[1, 4, 7, 2, 5]</code>  和  <code>[1, 7, 4, 5, 5]</code>  不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p></li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组  <code>nums</code>  ，返回  <code>nums</code>  中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3)</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 的摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8)</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,2,3,4,5,6,7,8,9]输出：2</code></pre><p><strong>提示：</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p><strong>进阶</strong>：你能否用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度完成此题？</p><h1 id="method-贪心"><a class="anchor" href="#method-贪心">#</a> Method: 贪心</h1><p>算法思路：不断交错选择数组中的「峰」与「谷」，使得摆动子序列尽可能长</p><p>如下图所示，选择  <code>[1, 17, 5, 15, 5, 16, 8]</code>  即可得到最长的摆动子序列（答案不唯一），这也就是贪心策略在本题中的体现</p><p height="200px"><img data-src="/posts/f6882869/example.png" class=""></p><p>本题要求的是最长摆动子序列的长度，也就是数组中 <strong>交替出现</strong> 的「峰」与「谷」的数量和，可通过计算 <strong>交替出现</strong> 的「上升坡」和「下降坡」的数量来获得</p><ul><li>若  <code>nums[i] &gt; nums[i - 1]</code>  ，则  <code>nums[i - 1]</code>  与  <code>nums[i]</code>  之间形成「上升坡」</li><li>若  <code>nums[i] &lt; nums[i - 1]</code>  ，则  <code>nums[i - 1]</code>  与  <code>nums[i]</code>  之间形成「下降坡」</li><li>若  <code>nums[i] == nums[i - 1]</code>  ，则  <code>nums[i - 1]</code>  与  <code>nums[i]</code>  之间不形成坡（或者描述为： <code>nums[i - 1]</code>  与  <code>nums[i]</code>  之间形成「平坡」）</li></ul><p>不妨用  <code>res</code>  来记录 <strong>交替出现</strong> 的「上升坡」和「下降坡」的数量之和（  <code>res</code>  的初始值为 0 ）</p><ul><li>如果之前统计到的最后一个坡是「下降坡」，当前遇到的坡为「上升坡」，则将当前「上升坡」统计在内， <code>res</code>  加一</li><li>如果之前统计到的最后一个坡是「下降坡」，当前遇到的坡仍为「下降坡」，不满足「上升坡」和「下降坡」交替，故而不统计当前「下降坡」</li><li>如果之前统计到的最后一个坡是「上升坡」，当前遇到的坡为「下降坡」，则将当前「下降坡」统计在内， <code>res</code>  加一</li><li>如果之前统计到的最后一个坡是「上升坡」，当前遇到的坡仍为「上升坡」，不满足「上升坡」和「下降坡」交替，故而不统计当前「上升坡」</li></ul><p>因此，所得到的最长摆动序列的长度为  <code>res + 1</code></p><p>代码实现：</p><pre><code class="language-cpp">int wiggleMaxLength(vector&lt;int&gt; &amp;nums) &#123;    int n = nums.size();    if (n &lt;= 1) return n;    int preDiff = 0; // 在摆动序列中，最后一对数的差值（统计到的最后一个坡）    int curDiff = 0; // 在原始序列中，当前遍历到的数字与后一个数的差值（当前遇到的坡）    int res = 1;    for (int i = 0; i &lt; n - 1; i++) &#123;        curDiff = nums[i + 1] - nums[i];        if ((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) &#123; // 遇到一个与之前方向相反的坡            res++;            preDiff = curDiff;        &#125;    &#125;    return res;&#125;</code></pre><p>其中， <code>preDiff</code>  初始化为 0 ，是为了方便统计  <code>nums</code>  数组中的第一个坡（即，直接将数组中的第一个坡统计在内，不管它是「上升坡」还是「下降坡」）</p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzNzYuJUU2JTkxJTg2JUU1JThBJUE4JUU1JUJBJThGJUU1JTg4JTk3Lmh0bWwjXzM3Ni0lRTYlOTElODYlRTUlOEElQTglRTUlQkElOEYlRTUlODglOTc=">代码随想录：摆动序列</span></p><blockquote><p>本题也还可以采用动态规划来求解，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzNzYuJUU2JTkxJTg2JUU1JThBJUE4JUU1JUJBJThGJUU1JTg4JTk3Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFGMi0lRTUlOEElQTglRTYlODAlODElRTglQTclODQlRTUlODglOTI=">代码随想录</span> 和 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93aWdnbGUtc3Vic2VxdWVuY2Uvc29sdXRpb24vYmFpLWRvbmcteHUtbGllLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLXloMm0v">力扣官方题解</span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 455. 分发饼干</title>
      <link href="/posts/6d4c99f1/"/>
      <url>/posts/6d4c99f1/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3NpZ24tY29va2llcy8=">455. Assign Cookies</span></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子  <code>i</code> ，都有一个胃口值  <code>g[i]</code> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干  <code>j</code> ，都有一个尺寸  <code>s[j]</code>  。如果  <code>s[j] &gt;= g[i]</code>  ，我们可以将这个饼干  <code>j</code>  分配给孩子  <code>i</code>  ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1：</strong></p><pre><code>输入：g = [1,2,3], s = [1,1]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：g = [1,2], s = [1,2,3]输出：2</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>g.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>g[i]</code> ,  <code>s[j]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>为满足尽可能多的孩子，应尽可能将饼干全部分发出去</p><p>于是，大尺寸的饼干应该优先分配给胃口大的孩子，这样才能使发出去的饼干尽可能多</p><p>可以采用贪心策略，选择每一阶段的局部最优（大尺寸饼干分配给胃口大的），从而达到全局最优（分发出的饼干数量达到最大）</p><blockquote><p>也可以换一个思路：先将小尺寸饼干分配给胃口小的孩子，可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0NTUuJUU1JTg4JTg2JUU1JThGJTkxJUU5JUE1JUJDJUU1JUI5JUIyLmh0bWwjXzQ1NS0lRTUlODglODYlRTUlOEYlOTElRTklQTUlQkMlRTUlQjklQjI=">代码随想录：分发饼干</span></p></blockquote><h1 id="method-排序-贪心"><a class="anchor" href="#method-排序-贪心">#</a> Method: 排序 + 贪心</h1><p>算法思想：</p><ol><li><p>分别将饼干尺寸数组  <code>s</code>  和小孩胃口数组  <code>g</code>  排序</p></li><li><p>将数组  <code>g</code>  的索引记为  <code>i</code>  ，初始化为  <code>i = g.size() - 1</code>  ，对应于胃口最大的孩子；将数组  <code>s</code>  的索引记为  <code>j</code>  ，初始化为  <code>j = s.size() - 1</code>  ，对应于尺寸最大的饼干</p></li><li><p>遍历数组  <code>s</code>  （从后往前遍历）：</p><ul><li>如果  <code>s[j] &gt;= g[i]</code>  ，说明饼干  <code>j</code>  能满足孩子  <code>i</code>  ，即，当前剩余的、尺寸最大的饼干能够满足孩子  <code>i</code>  ，将其分给孩子  <code>i</code>  。执行  <code>j--</code>  和  <code>i--</code>  （考虑是否将下一个饼干分给下一个孩子）</li><li>如果  <code>s[j] &lt; g[i]</code>  ，说明饼干  <code>j</code>  不能满足孩子  <code>i</code>  。执行  <code>i--</code>  （考虑是否将当前饼干分发给下一个孩子）</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;    sort(g.begin(), g.end()); // 排序    sort(s.begin(), s.end());    int ans = 0;    for (int i = g.size() - 1, j = s.size() - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--) &#123; // 从后往前遍历        if (s[j] &gt;= g[i]) &#123; // 饼干 j 可以分配给孩子 i            j--;            ans++;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \log{m} + n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是数组  <code>g</code>  和数组  <code>s</code>  的长度</p><ul><li>对两个数组进行排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \log{m} + n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>遍历两个数组的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>因此，总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \log{m} + n \log{n} + m + n) = O(m \log{m} + n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>m</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{m} + \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，考虑了排序所需的额外空间（平均情况下）</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3NpZ24tY29va2llcy9zb2x1dGlvbi9mZW4tZmEtYmluZy1nYW4tYnktbGVldGNvZGUtc29sdXRpb24tNTBzZS8=">力扣官方题解</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 47. 排列II</title>
      <link href="/posts/cd8e32d2/"/>
      <url>/posts/cd8e32d2/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMtaWkv">47. Permutations II</span></p><p>给定一个可<strong>包含重复数字</strong>的序列  <code>nums</code>  ，<strong>按任意顺序</strong> 返回所有 <strong>不重复</strong> 的全排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,2]输出：[[1,1,2],[1,2,1],[2,1,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">\le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题在 <a href="https://jiankychen.github.io/posts/1ba17777">46. 全排列</a> 的基础上，为  <code>nums</code>  数组引入了重复元素，要求返回所有不重复的全排列</p><p>因此，需要在每一层递归中，对  <code>for</code>  循环所遍历的元素进行去重</p><h1 id="method-回溯-排序"><a class="anchor" href="#method-回溯-排序">#</a> Method: 回溯 + 排序</h1><h2 id="算法思想"><a class="anchor" href="#算法思想">#</a> 算法思想</h2><ol><li><p>先对  <code>nums</code>  数组进行排序，使得重复元素在  <code>nums</code>  数组中连续</p></li><li><p>在递归函数中的去重操作：</p><ul><li>若  <code>nums[i]</code>  在上层递归中被选取过，本层不再选取  <code>nums[i]</code></li><li>若  <code>nums[i] == nums[i - 1]</code>  （  <code>i &gt; 0</code>  ），并且  <code>nums[i - 1]</code>  在上层递归中未被选取，则本层递归会选取  <code>nums[i - 1]</code>  ，故而本层不再选取  <code>nums[i]</code></li></ul></li></ol><p>若使用  <code>used[i]</code>  值为  <code>1</code>  来表示  <code>nums[i]</code>  已经被上层递归选取，则元素去重的代码如下</p><pre><code class="language-cpp">for (int i = 0; i &lt; num.size(); i++) &#123;    if (used[i] == 1) continue; // 情况一    if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0) continue; // 情况二    // 选取 nums[i] 的相关操作&#125;</code></pre><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; nums, vector&lt;int&gt; used) &#123;    if (path.size() == nums.size()) &#123;        result.push_back(path);        return;    &#125;    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (used[i] == 1) continue; // 上层递归已经选取过 nums[i]        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0)            continue; // 上一层未选取 nums[i - 1] ，但是当前层会选取 nums[i - 1] ，故而无需选取 nums[i]        path.push_back(nums[i]);    // 更新 path 数组        used[i] = 1;                // 更新 used 数组        backTracking(nums, used);   // 递归到下一层        used[i] = 0;                // 回溯：撤销对 used 数组的更改        path.pop_back();            // 回溯：撤销对 path 数组的更改    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt; &amp;nums) &#123;    sort(nums.begin(), nums.end());  // 排序，以便去重    vector&lt;int&gt; used(nums.size(), 0);    backTracking(nums, used);    return result;&#125;</code></pre><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNDcuJUU1JTg1JUE4JUU2JThFJTkyJUU1JTg4JTk3SUkuaHRtbCMlRTYlOEIlOTMlRTUlQjElOTU=">代码随想录：全排列 II</span> 上提到， <code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 1) continue</code>  也可以实现同一层递归中不选取重复元素，只不过效率相对较低</p></blockquote><p>事实上，这里用到的  <code>used</code>  数组也是哈希法的一种实现</p><h1 id="回溯-哈希"><a class="anchor" href="#回溯-哈希">#</a> 回溯 + 哈希</h1><h2 id="算法思想-2"><a class="anchor" href="#算法思想-2">#</a> 算法思想</h2><p>在每一层定义一个哈希表，用来记录  <code>for</code>  循环处理过的元素</p><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; nums, vector&lt;int&gt; used) &#123;    if (path.size() == nums.size()) &#123;        result.push_back(path);        return;    &#125;    unordered_set&lt;int&gt; uset;        // 用于记录当前层 for 循环遍历情况    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (used[i] == 1) continue; // 上层递归已经选取过 nums[i]        if (uset.find(nums[i]) != uset.end()) continue; // 本层递归已经处理过 nums[i] 的重复元素        uset.insert(nums[i]);       // 记录元素        path.push_back(nums[i]);        used[i] = 1;        backTracking(nums, used);        used[i] = 0;        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt; &amp;nums) &#123;    vector&lt;int&gt; used(nums.size(), 0);    backTracking(nums, used);    return result;&#125;</code></pre><p>这里同时使用了  <code>used</code>  数组和哈希表  <code>unordered_set</code>  ，前者用于实现不同层次递归间的去重，后者用于单次递归中  <code>for</code>  循环的去重</p><p>注：使用哈希  <code>unordered_set</code>  去重的效率较低（时间复杂度和空间复杂度都比较高）</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 46. 全排列</title>
      <link href="/posts/1ba17777/"/>
      <url>/posts/1ba17777/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMv">46. Permutations</span></p><p>给定一个不含重复数字的数组  <code>nums</code>  ，返回其 所有可能的全排列 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">\le 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><code>nums</code>  中的所有整数 互不相同</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题要求的是数组的全排列，需要区分元素在集合中的先后顺序，即， <code>[1, 2]</code>  与  <code>[2, 1]</code>  是不同的排列</p><p>若将该问题抽象成树结构，则需记录所有叶节点</p><ul><li>因为数组中所有元素都需要处理一次，对应树结构上的叶节点</li><li>需要获取所有可能的排列方式，故而需要遍历所有叶节点</li></ul><p>此前的组合问题、分割问题、子集问题不考虑集合中元素的顺序，即，不管按照什么顺序来选取元素，只要元素组成的集合相同，得到的结果就是相同的</p><ul><li>我们之前采用的选取顺序是：从递归的上层到下层，元素是按照索引逐渐增大的顺序选取的（例如，当前层选择第  <code>i</code>  位元素，下一层只能选择第  <code>i</code>  位以后的元素）</li><li>此时，对于每一层递归而言，“上层已经访问过的元素” 与 “ 尚未访问过的元素 ” 之间具有明确的分界线，故而可以使用  <code>startIndex</code>  来标记  <code>for</code>  循环遍历的起点</li><li>具体可见 <a href="https://jiankychen.github.io/posts/d1540be5">LeetCode 77. 组合</a></li></ul><p>但是在排列问题中，从递归的上层到下层，元素并不全都按照索引递增顺序选取（这是因为，选择元素的先后顺序不同，会得到不同的排列），此时，“上层已经访问过的元素” 与 “ 尚未访问过的元素 ” 之间不存在分界线，因此不能再使用  <code>startIndex</code>  了</p><p>对此，可以引入  <code>used</code>  数组（或者是哈希表）来标记上层已经选取的元素，需注意，递归函数中的  <code>for</code>  循环要从  <code>0</code>  开始</p><h1 id="method-回溯-哈希"><a class="anchor" href="#method-回溯-哈希">#</a> Method: 回溯 + 哈希</h1><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;used) &#123;    if (path.size() == nums.size()) &#123; // 得到一个全排列，将其添加到结果集        result.push_back(path);        return;    &#125;    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (used[nums[i] + 10] == 1) continue; // nums[i] 在之前层次已经使用过        used[nums[i] + 10] = 1;   // 当前层次使用了 nums[i] ，更新标记        path.push_back(nums[i]);  // 将 nums[i] 添加到 path        backTracking(nums, used); // 递归到下一层        used[nums[i] + 10] = 0;   // 回溯：撤销对 nums[i] 的标记        path.pop_back();          // 回溯：撤销对 path 的更改    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; used(21, 0);  // nums[i] 的取值范围为 [-10, 10]    backTracking(nums, used);    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>nums</code>  的长度</p><ul><li>一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span> 种全排列</li><li>每一种排列方案填入  <code>result</code>  数组都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间，递归的深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>这里用  <code>used[nums[i] + 10]</code>  来表示  <code>nums[i]</code>  是否被使用过，其实也可以直接用  <code>used[i]</code>  的值来表示  <code>nums</code>  数组的第  <code>i</code>  位是否被使用过</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 491. 递增子序列</title>
      <link href="/posts/8beb3ed8/"/>
      <url>/posts/8beb3ed8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ub24tZGVjcmVhc2luZy1zdWJzZXF1ZW5jZXMv">491. Increasing Subsequences</span></p><p>给你一个整数数组  <code>nums</code>  ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [4,4,3,2,1]输出：[[4,4]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">\le 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题属于子集问题，需要记录所有可行的子集。即，如果将该问题抽象成一棵树，则需要记录树上所有满足条件的节点</p><p>类似于 <a href="https://jiankychen.github.io/posts/a06c07a7">LeetCode 90. 子集 II</a> ，本题的  <code>nums</code>  数组也同样含有重复元素，因此，不能在同一层递归中取出重复元素（但可以分别在不同层次的递归中取出重复元素），即，需要对  <code>for</code>  循环的横向遍历进行去重</p><p>然而，不同于 <a href="https://jiankychen.github.io/posts/a06c07a7">LeetCode 90. 子集 II</a> ，本题需要的是子序列，元素之间的相对位置关系不能更改，因此不能对数组  <code>nums</code>  进行排序。故而不能再采用 <a href="https://jiankychen.github.io/posts/a06c07a7">LeetCode 90. 子集 II</a> 中的去重方式</p><p>对此，可以采用哈希法来去重</p><ul><li>由于需要对每一层递归的  <code>for</code>  循环遍历进行去重，每一层都需要定义一个数组来实现哈希表（本题的  <code>nums[i]</code>  取值范围较小，可直接用数组实现哈希法）</li><li>特别地，每一层递归中的哈希数组仅作用于当前层，不影响其他层，故而下一层可以使用上一层已经选择过的、数组  <code>nums</code>  中的重复元素</li></ul><p>此外，题目要求每个子序列都是递增的，因此，在把元素放入子集前，还需要比较该元素与子集中的最后一个元素进行比较</p><h1 id="method-回溯-哈希"><a class="anchor" href="#method-回溯-哈希">#</a> Method: 回溯 + 哈希</h1><p>算法思路：</p><ol><li><p>在使用数组  <code>used</code>  实现哈希表时，由于  <code>nums[i]</code>  的取值范围为  <code>[-100, 100]</code>  ，我们可以将  <code>nums[i]</code>  映射到  <code>used</code>  数组中索引为  <code>nums[i] + 100</code>  的位置。即</p><ul><li>若  <code>used[nums[i] + 100] == 1</code>  ，本层递归已经选过  <code>nums[i]</code>  这个数，不再重复选择</li><li>若  <code>used[nums[i] + 100] == 0</code>  ，本层递归没有选过  <code>nums[i]</code>  这个数，可以考虑选择  <code>nums[i]</code> （因为还需要判断其是否能够构成新的递增序列）</li></ul></li><li><p>本题要求递增子序列长度至少为 2 ，因此，在将序列加入到结果集前需要检验序列的长度</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; nums, int index) &#123;    if (path.size() &gt; 1) &#123;       // 需要记录所有的递增子序列（子序列中至少要有两个元素）        result.push_back(path);        // 注意，这里不能加 return ，因为要遍历树上所有节点    &#125;    vector&lt;int&gt; used(201, 0);    // 用于标记 nums[i] 这个数是否已经操作过    for (int i = index; i &lt; nums.size(); i++) &#123;        if (!path.empty() &amp;&amp; nums[i] &lt; path.back() || used[nums[i] + 100] == 1)            continue;            // 非递增，或者，当前递归层已经操作过 nums[i] 这个数        path.push_back(nums[i]);        used[nums[i] + 100] = 1; // nums[i] 被选择，更新标记        backTracking(nums, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt; &amp;nums) &#123;    backTracking(nums, 0);    return result;&#125;</code></pre><p>注意，在定义  <code>used</code>  数组时，需要初始化：大小为  <code>201</code>  ，每个元素值为  <code>0</code></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0OTEuJUU5JTgwJTkyJUU1JUEyJTlFJUU1JUFEJTkwJUU1JUJBJThGJUU1JTg4JTk3Lmh0bWw=">代码随想录：递增子序列</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 90. 子集 II</title>
      <link href="/posts/a06c07a7/"/>
      <url>/posts/a06c07a7/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLWlpLw==">90. Subsets II</span></p><p>给你一个整数数组  <code>nums</code>  ，其中<strong>可能包含重复元素</strong>，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>与 <a href="https://jiankychen.github.io/posts/7ea8ca7d">LeetCode 78. 子集</a> 相比，本题的  <code>nums</code>  数组含有重复元素，因此，不能在同一层递归中取出重复元素（但可以分别在不同层次的递归中取出重复元素），即，需要对  <code>for</code>  循环的横向遍历进行去重</p><p>去重的思路可参考 <a href="https://jiankychen.github.io/posts/e3119804">LeetCode 40. 组合总和 II</a></p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>针对不同的去重方法，有以下两种实现</p><h2 id="排序"><a class="anchor" href="#排序">#</a> 排序</h2><p>采用 <a href="https://jiankychen.github.io/posts/e3119804">LeetCode 40. 组合总和 II</a> 中的去重方式</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; &amp;nums, int index) &#123;    result.push_back(path);    for (int i = index; i &lt; nums.size(); i++) &#123;        if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) continue; // 去重，避免在同一层递归中取出重复元素        path.push_back(nums[i]);        backTracking(nums, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end()); // 排序，以便去重    backTracking(nums, 0);    return result;&#125;</code></pre><p>这里将  <code>vector&lt;vector&lt;int&gt;&gt; result;</code>  和  <code>vector&lt;int&gt; path;</code>  作为全局变量，实际上也可按照 <a href="https://jiankychen.github.io/posts/7ea8ca7d">LeetCode 78. 子集</a> 中的写法，将其作为递归函数的参数（建议采用引用传递的方式传入参数）</p><h2 id="哈希"><a class="anchor" href="#哈希">#</a> 哈希</h2><p>思想：在每一层定义一个哈希表，用来记录  <code>for</code>  循环处理过的元素</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;    result.push_back(path);    unordered_set&lt;int&gt; uset; // 用于记录当前层的 for 循环遍历情况    for (int i = startIndex; i &lt; nums.size(); i++) &#123;        if (uset.find(nums[i]) != uset.end()) &#123; // 当前层已经处理过 nums[i]            continue;        &#125;        uset.insert(nums[i]);        path.push_back(nums[i]);        backTracking(nums, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end());    backTracking(nums, 0);    return result;&#125;</code></pre><p>注：使用哈希  <code>unordered_set</code>  去重的效率较低（时间复杂度和空间复杂度都比较高）</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5QiU5RSVFNiVCQSVBRiVFNyVBRSU5NyVFNiVCMyU5NSVFNSU4RSVCQiVFOSU4NyU4RCVFOSU5NyVBRSVFOSVBMiU5OCVFNyU5QSU4NCVFNSU4RiVBNiVFNCVCOCU4MCVFNyVBNyU4RCVFNSU4NiU5OSVFNiVCMyU5NS5odG1sI185MC0lRTUlQUQlOTAlRTklOUIlODZpaQ==">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 78. 子集</title>
      <link href="/posts/7ea8ca7d/"/>
      <url>/posts/7ea8ca7d/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLw==">LeetCode 78. Subsets</span></p><p>给你一个整数数组  <code>nums</code>  ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><code>nums</code>  中的所有元素 <strong>互不相同</strong></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>组合问题、分割问题、子集问题都可以抽象为一棵树，其中，<strong>组合问题和分割问题是在收集树的叶节点，子集问题是收集树的所有节点</strong></p><p>因此，可以用回溯搜索法（枚举法）遍历整棵树，并记录所有的节点（每个节点都是一个子集）</p><p height="200px"><img data-src="/posts/7ea8ca7d/example.png" class=""></p><p>注意，子集中的元素是无序的，即，子集 {1, 2} 和 子集 {2, 1} 是一样的，因此，每一层递归的  <code>for</code>  循环起始位置不能重复</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNzguJUU1JUFEJTkwJUU5JTlCJTg2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：子集</span></p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><ol><li><p>递归函数的参数</p><ul><li><code>vector&lt;int&gt; nums</code>  ：原始数组</li><li><code>vector&lt;vector&lt;int&gt;&gt; &amp;result</code>  ：存放所有的子集</li><li><code>vector&lt;int&gt; path</code>  ：当前的子集</li><li><code>int index</code>  ： <code>for</code>  循环遍历起点</li></ul></li><li><p>递归终止条件：剩余集合为空（即，到达叶节点， <code>index == nums.size()</code>  ），递归结束</p></li><li><p>单层搜索的逻辑： <code>for</code>  循环遍历  <code>nums</code>  数组元素  <code>nums[i]</code> （从索引  <code>index</code>  开始遍历）：</p><ul><li>更新子集：将元素  <code>nums[i]</code>  添加到子集  <code>path</code>  中</li><li>存储结果：将子集  <code>path</code>  添加到结果数组  <code>result</code>  中</li><li>递归到下一层：继续扩充  <code>path</code>  这一子集（下一层递归的  <code>for</code>  循环从  <code>i + 1</code>  开始遍历）</li><li>回溯：撤销本次  <code>for</code>  循环对  <code>path</code>  的更改</li></ul></li></ol><p>特别地，由于空集也是数组  <code>nums</code>  的一个子集，需要将空集  <code>[]</code>  也添加到  <code>result</code>  当中</p><blockquote><p>建议将  <code>vector&lt;int&gt; nums</code>  和  <code>vector&lt;int&gt; path</code>  改为引用传递，即，采用  <code>vector&lt;int&gt; &amp;nums</code>  和  <code>vector&lt;int&gt; &amp;path</code>  形式作为递归函数的参数</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">void backTracking(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt; path, int index) &#123;    if (index == nums.size()) return; // 递归终止条件，这里可以不加这个条件    for (int i = index; i &lt; nums.size(); i++) &#123;        path.push_back(nums[i]); // 更新当前子集        result.push_back(path);  // 将当前子集添加到 result 数组        backTracking(nums, result, path, i + 1); // 递归到下一层        path.pop_back();         // 回溯    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    result.push_back(path); // 子集为空集的情况    backTracking(nums, result, path, 0);    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>nums</code>  的长度</p><ul><li>一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 个子集</li><li>构造每个子集的时间代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间，递归的最大深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>本题可以将  <code>result.push_back(path);</code>  放到递归函数体的第一行，即，每次递归时都会将子集  <code>path</code>  添加到目标数组  <code>result</code>  中。此时，不需要再单独将空集  <code>[]</code>  添加到目标数组</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 93. 复原 IP 地址</title>
      <link href="/posts/a920fddd/"/>
      <url>/posts/a920fddd/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXN0b3JlLWlwLWFkZHJlc3Nlcy8=">93. Restore IP Addresses</span></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于  <code>0</code>  到  <code>255</code>  之间组成，且不能含有前导  <code>0</code> ），整数之间用  <code>'.'</code>  分隔。</p><ul><li>例如： <code>&quot;0.1.2.201&quot;</code>  和  <code>&quot;192.168.1.1&quot;</code>  是 <strong>有效</strong> IP 地址，但是  <code>&quot;0.011.255.245&quot;</code> 、 <code>&quot;192.168.1.312&quot;</code>  和  <code>&quot;192.168@1.1&quot;</code>  是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串  <code>s</code>  ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在  <code>s</code>  中插入  <code>'.'</code>  来形成。你 <strong>不能</strong> 重新排序或删除  <code>s</code>  中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><code>s</code>  consists of digits only.</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题是一个分割问题（将字符串  <code>s</code>  分割成四个子串），需要列举出所有可行的分割方案</p><p>其中，以下情况无法形成有效的 IP 地址</p><ul><li>子串以 '0' 开头，且子串长度大于 1 （即，对应的整数有先导 0）</li><li>子串有非数字字符（本题的  <code>s</code>  只含有数字字符，无需考虑这一情况）</li><li>子串对应的整数大于 255</li></ul><p>解题思路类似于 <a href="https://jiankychen.github.io/posts/eeb65480">LeetCode 131. 分割回文串</a></p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><ol><li><p>递归函数的参数</p><ul><li><code>vector&lt;string&gt; &amp;result</code>  ：存放所有可行的分割方案（即，所有有效的 IP 地址）</li><li><code>string path</code>  ：当前的分割方案</li><li><code>int startIndex</code>  ：当前递归层的分割起始位置</li><li><code>int pointNum</code>  ：此前已添加的逗点数量</li></ul></li><li><p>递归终止条件：如果已经添加了 3 个逗点（即， <code>pointNum == 3</code>  ），说明已经将字符串分成了四段，分割完成，递归结束</p><ul><li>结束递归前，需要判断当前分割方案是否合法（更准确地说，需要判断第四个整数是否合法，因为前面三个整数在之前的递归层中已经判断过），若当前分割方案合法，则需将其加入到结果集  <code>result</code>  之中</li></ul></li><li><p>单层搜索的逻辑：利用  <code>for</code>  循环遍历分割线的位置  <code>for (int i = startIndex; i &lt; s.size(); i++)</code></p><ul><li>截取  <code>[startIndex, i]</code>  这一索引区间内的字符子串，记作  <code>str</code></li><li>判断子串  <code>str</code>  是否合法，若不合法，跳过当前分割方案，若合法，继续下一步</li><li>递归到下一层，以分割后续字符。其中，传入下一层的  <code>path</code>  需在当前  <code>path</code>  的基础上加上  <code>str + '.'</code>  ，下一层的分割起始位置  <code>startIndex</code>  需为  <code>i + 1</code>  ，逗点数量  <code>pointNum</code>  需更新为  <code>pointNum + 1</code> ）</li><li>回溯：撤销对  <code>path</code>  和  <code>pointNum</code>  的更改，以便  <code>for</code>  循环继续遍历</li></ul></li></ol><p>特别地，针对上述算法可以做以下考虑：</p><ul><li>可以在分割字符串  <code>s</code>  前对  <code>s</code>  的长度进行判断，若长度小于 4 ，或者长度大于 12，说明  <code>s</code>  无法形成有效 IP 地址，直接返回空数组即可</li><li>子串对应的整数不能大于 255 ，因此，分割的子串长度不能超过 3 ， <code>for</code>  循环遍历分割线位置时无需考虑长度大于 3 的子串</li></ul><blockquote><p>这里将  <code>string path</code>  作为递归函数的参数传入，但采用的是值传递，调用函数时会申请额外的内存空间。为降低空间复杂度，建议采用引用传递，即，将  <code>string path</code>  修改为  <code>string &amp;path</code></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">bool isValid(string s, int left, int right) &#123; // 判断 s[left, right] 对应的整数是否有效    if (s[left] == '0' &amp;&amp; right &gt; left) return false; // 整数有先导 0 ，无效    string str = s.substr(left, right - left + 1);    // 取出索引为 [left, right] 的子串    int num = 0;    for (int i = left; i &lt;= right; i++) &#123;             // 将 str 转换为 int 型整数        num = num * 10 + (s[i] - '0');        if (num &gt; 255) return false;                  // 整数大于 255 ，无效    &#125;    return true;&#125;void backTracking(vector&lt;string&gt; &amp;result, string path, string s, int startIndex, int pointNum) &#123;    if (pointNum == 3) &#123; // 已经添加 3 个逗点，分割结束        if (startIndex &lt; s.size() &amp;&amp; isValid(s, startIndex, s.size() - 1)) &#123; // 判断最后一个整数是否有效            path += s.substr(startIndex, s.size() - startIndex); // 将最后一个整数放入 path            result.push_back(path);                              // 将 path 放入结果集        &#125;        return;    &#125;    for (int i = startIndex; i &lt; s.size() &amp;&amp; i &lt;= startIndex + 2; i++) &#123; // 遍历分割线位置，其中，每个整数最多三位        if (isValid(s, startIndex, i)) &#123; // 判断 s[startIndex, i] 对应整数是否有效            string str = s.substr(startIndex, i - startIndex + 1);            backTracking(result, path + str + '.', s, i + 1, pointNum + 1); // 递归到下一层        &#125;    &#125;&#125;vector&lt;string&gt; restoreIpAddresses(string s) &#123;    vector&lt;string&gt; result;    if (s.size() &lt; 4 || s.size() &gt; 12) return result; // IP 地址至少 4 位，至多 12 位    string path;    backTracking(result, path, s, 0, 0);    return result;&#125;</code></pre><p>其中， <code>backTracking(result, path + str + '.', s, i + 1, pointNum + 1);</code>  既实现了递归到一层时的参数更新，也实现了回溯到当前层时的参数回退</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwOTMuJUU1JUE0JThEJUU1JThFJTlGSVAlRTUlOUMlQjAlRTUlOUQlODAuaHRtbA==">代码随想录：复原 IP 地址</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 131. 分割回文串</title>
      <link href="/posts/eeb65480/"/>
      <url>/posts/eeb65480/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLXBhcnRpdGlvbmluZy8=">131. Palindrome Partitioning</span></p><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;a&quot;输出：[[&quot;a&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">\le 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span></li><li><code>s</code>  仅由小写英文字母组成</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>分割问题本质上与组合问题类似，例如字符串 &quot;aaba&quot;</p><ul><li>组合问题：选取一个 &quot;a&quot; 之后，再在 &quot;aba&quot; 中选取第二个，依此类推</li><li>分割问题：分割第一段的 &quot;a&quot; 之后，再在 &quot;aba&quot; 中分割第二段，依此类推</li></ul><p>因此，分割问题也可以抽象成一棵树</p><p height="200px"><img data-src="/posts/eeb65480/example.jpg" class=""></p><p>其中， <code>for</code>  循环用于遍历分割线的位置，递归用于将分割线后面的字符做进一步的分割</p><p>根据题中对回文串的定义可知，回文串应为左右对称的字符串，可通过双指针法（定义左、右指针）来判断字符串是否左右对称</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMzEuJUU1JTg4JTg2JUU1JTg5JUIyJUU1JTlCJTlFJUU2JTk2JTg3JUU0JUI4JUIyLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：分割回文串</span></p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><ol><li><p>确定递归函数的参数</p><ul><li><code>string s</code>  ：原始的字符串</li><li><code>int startIndex</code>  ：待分割字符串的起始位置</li></ul></li><li><p>递归的终止条件： <code>startIndex</code>  到达字符串  <code>s</code>  的尾后，字符串  <code>s</code>  已分割完成，当前递归结束</p></li><li><p>单层搜索的逻辑</p><ul><li><code>for</code>  循环，遍历分割线的位置  <code>i</code>  （也就相当于遍历不同的分割方案）<ul><li>起始位置至分割线之间的字符，即，索引为  <code>[startIndex, i]</code>  的字符，就是当前分割所得的子串，记作  <code>str</code></li><li>判断  <code>str</code>  是否为回文串：若不是回文串，则说明当前分割不可行，需跳过当前分割方案；若是回文串，则进行下一步操作</li><li>将回文串  <code>str</code>  保存到  <code>path</code>  （分割所得回文串的集合）当中</li><li>递归到下一层，继续分割 索引为  <code>[i + 1, s.size() - 1]</code>  的字符</li><li>回溯，弹出本次已经填在  <code>path</code>  中的子串  <code>str</code>  ，以便遍历其余分割方案</li></ul></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; result;  // 存放所有的分割方案vector&lt;string&gt; path;            // 存放当前已经分割的回文子串bool isPalindrome(string str) &#123; // 判断 str 是否为回文串    if (str.size() == 0) return true;    for (int l = 0, r = str.size() - 1; l &lt; r; l++, r--) &#123; // 双指针        if (str[l] != str[r]) return false;    &#125;    return true;&#125;void backTracking(string s, int startIndex) &#123; // 将以 startIndex 为起始索引的子串进行分割    if (startIndex == s.size()) &#123; // 分割的起始位置在 s 尾后，说明分割已完成        result.push_back(path);   // 存储当前的分割方案        return;    &#125;    for (int i = startIndex; i &lt; s.size(); i++) &#123; // 对分割线的位置进行遍历        // 获取 s 中索引为 [startIndex, i] 的子串        string str(s.begin() + startIndex, s.begin() + i + 1);        if (!isPalindrome(str)) continue; // 分割得到的子串不是回文串，跳过当前分割方案        path.push_back(str);    // 子串是回文串，将其放入 path        backTracking(s, i + 1); // 递归到下一层，分割字符串 s 中的后续字符        path.pop_back();        // 回溯，删除已存储的字符串 str    &#125;&#125;vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;    backTracking(s, 0);    return result;&#125;</code></pre><p>其中， <code>string str(s.begin() + startIndex, s.begin() + i + 1);</code>  等效于  <code>string str = s.substr(startIndex, i - startIndex + 1);</code></p><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>上述算法利用了双指针法判断字符串是否为回文串，这会带来重复计算</p><p>以分割 &quot;aaba&quot; 为例</p><ul><li>如果第一次分割子串 &quot;a&quot; ，剩余子串为 &quot;aba&quot; ，则第二次分割需要分别判断 &quot;a&quot; &quot;ab&quot; &quot;aba&quot; 是否为回文串。进一步地，如果第二次分割的子串为 &quot;a&quot; ，则剩余子串为 &quot;ba&quot; ，第三次分割需要分别判断 &quot;b&quot; &quot;ba&quot; 是否为回文串</li><li>如果第一次分割子串为 &quot;ab&quot; ，剩余子串为 &quot;ba&quot; ，第二次分割需要分别判断 &quot;b&quot; &quot;ba&quot; 是否为回文串</li><li>因此，子串 &quot;b&quot; 与 &quot;ba&quot; 被重复判断过</li></ul><p>对此，可以先将字符串  <code>s</code>  中的每个子串进行预处理（判断其是否为回文串），可采用的办法包括：动态规划、记忆化搜索，具体可见 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLXBhcnRpdGlvbmluZy9zb2x1dGlvbi9mZW4tZ2UtaHVpLXdlbi1jaHVhbi1ieS1sZWV0Y29kZS1zb2x1dGlvLTZqa3Yv">力扣官方题解：分割回文串</span></p><p>这里采用动态规划方法进行预处理：</p><ul><li><p><code>f[i][j]</code>  表示索引  <code>[i, j]</code>  之间字符组成的子串是否为回文串</p></li><li><p>状态转移方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mtext>若 </mtext><mi>i</mi><mo>≥</mo><mi>j</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>若 </mtext><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f[i][j] = \begin{cases}True, \textrm{若} \ i \ge j \\(f[i + 1][j - 1]) \land (s[i] == s[j]), \textrm{若} \ i &lt; j\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord textrm cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord textrm cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∧</span></span></span></span> 表示逻辑与，即，索引  <code>[i, j]</code>  的子串为回文串，有以下三种情况：</p><ul><li>该子串为空</li><li>该子串长度为 1（即  <code>i == j</code>  ）</li><li>首尾字符相同（即  <code>s[i] == s[j]</code>  ）并且 索引  <code>[i + 1, j - 1]</code>  子串为回文串</li></ul></li></ul><p>由此，只需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间就能判断任意子串为回文串</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; result;vector&lt;string&gt; path;vector&lt;vector&lt;int&gt;&gt; f; // 动态规划的结果void backTracking(string s, int startIndex) &#123;    if (startIndex == s.size()) &#123;        result.push_back(path);        return;    &#125;    for (int i = startIndex; i &lt; s.size(); i++) &#123;        if (!f[startIndex][i]) continue; // 字符串 s[startIndex, i] 不是回文串        string str(s.begin() + startIndex, s.begin() + i + 1);        path.push_back(str);        backTracking(s, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;    f.assign(s.size(), vector&lt;int&gt;(s.size(), true)); // 初始化 f ：值全为 true    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;        // 计算索引为 [i, j] 的子串是否为回文串        for (int j = i + 1; j &lt; s.size(); j++) &#123;            f[i][j] = (s[i] == s[j]) &amp;&amp; (f[i + 1][j - 1]); // 状态转移        &#125;    &#125;    backTracking(s, 0);    return result;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 40. 组合总和 II</title>
      <link href="/posts/e3119804/"/>
      <url>/posts/e3119804/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWkv">40. Combination Sum II</span></p><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。</p><p><strong>示例 1：</strong></p><pre><code>输入：candidates = [10,1,2,7,6,1,5], target = 8输出：[[1,1,6],[1,2,5],[1,7],[2,6]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：candidates = [2,5,2,1,2], target = 5输出：[[1,2,2],[5]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>candidates.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>candidates[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题与 <a href="https://jiankychen.github.io/posts/c2253dcd">LeetCode 39. 组合总和</a> 有较大不同，本题的  <code>candidates</code>  数组包含重复元素，且每个元素只能在子集中出现一次（重复元素可以分别出现一次）</p><p>对此，递归下一层时需要从  <code>i + 1</code>  开始  <code>for</code>  循环的遍历，以使得每个元素最多只使用一次（重复的元素可以分别使用一次）</p><p>但是，如果仅仅是这样的话，结果将会产生重复的组合，以 示例 1 为例，结果为  <code>[[1,1,6],[1,2,5],[1,7],[1,2,5],[1,7],[2,6]]</code>  ，可以发现  <code>[1,2,5],[1,7]</code>  这两个重复出现了，此时回溯搜索的第一层如下所示：</p><p><img data-src="/posts/e3119804/example.png" class=""></p><p>可以发现，在当前的递归层中，由于  <code>candidates</code>  数组含有重复元素， <code>for</code>  循环进行横向遍历时会取出重复元素（误当成不同的子树），产生重复的子集  <code>[1,2,5,6,7,10]</code>  ，最终导致  <code>[1,2,5],[1,7]</code>  在答案中出现两次</p><p>因此，还需要对同一层的  <code>for</code>  循环进行去重，避免在同一层递归中取出重复元素</p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>有以下两种方法可以用来去重</p><h2 id="排序"><a class="anchor" href="#排序">#</a> 排序</h2><p>可直接利用  <code>for</code>  循环的起点  <code>index</code>  来实现当前层的去重</p><ul><li>首先须对  <code>candidates</code>  进行排序，使得重复元素的出现是连续的</li><li>在  <code>for</code>  循环遍历  <code>i</code>  的过程中，如果发现  <code>i &gt; index</code>  且  <code>candidates[i] == candidates[i - 1]</code>  ，则说明  <code>candidates[i]</code>  这个元素已经处理过了，不能再重复处理，因此，跳过当前  <code>i</code></li></ul><p>类似于 <a href="https://jiankychen.github.io/posts/c2253dcd">LeetCode 39. 组合总和</a> ，可对回溯搜索进行剪枝优化</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; candidates, int target, int sum, int index) &#123;    if (sum == target) &#123;        result.push_back(path);        return;    &#125;    for (int i = index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; // 剪枝        if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue; // 同一层的去重        path.push_back(candidates[i]);        sum += candidates[i];        backTracking(candidates, target, sum, i + 1); // 不含重复元素，下一层从 i + 1 开始遍历        path.pop_back();        sum -= candidates[i];    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;    sort(candidates.begin(), candidates.end()); // 排序，以实现 去重 以及 剪枝    backTracking(candidates, target, 0, 0);    return result;&#125;</code></pre><p>注意：条件  <code>i &gt; index</code>  不能改成  <code>i &gt; 0</code>  ，因为当前层的  <code>for</code>  循环是从  <code>index</code>  开始遍历的，只需判断在当前层是否处理过元素  <code>candidates[i]</code>  ，而不需要判断上一层是否处理过元素  <code>candidates[i]</code></p><ul><li><code>if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue;</code>  跳过的是同一层的重复元素</li><li><code>if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1]) continue;</code>  不仅会跳过同一层递归里的重复元素，也会跳过不同层次递归的重复元素（即，上一层处理过元素  <code>candidates[index - 1]</code>  ，下一层将不能够处理重复元素  <code>candidates[index]</code>  ）。在此情况下，针对 示例 1 得到的结果为  <code>[[1,2,5],[1,7],[2,6]]</code>  ，缺失了  <code>[1,1,6]</code>  这一组合</li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNDAuJUU3JUJCJTg0JUU1JTkwJTg4JUU2JTgwJUJCJUU1JTkyJThDSUkuaHRtbA==">代码随想录：组合总和 II</span></p><h2 id="哈希-排序"><a class="anchor" href="#哈希-排序">#</a> 哈希 + 排序</h2><p>在每一层定义一个哈希表，用来记录  <code>for</code>  循环处理过的元素</p><blockquote><p>这里使用排序是为了剪枝，并不是为了去重</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; candidates, int target, int sum, int index) &#123;    if (sum == target) &#123;        result.push_back(path);        return;    &#125;    unordered_set&lt;int&gt; uset; // 用于记录当前层的 for 循环遍历情况    for (int i = index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; // sum + candidates[i] &lt;= target 用以剪枝        if (uset.find(candidates[i]) != uset.end()) continue; // 同一层的去重        uset.insert(candidates[i]);        path.push_back(candidates[i]);        sum += candidates[i];        backTracking(candidates, target, sum, i + 1);        path.pop_back();        sum -= candidates[i];    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;    sort(candidates.begin(), candidates.end()); // 排序，便于剪枝    backTracking(candidates, target, 0, 0);    return result;&#125;</code></pre><p>使用哈希  <code>unordered_set</code>  去重的效率较低（时间复杂度和空间复杂度都比较高）</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5QiU5RSVFNiVCQSVBRiVFNyVBRSU5NyVFNiVCMyU5NSVFNSU4RSVCQiVFOSU4NyU4RCVFOSU5NyVBRSVFOSVBMiU5OCVFNyU5QSU4NCVFNSU4RiVBNiVFNCVCOCU4MCVFNyVBNyU4RCVFNSU4NiU5OSVFNiVCMyU5NS5odG1sI180MC0lRTclQkIlODQlRTUlOTAlODglRTYlODAlQkIlRTUlOTIlOEMtaWk=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 39. 组合总和</title>
      <link href="/posts/c2253dcd/"/>
      <url>/posts/c2253dcd/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0v">39. Combination Sum</span></p><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><pre><code>输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：    2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。    7 也是一个候选， 7 = 7 。    仅有这两种组合。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：candidates = [2,3,5], target = 8输出：[[2,2,2,2],[2,3,3],[3,5]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：candidates = [2], target = 1输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>candidates.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>candidates[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>candidates</code>  的所有元素互不相同</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>注意本题  <code>candidates</code>  中的元素可以被无限制重复选取，下一层递归中的  <code>for</code>  循环遍历起点应与当前层相同</p><p>本题对子集的元素数量并没有要求，因此递归返回的条件应为：元素和大于等于目标和</p><p>搜索过程如下所示：</p><p height="200px"><img data-src="/posts/c2253dcd/example.png" class=""></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; candidates, int target, int sum, int startIndex) &#123;    if (sum &gt; target) return;    if (sum == target) &#123;        result.push_back(path);        return;    &#125;    for (int i = startIndex; i &lt; candidates.size(); i++) &#123;        path.push_back(candidates[i]);        sum += candidates[i];        backTracking(candidates, target, sum, i); // 元素可重复选取，下一层从 i 开始        path.pop_back();        sum -= candidates[i];    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;    backTracking(candidates, target, 0, 0);    return result;&#125;</code></pre><h2 id="优化剪枝"><a class="anchor" href="#优化剪枝">#</a> 优化（剪枝）</h2><p>可以先对  <code>candidates</code>  进行排序（元素按升序排列）</p><p>在递归过程中，如果当前层的  <code>sum + candidates[i]</code>  （即，下一层的  <code>sum</code>  ）已经大于  <code>target</code>  ，无需再针对当前  <code>candidates[i]</code>  进行下一层的递归，也无需再继续遍历当前层的  <code>candidates</code>  数组（即，无需再进行  <code>for</code>  循环的遍历）</p><p height="200px"><img data-src="/posts/c2253dcd/optimized.png" class=""></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backTracking(vector&lt;int&gt; candidates, int target, int sum, int startIndex) &#123;    if (sum == target) &#123; // 注意这里无需处理 sum &gt; target 的情况        result.push_back(path);        return;    &#125;    for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; // 剪枝        path.push_back(candidates[i]);        sum += candidates[i];        backTracking(candidates, target, sum, i);        path.pop_back();        sum -= candidates[i];    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;    sort(candidates.begin(), candidates.end()); // 排序，以便剪枝    backTracking(candidates, target, 0, 0);    return result;&#125;</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMzkuJUU3JUJCJTg0JUU1JTkwJTg4JUU2JTgwJUJCJUU1JTkyJThDLmh0bWwjJUU1JTg5JUFBJUU2JTlFJTlEJUU0JUJDJTk4JUU1JThDJTk2">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 17. 电话号码的字母组合</title>
      <link href="/posts/39fb19/"/>
      <url>/posts/39fb19/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyLw==">LeetCode 17. Letter Combinations of a Phone Number</span></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意，1 不对应任何字母。</p><p><img data-src="/posts/39fb19/map.png" class=""></p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：digits = &quot;&quot;输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>digits.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\le 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></li><li><code>digits[i]</code>  is a digit in the range  <code>['2', '9']</code> .</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题每一个数字代表的是不同集合，也就是求不同集合之间的组合</p><p>首先，需要建立 键盘数字 与 字符串 之间的映射，这里使用字符串数组将数字 0 - 9 与 字母 对应起来</p><pre><code class="language-cpp">const string letterMap[10] = &#123;    &quot;&quot;,     // 数字 0    &quot;&quot;,     // 数字 1    &quot;abc&quot;,  // 数字 2    &quot;def&quot;,    &quot;ghi&quot;,    &quot;jkl&quot;,    &quot;mno&quot;,    &quot;pqrs&quot;,    &quot;tuv&quot;,    &quot;wxyz&quot;  // 数字 9&#125;</code></pre><p>本题可通过回溯算法解题</p><ul><li>递归函数内嵌一个  <code>for</code>  循环， <code>for</code>  循环用于遍历数字所对应的字母（即，遍历  <code>letterMap</code>  ）</li><li>递归用于实现对数字的遍历（即，遍历  <code>digits</code>  ）</li></ul><p height="200px"><img data-src="/posts/39fb19/example.png" class=""></p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路： <code>for</code>  循环横向遍历，递归纵向遍历，回溯不断调整结果集</p><p>本题输入的  <code>digits[i]</code>  是范围  <code>[2, 9]</code>  之间的数字，因此不需要考虑 0 和 1 这样的特殊情况</p><p>代码实现：</p><pre><code class="language-cpp">const string letterMap[10] = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;vector&lt;string&gt; result;string path;void backtracking(string digits, int index) &#123;    if (path.size() == digits.size()) &#123;        result.push_back(path);        return;    &#125;    int num = digits[index] - '0';   // 当前遍历到的数字（index 指向的数字）    string letters = letterMap[num]; // 当前数字对应的字符串    for (int i = 0; i &lt; letters.size(); i++) &#123; // for 循环：遍历 letterMap[num] 字符串        path.push_back(letters[i]);      // 处理节点        backtracking(digits, index + 1); // 递归到下一层：选取第 index + 1 位数字对应的字母        path.pop_back();                 // 回溯    &#125;&#125;vector&lt;string&gt; letterCombinations(string digits) &#123;    if (digits.size() == 0) return result; // 处理 digits 为空这一特殊情况    backtracking(digits, 0);    return result;&#125;</code></pre><p>须注意： <code>digits</code>  是  <code>string</code>  型的对象，对应的元素  <code>digits[index]</code>  是  <code>char</code>  型，需先将  <code>char</code>  型转换成  <code>int</code>  型才能索引字符串数组  <code>letterMap</code></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>3</mn><mi>m</mi></msup><mo>×</mo><msup><mn>4</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3^m \times 4^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是输入到  <code>digits</code>  中的、对应键盘上有三个字母的数字个数（包括数字 2、3、4、5、6、8），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是对应四个字母的数字个数（包括数字 7、9），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是输入数字的总个数，对应的字母组合一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mi>m</mi></msup><mo>×</mo><msup><mn>4</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">3^m \times 4^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归调用的层数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMTcuJUU3JTk0JUI1JUU4JUFGJTlEJUU1JThGJUI3JUU3JUEwJTgxJUU3JTlBJTg0JUU1JUFEJTk3JUU2JUFGJThEJUU3JUJCJTg0JUU1JTkwJTg4Lmh0bWw=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyL3NvbHV0aW9uL2RpYW4taHVhLWhhby1tYS1kZS16aS1tdS16dS1oZS1ieS1sZWV0Y29kZS1zb2x1dGlvLw==">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 216. 组合总和 III</title>
      <link href="/posts/382688bd/"/>
      <url>/posts/382688bd/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWlpLw==">LeetCode 216. Combination Sum III</span></p><p>找出所有相加之和为  <code>n</code>  的  <code>k</code>  个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：k = 3, n = 7输出：[[1,2,4]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：k = 3, n = 9输出：[[1,2,6],[1,3,5],[2,3,4]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：k = 4, n = 1输出：[]解释：不存在有效的组合</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>60</mn></mrow><annotation encoding="application/x-tex">\le 60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>类似于 <a href="https://jiankychen.github.io/posts/d1540be5">LeetCode 77. 组合</a> ，旨在查找满足条件的子集，只不过本题多出了一个条件，即， <code>k</code>  个数的和须为  <code>n</code></p><p>因此，需记录递归的路径和，并将递归的终止条件修改为：元素个数等于  <code>k</code>  且 路径和等于  <code>n</code></p><p height="200px"><img data-src="/posts/382688bd/example.png" class=""></p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><ol><li><p>定义三个全局变量</p><ul><li><code>vector&lt;vector&lt;int&gt;&gt; result</code>  ：所有可行路径</li><li><code>vector&lt;int&gt; path</code>  ：当前路径</li><li><code>int sum</code>  ：当前路径和</li></ul></li><li><p>确定回溯函数的参数</p><ul><li><code>int k</code>  ：目标子集的大小</li><li><code>int n</code>  ：目标和</li><li><code>int startIndex</code>  ：递归函数体中的  <code>for</code>  循环遍历起始位置</li></ul></li><li><p>回溯的终止条件：已经选取  <code>k</code>  个元素，即， <code>path.size() == k</code></p></li><li><p>单层搜索过程</p><ul><li>若已经选取  <code>k</code>  个元素，进一步判断当前路径和  <code>sum</code>  是否等于目标和  <code>n</code><ul><li>若是，记录当前路径，结束当前递归</li><li>若否，直接结束当前递归</li></ul></li><li>若未选取  <code>k</code>  个元素，利用  <code>for</code>  循环遍历  <code>startIndex</code>  至  <code>9</code>  之间的数，针对其中每个数，执行以下操作：<ul><li>更新当前路径以及路径和：将  <code>i</code>  加入到路径  <code>path</code>  中，并计算  <code>sum = sum + i</code></li><li>继续查找下一个数：递归到下一个数，即， <code>backtracking(k, n, i + 1)</code></li><li>回溯：回退路径  <code>path.pop_back</code>  ，回退路径和  <code>sum = sum - i</code></li></ul></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result; // 所有可行路径vector&lt;int&gt; path; // 当前路径int sum = 0; // 当前路径的和void backtracking(int k, int n, int startIndex) &#123;    if (path.size() == k) &#123;        if (sum == n) result.push_back(path); // 满足条件，将路径添加到目标数组        return; // path.size() == k 但sum != n 时，直接返回    &#125;    for (int i = startIndex; i &lt;= 9; i++) &#123; // 横向遍历        path.push_back(i); // 更新路径        sum += i;          // 更新路径和        backtracking(k, n, i + 1); // 递归到下一层，查找下一个数        path.pop_back();   // 回溯        sum -= i;          // 回溯    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;    backtracking(k, n, 1);    return result;&#125;</code></pre><h2 id="优化剪枝"><a class="anchor" href="#优化剪枝">#</a> 优化（剪枝）</h2><p>针对上述算法，可进行以下两个方面的剪枝：</p><ul><li><p>若当前路径和大于  <code>n</code>  ，不需要再向下查找（继续查找也无法找到可行解），直接结束当前递归</p></li><li><p>若 可供选择的剩余元素个数（  <code>9 - i + 1</code>  ）小于 仍需选择的元素个数（  <code>k - path.size()</code>  ），也不需要再继续向下查找</p></li></ul><p>代码实现</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;int sum = 0;void backtracking(int k, int n, int startIndex) &#123;    if (sum &gt; n) return; // 剪枝    if (path.size() == k) &#123;        if (sum == n) result.push_back(path);        return;    &#125;    for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) &#123; // 剪枝        path.push_back(i);        sum += i;        backtracking(k, n, i + 1);        path.pop_back();        sum -= i;    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;    backtracking(k, n, 1);    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mi>C</mi><mn>9</mn><mi>k</mi></msubsup><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(C_9^k \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mi>C</mi><mn>9</mn><mi>k</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(C_9^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 种组合（从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 个数中选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数），每种组合进行递归判断的时间代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，其中， <code>path</code>  数组所需空间、递归使用的栈空间均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMTYuJUU3JUJCJTg0JUU1JTkwJTg4JUU2JTgwJUJCJUU1JTkyJThDSUlJLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 77. 组合</title>
      <link href="/posts/d1540be5/"/>
      <url>/posts/d1540be5/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMv">77. Combinations</span></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 4, k = 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1, k = 1输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>针对示例  <code>n = 4, k = 2</code>  ，可通过以下代码来实现暴力搜索</p><pre><code class="language-cpp">int n = 4;for (int i = 1; i &lt;= n; i++) &#123;    for (int j = i + 1; j &lt;= n; j++) &#123;        cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;    &#125;&#125;</code></pre><p>但如果要解决 n 为 100 ，k 为 50 的情况，暴力搜索的写法需要嵌套 50 层  <code>for</code>  循环</p><p>此时，可以用递归来解决嵌套层数的问题，即，每一次的递归中嵌套一个  <code>for</code>  循环</p><p>这里可以把问题抽象为如下树形结构，回溯法的搜索过程就是这样一个树型结构的遍历过程， <code>for</code>  循环用来横向遍历，递归用来纵向遍历。其中，每搜索到一个叶节点，就是找到一个可行结果</p><p height="200px"><img data-src="/posts/d1540be5/1.png" class=""></p><p>可以发现， <code>n</code>  相当于树的宽度， <code>k</code>  相当于树的高度</p><h1 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h1><p>算法思路：</p><ol><li><p>确定回溯函数的参数与返回值</p><ul><li>参数：元素的取值范围  <code>n</code>  ，选取元素的个数  <code>k</code>  ，当前递归选择元素的起点  <code>startIndex</code><ul><li>每次从集合中选取元素，可选择的范围都会收缩， <code>startIndex</code>  就是用来记录选取元素的起始位置</li></ul></li><li>回溯算法一般不需要返回值，返回类型为  <code>void</code></li></ul></li><li><p>回溯函数的终止条件： <code>path</code>  数组大小等于  <code>k</code>  ，说明已经找到  <code>k</code>  个数的组合，记录当前结果即可返回</p></li><li><p>回溯函数的单层搜索过程</p><ul><li><code>for</code>  循环每次从  <code>startIndex</code>  开始遍历<ul><li>记遍历的元素为  <code>i</code></li><li>处理节点：将  <code>i</code>  放入  <code>path</code>  数组中（记录递归的路径）</li><li>递归到树的下一层：为子集选择下一个元素（注意，下一层搜索要从  <code>i + 1</code>  开始）</li><li>回溯：因为需要遍历这一层的其他子树，故而将  <code>i</code>  从  <code>path</code>  从取出</li></ul></li></ul></li></ol><blockquote><p>这里定义了  <code>vector&lt;vector&lt;int&gt;&gt; result</code>  和  <code>vector&lt;int&gt; path</code>  两个全局变量，分别存放所有可行的搜索结果、当前的搜索结果（递归的路径）。事实上，可以把这两个变量定义到递归函数的参数里，这里定义为全局变量有两方面的考虑：1) 函数参数过多时会影响可读性；2) 定义成全局变量可显式地表现出回溯的过程</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result; // 存放所有符合条件的搜索结果vector&lt;int&gt; path;           // 当前的搜索结果void DFS(int n, int k, int startIndex) &#123;    if (path.size() == k) &#123; // 子集的大小为 k ，符合条件        result.push_back(path); // 将当前搜索结果存入 result 数组        return;    &#125;    for (int i = startIndex; i &lt;= n; i++) &#123; // for 循环：控制树的横向遍历        path.push_back(i); // 处理节点         DFS(n, k, i + 1);  // 递归：控制树的纵向遍历，注意下一层搜索要从 i + 1 开始        path.pop_back();   // 回溯，撤销处理的节点    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;    DFS(n, k, 1);    return result;&#125;</code></pre><h2 id="优化剪枝"><a class="anchor" href="#优化剪枝">#</a> 优化（剪枝）</h2><p>事实上，当 可选择的剩余元素个数 小于 仍需选择的元素个数 时，不再存在可行方案，不需要再进行后续的搜索</p><p>换而言之，只有 可选择的剩余元素个数 大于等于 仍需选择的元素个数 时，才需进行搜索</p><p>因此，可对回溯搜索进行剪枝操作：</p><ul><li>当前已选择的元素个数为  <code>path.size()</code>  ，后续仍需选择  <code>k - path.size()</code>  个元素</li><li>在  <code>i</code>  被选择之前，区间  <code>[i, n]</code>  一共有  <code>n - i + 1</code>  个元素可供选择</li><li>因此， <code>for</code>  循环的循环控制条件应为  <code>n - i + 1 &gt;= k - path.size()</code>  ，即： <code>i &lt;= n - (k - path.size()) + 1</code></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void DFS(int n, int k, int startIndex) &#123;    if (path.size() == k) &#123;        result.push_back(path);        return;    &#125;    for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123; // 已剪枝        path.push_back(i); // 处理节点        DFS(n, k, i + 1);  // 递归：控制树的纵向遍历，注意下一层搜索要从 i + 1 开始        path.pop_back();   // 回溯，撤销处理的节点    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;    DFS(n, k, 1);    return result;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(C_n^k \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span> 种组合方案（从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数中选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数），其中每一种组合方案填入  <code>result</code>  数组都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 的时间</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，考虑了递归需要的栈空间以及临时数组  <code>path</code>  所需空间（未考虑存储答案的数组  <code>result</code>  ）</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNzcuJUU3JUJCJTg0JUU1JTkwJTg4Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMvc29sdXRpb24venUtaGUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/posts/b754d2ea/"/>
      <url>/posts/b754d2ea/</url>
      
        <content type="html"><![CDATA[<p>回溯法也叫回溯搜索法，它是一种搜索的方式</p><p>只要有递归就会有回溯</p><p>回溯法的工作原理</p><ul><li><p>构造空间树</p></li><li><p>进行遍历</p></li><li><p>如遇到边界条件，即不再向下搜索，转而搜索另一棵子树</p></li><li><p>达到目标条件，输出结果</p></li></ul><p>回溯的本质是穷举，即便加入 <strong>剪枝</strong> 操作，回溯法也并不高效</p><p>回溯法一般可以解决如下几种问题：</p><ul><li><strong>组合问题</strong> ：N 个数里面按一定规则找出 k 个数的集合</li><li><strong>切割问题</strong> ：一个字符串按一定规则有几种切割方式</li><li><strong>子集问题</strong> ：一个 N 个数的集合里有多少符合条件的子集</li><li><strong>排列问题</strong> ：N 个数按一定规则全排列，有几种排列方式</li><li><strong>棋盘问题</strong> ：N 皇后，解数独等等</li></ul><p>以上问题都可以近似成：在集合中查找子集。可以把这些问题抽象为树形结构，集合大小决定了树的宽度，递归的深度（例如，子集的大小）决定了树的深度</p><p>回溯法的算法框架如下：（回溯函数，也就是递归函数）</p><ol><li><p>回溯函数模板返回值以及参数</p><ul><li>回溯算法中函数返回值一般为  <code>void</code></li><li>回溯算法需要的参数并不像二叉树递归那样容易确定，一般是先写逻辑，然后再看需要什么参数</li></ul></li><li><p>回溯函数终止条件：回溯法解决的问题都可以抽象成树形结构，因此，一般来说，遇到叶节点也就说明找到了一个符合条件的答案，记录答案，然后结束本层递归</p></li><li><p>回溯搜索的遍历过程：</p><ul><li><code>for</code>  循环用于实现横向遍历（在同一层遍历不同的节点）</li><li>递归用于实现纵向遍历（遍历不同的层次）</li></ul><p><img data-src="/posts/b754d2ea/example.png" class=""></p></li></ol><p>回溯算法模板：</p><pre><code class="language-cpp">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 538. 把二叉搜索树转换为累加树</title>
      <link href="/posts/9b180ff8/"/>
      <url>/posts/9b180ff8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUv">538. Convert BST to Greater Tree</span></p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点  <code>node</code>  的新值等于原树中大于或等于  <code>node.val</code>  的值之和。</p><p>二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 小于 节点键的节点。</li><li>节点的右子树仅包含键 大于 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/9b180ff8/tree.png" class=""></p><pre><code>输入：root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [0,null,1]输出：[1,null,1]</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>树中的所有值 互不相同</li><li>给定的树为二叉搜索树</li></ul><p><strong>说明：</strong> 本题与 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC10cmVlLXRvLWdyZWF0ZXItc3VtLXRyZWUv">LeetCode 1038</span> 相同</p><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>二叉搜索树的中序遍历是一个单调递增的有序序列</p><p>若按照 右 - 根 - 左 的顺序遍历，则会得到一个单调递减的有序序列</p><p>本题要求将 每个节点的值 修改为 原来的节点值加上所有大于它的节点值之和 ，<strong>可以按照 右 - 根 - 左 的顺序遍历二叉树，记录过程中的节点值之和，并不断更新遍历到的节点值</strong></p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">void traversal(TreeNode *root, int &amp;sum) &#123; // 按 右-根-左 顺序遍历    if (!root) return;    traversal(root-&gt;right, sum); // 先递归右子树，统计 所有 值大于 root-&gt;val 的节点 之和    sum += root-&gt;val; // 统计所有 值大于等于 root-&gt;val 的节点 之和    root-&gt;val = sum;  // 将 root-&gt;val 更新为 sum    traversal(root-&gt;left, sum);  // 递归到左子树&#125;TreeNode* convertBST(TreeNode* root) &#123;    int sum = 0; // 累加和    traversal(root, sum);    return root;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用的栈空间</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUvc29sdXRpb24vYmEtZXItY2hhLXNvdS1zdW8tc2h1LXpodWFuLWh1YW4td2VpLWxlaS1qaWEtc2gtMTQv">力扣官方题解：把二叉搜索树转换为累加树</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MzguJUU2JThBJThBJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU4JUJEJUFDJUU2JThEJUEyJUU0JUI4JUJBJUU3JUI0JUFGJUU1JThBJUEwJUU2JUEwJTkxLmh0bWw=">代码随想录：把二叉搜索树转换为累加树</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 108. 将有序数组转换为二叉搜索树</title>
      <link href="/posts/c3291a68/"/>
      <url>/posts/c3291a68/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUv">108. Convert Sorted Array to Binary Search Tree</span></p><p>给你一个整数数组  <code>nums</code>  ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/c3291a68/btree1.jpg" class=""></p><pre><code>输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案</code></pre><p><img data-src="/posts/c3291a68/btree2.jpg" class=""></p><p><strong>示例 2：</strong></p><p><img data-src="/posts/c3291a68/btree.jpg" class=""></p><pre><code>输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>104</mn></mrow><annotation encoding="application/x-tex">\le 104</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>104</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-104 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>104</mn></mrow><annotation encoding="application/x-tex">\le 104</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span></span></span></span></li><li><code>nums</code>  按 严格递增 顺序排列</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>注意本题的数组  <code>nums</code>  为严格递增的有序序列</p><p>取数组最中间元素  <code>mid</code>  作为二叉树的根节点， <code>mid</code>  左侧所有元素作为左子树， <code>mid</code>  右侧所有元素作为右子树</p><p>于是，左子树所有节点值小于根节点，右子树所有节点值大于根节点，即，满足二叉搜索树的要求</p><p>并且，左子树、右子树的最大高度差不超过 1 （当数组元素为偶数时，高度差最大，值为 1），即，满足平衡二叉树的要求</p><ul><li>若取  <code>mid = left + (right - left) / 2;</code>  ，左侧元素个数比右侧少 1</li><li>若取  <code>mid = left + (right - left + 1) / 2;</code>  ，左侧元素个数比右侧多 1</li></ul><blockquote><p>注意：在分割数组时需要坚持不变量原则，即，预先定义有效区间为 左闭右闭  <code>[left, right]</code>  （或者 左闭右开  <code>[left, right)</code>  ）</p></blockquote><p>由于选择根节点的方式不同，构造出的二叉搜索树也就不同，因此，本题存在多解</p><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><p>算法思路：总是选择中间位置左边的数字作为根节点，即，取  <code>mid = left + (right - left) / 2;</code></p><p>这里采用 左闭右闭 原则：从  <code>nums</code>  数组中取出索引为  <code>[left, right]</code>  的所有元素，将其构建为一棵平衡二叉搜索树</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* buildTree(vector&lt;int&gt; &amp;nums, int left, int right) &#123; // 将数组索引为 [left, right] 的元素建成一棵二叉搜索树    if (left &gt; right) return nullptr;    // 没有节点需要建立    int mid = left + (right - left) / 2; // 取 [left, right] 区间中点对应元素值作为根节点值    TreeNode *node = new TreeNode(nums[mid]);      // 根节点    node-&gt;left = buildTree(nums, left, mid - 1);   // 左子树    node-&gt;right = buildTree(nums, mid + 1, right); // 右子树    return node;&#125;TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;    return buildTree(nums, 0, nums.size() - 1);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，递归的最大深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 669. 修剪二叉搜索树</title>
      <link href="/posts/40d04a5/"/>
      <url>/posts/40d04a5/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmltLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">669. Trim a Binary Search Tree</span></p><p>给你二叉搜索树的根节点  <code>root</code>  ，同时给定最小边界  <code>low</code>  和最大边界  <code>high</code>  。通过修剪二叉搜索树，使得所有节点的值在  <code>[low, high]</code>  中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/40d04a5/trim1.jpg" class=""></p><pre><code>输入：root = [1,0,2], low = 1, high = 2输出：[1,null,2]</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/40d04a5/trim2.jpg" class=""></p><pre><code>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>树中每个节点的值都是 唯一 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>low</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>high</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>若节点  <code>node</code>  的值小于  <code>low</code>  ，则节点  <code>node</code>  应删除，并且</p><ul><li><code>node</code>  左子树上节点的值一定小于  <code>low</code>  ，因此左子树也应删除</li><li><code>node</code>  右子树上节点的值可能落在  <code>[low, high]</code>  外，因此需要修剪右子树，用修剪过的右子树接替  <code>node</code>  的位置</li></ul><p>若节点  <code>node</code>  的值大于  <code>high</code>  ，则节点  <code>node</code>  应删除，并且</p><ul><li><code>node</code>  右子树上节点的值一定大于  <code>high</code>  ，因此右子树也应删除</li><li><code>node</code>  左子树上节点的值可能落在  <code>[low, high]</code>  外，因此需要修剪左子树，用修剪过的左子树接替  <code>node</code>  的位置</li></ul><p>若节点  <code>node</code>  的值落在  <code>[low, high]</code>  内，需进一步修剪  <code>node</code>  的左子树、右子树</p><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><p>代码实现：</p><pre><code class="language-cpp">TreeNode* trimBST(TreeNode* root, int low, int high) &#123;    if (!root) return nullptr;    if (root-&gt;val &lt; low)  // root 及其左子树应移除        return trimBST(root-&gt;right, low, high); // 修剪右子树，并用右子树接替 root 的位置    if (root-&gt;val &gt; high) // root 及其右子树应移除        return trimBST(root-&gt;left, low, high);  // 修剪左子树，并用左子树接替 root 的位置    root-&gt;left = trimBST(root-&gt;left, low, high);   // 递归到左子树    root-&gt;right = trimBST(root-&gt;right, low, high); // 递归到右子树    return root;&#125;</code></pre><p>注意：以下代码</p><pre><code class="language-cpp">if (root-&gt;val &lt; low)  // root 及其左子树应移除    return trimBST(root-&gt;right, low, high); // 修剪右子树，并用右子树接替 root 的位置if (root-&gt;val &gt; high) // root 及其右子树应移除    return trimBST(root-&gt;left, low, high);  // 修剪左子树，并用左子树接替 root 的位置</code></pre><p>不能被替换成</p><pre><code class="language-cpp">if (root-&gt;val &lt; low)    return root-&gt;right; // 这里直接返回了 root 右子树，并未对其修剪（此后的遍历也不会再修剪该子树）if (root-&gt;val &gt; high)    return root-&gt;left); // 这里直接返回了 root 左子树，并未对其修剪（此后的遍历也不会再修剪该子树）</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA2NjkuJUU0JUJGJUFFJUU1JTg5JUFBJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxLmh0bWw=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 450. 删除二叉搜索树中的节点</title>
      <link href="/posts/7cd023d4/"/>
      <url>/posts/7cd023d4/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=">450. Delete Node in a BST</span></p><p>给定一个二叉搜索树的根节点  <code>root</code>  和一个值  <code>key</code>  ，删除二叉搜索树中的  <code>key</code>  对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ul><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="/posts/7cd023d4/example.jpg" class=""></p><pre><code>输入：root = [5,3,6,2,4,null,7], key = 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如图所示。另一个正确答案是 [5,2,6,null,4,null,7]。</code></pre><p><img data-src="/posts/7cd023d4/result.jpg" class=""></p><p><strong>示例 2：</strong></p><pre><code>输入：root = [5,3,6,2,4,null,7], key = 0输出：[5,3,6,2,4,null,7]解释：二叉树不包含值为 0 的节点</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [], key = 0输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>节点数的范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li>节点值唯一</li><li><code>root</code>  是合法的二叉搜索树</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>key</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：要求算法时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 为树的高度。</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p><strong>建议先画示意图，结合图来分析</strong></p><p>本题可能有以下情况：</p><ol><li><p>二叉树中不存在值为  <code>key</code>  的节点</p></li><li><p>二叉树中存在值为  <code>key</code>  的节点，不妨记作  <code>node</code></p><ul><li><code>node</code>  的左、右子节点均为空，即， <code>node</code>  是叶节点，直接删除  <code>node</code>  即可</li><li><code>node</code>  的左子节点为空、右子节点不为空，在删除  <code>node</code>  时需要将其右子节点作为新的  <code>node</code></li><li><code>node</code>  的左子节点为空、右子节点为空，在删除  <code>node</code>  时需要将其左子节点作为新的  <code>node</code></li><li><code>node</code>  的左、右子节点均不为空，需要找到一个节点来承接  <code>node</code>  的左、右子节点</li></ul></li></ol><p>其中，针对  <code>node</code>  的左、右子节点均不为空 的情况：由于  <code>node</code>  左子树上所有节点值均小于  <code>node</code>  ，而  <code>node</code>  右子树上所有节点值均大于  <code>node</code>  ，可确定新的  <code>node</code>  节点为（二者选其一）</p><ul><li>左子树上的最大节点（左子树的最右侧节点）</li><li>右子树上的最小节点（右子树的最左侧节点）</li></ul><p>不妨取右子树上的最小节点，将其记作  <code>successor</code>  ，在利用  <code>successor</code>  替换  <code>node</code>  的过程中需做以下考虑： <code>successor</code>  的右子树不一定为空，在从   <code>successor</code>  原本的位置上移除  <code>successor</code>  时，需妥善处理其右子树</p><ul><li>如果  <code>successor</code>  是  <code>node</code>  的右子节点（即， <code>node-&gt;right</code>  就是  <code>node</code>  右子树上的最小节点），可以直接将  <code>successor</code>  的右子树作为  <code>node</code>  的右子树</li><li>否则，需要记录  <code>successor</code>  的父节点（记作  <code>parent</code>  ），将  <code>successor</code>  的右子树作为  <code>parent</code>  的左子树</li></ul><blockquote><p>除了上述方式外，也可以直接调用函数  <code>deleteNode(root-&gt;right, successor-&gt;val)</code>  ，从以  <code>root-&gt;right</code>  为根的树上删除值为  <code>successor-&gt;val</code>  的节点</p></blockquote><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>代码实现：</p><pre><code class="language-cpp">TreeNode* deleteNode(TreeNode* root, int key) &#123;    if (!root) return nullptr; // 未找到 key    if (root-&gt;val &gt; key)       // 递归到左子树寻找 key        root-&gt;left = deleteNode(root-&gt;left, key);    if (root-&gt;val &lt; key)       // 递归到右子树寻找 key        root-&gt;right = deleteNode(root-&gt;right, key);    if (root-&gt;val == key) &#123;    // root 就是应删除的节点        if (!root-&gt;left &amp;&amp; !root-&gt;right) // root 为叶节点，直接删除            return nullptr;        if (root-&gt;left &amp;&amp; !root-&gt;right)  // 用 root-&gt;left 替代 root            return root-&gt;left;        if (!root-&gt;left &amp;&amp; root-&gt;right)  // 用 root-&gt;right 替代 root            return root-&gt;right;        if (root-&gt;left &amp;&amp; root-&gt;right) &#123; // 从左、右子树中选出一个新的 root            TreeNode *successor = root-&gt;right; // 新的 root（初始化）            while (successor-&gt;left)      // 取 root 右子树的最左侧节点                successor = successor-&gt;left;            root-&gt;right = deleteNode(root-&gt;right, successor-&gt;val); // 删除 successor 原本的位置            successor-&gt;left = root-&gt;left;   // 将 root 左子树移动到 successor 上            successor-&gt;right = root-&gt;right; // 将 root 右子树移动到 successor 上            return successor;        &#125;    &#125;    return root;&#125;</code></pre><p>其中</p><pre><code class="language-cpp">TreeNode *successor = root-&gt;right; // 新的 rootwhile (successor-&gt;left)      // 将 root 右子树的最左侧节点作为新的 root    successor = successor-&gt;left;root-&gt;right = deleteNode(root-&gt;right, successor-&gt;val); // 删除 successor 原本的位置</code></pre><p>可替换为</p><pre><code class="language-cpp">TreeNode *successor = root-&gt;right; // 新的 root （初始化）TreeNode *parent = root;  // successor 的父节点while (successor-&gt;left) &#123; // 将 root 右子树的最左侧节点作为新的 root    parent = successor;    successor = successor-&gt;left;&#125;if (parent == root) // successor 就是 root-&gt;right     parent-&gt;right = successor-&gt;right; // 将 successor 右子树作为 root 右子树else // successor 是 root-&gt;right 的左子树上节点    parent-&gt;left = successor-&gt;right;  // 将 successor 右子树作为 parent 左子树</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC9zb2x1dGlvbi9zaGFuLWNodS1lci1jaGEtc291LXN1by1zaHUtemhvbmctZGUtamllLW42dm8v">力扣官方题解：删除二叉树中的节点</span></p><blockquote><p>附注：在 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0NTAuJUU1JTg4JUEwJUU5JTk5JUE0JUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU4JThBJTgyJUU3JTgyJUI5Lmh0bWw=">代码随想录</span> 中，针对  <code>node</code>  的左、右子节点均不为空 的情况，其直接将  <code>node</code>  的左子树作为  <code>successor</code>  的左子树</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 701. 二叉搜索树中的插入操作</title>
      <link href="/posts/f9bf03da/"/>
      <url>/posts/f9bf03da/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtaW50by1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">701. Insert into a Binary Search Tree</span></p><p>给定二叉搜索树（BST）的根节点  <code>root</code>  和要插入树中的值  <code>value</code>  ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/f9bf03da/example.jpg" class=""></p><pre><code>输入：root = [4,2,7,1,3], val = 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是：</code></pre><p height="200px"><img data-src="/posts/f9bf03da/result.jpg" class=""></p><p><strong>示例 2：</strong></p><pre><code>输入：root = [40,20,60,10,30,50,70], val = 25输出：[40,20,60,10,30,50,70,null,null,25]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5输出：[4,2,7,1,3,5]</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^8 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></li><li>所有值  <code>Node.val</code>  互不相同</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^8 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></li><li>保证  <code>val</code>  在原始 BST 中不存在</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>根据  <code>root</code>  节点值与  <code>val</code>  的大小关系，确定将  <code>val</code>  插入到  <code>root</code>  的哪一棵子树</p><ul><li>如果该子树不为空，则问题转化为 将  <code>val</code>  插入到  <code>root</code>  子树的子树上</li><li>如果子树为空，则新建一个值为  <code>val</code>  的节点，将其链接到父节点  <code>root</code>  上</li></ul><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><h2 id="写法一有返回值"><a class="anchor" href="#写法一有返回值">#</a> 写法一：有返回值</h2><p>代码实现：</p><pre><code class="language-cpp">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;    if (root == nullptr) &#123; // 空节点，亦即 val 的插入点        root = new TreeNode(val);        return root;    &#125;    if (root-&gt;val &gt; val) // val 小于 root ，应将其插入到左子树        root-&gt;left = insertIntoBST(root-&gt;left, val);    if (root-&gt;val &lt; val) // val 大于 root ，应将其插入到右子树        root-&gt;right = insertIntoBST(root-&gt;right, val);    return root;&#125;</code></pre><p>注意， <code>root-&gt;left = insertIntoBST(root-&gt;left, val);</code>  和  <code>root-&gt;right = insertIntoBST(root-&gt;right, val);</code>  这两个命令是为了将插入的节点与其父节点建立连接</p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p><h2 id="写法二无返回值"><a class="anchor" href="#写法二无返回值">#</a> 写法二：无返回值</h2><p>算法思路：在不设定递归函数返回值的情况下，需要记录父节点，当找到插入节点的位置时，直接让其父节点指向插入节点。其中，新节点是作为左子节点还是右子节点，取决于父节点的值与  <code>val</code>  的大小关系</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode *parent = nullptr;void helper(TreeNode *root, int val) &#123;    if (root == nullptr) &#123;        TreeNode *node = new TreeNode(val);        if (parent-&gt;val &gt; val) parent-&gt;left = node;        else parent-&gt;right = node;        return;    &#125;    parent = root;    if (root-&gt;val &gt; val) helper(root-&gt;left, val);    if (root-&gt;val &lt; val) helper(root-&gt;right, val);&#125;TreeNode* insertIntoBST(TreeNode* root, int val) &#123;    if (root == nullptr) return new TreeNode(val);    helper(root, val);    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDEuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU2JThGJTkyJUU1JTg1JUE1JUU2JTkzJThEJUU0JUJEJTlDLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录</span></p><h1 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h1><p>算法思路：利用迭代法实现插入节点</p><h2 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h2><p>代码实现：</p><pre><code class="language-cpp">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;    if (!root) return new TreeNode(val);    TreeNode *node = root;    while (node != nullptr) &#123;        if (node-&gt;val &gt; val) &#123; // 应插入到 node 的左子树            if (node-&gt;left != nullptr) &#123;                node = node-&gt;left;            &#125; else &#123;                node-&gt;left = new TreeNode(val);                break;            &#125;        &#125; else &#123; // 应插入到 node 的右子树            if (node-&gt;right != nullptr) &#123;                node = node-&gt;right;            &#125; else &#123;                node-&gt;right = new TreeNode(val);                break;            &#125;        &#125;    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtaW50by1hLWJpbmFyeS1zZWFyY2gtdHJlZS9zb2x1dGlvbi9lci1jaGEtc291LXN1by1zaHUtemhvbmctZGUtY2hhLXJ1LWNhby16dW8tYnktbGUtMy8=">力扣官方题解</span></p><h2 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h2><p>代码实现：</p><pre><code class="language-cpp">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;    if (root == NULL) &#123;        TreeNode* node = new TreeNode(val);        return node;    &#125;    TreeNode* cur = root;    TreeNode* parent = root; // 记录上一个节点，以便链接新节点    while (cur != NULL) &#123;        parent = cur;        if (cur-&gt;val &gt; val) cur = cur-&gt;left;        else cur = cur-&gt;right;    &#125;    TreeNode* node = new TreeNode(val);    if (val &lt; parent-&gt;val) parent-&gt;left = node;    else parent-&gt;right = node;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDEuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU2JThGJTkyJUU1JTg1JUE1JUU2JTkzJThEJUU0JUJEJTlDLmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEz">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 235. 二叉搜索树的最近公共祖先</title>
      <link href="/posts/adb53b8e/"/>
      <url>/posts/adb53b8e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">235. Lowest Common Ancestor of a Binary Search Tree</span></p><p>给定一个二叉搜索树，找到该树中两个指定节点的 <strong>最近公共祖先</strong> 。</p><p>最近公共祖先 的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img data-src="/posts/adb53b8e/tree.png" class=""></p><p><strong>示例 1：</strong></p><pre><code>输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出：6解释：节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出：2解释：节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [2,1], p = 2, q = 1输出：2</code></pre><p><strong>提示：</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题可采用 <a href="https://jiankychen.github.io/posts/8d6a58cf">LeetCode 236. 二叉树的最近公共祖先</a> 中的方法求解</p><p>但由于本题的二叉树为二叉搜索树，可在 <a href="https://jiankychen.github.io/posts/8d6a58cf">LeetCode 236. 二叉树的最近公共祖先</a> 的基础上简化求解</p><h1 id="method-1-确定路径"><a class="anchor" href="#method-1-确定路径">#</a> Method 1: 确定路径</h1><p>算法思路：根据二叉搜索树的特性，分别找出从  <code>root</code>  到  <code>p</code>  的路径、从  <code>root</code>  到  <code>q</code>  的路径，然后从两个路径中找到最后一个公共节点，即为最近公共祖先</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;TreeNode*&gt; getPath(TreeNode *root, TreeNode * target) &#123; // 记录从 root 到 target 的路径    vector&lt;TreeNode*&gt; path;    while (root != target) &#123;        path.push_back(root);        if (root-&gt;val &gt; target-&gt;val) root = root-&gt;left;        else root = root-&gt;right; // 注意这里是 else 语句，与前面的 if 互斥    &#125;    path.push_back(root);    return path;&#125;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    vector&lt;TreeNode*&gt; pathP = getPath(root, p); // 获取 root 到 p 的路径    vector&lt;TreeNode*&gt; pathQ = getPath(root, q); // 获取 root 到 q 的路径    TreeNode *ans = NULL; // 公共祖先    for (int i = 0; i &lt; pathP.size() &amp;&amp; i &lt; pathQ.size(); i++) &#123; // 找到深度最大的公共祖先        if (pathP[i] == pathQ[i]) ans = pathP[i];        else break;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑存放路径的数组空间</p><h1 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h1><p>算法思路：</p><ul><li><p>如果当前节点的值大于  <code>p</code>  和  <code>q</code>  的值，说明  <code>p</code>  和  <code>q</code>  在当前节点的左子树，因此，将当前节点移动到左子节点</p></li><li><p>如果当前节点的值小于  <code>p</code>  和  <code>q</code>  的值，说明  <code>p</code>  和  <code>q</code>  在当前节点的右子树，因此，将当前节点移动到右子节点</p></li><li><p>如果当前节点值不满足以上两种情况，则当前节点就是  <code>p</code>  和  <code>q</code>  的最近公共祖先</p></li></ul><p>换而言之，  <code>p</code>  和  <code>q</code>  的最近公共祖先节点的值一定落在  <code>[p-&gt;val, q-&gt;val]</code>  或者  <code>[q-&gt;val, p-&gt;val]</code>  区间内</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    while (true) &#123;        if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;            root = root-&gt;left;        &#125; else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;            root = root-&gt;right;        &#125; else &#123;            break;        &#125;    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlL3NvbHV0aW9uL2VyLWNoYS1zb3Utc3VvLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLTI2Lw==">力扣官方题解</span></p><h1 id="method-3-递归"><a class="anchor" href="#method-3-递归">#</a> Method 3: 递归</h1><p>算法思路：判断  <code>root</code>  的值是否落在  <code>[p-&gt;val, q-&gt;val]</code>  或者  <code>[q-&gt;val, p-&gt;val]</code>  区间内</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* helper(TreeNode *root, TreeNode* p, TreeNode* q) &#123;    if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)        return helper(root-&gt;right, p, q);    else if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)        return helper(root-&gt;left, p, q);    else return root;&#125;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    return helper(root, p, q);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMzUuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4Lmh0bWw=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 236. 二叉树的最近公共祖先</title>
      <link href="/posts/8d6a58cf/"/>
      <url>/posts/8d6a58cf/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">236. Lowest Common Ancestor of a Binary Tree</span></p><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/8d6a58cf/tree.png" class=""></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,2], p = 1, q = 2输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2, 10^5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>若  <code>x</code>  满足以下任意一种情况， <code>x</code>  是  <code>p</code>  和  <code>q</code>  的最近公共祖先</p><ul><li><code>x</code>  的左子树包含  <code>p</code>  节点，并且  <code>x</code>  的右子树包含  <code>q</code>  节点（或者， <code>x</code>  的左子树包含  <code>q</code>  节点 且  <code>x</code>  的右子树包含  <code>p</code>  节点）</li><li><code>x</code>  恰好是  <code>p</code>  节点，并且  <code>x</code>  的其中一个子树包含  <code>q</code>  节点（或者， <code>x</code>  恰好是  <code>q</code>  节点，并且  <code>x</code>  的其中一个子树包含  <code>p</code>  节点）</li></ul><p>若按照后序遍历顺序来遍历二叉树（即，自底向上遍历二叉树），在所有满足条件的公共祖先中，一定是深度最大的祖先最先被访问到。因此，可以找到最近公共祖先</p><h1 id="method-1"><a class="anchor" href="#method-1">#</a> Method 1</h1><p>代码实现：</p><pre><code class="language-cpp">TreeNode *ans = nullptr; // 最近公共祖先bool helper(TreeNode *root, TreeNode *p, TreeNode *q) &#123; // 判断以 root 为根节点的树是否含有 p 节点或 q 节点    if (!root) return false;    bool left = helper(root-&gt;left, p, q);   // 递归到左子树    bool right = helper(root-&gt;right, p, q); // 递归到右子树    if (left &amp;&amp; right) ans = root;          // 情形一    if (root == p || root == q) &#123;        if (left || right)                  // 情形二            ans = root;    &#125;    return (left || right) || (root == p || root == q); // 返回值：是否含有 p 节点或 q 节点&#125;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    helper(root, p, q);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUvc29sdXRpb24vZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWJ5LWxlZXRjLTIv">力扣官方题解</span></p><h1 id="method-2"><a class="anchor" href="#method-2">#</a> Method 2</h1><p>算法思路：</p><p>针对情形二，在找到一个节点是  <code>p</code>  或者  <code>q</code>  的时候，直接返回当前节点即可，无需继续递归子树。在接下来的遍历中，如果找到了后继节点满足情形一，则修改返回值为后继节点，否则，继续返回已找到的节点即可</p><p height="200px">示意图：<br /><img data-src="/posts/8d6a58cf/method2.png" class=""></p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    if (root == p || root == q || root == NULL) return root;    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);    TreeNode* right = lowestCommonAncestor(root-&gt;right, p ,q);    if (left &amp;&amp; right) return root; // 左、右子树分别包含 p 、q 节点    if (left || right) return left ? left : right; // 左子树或者右子树包含 p 或 q 节点    return NULL;                    // 不包含 p 和 q 节点&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMzYuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p><blockquote><p>本题也可以用哈希表存储所有节点的父节点，然后分别从  <code>p</code>  、 <code>q</code>  节点开始向上访问父节点以及祖先节点，遇到的第一个公共祖先节点即为所求，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUvc29sdXRpb24vZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWJ5LWxlZXRjLTIv">力扣官方题解 - 方法二</span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 501. 二叉搜索树中的众数</title>
      <link href="/posts/a4aa1b78/"/>
      <url>/posts/a4aa1b78/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1vZGUtaW4tYmluYXJ5LXNlYXJjaC10cmVlLw==">501. Find Mode in Binary Search Tree</span></p><p>给你一个含重复值的二叉搜索树（BST）的根节点  <code>root</code>  ，找出并返回 BST 中的所有 <strong>众数</strong>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 小于等于 当前节点的值</li><li>结点右子树中所含节点的值 大于等于 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><p><img data-src="/posts/a4aa1b78/mode-tree.jpg" class=""></p><pre><code>输入：root = [1,null,2,2]输出：[2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>在二叉搜索树中，中序遍历可以得到有序序列</p><p>重复数字在中序遍历序列中必定是连续出现的</p><p>因此，可以先获得这棵树的中序遍历，然后扫描中序遍历序列，统计每个数字出现的个数，这样就可以找到出现次数最多的数字</p><h1 id="method-1-中序遍历额外数组"><a class="anchor" href="#method-1-中序遍历额外数组">#</a> Method 1: 中序遍历（额外数组）</h1><p>算法思路：</p><ol><li><p>中序遍历二叉树，得到非递减的有序序列  <code>nums</code></p></li><li><p>定义  <code>curCount</code>  记录当前数字的出现次数， <code>maxCount</code>  表示当前统计到的最大出现次数，数组  <code>res</code>  记录出现的众数</p></li><li><p>遍历数组  <code>nums</code>  的元素</p><ul><li>更新  <code>curCount</code><ul><li>如果该元素是第 0 位元素，或者，该元素与上一位元素相等， <code>curCount</code>  自增 1</li><li>否则，意味着出现新数字， <code>curCount</code>  置为 1</li></ul></li><li>更新  <code>maxCount</code><ul><li>若  <code>curCount == maxCount</code>  ，当前数字的出现次数等于统计到的最大出现次数，将当前数字加入  <code>res</code></li><li>若  <code>curCount &gt; maxCount</code>  ，当前数字的出现次数大于统计到的最大出现次数，需将  <code>maxCount</code>  更新为  <code>curCount</code>  ，清空  <code>res</code>  数组后再将当前元素加入  <code>res</code>  数组</li></ul></li></ul></li></ol><blockquote><p>注：该算法在条件  <code>curCount &gt; maxCount</code>  或条件  <code>curCount == maxCount</code>  满足时就会更新  <code>res</code>  数组，而不只是在  <code>nums[i] != nums[i - 1]</code>  时更新  <code>res</code>  数组</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">void traversal(TreeNode *root, vector&lt;int&gt; &amp;nums) &#123; // 中序遍历    if (!root) return;    traversal(root-&gt;left, nums);    nums.push_back(root-&gt;val);    traversal(root-&gt;right, nums);&#125;vector&lt;int&gt; findMode(TreeNode* root) &#123;    vector&lt;int&gt; nums;    traversal(root, nums); // 中序遍历序列    int maxCount = 0;      // 最大出现频率    int curCount = 0;      // 当前出现频率    vector&lt;int&gt; res;       // 目标数组    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (i == 0 || nums[i] == nums[i - 1]) curCount++; // 连续相同数字        else curCount = 1;          // 不相同数字，重新统计频率        if (curCount &gt; maxCount) &#123;  // 遇到出现频率更高的数字            maxCount = curCount;    // 更新最大出现频率            res = &#123;nums[i]&#125;;        // 清空此前记录的众数，并放入新的众数        &#125; else if (curCount == maxCount) &#123; // 多个众数            res.push_back(nums[i]);        &#125;    &#125;    return res;&#125;</code></pre><p>其中， <code>res = &#123;nums[i]&#125;;</code>  等价于</p><pre><code class="language-cpp">res.clear();res.push_back(nums[i]);</code></pre><p>算法的时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li>遍历二叉树、遍历数组  <code>nums</code>  的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>算法的空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归需要的栈空间、存放中序遍历结果的所需的空间</p><h1 id="method-2-中序遍历无额外数组"><a class="anchor" href="#method-2-中序遍历无额外数组">#</a> Method 2: 中序遍历（无额外数组）</h1><p>Method 1 先将二叉树节点值存放到中序遍历序列，然后再统计各数字的出现次数，这一过程使用了额外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的空间</p><p>实际上，也可以不存储中序遍历序列，直接在中序遍历二叉树的过程中操作</p><p>代码实现：</p><pre><code class="language-cpp">int curCount = 0; // 当前出现次数int maxCount = 0; // 最大出现次数TreeNode *pre = nullptr; // 前一个节点vector&lt;int&gt; res;  // 存放众数void update(TreeNode *root) &#123; // 更新 curCount , maxCount 和 res    if (pre == nullptr || root-&gt;val == pre-&gt;val) curCount++;    else curCount = 1;    if (curCount &gt; maxCount) &#123;        maxCount = curCount;        res = &#123;root-&gt;val&#125;;    &#125; else if (curCount == maxCount) &#123;        res.push_back(root-&gt;val);    &#125;    pre = root;&#125;void traversal(TreeNode *root) &#123; // 中序遍历    if (!root) return;    traversal(root-&gt;left);    update(root);    traversal(root-&gt;right);&#125;vector&lt;int&gt; findMode(TreeNode* root) &#123;    traversal(root);    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里仅需考虑递归需要的栈空间</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MDEuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU0JUJDJTk3JUU2JTk1JUIwLmh0bWw=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1vZGUtaW4tYmluYXJ5LXNlYXJjaC10cmVlL3NvbHV0aW9uL2VyLWNoYS1zb3Utc3VvLXNodS16aG9uZy1kZS16aG9uZy1zaHUtYnktbGVldGNvZGUtLw==">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 530. 二叉搜索树的最小绝对差</title>
      <link href="/posts/38849bf2/"/>
      <url>/posts/38849bf2/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWFic29sdXRlLWRpZmZlcmVuY2UtaW4tYnN0Lw==">530. Minimum Absolute Difference in BST</span></p><p>给你一个二叉搜索树的根节点  <code>root</code>  ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/38849bf2/bst1.jpg" class=""></p><pre><code>输入：root = [4,2,6,1,3]输出：1</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/38849bf2/bst2.jpg" class=""></p><pre><code>输入：root = [1,0,48,null,null,12,49]输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>说明</strong>：本题与 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1kaXN0YW5jZS1iZXR3ZWVuLWJzdC1ub2Rlcy8=">LeetCode 783</span> 相同</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>本题类似于 <a href="https://jiankychen.github.io/posts/282d26b5">LeetCode 98. 验证二叉搜索树</a></p><p>只需在中序遍历过程中计算前一个节点值和后一个节点值之差即可</p><h1 id="method-中序遍历"><a class="anchor" href="#method-中序遍历">#</a> Method: 中序遍历</h1><p>代码实现：</p><pre><code class="language-cpp">void helper(TreeNode *root, int &amp;minDif, int &amp;preValue) &#123; // 计算 root 与前一个节点值的绝对差，并更新最小绝对差    if (!root) return;    helper(root-&gt;left, minDif, preValue);            // 左    minDif = min(abs(root-&gt;val - preValue), minDif); // 根    preValue = root-&gt;val;    helper(root-&gt;right, minDif, preValue);           // 右&#125;int getMinimumDifference(TreeNode* root) &#123;    int minDif = INT_MAX;   // 最小差值    int preValue = INT_MAX; // 前一个节点的值    helper(root, minDif, preValue);    return minDif;&#125;</code></pre><p>也可以写成：</p><pre><code class="language-cpp">int minDif = INT_MAX;    // 最小绝对差TreeNode *pre = nullptr; // 前一个节点void helper(TreeNode *root) &#123;    if (!root) return;    helper(root-&gt;left);  // 左    if (pre != nullptr)        minDif = min(abs(root-&gt;val - pre-&gt;val), minDif); // 根    pre = root;    helper(root-&gt;right); // 右&#125;int getMinimumDifference(TreeNode* root) &#123;    helper(root);    return minDif;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 98. 验证二叉搜索树</title>
      <link href="/posts/282d26b5/"/>
      <url>/posts/282d26b5/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">98. Validate Binary Search Tree</span></p><p>给你一个二叉树的根节点  <code>root</code>  ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="/posts/282d26b5/tree1.jpg" class=""></p><pre><code>输入：root = [2,1,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/282d26b5/tree2.jpg" class=""></p><pre><code>输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="method-1-中序遍历"><a class="anchor" href="#method-1-中序遍历">#</a> Method 1: 中序遍历</h1><p>二叉搜索树的中序遍历序列是一个有序序列（升序序列）</p><p>因此，可通过判断中序遍历序列是否有序来判断该二叉树是否为二叉搜索树</p><h2 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h2><p>把二叉树转变为数组，判断数组元素按升序排列</p><p>代码实现：</p><pre><code class="language-cpp">void midorder(TreeNode *root, vector&lt;int&gt; &amp;nums) &#123; // 中序遍历    if (!root) return;    midorder(root-&gt;left, nums);    nums.push_back(root-&gt;val);    midorder(root-&gt;right, nums);&#125;bool isValidBST(TreeNode* root) &#123;    vector&lt;int&gt; nums;    midorder(root, nums);    for (int i = 1; i &lt; nums.size(); i++) &#123; // 检查中序遍历数组是否按升序排列        if (nums[i] &lt;= nums[i - 1]) return false;    &#125;    return true;&#125;</code></pre><h2 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h2><p>可以直接在中序遍历的过程中判断前一个节点的值是否小于后一个节点的值，以判断中序遍历序列是否有序</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode *pre = nullptr; // 前一个节点bool isValidBST(TreeNode* root) &#123;    if (!root) return true;    if (!isValidBST(root-&gt;left)) return false;      // 验证左子树是否为二叉搜索树    if (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false; // 检查中序遍历序列是否有序    pre = root;          // 更新 pre    return isValidBST(root-&gt;right); // 验证右子树是否为二叉搜索树&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>中序遍历也可以由迭代法实现</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwOTguJUU5JUFBJThDJUU4JUFGJTgxJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTkyJUU2JUIzJTk1">代码随想录：验证二叉搜索树</span></p><h1 id="method-2-前序遍历"><a class="anchor" href="#method-2-前序遍历">#</a> Method 2: 前序遍历</h1><p>二叉搜索树的性质：</p><ul><li>若二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值</li><li>若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值</li><li>它的左、右子树也为二叉搜索树</li></ul><p>由此，可以设计一个递归函数  <code>traversal(root, lowerBound, upperBound)</code>  来递归判断：</p><ul><li>如果  <code>root</code>  节点的值不在  <code>(lowerBound, upperBound)</code>  范围内，说明不满足条件，直接返回</li><li>否则，继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树</li></ul><p>算法思路：</p><ol><li><p>确定递归的参数和返回值：</p><ul><li>参数：根节点  <code>TreeNode *root</code>  、节点取值的下界  <code>long long lowerBound</code>  、节点取值的上界  <code>long long upperBound</code></li><li>返回值：所有节点取值是否都落在  <code>(lowerBound, upperBound)</code>  范围内</li></ul></li><li><p>递归终止条件：空节点，返回  <code>true</code>  ，当前递归结束</p></li><li><p>单层递归的逻辑</p><ul><li>若  <code>root</code>  的值落在  <code>(lowerBound, upperBound)</code>  范围外，条件不满足，返回  <code>false</code></li><li>递归到左子树，其中，节点取值的下界、上界分别为  <code>lowerBound</code>  、 <code>root-&gt;val</code></li><li>递归到右子树，其中，节点取值的下界、上界分别为  <code>root-&gt;val</code>  、 <code>upperBound</code></li><li>若左、右子树均满足条件，返回  <code>true</code></li></ul></li></ol><blockquote><p>注意到  <code>Node.val</code>  可能取到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这两个值，需要将  <code>lowerBound</code>  和  <code>upperBound</code>  分别设定为  <code>long long</code>  型，并分别初始化为  <code>LONG_MIN</code>  和  <code>LONG_MAX</code>  ，即， <code>long long</code>  型的  <code>-inf</code>  和  <code>+inf</code> （因为递归函数的检验范围  <code>(lowerBound, upperBound)</code>  是开区间，若取  <code>int</code>  型的  <code>INT_MIN</code>  和  <code>INT_MAX</code>  ，则无法正确处理  <code>Node.val</code>  取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这两个值的情况）</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">bool traversal(TreeNode* root, long long lowerBound, long long upperBound) &#123;    if (!root) return true;    if (root-&gt;val &lt;= lowerBound || root-&gt;val &gt;= upperBound)        return false;    bool left = traversal(root-&gt;left, lowerBound, root-&gt;val);    bool right = traversal(root-&gt;right, root-&gt;val, upperBound);    return left &amp;&amp; right;&#125;bool isValidBST(TreeNode* root) &#123;    return traversal(root, LONG_MIN, LONG_MAX);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUvc29sdXRpb24veWFuLXpoZW5nLWVyLWNoYS1zb3Utc3VvLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：验证二叉搜索树</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 700. 二叉搜索树中的搜索</title>
      <link href="/posts/40131ff6/"/>
      <url>/posts/40131ff6/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tYS1iaW5hcnktc2VhcmNoLXRyZWUv">700. Search in a Binary Search Tree</span></p><p>给定二叉搜索树（BST）的根节点  <code>root</code>  和一个整数值  <code>val</code>  。</p><p>你需要在 BST 中找到节点值等于  <code>val</code>  的节点。 返回以该节点为根的子树。 如果节点不存在，则返回  <code>null</code>  。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/40131ff6/tree1.jpg" class=""></p><pre><code>输入：root = [4,2,7,1,3], val = 2输出：[2,1,3]</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/40131ff6/tree2.jpg" class=""></p><pre><code>输入：root = [4,2,7,1,3], val = 5输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>数中节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></li><li><code>root</code>  是二叉搜索树</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>二叉搜索树是一个有序树</p><ul><li>若它的左子树非空，则左子树上所有节点的值均小于根节点值</li><li>若它的右子树非空，则右子树上所有节点的值均大于根节点值</li><li>左、右子树也分别为二叉搜索树</li></ul><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>算法思路：</p><ol><li><p>确定递归参数和返回值</p><ul><li>参数：根节点  <code>root</code>  与 目标值  <code>val</code></li><li>返回值：目标值对应的节点</li></ul></li><li><p>递归终止条件： <code>root</code>  为空，未找到  <code>val</code>  ，返回  <code>NULL</code>  ，递归结束</p></li><li><p>单层递归的逻辑</p><ul><li>若  <code>root-&gt;val == val</code>  ，找到  <code>val</code>  ，返回  <code>root</code></li><li>若  <code>root-&gt;val &gt; val</code>  ，搜索左子树</li><li>若  <code>root-&gt;val &lt; val</code>  ，搜索右子树</li><li>如果没有搜索到，返回  <code>NULL</code></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">TreeNode* searchBST(TreeNode* root, int val) &#123;    if (!root) return nullptr;          // root 为空，未找到 val    if (root-&gt;val == val) return root;  // root 节点值等于 val ，找到 val    if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val); // 递归到左子树中搜索    return searchBST(root-&gt;right, val); // 递归到右子树中搜索&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h1><p>由于二叉搜索树的特殊性（节点的有序性），无需辅助栈或者队列就可实现迭代法</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* searchBST(TreeNode* root, int val) &#123;    while (root != nullptr) &#123;        if (root-&gt;val &lt; val) root = root-&gt;right;        else if (root-&gt;val &gt; val) root = root-&gt;left;        else return root;    &#125;    return nullptr;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDAuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTkwJTlDJUU3JUI0JUEyLmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1">代码随想录：二叉搜索树中的搜索 - 迭代法</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 654. 最大二叉树</title>
      <link href="/posts/ce78200f/"/>
      <url>/posts/ce78200f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJpbmFyeS10cmVlLw==">654. Maximum Binary Tree</span></p><p>给定一个不重复的整数数组  <code>nums</code>  。<strong>最大二叉树</strong> 可以用下面的算法从  <code>nums</code>  递归地构建:</p><ul><li>创建一个根节点，其值为 nums 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li><li>返回  <code>nums</code>  构建的 <strong>最大二叉树</strong> 。</li></ul><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/ce78200f/tree1.jpg" class=""></p><pre><code>输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/ce78200f/tree2.jpg" class=""></p><pre><code>输入：nums = [3,2,1]输出：[3,null,2,null,1]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>nums</code>  中的所有整数 互不相同</li></ul><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><p>算法思路：定义递归函数  <code>constructTree(nums, left, right)</code>  ，找出数组在区间  <code>[left, right)</code>  内的最大值，利用最大值左侧元素构造左子树、最大值右侧元素构造右子树</p><blockquote><p>注意：类似的用数组构造二叉树的题目，每次分割时尽量不要定义新数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">TreeNode *constructTree(vector&lt;int&gt;&amp; nums, int left, int right) &#123; // 区间为 [left, right)    if (left == right) return nullptr; // 允许空节点进入递归，终止条件为：遇到空数组    int maxValueIndex = left; // 最大值对应的索引    for (int i = left; i &lt; right; i++) &#123;        if (nums[i] &gt; nums[maxValueIndex])            maxValueIndex = i;    &#125;    TreeNode *root = new TreeNode(nums[maxValueIndex]);          // 根节点    root-&gt;left = constructTree(nums, left, maxValueIndex);       // 左子节点    root-&gt;right = constructTree(nums, maxValueIndex + 1, right); // 右子节点    return root;&#125;TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;    return constructTree(nums, 0, nums.size());&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li><code>constructTree</code>  函数一共被调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次调用需要遍历当前的  <code>[left, right)</code>  区间<ul><li>平均情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下， <code>nums</code>  本身有序，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA2NTQuJUU2JTlDJTgwJUU1JUE0JUE3JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：最大二叉树</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJpbmFyeS10cmVlL3NvbHV0aW9uL3p1aS1kYS1lci1jaGEtc2h1LWJ5LWxlZXRjb2RlLw==">力扣官方题解：最大二叉树</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 105. 从前序与中序遍历序列构造二叉树</title>
      <link href="/posts/4cb77bf3/"/>
      <url>/posts/4cb77bf3/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwv">105. Construct Binary Tree from Preorder and Inorder Traversal</span></p><p>给定两个整数数组  <code>preorder</code>  和  <code>inorder</code>  ，其中  <code>preorder</code>  是二叉树的先序遍历， <code>inorder</code>  是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/4cb77bf3/tree.jpg" class=""></p><pre><code>输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出：[3,9,20,null,null,15,7]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：preorder = [-1], inorder = [-1]输出：[-1]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>preorder.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>inorder.length == preorder.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>3000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-3000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>preorder[i]</code> ,  <code>inorder[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>preorder</code>  和  <code>inorder</code>  均无重复元素</li><li><code>inorder</code>  的每个元素均出现在  <code>preorder</code></li><li><code>preorder</code>  保证为二叉树的前序遍历序列</li><li><code>inorder</code>  保证为二叉树的中序遍历序列</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>根据前序遍历数组的第一个元素来确定根节点</p><p>在中序遍历数组中找到根节点，根节点左侧、右侧分别为左子树、右子树的中序遍历序列</p><p>根据左子树的中序遍历序列长度，确定左子树、右子树的前序遍历序列</p><ul><li>树的中序遍历序列长度等于前序遍历序列长度，并且同一棵树的节点在遍历数组中连续</li></ul><p>依此类推，最终可确定每个节点的左、右子节点</p><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><p>算法思路：类似于 <a href="https://jiankychen.github.io/posts/65174f2a">LeetCode 106. 从中序与后序遍历序列构造二叉树</a></p><blockquote><p>分割数组时，坚持区间不变量原则，左闭右开，或者左闭右闭</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preorderBegin, int preorderEnd, int inorderBegin, int inorderEnd) &#123;    if (preorderBegin == preorderEnd) return nullptr;        // 根节点    int rootValue = preorder[preorderBegin];    TreeNode *root = new TreeNode(rootValue);        // 中序遍历分界线    int delimiterIndex = inorderBegin;    for (; delimiterIndex &lt; inorderEnd; delimiterIndex++)        if (inorder[delimiterIndex] == rootValue) break;        // 左子树的节点数    int leftSize = delimiterIndex - inorderBegin;    // 左子树的前序区间：[preorderBegin + 1, preorderBegin + 1 + leftSize)     // 左子树的中序区间：[inorderBegin, delimiterIndex)    root-&gt;left = traversal(preorder, inorder, preorderBegin + 1, preorderBegin + 1 + leftSize, inorderBegin, delimiterIndex);    // 右子树的前序区间：[preorderBegin + 1 + leftSize, preorderEnd)    // 右子树的中序区间：[delimiterIndex + 1, inorderEnd)    root-&gt;right = traversal(preorder, inorder, preorderBegin + 1 + leftSize, preorderEnd, delimiterIndex + 1, inorderEnd);    return root;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;    return traversal(preorder, inorder, 0, preorder.size(), 0, inorder.size());&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>每个节点都将调用一次  <code>traversal</code>  函数，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次调用  <code>traversal</code>  函数时，需要找到根节点在中序遍历数组中的位置<ul><li>平均情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>可以考虑使用哈希表来快速定位根节点在中序遍历数组中的位置</p><ul><li><code>key</code>  表示一个元素（节点的值）， <code>value</code>  表示其在中序遍历序列中的出现位置</li></ul><p>具体实现：</p><ol><li><p>定义全局变量</p><pre><code class="language-cpp">unordered_map&lt;int, int&gt; index;</code></pre></li><li><p>在  <code>buildTree</code>  函数中，构造哈希映射</p><pre><code class="language-cpp">for (int i = 0; i &lt; n; ++i) &#123;    index[inorder[i]] = i;&#125;</code></pre></li><li><p>在递归函数  <code>traversal</code>  中，使用哈希表查询根节点</p><pre><code class="language-cpp">int delimiterIndex = index[preorder[preorderBegin]]; // preorder 首元素为根节点的值</code></pre></li></ol><p>优化后的算法时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwvc29sdXRpb24vY29uZy1xaWFuLXh1LXl1LXpob25nLXh1LWJpYW4tbGkteHUtbGllLWdvdS16YW8tOS8=">力扣官方题解：从前序与中序遍历序列构造二叉树</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 106. 从中序与后序遍历序列构造二叉树</title>
      <link href="/posts/65174f2a/"/>
      <url>/posts/65174f2a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1pbm9yZGVyLWFuZC1wb3N0b3JkZXItdHJhdmVyc2FsLw==">106. Construct Binary Tree from Inorder and Postorder Traversal</span></p><p>给定两个整数数组  <code>inorder</code>  和  <code>postorder</code>  ，其中  <code>inorder</code>  是二叉树的中序遍历， <code>postorder</code>  是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/65174f2a/tree.jpg" class=""></p><pre><code>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：inorder = [-1], postorder = [-1]输出：[-1]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>inorder.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>postorder.length == inorder.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>3000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-3000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>inorder[i]</code> ,  <code>postorder[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>inorder</code>  和  <code>postorder</code>  均无重复元素</li><li><code>postorder</code>  的每个元素均出现在  <code>inorder</code></li><li><code>inorder</code>  保证为二叉树的中序遍历序列</li><li><code>postorder</code>  保证为二叉树的后序遍历序列</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>根据后序遍历的最后一个元素来确定根节点</p><p>在中序遍历中找到根节点，得到左子树的中序遍历、右子树的中序遍历</p><ul><li>依据：在中序遍历的数组中，根节点左侧为左子树，右侧为右子树</li></ul><p>在后序遍历中分别找到左子树所有节点、右子树所有节点，即可得到左子树、右子树的后序遍历</p><ul><li>依据：后序遍历的数组大小等于中序的数组大小，同一棵树的节点在遍历数组中连续</li></ul><p>依此类推，最终可确定每个节点的左、右子节点</p><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><p>算法流程：</p><ul><li><p>若二叉树的中序遍历数组为空，当前树为空</p></li><li><p>若不为空，取后序数组的最后一个元素作为根节点</p></li><li><p>找到根节点在中序数组的位置，作为切割点</p></li><li><p>切割中序数组，分成中序左数组、中序右数组</p></li><li><p>根据中序左数组、中序右数组的大小来切割后序数组，将其分成后序左数组、后序右数组</p></li><li><p>递归处理左子树和右子树</p></li></ul><blockquote><p>分割数组时，坚持区间不变量原则，左闭右开，或者左闭右闭</p></blockquote><p>为降低时空间复杂度，通过使用左子树、右子树节点在数组  <code>inorder</code>  和  <code>postorder</code>  的下标索引，表示左子树、右子树的中序、后序遍历的结果数组</p><p>代码实现：</p><pre><code class="language-cpp">// 根据中序区间和后序区间确定根节点及左右子树// 中序区间 [inorderBegin, inorderEnd)，后序区间 [postorderBegin, postorderEnd)TreeNode* traversal(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd) &#123;    if (inorderBegin == inorderEnd) return nullptr;  // 空数组，二叉树为空    int rootValue = postorder[postorderEnd - 1];     // 后序遍历的最后一个元素为根节点    TreeNode *root = new TreeNode(rootValue);        // 根节点    if (inorder.size() == 1) return root;    // 找到根节点在中序遍历数组中的位置，即，左、右子树的分界线    int delimiterIndex;    for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd ; delimiterIndex++) &#123;        if (inorder[delimiterIndex] == rootValue) break;    &#125;    // 切割中序数组    // 左子树的中序遍历数组，对应在 inorder 中的索引为 [leftInorderBegin, leftInorderEnd)    int leftInorderBegin = inorderBegin;    int leftInorderEnd = delimiterIndex;    // 右子树的中序遍历数组，对应在 inorder 中的索引为 [rightInorderBegin, rightInorderEnd)    int rightInorderBegin = delimiterIndex + 1; // 需排除根节点    int rightInorderEnd = inorderEnd;    // 切割后序数组    // 左子树的后序遍历数组，对应在 postorder 中的索引为 [leftPostorderBegin, leftPostorderEnd)    int leftPostorderBegin = postorderBegin;    int leftPostorderEnd = postorderBegin + (leftInorderEnd - leftInorderBegin);    // 右子树的后序遍历数组，对应在 postorder 中的索引为 [rightPostorderBegin, rightPostorderEnd)    int rightPostorderBegin = postorderBegin + (leftInorderEnd - leftInorderBegin);    int rightPostorderEnd = postorderEnd - 1; // 需排除根节点    // 递归到左子树（确定 root 的左子节点指针）    root-&gt;left = traversal(inorder, postorder, leftInorderBegin, leftInorderEnd, leftPostorderBegin, leftPostorderEnd);    // 递归到右子树（确定 root 的右子节点指针）    root-&gt;right = traversal(inorder, postorder, rightInorderBegin, rightInorderEnd, rightPostorderBegin, rightPostorderEnd);    return root;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;    if (inorder.size() == 0) return nullptr;    return traversal(inorder, postorder, 0, inorder.size(), 0, postorder.size());&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>每个节点都将调用一次  <code>traversal</code>  函数，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次调用  <code>traversal</code>  函数时，需要找到根节点在中序遍历数组中的位置<ul><li>平均情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDYuJUU0JUJCJThFJUU0JUI4JUFEJUU1JUJBJThGJUU0JUI4JThFJUU1JTkwJThFJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2JUU1JUJBJThGJUU1JTg4JTk3JUU2JTlFJTg0JUU5JTgwJUEwJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjYy0lRTQlQkMlOTglRTUlOEMlOTYlRTclODklODglRTYlOUMlQUM=">代码随想录：从中序与后序遍历序列构造二叉树</span></p><p>简化版：</p><pre><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd) &#123;    if (inorderBegin == inorderEnd) return nullptr;  // 空数组，二叉树为空    int rootValue = postorder[postorderEnd - 1];     // 后序遍历的最后一个元素为根节点    TreeNode *root = new TreeNode(rootValue);        // 根节点    if (inorder.size() == 1) return root;    // 找到根节点在中序遍历数组中的位置    int delimiterIndex;    for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd ; delimiterIndex++)        if (inorder[delimiterIndex] == rootValue) break;    // 左子树节点数    int leftSize = delimiterIndex - inorderBegin;    // 递归到左子树    root-&gt;left = traversal(inorder, postorder, inorderBegin, delimiterIndex, postorderBegin, postorderBegin + leftSize);    // 递归到右子树    root-&gt;right = traversal(inorder, postorder, delimiterIndex + 1, inorderEnd, postorderBegin + leftSize, postorderEnd - 1);    return root;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;    if (inorder.size() == 0) return nullptr;    return traversal(inorder, postorder, 0, inorder.size(), 0, postorder.size());&#125;</code></pre><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>另外，可以考虑使用哈希表来快速定位根节点</p><ul><li><code>key</code>  表示一个元素（节点的值）， <code>value</code>  表示其在中序遍历序列中的出现位置</li><li>在调用递归函数前，先对中序遍历序列进行一遍扫描，构造出哈希表</li><li>以后只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间就可以对中序遍历中的根节点进行定位</li></ul><p>具体实现：</p><ol><li><p>定义全局变量</p><pre><code class="language-cpp">unordered_map&lt;int, int&gt; index;</code></pre></li><li><p>在  <code>buildTree</code>  函数中构造哈希映射</p><pre><code class="language-cpp">for (int i = 0; i &lt; n; ++i) &#123;    index[inorder[i]] = i;&#125;</code></pre></li><li><p>在递归函数  <code>traversal</code>  中使用哈希表查询根节点</p><pre><code class="language-cpp">int delimiterIndex = index[postorder[postorderEnd]]; // postorder 最后元素为根节点的值</code></pre></li></ol><p>优化后的算法时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1pbm9yZGVyLWFuZC1wb3N0b3JkZXItdHJhdmVyc2FsL3NvbHV0aW9uL2NvbmctemhvbmcteHUteXUtaG91LXh1LWJpYW4tbGkteHUtbGllLWdvdS16YW8tMTQv">力扣官方题解：从中序与后序遍历序列构造二叉树</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 113. 路径总和 II</title>
      <link href="/posts/5e6fc759/"/>
      <url>/posts/5e6fc759/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paS8=">113. Path Sum II</span></p><p>给你二叉树的根节点  <code>root</code>  和一个整数目标和  <code>targetSum</code>  ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/5e6fc759/pathsum1.jpg" class=""></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]]</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/5e6fc759/pathsum2.jpg" class=""></p><pre><code>输入：root = [1,2,3], targetSum = 5输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,2], targetSum = 0输出：[]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>targetSum</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>算法思路：综合 <a href="https://jiankychen.github.io/posts/30d556a7">LeetCode 257. 二叉树的所有路径</a> 和 <a href="https://jiankychen.github.io/posts/ee978a9e">LeetCode 112. 路径总和</a> 这两题的思想</p><p>递归函数的参数：</p><ul><li><code>TreeNode *root</code>  ：当前节点</li><li><code>vector&lt;int&gt; path</code>  ：记录从二叉树根节点到当前节点的路径（注意，参数传递方式为值传递）</li><li><code>int sum</code>  ：从当前节点到叶节点应满足的路径和（注意，参数传递方式为值传递）</li></ul><p>为避免  <code>getPaths</code>  函数需要传入太多参数，特将  <code>vector&lt;vector&lt;int&gt;&gt; ans</code>  设置为全局变量（记录所有可行路径）</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ans;void getPaths(TreeNode *root, vector&lt;int&gt; path, int sum) &#123;    if (!root) return;                 // 空节点，递归终止    path.push_back(root-&gt;val);         // 更新路径    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // root 为叶节点        if (root-&gt;val == sum)          // 若当前值等于 sum ，路径符合要求，将其添加到 ans            ans.push_back(path);        return;    &#125;    getPaths(root-&gt;left, path, sum - root-&gt;val);  // 递归到左子树（传入 sum - root-&gt;val）    getPaths(root-&gt;right, path, sum - root-&gt;val); // 递归到右子树（传入 sum - root-&gt;val）&#125;vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;    vector&lt;int&gt; path;    getPaths(root, path, targetSum);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li>在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶节点的路径都符合要求</li><li>此时，路径数目为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，每一条路径的节点个数也为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，因此总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈空间的开销</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paS9zb2x1dGlvbi9sdS1qaW5nLXpvbmctaGUtaWktYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：路径总和 II</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 112. 路径总和</title>
      <link href="/posts/ee978a9e/"/>
      <url>/posts/ee978a9e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS8=">112. Path Sum</span></p><p>给你二叉树的根节点  <code>root</code>  和一个表示目标和的整数  <code>targetSum</code>  。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和  <code>targetSum</code>  。如果存在，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/ee978a9e/pathsum1.jpg" class=""></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,2,3], targetSum = 5输出：false解释：不存在 sum = 5 的根节点到叶子节点的路径。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>targetSum</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p><code>hasPathSum</code>  函数的功能：判断是否存在从当前节点  <code>root</code>  到叶节点的路径，使得路径和为  <code>targetSum</code></p><p>假定从根节点到当前节点的路径和为  <code>val</code>  ，则问题可以转换为：判断是否存在一条从当前节点的子节点到叶节点的路径，满足其路径和为  <code>targetSum - val</code></p><p>因此，可以利用递归来实现这一系列问题的求解</p><p>算法思路：</p><ol><li><p>确定递归的参数和返回值：</p><ul><li>参数：根节点  <code>root</code>  ，期望的  <code>root-to-leaf</code>  路径和  <code>sum</code></li><li>返回值： <code>bool</code>  类型，表示是否找到可行路径（设定返回值是为了在遇到可行路径时就返回，不再继续递归）</li></ul></li><li><p>递归终止条件：遇到叶节点，当前递归结束</p></li><li><p>单层递归的逻辑：</p><ul><li>若  <code>root</code>  是叶节点，判断当前路径是否满足条件</li><li>若不是叶节点，分别递归到左、右子树（注意，传入的第二个参数为  <code>sum - root-&gt;val</code>  ）</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool hasPathSum(TreeNode* root, int sum) &#123;    if (!root) return false;        // 空节点，递归返回    if (!root-&gt;left &amp;&amp; !root-&gt;right)        return  root-&gt;val == sum;   // 若当前叶节点的值等于sum，路径符合条件，返回 true    return hasPathSum(root-&gt;left, sum - root-&gt;val) ||            hasPathSum(root-&gt;right, sum - root-&gt;val); // 判断是否存在从子节点到叶节点路径和为 sum - root-&gt;val 的路径&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><blockquote><p>本题也可以累加路径和，在遇到叶节点时，判断路径和是否与目标值相等，但那样比较麻烦，例如：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9zdWJtaXNzaW9ucy9kZXRhaWwvMzI1OTQ0NDQ0Lw==">LeetCode 提交记录</span></p></blockquote><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMTIuJUU4JUI3JUFGJUU1JUJFJTg0JUU2JTgwJUJCJUU1JTkyJThDLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录：路径总和</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS9zb2x1dGlvbi9sdS1qaW5nLXpvbmctaGUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：路径总和</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 513. 找树左下角的值</title>
      <link href="/posts/9392a5dc/"/>
      <url>/posts/9392a5dc/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWJvdHRvbS1sZWZ0LXRyZWUtdmFsdWUv">513. Find Bottom Left Tree Value</span></p><p>给定一个二叉树的 根节点  <code>root</code>  ，请找出该二叉树的 <strong>最底层</strong> <strong>最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/9392a5dc/tree1.jpg" class=""></p><pre><code>输入：root = [2,1,3]输出：1</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/9392a5dc/tree2.jpg" class=""></p><pre><code>输入：root = [1,2,3,4,null,5,6,null,null,7]输出：7</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>找出最后一行的最左侧节点的值：首先要是最后一行，然后是最左侧节点</p><h1 id="method-1-层序遍历"><a class="anchor" href="#method-1-层序遍历">#</a> Method 1: 层序遍历</h1><p>算法思路：逐层遍历，记录每层最左侧的节点（用下一层的记录覆盖上一层），遍历结束时，即得到最后一层的最左侧节点</p><p>代码实现：</p><pre><code class="language-cpp">int findBottomLeftValue(TreeNode* root) &#123;    TreeNode* leftMost = new TreeNode(0); // 最左侧节点    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        leftMost = que.front();        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            TreeNode* tmp = que.front();            que.pop();            if (tmp-&gt;left) que.push(tmp-&gt;left);            if (tmp-&gt;right) que.push(tmp-&gt;right);        &#125;    &#125;    return leftMost-&gt;val;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>在遍历每一层时，可以按照 从右到左 的遍历顺序，于是，广度优先搜索所遍历的最后一个节点就是最底层最左边节点</p></blockquote><h1 id="method-2-前序遍历"><a class="anchor" href="#method-2-前序遍历">#</a> Method 2: 前序遍历</h1><p>利用递归法计算二叉树的最大深度，并记录访问到的第一个具有最大深度的叶节点</p><p>算法思路：</p><ol><li><p>递归函数  <code>getValue</code>  的参数和返回值</p><ul><li>传入参数为根节点  <code>root</code>  及其深度  <code>depth</code></li><li>无返回值，返回值类型为  <code>void</code></li></ul></li><li><p>递归的终止条件：遇到叶节点，当前递归结束</p></li><li><p>单层递归的逻辑：</p><ul><li>若当前节点是叶节点<ul><li>若当前节点深度大于此前所有节点的深度，则更新二叉树最大深度为当前节点的深度，并记录当前叶节点的值</li><li>当前递归结束，返回上一层递归</li></ul></li><li>若当前节点不是叶节点，分别递归到左、右子节点</li></ul></li></ol><p>注意：</p><ul><li>最大深度  <code>maxDepth</code>  和 最左侧节点值  <code>value</code>  是全局变量</li><li>递归函数的参数  <code>depth</code>  采用拷贝赋值的方式传递，而不是以引用方式传递，这是为了递归的回溯</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxDepth = INT_MIN; // 最大深度int value = 0;          // 最大深度最左侧节点值void getValue(TreeNode* root, int depth) &#123; // 查找以 root 为根的树底层最左侧节点    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // root 为叶节点        if (depth &gt; maxDepth) &#123; // 遍历到更大深度，更新 maxDepth 以及 value            maxDepth = depth;            value = root-&gt;val;        &#125;        return;         // root 为叶节点，不再向下遍历    &#125;    if (root-&gt;left) getValue(root-&gt;left, depth + 1);   // 递归到左子树    if (root-&gt;right) getValue(root-&gt;right, depth + 1); // 递归到右子树    return;&#125;int findBottomLeftValue(TreeNode* root) &#123;    getValue(root, 1);    return value;&#125;</code></pre><p>补充说明：具有最大深度的节点一定是在最底层，这一点容易理解。但是，为什么可以找到最左侧的节点呢？</p><ul><li>对于具有相同深度的两个节点，左侧节点的访问 / 处理一定先于右侧节点（无论是采用何种深度优先遍历方式）</li><li>在访问到第一个具有最大深度的节点（即，最底层的最左侧节点）时， <code>maxDepth</code>  和  <code>value</code>  均被更新。此后，访问到最底层的其余节点时， <code>depth &gt; maxDepth</code>  这一条件并不满足， <code>value</code>  也就不会被更新。故而， <code>value</code>  是最底层最左侧节点的值</li></ul><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MTMuJUU2JTg5JUJFJUU2JUEwJTkxJUU1JUI3JUE2JUU0JUI4JThCJUU4JUE3JTkyJUU3JTlBJTg0JUU1JTgwJUJDLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录：找树左下角的值</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 404. 左叶子之和</title>
      <link href="/posts/d5288e2a/"/>
      <url>/posts/d5288e2a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tb2YtbGVmdC1sZWF2ZXMv">404. Sum of Left Leaves</span></p><p>给定二叉树的根节点  <code>root</code>  ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/d5288e2a/leftsum-tree.jpg" class=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：24解释：在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：0</code></pre><p></p><p><strong>提示：</strong></p><ul><li>节点数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 范围内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>注意，本题计算的是 <strong>左叶节点</strong> 的和，而不是 左子节点 的和</p><p><strong>若节点  <code>node</code>  是叶节点（即，不存在左右子节点），并且， <code>node</code>  是其父节点的左子节点，则节点  <code>node</code>  是左叶节点</strong></p><p>例如，在 示例 1 中，值为 9 的节点和值为 15 的节点都是左叶节点</p><p>对于节点  <code>node</code>  而言，容易判断  <code>node</code>  是否为叶节点，但是，要想判断  <code>node</code>  是否为其父节点的左子节点，则并不容易</p><p>对此，我们可以退而求其次：判断每个  <code>node</code>  节点的左子节点（即， <code>node-&gt;left</code>  ）是否为叶节点</p><ul><li>若是，则  <code>node-&gt;left</code>  是左叶节点</li><li>若否，则  <code>node-&gt;left</code>  不是左叶节点</li></ul><h1 id="method-1-后序遍历"><a class="anchor" href="#method-1-后序遍历">#</a> Method 1: 后序遍历</h1><p>采用递归法，实现后序遍历（处理节点的顺序为：左 - 右 - 根）</p><p>算法思路：</p><ol><li><p>递归函数的参数和返回值：</p><ul><li>传入参数为树的根节点  <code>root</code></li><li>返回值为左叶节点的数值和，数据类型为  <code>int</code></li></ul></li><li><p>递归的终止条件：遇到空节点  <code>root</code>  ，递归结束</p></li><li><p>单层递归的逻辑：</p><ul><li>判断  <code>root-&gt;left</code>  是否为叶节点<ul><li>若是，记录其数值</li><li>若否，分别递归到  <code>root</code>  的左、右子树，计算左、右子树上的左叶节点数值和</li></ul></li><li>计算以  <code>root</code>  为根的所有左叶节点数值之和</li></ul></li></ol><blockquote><p>注意， <code>node</code>  的右子树也可能含有左子节点，例如 示例 1 中值为 15 的节点</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int sumOfLeftLeaves(TreeNode* root) &#123;    if (!root) return 0;    int midValue = 0;    if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) // root-&gt;left 为左叶节点        midValue = root-&gt;left-&gt;val;    return midValue + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间，最坏情况下，树呈链状，深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-前序遍历"><a class="anchor" href="#method-2-前序遍历">#</a> Method 2: 前序遍历</h1><p>采用迭代法，实现前序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int sumOfLeftLeaves(TreeNode* root) &#123;    int ans = 0;    stack&lt;TreeNode*&gt; stk;    if (root) stk.push(root);    while (!stk.empty()) &#123;        TreeNode* node = stk.top();        stk.pop();        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)            ans += node-&gt;left-&gt;val;        if (node-&gt;right) stk.push(node-&gt;right); // 右        if (node-&gt;left) stk.push(node-&gt;left);   // 左    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-3-层序遍历"><a class="anchor" href="#method-3-层序遍历">#</a> Method 3: 层序遍历</h1><p>特别地，本题只需计算左叶节点的数值和，层序遍历时不必区分节点的层次。故而，只需将 Method 2 中的栈换成队列，即可实现层序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int sumOfLeftLeaves(TreeNode* root) &#123;    int ans = 0;    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        TreeNode* node = que.front();        que.pop();        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)            ans += node-&gt;left-&gt;val;        if (node-&gt;left) que.push(node-&gt;left);   // 左        if (node-&gt;right) que.push(node-&gt;right); // 右    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 572. 另一棵树的子树</title>
      <link href="/posts/1994ddf3/"/>
      <url>/posts/1994ddf3/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJ0cmVlLW9mLWFub3RoZXItdHJlZS8=">572. Subtree of Another Tree</span></p><p>给你两棵二叉树  <code>root</code>  和  <code>subRoot</code>  。检验  <code>root</code>  中是否包含和  <code>subRoot</code>  具有相同结构和节点值的子树。如果存在，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>二叉树  <code>tree</code>  的一棵子树包括  <code>tree</code>  的某个节点和这个节点的所有后代节点。 <code>tree</code>  也可以看做它自身的一棵子树。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/1994ddf3/subtree1-tree.jpg" class=""></p><pre><code>输入：root = [3,4,5,1,2], subRoot = [4,1,2]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/1994ddf3/subtree2-tree.jpg" class=""></p><pre><code>输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]输出：false</code></pre><p></p><p><strong>提示：</strong></p><ul><li><code>root</code>  树上的节点数量范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><code>subRoot</code>  树上的节点数量范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>root.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>subRoot.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-1-深度优先遍历-暴力匹配"><a class="anchor" href="#method-1-深度优先遍历-暴力匹配">#</a> Method 1: 深度优先遍历 + 暴力匹配</h1><p>算法思路：按照前序遍历的顺序枚举树  <code>root</code>  中的每一个节点，判断以这个节点为根的树是否和树  <code>subRoot</code>  相同，其中，判断两树是否相同可参考 <a href="https://jiankychen.github.io/posts/b45c53f3">LeetCode 100. 相同二叉树</a></p><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode *root1, TreeNode *root2) &#123; // 判断以 root1 为根的树是否相同于以 root2 为根的树    if (!root1 &amp;&amp; !root2) return true;    if (!root1 || !root2) return false;    if (root1-&gt;val != root2-&gt;val) return false;    return isSameTree(root1-&gt;left, root2-&gt;left) &amp;&amp; isSameTree(root1-&gt;right, root2-&gt;right);&#125;bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;    if (!root) return false; // root 为空，subRoot 不是 root 的子树    if (isSameTree(root, subRoot)) return true; // 以 root 为根的树 相同于 以 subRoot 为根的树    return isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot); // root 递归到左、右子节点&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是树  <code>root</code>  和树  <code>subRoot</code>  的节点个数</p><ul><li>最坏情况下，需要遍历树  <code>root</code>  中每个节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li><li>判断两树是否相同 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\max(d_r, d_s))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">d_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">d_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别是树  <code>root</code>  和树  <code>subRoot</code>  的深度。这里考虑了递归调用栈，任意时刻下栈使用的最大空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\max(d_r, d_s))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJ0cmVlLW9mLWFub3RoZXItdHJlZS9zb2x1dGlvbi9saW5nLXlpLWdlLXNodS1kZS16aS1zaHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：另一棵树的子树</span></p><h1 id="method-2-深度优先遍历-kmp-匹配"><a class="anchor" href="#method-2-深度优先遍历-kmp-匹配">#</a> Method 2: 深度优先遍历 + KMP 匹配</h1><p>先验知识：一棵子树上的节点在深度优先搜索序列（前序遍历）中是连续的</p><p>因此，可以利用前序遍历得到树  <code>root</code>  和树  <code>subRoot</code>  的节点序列，分别记作  <code>s</code>  和  <code>t</code>  ，然后判断  <code>t</code>  是否为  <code>s</code>  的子串</p><ul><li><p>但需注意，仅仅是前序遍历无法唯一确定一棵二叉树</p></li><li><p>例如， <code>root</code>  由两个点组成：1 是根，2 是 1 的左子节点； <code>subRoot</code>  也由两个点组成：1 是根，2 是 1 的右子节点，此时，树  <code>root</code>  和  <code>subRoot</code>  的前序遍历序列相同，但  <code>subRoot</code>  并不是  <code>root</code>  的某一棵子树</p></li><li><p>由此可见：“  <code>t</code>  是  <code>s</code>  的子串 ” 是 “  <code>subRoot</code>  是  <code>root</code>  的子树 ” 的必要不充分条件</p></li><li><p>对此，可以引入两个空值  <code>lNull</code>  和  <code>rNull</code>  ，当前序遍历遇到空的左子节点、空的右子节点时，分别在节点序列中放入   <code>lNull</code>  和  <code>rNull</code>  值，由此，可以唯一确定一棵二叉树</p></li></ul><p>判断  <code>t</code>  是否为  <code>s</code>  的子串，可以采用暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法</p><p>可参考 <a href="https://jiankychen.github.io/posts/36b55f59">KMP 算法</a> 和 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJ0cmVlLW9mLWFub3RoZXItdHJlZS9zb2x1dGlvbi9saW5nLXlpLWdlLXNodS1kZS16aS1zaHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：另一棵树的子树 - 方法二</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 257. 二叉树的所有路径</title>
      <link href="/posts/30d556a7/"/>
      <url>/posts/30d556a7/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy8=">257. Binary Tree Paths</span></p><p>给你一个二叉树的根节点  <code>root</code>  ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p></p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/30d556a7/paths-tree.jpg" class=""></p><pre><code>输入：root = [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[&quot;1&quot;]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="method-1-前序遍历"><a class="anchor" href="#method-1-前序遍历">#</a> Method 1: 前序遍历</h1><p>算法思路：</p><ol><li><p>定义一个递归函数  <code>getPaths</code>  ，用于获取从  <code>root</code>  到叶节点的路径，具有以下输入参数：</p><ul><li><code>TreeNode* root</code>  ：路径的起点</li><li><code>string path</code>  ：记录当前查找路径。注意，这里不能使用引用  <code>&amp;</code>  ：因为在探寻到叶节点后，需要回溯到它的父节点（以及祖先节点），回溯后的  <code>path</code>  不能包含已经遍历过的叶节点。因此，在每次调用时，都是采用复制赋值的方法传入  <code>path</code>  参数</li><li><code>vector&lt;string&gt; &amp;res</code>  ：存放所有查找到的  <code>root-to-leaf</code>  路径</li></ul></li><li><p>递归函数  <code>getPaths</code>  的实现：</p><ul><li>若  <code>root</code>  为空，当前的递归结束，否则，执行后续操作</li><li>将  <code>root</code>  的值（需转换成  <code>string</code>  类型）添加到  <code>path</code>  中，以记录路径</li><li>若  <code>root</code>  是叶节点，记录到的路径  <code>path</code>  即为一条从根节点到叶节点的路径，将  <code>path</code>  添加到答案数组  <code>res</code>  ，当前递归结束</li><li>若  <code>root</code>  不是叶节点，将路径的间隔符  <code>&quot;-&gt;&quot;</code>  添加到  <code>path</code>  中，并分别递归到左子节点、右子节点</li></ul></li></ol><blockquote><p><code>to_string</code>  函数：将变量转换成  <code>string</code>  类型，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdHJpbmcvdG9fc3RyaW5nLz9rdz10b19zdHJpbmc=">std::to_string</span></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">void getPaths(TreeNode* root, string path, vector&lt;string&gt; &amp;res) &#123;    if (!root) return;    path += to_string(root-&gt;val);      // 将节点值转换成 string 并添加到路径    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // 叶节点        res.push_back(path);           // 将路径添加到目标数组        return;    &#125;    path += &quot;-&gt;&quot;; // 当前节点不是叶节点，继续递归遍历子节点    getPaths(root-&gt;left, path, res);    getPaths(root-&gt;right, path, res);&#125;vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;    vector&lt;string&gt; res;    getPaths(root, &quot;&quot;, res);    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：这里不考虑存放  <code>res</code>  的空间，但考虑  <code>path</code>  变量所需空间：</p><ul><li>对于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 层，存放  <code>path</code>  变量所需的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 小于等于二叉树的高度</li><li>平均情况下，二叉树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，此时，总的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n} \times \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，二叉树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，此时，总的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy9zb2x1dGlvbi9lci1jaGEtc2h1LWRlLXN1by15b3UtbHUtamluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：二叉树的所有路径</span></p><p>本题也可以采用迭代法来实现前序遍历，除了需要一个栈来模拟递归之外，还需要一个栈来存放对应的遍历路径，可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyNTcuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTg5JTgwJUU2JTlDJTg5JUU4JUI3JUFGJUU1JUJFJTg0Lmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1">代码随想录：二叉树的所有路径 - 迭代法</span></p><p>此外，也可以使用层序遍历解题，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy9zb2x1dGlvbi9lci1jaGEtc2h1LWRlLXN1by15b3UtbHUtamluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：二叉树的所有路径 - 方法二</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 110. 平衡二叉树</title>
      <link href="/posts/cd137cbe/"/>
      <url>/posts/cd137cbe/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWxhbmNlZC1iaW5hcnktdHJlZS8=">110. Balanced Binary Tree</span></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1 。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/cd137cbe/balance_1.jpg" class=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/cd137cbe/balance_2.jpg" class=""></p><pre><code>输入：root = [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：true</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="概念辨析"><a class="anchor" href="#概念辨析">#</a> 概念辨析</h1><h2 id="节点的深度与高度"><a class="anchor" href="#节点的深度与高度">#</a> 节点的深度与高度</h2><p>深度是从上往下数，而高度是从下往上数</p><ol><li><p>维基百科</p><ul><li>节点的深度：从根节点到该节点路径上的边的条数</li><li>结点的高度：从该节点到叶节点路径上的边的条数</li></ul></li><li><p>Leetcode</p><ul><li>节点的深度：从根节点到该节点路径上的节点个数</li><li>结点的高度：从该节点到叶节点路径上的节点个数</li></ul></li></ol><p>按照维基百科的定义，根节点的深度为 0 ；按照 Leetcode 的定义，根节点的深度为 1</p><p>这里以 Leetcode 定义为准</p><p><img data-src="https://img-blog.csdnimg.cn/20210203155515650.png" alt="节点的深度与高度" height="150px" /></p><blockquote><p>对于具有相同深度的节点，它们的高度不一定相同，这取决于它们下面的叶结点的深度</p></blockquote><p>计算节点的深度，按照从上往下的顺序去遍历子节点，需要采用前序遍历</p><p>计算节点的高度，按照从下往上的顺序去遍历，需要采用后序遍历</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMTAuJUU1JUI5JUIzJUU4JUExJUExJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU5JUEyJTk4JUU1JUE0JTk2JUU4JUFGJTlE">代码随想录：二叉树节点的深度与高度</span></p><h2 id="树的深度与高度"><a class="anchor" href="#树的深度与高度">#</a> 树的深度与高度</h2><p>二叉树的深度：所有节点中最深节点的深度，即，二叉树最底层节点的深度</p><p>二叉树的高度：根节点的高度</p><p>二叉树的 深度 与 高度 在数值上相等</p><p>因此，计算二叉树的深度（高度），可按照从上往下的顺序（前序遍历、层序遍历）计算最底层节点的深度，也可按照从下往上的顺序（后序遍历）计算根节点的高度</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>按照本题的提示 “若每个节点的左子树与右子树的高度差不超过 1 ，该二叉树为平衡二叉树” ，可以通过计算每个节点左右子树的高度差来判断是否为平衡二叉树</p><p>一棵二叉树为平衡二叉树，当且仅当其所有子树都是平衡二叉树</p><p>因此，可以使用递归来判断。其中，递归可以按照 自顶向下 的顺序，也可以按照 自底向上 的顺序</p><h1 id="method-1-自顶向下"><a class="anchor" href="#method-1-自顶向下">#</a> Method 1: 自顶向下</h1><p>算法思路：</p><ol><li>定义一个递归函数  <code>height</code>  ，用于计算节点  <code>root</code>  的高度</li><li>从根节点开始遍历节点<ul><li>分别调用  <code>height</code>  函数计算左、右子树的高度</li><li>若左右子树的高度差的绝对值大于 1，二叉树不是平衡二叉树，返回  <code>false</code></li><li>若左右子树的高度差的绝对值不超过 1，分别递归到左、右子节点（分别判断以左子节点为根节点、以右子节点为根节点的二叉树是否为平衡二叉树）</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">int height(TreeNode* root) &#123; // 计算 root 节点的高度    if (root == nullptr) return 0;    return 1 + max(height(root-&gt;left), height(root-&gt;right));&#125;bool isBalanced(TreeNode* root) &#123; // 判断以 root 为根节点的树是否为平衡二叉树    if (!root) return true;    if (abs(height(root-&gt;left) - height(root-&gt;right)) &gt; 1) // root 左右子树的高度差大于 1        return false;    return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); // 递归到左右子节点&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li>最坏情况下，二叉树为满二叉树，需要遍历满二叉树的所有节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>对于任意节点  <code>p</code>  ，如果它的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span> ，则  <code>height(p)</code>  最多会被调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span> 次（被  <code>p</code>  及其祖先节点调用），因此节点  <code>p</code>  的计算时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>≤</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">d \le h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 是二叉树的最大高度<ul><li>平均情况下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h) = O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，此时，总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，二叉树呈链状，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，此时，总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归调用栈</p><h1 id="method-2-自底向上"><a class="anchor" href="#method-2-自底向上">#</a> Method 2: 自底向上</h1><p>注意，在上述方法中，对于每个节点， <code>height</code>  函数会被调用多次，故而时间复杂度较高</p><p>可以采用自底向上的顺序，对于每个节点， <code>height</code>  函数仅被调用 1 次</p><p>算法思路：</p><ol><li><p>定义  <code>height</code>  函数，输入参数为  <code>root</code>  ，返回参数为  <code>int</code>  型的数</p><ul><li>分别递归到左子树、右子树（即，调用  <code>height(root-&gt;left)</code>  和  <code>height(root-&gt;right)</code>  ），并记录其返回值</li><li>判断左子树、右子树是否平衡<ul><li>若否，返回  <code>-1</code></li></ul></li><li>判断以当前  <code>root</code>  节点为根节点的树是否平衡<ul><li>若是，返回  <code>root</code>  的高度</li><li>否则，返回  <code>-1</code></li></ul></li></ul></li><li><p>若  <code>height</code>  函数返回值为  <code>-1</code>  ，二叉树不是平衡二叉树， <code>isBalanced</code>  函数返回  <code>false</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int height(TreeNode* root) &#123; // 若二叉树为平衡二叉树，返回 root 的高度；否则，返回 -1    if (!root) return 0;    int leftHight = height(root-&gt;left);    int rightHight = height(root-&gt;right);    if (leftHight == -1 || rightHight == -1 || abs(leftHight - rightHight) &gt; 1) // 非平衡        return -1; // 返回 -1    return 1 + max(leftHight, rightHight); // 平衡，返回高度&#125;bool isBalanced(TreeNode* root) &#123;    if (height(root) == -1) return false;    return true;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>最坏情况下，需要遍历二叉树的所有节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每个节点仅计算一次高度，只进行一次 是否平衡 的判断，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归调用栈</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWxhbmNlZC1iaW5hcnktdHJlZS9zb2x1dGlvbi9waW5nLWhlbmctZXItY2hhLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：平衡二叉树</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 222. 完全二叉树的节点个数</title>
      <link href="/posts/63982204/"/>
      <url>/posts/63982204/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1jb21wbGV0ZS10cmVlLW5vZGVzLw==">LeetCode 222. Count Complete Tree Nodes</span></p><p>给你一棵 <strong>完全二叉树</strong> 的根节点  <code>root</code>  ，求出该树的节点个数。</p><p><strong>完全二叉树</strong> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第  <code>h</code>  层，则该层包含 1~ 2<sup>h</sup> 个节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/63982204/complete.jpg" class=""></p><pre><code>输入：root = [1,2,3,4,5,6]输出：6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：0</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1]输出：1</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5 \times 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><p><strong>进阶：</strong> 遍历树来统计节点是一种时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的简单解决方案。你可以设计一个更快的算法吗？</p><h1 id="method-1-遍历"><a class="anchor" href="#method-1-遍历">#</a> Method 1: 遍历</h1><p>算法思路：遍历二叉树的所有节点，逐个计数</p><p>代码实现：</p><pre><code class="language-cpp">int countNodes(TreeNode* root) &#123;    if (!root) return 0;    int left = countNodes(root-&gt;left);   // 左子树节点数    int right = countNodes(root-&gt;right); // 右子树节点数    return 1 + left + right;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，未考虑递归调用栈</p><blockquote><p>这里采用的是递归法实现遍历（后序遍历），也可以采用迭代法实现</p></blockquote><h1 id="method-2-寻找满二叉树"><a class="anchor" href="#method-2-寻找满二叉树">#</a> Method 2: 寻找满二叉树</h1><p>完全二叉树有两种情况：</p><ul><li>最底层的叶节点是满的，即，二叉树为满二叉树。此时，二叉树的节点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 是树的深度</li><li>最底层的叶节点没有满。此时，从根节点开始，分别递归左子树、右子树，递归到一定深度时就会出现满二叉树，然后按照第一种情况计算节点数量即可</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201124092634138.png" alt="代码随想录：完全二叉树中的满二叉树示意图" height="150px" /></p><p>注意：若根节点的最左侧深度等于最右侧深度，则该二叉树为满二叉树</p><p>代码实现：</p><pre><code class="language-cpp">int countNodes(TreeNode* root) &#123;    if (!root) return 0;    int leftDepth = 1, rightDepth = 1;    TreeNode* leftNode = root-&gt;left;    TreeNode* rightNode = root-&gt;right;    while (leftNode) &#123;  // 左子树的深度（最左侧的深度）        leftDepth++;        leftNode = leftNode-&gt;left;    &#125;    while (rightNode) &#123; // 右子树的深度（最右侧的深度）        rightDepth++;        rightNode = rightNode-&gt;right;    &#125;    if (leftDepth == rightDepth) // 以 root 为根节点的二叉树为满二叉树        return (1 &lt;&lt; leftDepth) - 1; // 利用位左移计算 2^leftDepth    int leftCount = countNodes(root-&gt;left);   // 递归左子树    int rightCount = countNodes(root-&gt;right); // 递归右子树    return 1 + leftCount + rightCount;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n} \times \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为节点数</p><ul><li>对于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的节点（$ 1 \le i \le \log {n}$），需要计算左右子树的深度，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n} - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></li><li>总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow></msub><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{1 \le i \le \log{n}} O(\log{n} - i) = O(\log{n} \times \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.18639799999999984em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归调用栈</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMjIuJUU1JUFFJThDJUU1JTg1JUE4JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU4JThBJTgyJUU3JTgyJUI5JUU0JUI4JUFBJUU2JTk1JUIwLmh0bWwjJUU1JUFFJThDJUU1JTg1JUE4JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkx">代码随想录：完全二叉树的节点个数</span></p><h1 id="method-3-二分查找-位运算"><a class="anchor" href="#method-3-二分查找-位运算">#</a> Method 3: 二分查找 + 位运算</h1><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1jb21wbGV0ZS10cmVlLW5vZGVzL3NvbHV0aW9uL3dhbi1xdWFuLWVyLWNoYS1zaHUtZGUtamllLWRpYW4tZ2Utc2h1LWJ5LWxlZXRjby0yLw==">力扣官方题解：完全二叉树的节点个数</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2. 两数相加</title>
      <link href="/posts/431c26c9/"/>
      <url>/posts/431c26c9/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv">LeetCode 2. Add Two Numbers</span></p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/431c26c9/addtwonumber1.jpg" class=""></p><pre><code>输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：l1 = [0], l2 = [0]输出：[0]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>链表的首端对应数的最低位，末端对应数的最高位</p><p>将两数相加，即，将两链表相同位置上的节点的值相加</p><p>注意，<strong>需要考虑进位</strong></p><ul><li>将来自前一位的进位值加到当前位</li><li>根据当前位的值，更新进位值</li><li>若最高位产生进位，则需新增一个更高位</li></ul><p>本题采用 模拟 算法来实现两数相加，即，模拟两数相加的计算过程（列竖式）</p><h1 id="method-模拟"><a class="anchor" href="#method-模拟">#</a> Method: 模拟</h1><h2 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h2><p>将  <code>l1</code>  作为长链，并利用  <code>l1</code>  存储两数之和的结果</p><p>代码实现：</p><pre><code class="language-cpp">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;    int num1 = 0, num2 = 0;    for (ListNode *cur1 = l1; cur1 != nullptr; cur1 = cur1-&gt;next)        num1++;    for (ListNode *cur2 = l2; cur2 != nullptr; cur2 = cur2-&gt;next)        num2++;    if (num1 &lt; num2) swap(l1, l2);   // 令 l1 指向长链    int tag = 0;    // 进位的值    for (ListNode *cur1 = l1, *cur2 = l2; cur1 != nullptr; cur1 = cur1-&gt;next) &#123;        if (cur2) &#123; // cur2 非空，应计算 cur1 、cur2 、 tag 之和            cur1-&gt;val = cur1-&gt;val + cur2-&gt;val + tag;            cur2 = cur2-&gt;next;        &#125; else      // cur2 为空，只计算 cur1 与 tag 之和            cur1-&gt;val = cur1-&gt;val + tag;        tag = cur1-&gt;val / 10;     // 更新进位值        cur1-&gt;val %= 10;          // 更新进位后的 cur1-&gt;val        if (!cur1-&gt;next &amp;&amp; tag) &#123; // 最高位进 1            cur1-&gt;next = new ListNode(tag);            return l1;        &#125;    &#125;    return l1;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\max(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别为两链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h2><p>定义一个新的链表，存储计算结果</p><p>代码实现：</p><pre><code class="language-cpp">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;    ListNode *head = nullptr;  // head 为结果链表的头节点    ListNode *cur = nullptr;   // cur 为当前节点（通过 cur  将 head 链表串联起来）    int carry = 0;             // 进位    while (l1 || l2) &#123;        int val1 = l1 ? l1-&gt;val : 0, val2 = l2 ? l2-&gt;val : 0; // 获取 l1 与 l2 节点的值        int sum = val1 + val2 + carry; // 计算 l1 与 l2 节点值之和，再加上前一位的进位值        if (head == nullptr) &#123; // head 为空，将两数之后的最低位值赋给 head            cur = new ListNode(sum % 10);            head = cur;        &#125; else &#123;               // head 不为空，令 cur 下一个节点的值为 sum % 10            cur-&gt;next = new ListNode(sum % 10);            cur = cur-&gt;next;        &#125;        carry = sum / 10;      // 更新进位值        if (l1) l1 = l1-&gt;next; // l1 右移        if (l2) l2 = l2-&gt;next; // l2 右移    &#125;    if (carry) // 最高位的进位        cur-&gt;next = new ListNode(carry);    return head;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\max(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别为两链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，这里未考虑存储结果所需的空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMvc29sdXRpb24vbGlhbmctc2h1LXhpYW5nLWppYS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：两数相加</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 111. 二叉树的最小深度</title>
      <link href="/posts/3fb6472b/"/>
      <url>/posts/3fb6472b/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">LeetCode 111. Minimum Depth of Binary Tree</span></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明</strong>：叶子节点是指没有子节点的节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/tmp-tree.jpg" alt="" height="150px" /></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>最小深度：从根节点到最近叶节点的最短路径上的节点数量</p><p>注意：<strong>叶节点是指左右子节点均为空的节点</strong></p><p><img data-src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="" height="200px" /></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMTEuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU1JUIwJThGJUU2JUI3JUIxJUU1JUJBJUE2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：二叉树的最小深度</span></p><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>递归函数：</p><ul><li>输入参数： <code>root</code></li><li>函数返回值：以  <code>root</code>  为根节点的树的最小深度</li></ul><h2 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h2><p>递归终止条件：</p><ul><li><p>若左子树与右子树均不为空，返回  <code>1 + min (左子树最小深度、右子树最小深度)</code></p></li><li><p>若左子树为空、右子树不为空，返回  <code>1 + 右子树的最小深度</code></p></li><li><p>若左子树不为空、右子树为空，返回  <code>1 + 左子树的最小深度</code></p></li><li><p>若右子树与右子树均为空，节点为叶节点，返回  <code>1</code></p></li></ul><p>其中，第四种情况可与第二种（或，第三种）情况合并</p><p>代码实现：</p><pre><code class="language-cpp">int minDepth(TreeNode* root) &#123;    if (!root) return 0;    if (!root-&gt;left) return 1 + minDepth(root-&gt;right);           // 左子树为空（包括左右子树均为空的情形）    if (!root-&gt;right) return 1 + minDepth(root-&gt;left);           // 右子树为空    return 1 + min(minDepth(root-&gt;right), minDepth(root-&gt;left)); // 左右子树均不为空&#125;</code></pre><h2 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h2><p>代码实现：</p><pre><code class="language-cpp">int minDepth(TreeNode* root) &#123; // 返回 root 到叶节点的最小深度    if (root == nullptr) return 0;    int left = minDepth(root-&gt;left);   // 左子树最小深度    int right = minDepth(root-&gt;right); // 右子树最小深度    if (!left || !right)               // 左子树为空，或，右子树为空，最小深度为 1 + left + right        return 1 + left + right;    return 1 + min(left, right);       // 左子树与右子树非空，最小深度为 1 + min(left, right)&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 为二叉树的最大深度（这里考虑了递归时栈空间的开销）</p><ul><li>最坏情况下，树呈现链状，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>平均情况下，树的高度与节点数的对数正相关，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL3NvbHV0aW9uL2xpLWppZS16aGUtZGFvLXRpLWRlLWppZS1zaHUtdGlhby1qaWFuLWJ5LXVzZXI3MjA4Lw==">reals：二叉树的最小深度 - 理解递归结束条件</span></p><h1 id="method-2-层序遍历"><a class="anchor" href="#method-2-层序遍历">#</a> Method 2: 层序遍历</h1><p>算法思路：</p><ul><li>逐层遍历，每层按从左到右顺序遍历</li><li>若遇到叶节点（即，左右子节点均为空），则返回当前遍历到的层数</li></ul><p>代码实现：</p><pre><code class="language-cpp">int minDepth(TreeNode* root) &#123;    int ans = 0;    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        ans++;        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            TreeNode* tmp = que.front();            que.pop();            if (tmp-&gt;left == nullptr &amp;&amp; tmp-&gt;right == nullptr) return ans; // tmp 为叶节点            if (tmp-&gt;left) que.push(tmp-&gt;left);            if (tmp-&gt;right) que.push(tmp-&gt;right);        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 100. 相同二叉树</title>
      <link href="/posts/b45c53f3/"/>
      <url>/posts/b45c53f3/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYW1lLXRyZWUv">100. Same Tree</span></p><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/b45c53f3/ex1.jpg" class=""></p><pre><code>输入：p = [1,2,3], q = [1,2,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/b45c53f3/ex2.jpg" class=""></p><pre><code>输入：p = [1,2], q = [1,null,2]输出：false</code></pre><p><strong>示例 3：</strong></p><p><img data-src="/posts/b45c53f3/ex3.jpg" class=""></p><pre><code>输入：p = [1,2,1], q = [1,1,2]输出：false</code></pre><p></p><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>如果两棵树的所有节点都相同，则这两棵二叉树相同</p><p>因此，判断两棵二叉树是否相同的步骤可分为：</p><ul><li>判断根节点的值是否相等</li><li>判断左子树是否相同</li><li>判断右子树是否相同</li></ul><p>解法类似于 <a href="https://jiankychen.github.io/posts/3c1e41f">LeetCode 101. 对称二叉树</a></p><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>算法思路：</p><ol><li><p>定义递归函数：检查以  <code>p</code>  、  <code>q</code>  为根节点的两棵是否相同</p></li><li><p>递归函数的内部，做以下判断：</p><ul><li>若  <code>p</code>  与  <code>q</code>  同时为空，则两树相同</li><li>若  <code>p</code>  与  <code>q</code>  不同时为空，则两树不同</li><li>若  <code>p</code>  与  <code>q</code>  的值不相等，则两树相同</li><li>若  <code>p</code>  的左子树 与  <code>q</code>  的左子树不相同，则两树不同</li><li>若  <code>p</code>  的右子树 与  <code>q</code>  的右子树不相同，则两树不同</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;    if (!p &amp;&amp; !q) return true;    if (!p || !q) return false;    if (p-&gt;val != q-&gt;val) return false;    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是两棵二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><ul><li>递归调用的层数不会超过较小的二叉树的最大高度</li><li>最坏情况下，二叉树的高度等于节点数</li></ul><h1 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h1><p>本题也可以使用迭代法来显式地维护 Method 1 中调用的栈</p><p>这里利用 栈 来存放待访问的节点（也可以使用队列，区别仅在于节点的访问顺序）</p><h2 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h2><p>类似于 <a href="https://jiankychen.github.io/posts/3c1e41f">LeetCode 101. 对称二叉树</a> 的 Method 2</p><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;    stack&lt;TreeNode*&gt; stk;    stk.push(q);    stk.push(p);    TreeNode *u = nullptr, *v = nullptr;    while (!stk.empty()) &#123;        u = stk.top();        stk.pop();        v = stk.top();        stk.pop();        if ((u == nullptr) &amp;&amp; (v == nullptr)) continue;        if ((u == nullptr) || (v == nullptr)) return false;        if (u-&gt;val != v-&gt;val) return false;        stk.push(v-&gt;right);        stk.push(u-&gt;right);        stk.push(v-&gt;left);        stk.push(u-&gt;left);    &#125;    return true;&#125;</code></pre><p>若采用 队列 来实现迭代法，将上述代码中的 栈（及其成员函数）替换为 队列（及其成员函数）即可</p><h2 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h2><p>为降低算法复杂度，可以仅将非空节点入栈</p><p>因此，在将两棵树的子节点入栈前，须对两棵树的结构进行判断</p><p>算法思路：</p><ol><li>定义一个栈，若  <code>p</code>  与  <code>q</code>  非空，将其入栈</li><li>执行循环，直到栈为空：<ul><li>从栈中取出两个节点，记作  <code>u</code>  和  <code>v</code></li><li>判断  <code>u</code>  和  <code>v</code>  的值是否相等</li><li>判断  <code>u</code>  的右子节点 和  <code>v</code>  的右子节点 是否为空<ul><li>如果有且仅有一个为空，则说明  <code>u</code>  和  <code>v</code>  的右子树结构不同，返回  <code>false</code></li><li>如果均不为空，则将其入栈，以进一步判断右子树是否相同</li></ul></li><li>判断  <code>u</code>  和  <code>v</code>  的左子节点是否为空，类似于上一步</li></ul></li><li>循环结束时，栈为空，且不存在不相同的节点，返回  <code>true</code></li></ol><p>其中，当  <code>u</code>  和  <code>v</code>  的右子节点均为空时，对应的右子树相同，无需再将其入栈，类似地，当  <code>u</code>  和  <code>v</code>  的左子节点均为空时，也无需将其入栈</p><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;    if (!p &amp;&amp; !q) return true;    if (!p || !q) return false;    stack&lt;TreeNode*&gt; stk;    stk.push(q);    stk.push(p);    TreeNode *u = nullptr, *v = nullptr;    while (!stk.empty()) &#123;        u = stk.top();        stk.pop();        v = stk.top();        stk.pop();        if (u-&gt;val != v-&gt;val) return false;        if ((u-&gt;right == nullptr) ^ (v-&gt;right == nullptr)) // u 或 v 不存在右子节点            return false;        if ((u-&gt;left == nullptr) ^ (v-&gt;left == nullptr))   // u 或 v 不存在左子节点            return false;        if (v-&gt;right) stk.push(v-&gt;right); // 将非空的右子节点入栈        if (u-&gt;right) stk.push(u-&gt;right);        if (v-&gt;left) stk.push(v-&gt;left);   // 将非空的左子节点入栈        if (u-&gt;left) stk.push(u-&gt;left);    &#125;    return true;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是两棵二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYW1lLXRyZWUvc29sdXRpb24veGlhbmctdG9uZy1kZS1zaHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：相同的树</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 101. 对称二叉树</title>
      <link href="/posts/3c1e41f/"/>
      <url>/posts/3c1e41f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">LeetCode 101. Symmetric Tree</span></p><p>给你一个二叉树的根节点  <code>root</code>  ， 检查它是否轴对称。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/3c1e41f/symtree1.jpg" class=""></p><pre><code>输入：root = [1,2,2,3,4,4,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/3c1e41f/symtree2.jpg" class=""></p><pre><code>输入：root = [1,2,2,null,3,null,3]输出：false</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：你可以运用递归和迭代两种方法解决这个问题吗？</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>如果一棵树的左子树与右子树对称，那么这棵树就是对称的</p><p>进一步地分析，子树 A1 与子树 A2 对称，需要满足以下条件：</p><ul><li>A1 的根节点值 等于 A2 的根节点值</li><li>A1 的左子树 与 A2 的右子树 对称</li><li>A1 的右子树 与 A2 的左子树 对称</li></ul><p>如下图所示，检查二叉树对称性的步骤可分为：</p><ul><li>检查 B 与 C 的值是否相等</li><li>检查 D 与 G 的值是否相等</li><li>检查 E 与 F 的值是否相等</li></ul><p><img data-src="/posts/3c1e41f/example.png" class=""></p><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>算法思路：</p><ol><li><p>定义一个递归函数，函数传入两个参数：</p><ul><li>指针  <code>l</code>  ：指向左侧的子树 A1</li><li>指针  <code>r</code>  ：指向右侧的子树 A2</li></ul></li><li><p>递归函数的作用：检查子树 A1 与 A2 是否对称</p></li><li><p>递归函数的内部，做以下判断：</p><ul><li>若  <code>l</code>  与  <code>r</code>  同时为空，则 A1 与 A2 对称</li><li>若  <code>l</code>  与  <code>r</code>  不同时为空，则 A1 与 A2 不对称</li><li>若  <code>l</code>  与  <code>r</code>  的值不相等，则 A1 与 A2 不对称</li><li>若  <code>l</code>  的左子树 与  <code>r</code>  的右子树不对称，则 A1 与 A2 不对称</li><li>若  <code>l</code>  的右子树 与  <code>r</code>  的左子树不对称，则 A1 与 A2 不对称</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool check(TreeNode* l, TreeNode* r) &#123;  // 检查 l 与 r 及其子树是否对称    if (l == nullptr &amp;&amp; r == nullptr) return true;  // l 与 r 均为空    if (l == nullptr || r == nullptr) return false; // l 为空，或，r 为空    if (l-&gt;val != r-&gt;val) return false; // 检查 l 与 r 是否对称    return check(l-&gt;left, r-&gt;right) &amp;&amp; check(l-&gt;right, r-&gt;left); // 检查 l 与 r 的子树是否对称&#125;bool isSymmetric(TreeNode* root) &#123;    if (root == nullptr) return true;    return check(root-&gt;left, root-&gt;right);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><h1 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h1><p>对于二叉树的前序、中序、后序遍历，我们可以使用迭代法来显式地维护递归调用的栈</p><p>类似地，本题可以定义一个 队列 来显式地维护 Method 1 中递归调用的栈，以检查两棵子树的对称性</p><blockquote><p>这里为了能够逐层遍历，采用的是 队列 来实现迭代法，事实上，也可以使用 栈 来实现</p></blockquote><p>算法流程：</p><ol><li>定义一个队列，并将根节点  <code>root</code>  的两个子节点入队</li><li>执行循环，直到队列为空：<ul><li>从队列中取出两个节点，记作  <code>u</code>  和  <code>v</code>  （类似于 Method 1 中的 指针  <code>l</code>  和  <code>r</code>  ，分别指向子树 A1 和 A2）</li><li>若  <code>u</code>  和  <code>v</code>  均为空，则跳过本次循环</li><li>若  <code>u</code>  和  <code>v</code>  中有且仅有一个为空，则子树不对称，返回  <code>false</code></li><li>若  <code>u</code>  和  <code>v</code>  均不为空，判断  <code>u</code>  与  <code>v</code>  的值是否相等，若不相等，则返回  <code>false</code></li><li>将  <code>u</code>  的左子节点、 <code>v</code>  的右子节点依次入队</li><li>将  <code>u</code>  的右子节点、 <code>v</code>  的左子节点依次入队</li></ul></li><li>循环结束时，队列为空，不存在不对称的子树，返回  <code>true</code></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool isSymmetric(TreeNode* root) &#123;    if (root == nullptr) return true;    queue&lt;TreeNode*&gt; que;    que.push(root-&gt;left);    que.push(root-&gt;right);    TreeNode *u = new TreeNode(0), *v = new TreeNode(0);    while (!que.empty()) &#123;        u = que.front();    // 指向子树 A1        que.pop();        v = que.front();    // 指向子树 A2        que.pop();        if (!u &amp;&amp; !v) continue;             // A1 与 A2 同时为空        if (!u || !v) return false;         // A1 与 A2 不同时为空        if (u-&gt;val != v-&gt;val) return false; // A1 与 A2 的根节点值不相等        que.push(u-&gt;left);  // A1 的左子树        que.push(v-&gt;right); // A2 的右子树        que.push(u-&gt;right); // A1 的右子树        que.push(v-&gt;left);  // A2 的左子树    &#125;    return true;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 589. N 叉树的前序遍历 / LeetCode 590. N 叉树的后序遍历</title>
      <link href="/posts/f9949bc5/"/>
      <url>/posts/f9949bc5/</url>
      
        <content type="html"><![CDATA[<h1 id="n-叉树的前序遍历"><a class="anchor" href="#n-叉树的前序遍历">#</a> N 叉树的前序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXByZW9yZGVyLXRyYXZlcnNhbC8=">589. N-ary Tree Preorder Traversal</span></p><p>给定一个 n 叉树的根节点  <code>root</code>  ，返回 其节点值的 <strong>前序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值  <code>null</code>  分隔。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/f9949bc5/example1.png" class=""></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]输出：[1,3,5,6,2,4]</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/f9949bc5/example2.png" class=""></p><pre><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</code></pre><p><strong>提示：</strong></p><ul><li>节点总数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>n 叉树的高度小于或等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归法很简单，你可以使用迭代法完成此题吗？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>类似于 <a href="https://jiankychen.github.io/posts/1e967892">144. 二叉树的前序遍历</a></p><h2 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h2><p>算法思路：按照 根 - 左 - 右 的顺序访问节点，并将节点的值添加到目标数组</p><p>代码实现：</p><pre><code class="language-cpp">void DFS(Node* root, vector&lt;int&gt; &amp;res) &#123;    if (root == nullptr) return;    res.push_back(root-&gt;val);        // 将 root 的值添加到数组 res    for (auto node : root-&gt;children) // 访问子节点        DFS(node, res);&#125;vector&lt;int&gt; preorder(Node* root) &#123;    vector&lt;int&gt; res;    DFS(root, res);    return res;&#125;</code></pre><h2 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h2><p>算法思路：子节点须按从右到左的顺序依次放入栈中，以使得子节点按从左到右顺序出栈，以实现 根 - 左 - 右 顺序访问</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorder(Node* root) &#123;    vector&lt;int&gt; res;    stack&lt;Node*&gt; stk;    if (root) stk.push(root);    Node* tmp = new Node(0);    while (!stk.empty()) &#123;        tmp = stk.top();        stk.pop();        res.push_back(tmp-&gt;val);        int size = tmp-&gt;children.size();        for (int i = size - 1; i &gt;= 0; i--) &#123; // 逆序入栈，顺序出栈            if (tmp-&gt;children[i]) stk.push(tmp-&gt;children[i]);        &#125;    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="n-叉树的后序遍历"><a class="anchor" href="#n-叉树的后序遍历">#</a> N 叉树的后序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXBvc3RvcmRlci10cmF2ZXJzYWwv">LeetCode 590. N-ary Tree Postorder Traversal</span></p><p>Given the  <code>root</code>  of an n-ary tree, return <em>the postorder traversal of its nodes' values</em>.</p><h2 id="思路-2"><a class="anchor" href="#思路-2">#</a> 思路</h2><p>类似于 <a href="https://jiankychen.github.io/posts/4e96229e">145. 二叉树的后序遍历</a></p><h2 id="method-1-递归-2"><a class="anchor" href="#method-1-递归-2">#</a> Method 1: 递归</h2><p>算法思路：按照 左 - 右 - 根 的顺序访问节点，并将节点的值添加到目标数组</p><p>代码实现：</p><pre><code class="language-cpp">void DFS(Node* root, vector&lt;int&gt; &amp;res) &#123; // 左-右-根    if (root == nullptr) return;    int size = root-&gt;children.size();    for (int i = 0; i &lt; size; i++)        DFS(root-&gt;children[i], res);    res.push_back(root-&gt;val);&#125;vector&lt;int&gt; postorder(Node* root) &#123;    vector&lt;int&gt; res;    DFS(root, res);    return res;&#125;</code></pre><h2 id="method-2-迭代-2"><a class="anchor" href="#method-2-迭代-2">#</a> Method 2: 迭代</h2><p>算法思路：</p><ul><li><p>按照 根 - 右 - 左 的顺序访问节点，并将节点的值添加到目标数组</p></li><li><p>最后将目标数组反转，即为所求</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorder(Node* root) &#123;    vector&lt;int&gt; res;    stack&lt;Node*&gt; stk;    if (root) stk.push(root);    Node* tmp = new Node(0);    while (!stk.empty()) &#123;        tmp = stk.top();        stk.pop();        res.push_back(tmp-&gt;val);        int size = tmp-&gt;children.size();        for (int i = 0; i &lt; size; i++) // 节点按从左到右顺序入栈，按逆序出栈            if (tmp-&gt;children[i]) stk.push(tmp-&gt;children[i]);    &#125;    reverse(res.begin(), res.end());    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 226. 翻转二叉树</title>
      <link href="/posts/94c5ffae/"/>
      <url>/posts/94c5ffae/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">LeetCode 226. Invert Binary Tree</span></p><p>给你一棵二叉树的根节点  <code>root</code>  ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p height="150px"><img data-src="/posts/94c5ffae/invert1-tree.jpg" class=""></p><pre><code>输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p><strong>示例 2：</strong></p><p height="150px"><img data-src="/posts/94c5ffae/invert2-tree.jpg" class=""></p><pre><code>输入：root = [2,1,3]输出：[2,3,1]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>翻转二叉树的本质是：交换每个节点的左右子节点</p><p>因此，本题需遍历二叉树，并翻转每个节点的左右子节点</p><p>本题采用前序、中序、后序、层序遍历都可以</p><blockquote><p>若采用中序遍历，即，按照 “翻转左子树、交换左右子节点、翻转右子树” 这一原理进行操作时，须注意，在交换左右子节点以后，原本的右子树将变成左子树，因此， “翻转右子树” 须通过 翻转左子树 实现。可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMjYuJUU3JUJGJUJCJUU4JUJEJUFDJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU2JThCJTkzJUU1JUIxJTk1">代码随想录：翻转二叉树</span></p></blockquote><h1 id="method-1-前序遍历递归"><a class="anchor" href="#method-1-前序遍历递归">#</a> Method 1: 前序遍历（递归）</h1><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;    if (root == nullptr) return root;    swap(root-&gt;left, root-&gt;right); // 交换左、右子节点    invertTree(root-&gt;right);       // 将最初的左子树（新的右子树）翻转    invertTree(root-&gt;left);        // 将最初的右子树（新的左子树）翻转    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-前序遍历迭代"><a class="anchor" href="#method-2-前序遍历迭代">#</a> Method 2: 前序遍历（迭代）</h1><h2 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h2><p>类似于 <a href="https://jiankychen.github.io/posts/1e967892">144. 二叉树的前序遍历</a></p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;    stack&lt;TreeNode*&gt; stk;    if (root) stk.push(root);    TreeNode* tmp = new TreeNode();    while (!stk.empty()) &#123;        tmp = stk.top();        stk.pop();        swap(tmp-&gt;left, tmp-&gt;right);          // 交换左右子节点        if (tmp-&gt;left) stk.push(tmp-&gt;left);   // 将最初的右子节点（新的左子节点）入栈        if (tmp-&gt;right) stk.push(tmp-&gt;right); // 将最初的左子节点（新的右子节点）入栈    &#125;    return root;&#125;</code></pre><h2 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h2><p>类似于 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU3JUJCJTlGJUU0JUI4JTgwJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1Lmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1JUU1JTg5JThEJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2">二叉树深度优先搜索的统一迭代法</span> ，在第一次访问到某个节点时，不对该节点进行处理，反而将其重新放入栈，并紧接着放入一个空指针</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;    stack&lt;TreeNode*&gt; stk;    if (root) stk.push(root);    while (!stk.empty()) &#123;        TreeNode* node = stk.top();        stk.pop();        if (node == NULL) &#123; // 遇到空指针，意味着第二次访问到根节点            node = stk.top();            stk.pop();            swap(node-&gt;left, node-&gt;right); // 将左右子节点进行交换        &#125; else &#123;  // 非空指针，意味着第一次访问到根节点            if (node-&gt;right) stk.push(node-&gt;right); // 将右子节点入栈（此前并未交换过左右子节点）            if (node-&gt;left) stk.push(node-&gt;left);   // 将左子节点入栈            stk.push(node); // 访问过 node 节点，但并未处理，将其重新放入栈            stk.push(NULL); // 加入空指针作为标记        &#125;    &#125;    return root;&#125;</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMjYuJUU3JUJGJUJCJUU4JUJEJUFDJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU2JUI3JUIxJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU5JTgxJThEJUU1JThFJTg2">代码随想录：翻转二叉树之深度优先遍历</span></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-3-层序遍历"><a class="anchor" href="#method-3-层序遍历">#</a> Method 3: 层序遍历</h1><p>Method 1 与 Method 2 均为深度优先搜索，本题也还可以采用广度优先搜索，即，层序遍历</p><p>与 <a href="https://jiankychen.github.io/posts/c7ba20f5">102. 二叉树的层序遍历</a> 不同，本题无需按层输出结果，故而，在交换左右字节数时，不需要每次从队列中取出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个元素（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 为当前所在层数），只需逐个取出元素即可</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    TreeNode* tmp = new TreeNode();    while (!que.empty()) &#123;        tmp = que.front();        que.pop();        swap(tmp-&gt;left, tmp-&gt;right);          // 交换左右子节点        if (tmp-&gt;right) que.push(tmp-&gt;right); // 将最初的左子节点（新的右子节点）入队        if (tmp-&gt;left) que.push(tmp-&gt;left);   // 将最初的右子节点（新的左子节点）入队    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 104. 二叉树的最大深度 / LeetCode 559. N 叉树的最大深度</title>
      <link href="/posts/356d8218/"/>
      <url>/posts/356d8218/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的最大深度"><a class="anchor" href="#二叉树的最大深度">#</a> 二叉树的最大深度</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">LeetCode 104. Maximum Depth of Binary Tree</span></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明</strong>：叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p height="150px"><img data-src="/posts/356d8218/tmp-tree.jpg" class=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,null,2]输出：2</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>二叉树的深度是从上往下数，而高度是从下往上数</p><p>即，按前序遍历顺序求的是二叉树的深度，按后序遍历顺序求的是二叉树的高度。具体可参考 <a href="https://jiankychen.github.io/posts/cd137cbe/">LeetCode 110. 平衡二叉树</a> 中的概念辨析</p><h2 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h2><p>本题可通过后序遍历来计算根节点的高度，从而得到二叉树的最大深度（根节点的高度，即为二叉树的最大深度）</p><p>算法思路：</p><ul><li (l,="" r)=""><p>若已知左子树和右子树的高度分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> ，则二叉树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>max</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">1 + \max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop">max</span></span></span></span></p></li><li><p>左子树与右子树的高度可通过同样方式获得，即，递归</p></li><li><p>递归的终止条件为：节点为空</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(TreeNode* root) &#123;    if (root == nullptr) return 0; // 当 root 为空时，深度为 0    int l = maxDepth(root-&gt;left);  // 左子树的高度    int r = maxDepth(root-&gt;right); // 右子树的高度    int ans = 1 + max(l, r);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 为二叉树的最大深度（这里考虑了递归所需的栈空间）</p><blockquote><p>本题也可以使用前序遍历计算节点的深度，节点深度的最大值即为二叉树的最大深度。具体可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDQuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU1JUE0JUE3JUU2JUI3JUIxJUU1JUJBJUE2Lmh0bWwjJUU5JTgwJTkyJUU1JUJEJTkyJUU2JUIzJTk1">代码随想录：二叉树的最大深度</span></p></blockquote><h2 id="method-2-层序遍历"><a class="anchor" href="#method-2-层序遍历">#</a> Method 2: 层序遍历</h2><p>算法思路：</p><ul><li>利用队列存储待访问的节点，与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似</li><li>逐层遍历，遍历的层数就是二叉树的最大深度（即，从根节点到最底层节点所经历的层数）</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(TreeNode* root) &#123;    int ans = 0; // 二叉树的深度    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            TreeNode* tmp = que.front();            que.pop();            if (tmp-&gt;left) que.push(tmp-&gt;left);            if (tmp-&gt;right) que.push(tmp-&gt;right);        &#125;        ans++;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL3NvbHV0aW9uL2VyLWNoYS1zaHUtZGUtenVpLWRhLXNoZW4tZHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：二叉树的最大深度</span></p><h1 id="n-叉树的最大深度"><a class="anchor" href="#n-叉树的最大深度">#</a> N 叉树的最大深度</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLW4tYXJ5LXRyZWUv">LeetCode 559. Maximum Depth of N-ary Tree</span></p><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/356d8218/narytreeexample1.png" class=""></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]输出：3</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/356d8218/narytreeexample2.png" class=""></p><pre><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：5</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树的深度不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>树的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li></ul><h2 id="method-1-递归-2"><a class="anchor" href="#method-1-递归-2">#</a> Method 1: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(Node* root) &#123;    if (!root) return 0;    int depth = 0;    for (int i = 0; i &lt; root-&gt;children.size(); i++) &#123;        int temp = maxDepth(root-&gt;children[i]); // 第 i 棵子树的最大深度        depth = max(depth, temp); // 所有子树的最大深度    &#125;    return 1 + depth;             // 以 root 为根节点的树的最大深度&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为 N 叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 为 N 叉树的最大深度（这里考虑了递归所需的栈空间）</p><h2 id="method-2-层序遍历-2"><a class="anchor" href="#method-2-层序遍历-2">#</a> Method 2: 层序遍历</h2><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(Node* root) &#123;    int depth = 0;    queue&lt;Node*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        depth++;        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            Node* tmp = que.front();            que.pop();            for (int j = 0; j &lt; tmp-&gt;children.size(); j++)                if (tmp-&gt;children[j]) que.push(tmp-&gt;children[j]);        &#125;    &#125;    return depth;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为 N 叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 117. 填充每个节点的下一个右侧节点指针 II</title>
      <link href="/posts/9147e73d/"/>
      <url>/posts/9147e73d/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLWlpLw==">LeetCode 117. Populating Next Right Pointers in Each Node II</span></p><p>给定一个二叉树：</p><pre><code>struct Node &#123;    int val;    Node *left;    Node *right;    Node *next;&#125;</code></pre><p>填充它的每个  <code>next</code>  指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将  <code>next</code>  指针设置为  <code>NULL</code>  。</p><p>初始状态下，所有  <code>next</code>  指针都被设置为  <code>NULL</code>  。</p><p></p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/9147e73d/example.png" class=""></p><pre><code>输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>6000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 6000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>与 <a href="">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 不同，本题并未限定二叉树为满二叉树</p><p>因此，针对每个节点，都需在其右侧寻找距离其最近的节点</p><h1 id="method-1-层序遍历"><a class="anchor" href="#method-1-层序遍历">#</a> Method 1: 层序遍历</h1><p>算法思路：与 <a href="https://jiankychen.github.io/33b5a27e">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 的 Method 1 相同，利用队列存放待访问的节点，在二叉树每一层的访问完成之前，队列下一个元素即为当前元素  <code>next</code>  指针应指向的对象</p><blockquote><p>该算法与 二叉树是否为满二叉树 无关</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;    queue&lt;Node*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            Node* cur = que.front();            que.pop();            if (i &lt; size - 1) cur-&gt;next = que.front();            if (cur-&gt;left) que.push(cur-&gt;left);            if (cur-&gt;right) que.push(cur-&gt;right);        &#125;    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-使用已建立的-next-指针"><a class="anchor" href="#method-2-使用已建立的-next-指针">#</a> Method 2: 使用已建立的 next 指针</h1><p>算法思路：</p><ul><li><p>与 <a href="https://jiankychen.github.io/33b5a27e">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 的 Method 2 类似，可以利用已经建立了的  <code>next</code>  指针：即，在遍历  <code>cur</code>  的过程中，与  <code>cur</code>  处于同一层的各个节点的  <code>next</code>  指针均已建立完成，需要建立的是  <code>cur</code>  下一层节点的  <code>next</code>  指针</p></li><li><p>不同的是，由于二叉树不一定为满二叉树， <code>cur</code>  不一定存在左、右子节点，如果存在的话， <code>cur-&gt;left</code>  、  <code>cur-&gt;right</code>  应分别指向  <code>cur-&gt;left</code>  右侧的第一个节点、 <code>cur-&gt;right</code>  右侧的第一个节点，如 示例 1 所示</p></li><li><p>由于  <code>pre</code>  不一定具有左子节点，在更新  <code>pre</code>  时，不能简单地令  <code>pre = pre-&gt;left</code>  ，需要对  <code>pre</code>  下一层的节点情况进行判断，更准确地说，需要找到  <code>pre</code>  下一层的最左侧节点，将其作为新的  <code>pre</code></p></li></ul><p>因此，本题在 <a href="https://jiankychen.github.io/33b5a27e">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 的基础上，作出以下改变：</p><ul><li><p>定义  <code>leftmost</code>  指向  <code>pre</code>  下一层的最左侧节点</p></li><li><p>定义一个  <code>handle</code>  函数，在  <code>root</code>  右侧找到第一个非叶节点，返回其左子节点（不存在左子节点时，则返回右子节点）</p><ul><li>该函数用于确定  <code>cur-&gt;left</code> （不存在  <code>cur-&gt;right</code>  时）、 <code>cur-&gt;right</code>  的  <code>next</code>  指针的方向，也用于  <code>leftmost</code>  的更新</li></ul></li></ul><p>代码实现：</p><pre><code class="language-cpp">Node* handle(Node* root) &#123; // 寻找 root 右侧第一个非叶节点的子节点（靠左侧的子节点）    Node* cur = root-&gt;next;    while (cur != nullptr) &#123;        if (cur-&gt;left) return cur-&gt;left;        if (cur-&gt;right) return cur-&gt;right;        cur = cur-&gt;next;    &#125;    return nullptr;&#125;Node* connect(Node* root) &#123;    if (root == nullptr) return root;    Node* pre = root;    Node* leftmost = pre-&gt;left ? pre-&gt;left : pre-&gt;right; // pre 下一层的最左侧节点    while (leftmost != nullptr) &#123;  // 当 pre 不是叶节点时执行循环        Node* cur = pre;        while (cur != nullptr) &#123;            if (cur-&gt;left)   // 当 cur 存在左子节点时，其 next 指针指向 cur-&gt;left 右侧第一个节点                cur-&gt;left-&gt;next = cur-&gt;right ? cur-&gt;right : handle(cur);            if (cur-&gt;right)  // 当 cur 存在右子节点时，其 next 指针指向 cur-&gt;right 右侧第一个节点                cur-&gt;right-&gt;next = handle(cur);            cur = cur-&gt;next; // cur 向右移动        &#125;        pre = leftmost;      // pre 向下移动：更新 pre 为 leftmost        if (pre-&gt;left)       // 更新 leftmost            leftmost = pre-&gt;left;        else if (pre-&gt;right)            leftmost = pre-&gt;right;        else            leftmost = handle(pre);    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数，每个节点至多被访问 3 次</p><ul><li>确定  <code>cur-&gt;left</code>  和  <code>cur-&gt;right</code>  的  <code>next</code>  指针时，至多访问 <code>cur</code>  右侧各个节点 1 次</li><li>遍历  <code>cur</code>  时，访问各节点 1 次</li><li>更新  <code>leftmost</code>  时，至多访问  <code>pre</code>  下一层的各个节点 1 次</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p>注意，本题的样例并不一定为满二叉树，不能将该算法改写成递归法（深度优先搜索）。因为在调用  <code>handle</code>  时，与  <code>root</code>  同一层节点的  <code>next</code>  指针可能并未更新完成，这将导致  <code>handle</code>  函数返回错误结果</p></blockquote><p>与 Method 1 相比，Method 2 的时间复杂度相对较高，空间复杂度相对较低</p><h1 id="method-3-链表"><a class="anchor" href="#method-3-链表">#</a> Method 3: 链表</h1><p>可以将二叉树的每一层都看成一个链表</p><p>算法流程：</p><ol><li><p>定义：指针  <code>dummyHead</code>  指向虚拟头节点，指针  <code>cur</code>  指向当前遍历到的二叉树节点，指针  <code>LinkedNode</code>  指向链表的当前节点</p></li><li><p>当  <code>cur</code>  不为空时，执行循环：</p><ul><li>令  <code>LinkedNode = dummyHead</code></li><li>在同一层上遍历  <code>cur</code>  ：<ul><li>若  <code>cur</code>  的左子节点不为空，将左子节点串进链表，并更新  <code>LinkedNode</code></li><li>若  <code>cur</code>  的右子节点不为空，将右子节点串进链表，并更新  <code>LinkedNode</code></li><li>继续访问这一层的下一个节点</li></ul></li><li>更新  <code>cur</code>  为下一层的最左侧节点，即， <code>cur = dummyHead-&gt;next</code></li><li>重置哑结点  <code>dummyHead</code>  的  <code>next</code>  指针，即， <code>dummyHead-&gt;next = nullptr</code></li></ul></li></ol><blockquote><p>在内层的循环中，遍历的是  <code>cur</code>  所在层的节点，串联的是  <code>cur</code>  下一层的节点</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;    if (root == nullptr) return root;    Node* cur = root;              // 当前节点    Node* dummyHead = new Node();  // 链表的哑结点（定义在最外层，确保空间复杂度为 O(1)）    Node* LinkedNode = nullptr;    // 链表的当前节点    while (cur != nullptr) &#123;        LinkedNode = dummyHead;        while (cur != nullptr) &#123; // 遍历 cur ，将 cur 下一层的节点串联成链表            if (cur-&gt;left) &#123;                LinkedNode-&gt;next = cur-&gt;left;  // 将 cur 左子节点串进链表                LinkedNode = LinkedNode-&gt;next; // LinkedNode 右移            &#125;            if (cur-&gt;right) &#123;                LinkedNode-&gt;next = cur-&gt;right; // 将 cur 右子节点串进链表                LinkedNode = LinkedNode-&gt;next; // LinkedNode 右移            &#125;            cur = cur-&gt;next;   // cur 向右移动        &#125;        cur = dummyHead-&gt;next; // cur 向下移动        dummyHead-&gt;next = nullptr; // 重置 dummyHead 的 next 指针    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLWlpL3NvbHV0aW9uL2Jmc2ppZS1qdWUtenVpLWhhby1kZS1qaS1iYWktbGlhby0xMDBkZS15b25nLWh1LWJ5Lw==">sdwwld：BFS 解决</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 515. 在每个树行中找最大值</title>
      <link href="/posts/a04bbb24/"/>
      <url>/posts/a04bbb24/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWxhcmdlc3QtdmFsdWUtaW4tZWFjaC10cmVlLXJvdy8=">LeetCode 515. Find Largest Value in Each Tree Row</span></p><p>给定一棵二叉树的根节点  <code>root</code>  ，请找出该二叉树中每一层的最大值。</p><p></p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/a04bbb24/example1.jpg" class=""></p><pre><code>输入：root = [1,3,2,5,3,null,9]输出：[1,3,9]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,2,3]输出：[1,3]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似</p><p>逐层、从左到右遍历，利用队列存放待访问的节点</p><p>在遍历过程中，只需将 每一层节点值的最大值 添加到目标数组</p><h1 id="method-广度优先搜索"><a class="anchor" href="#method-广度优先搜索">#</a> Method: 广度优先搜索</h1><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; largestValues(TreeNode* root) &#123;    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    vector&lt;int&gt; ans;    while (!que.empty()) &#123;        int size = que.size();        int value = que.front()-&gt;val; // 每一行的最大值        for (int i = 0; i &lt; size; i++) &#123;            TreeNode* node = que.front();            que.pop();            if (node-&gt;val &gt; value) value = node-&gt;val; // 查找最大值            if (node-&gt;left) que.push(node-&gt;left);            if (node-&gt;right) que.push(node-&gt;right);        &#125;        ans.push_back(value); // 将最大值添加到目标数组    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 429. N 叉树的层序遍历</title>
      <link href="/posts/703dcf9d/"/>
      <url>/posts/703dcf9d/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLWxldmVsLW9yZGVyLXRyYXZlcnNhbC8=">LeetCode 429. N-ary Tree Level Order Traversal</span></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔。</p><p></p><p><strong>示例 1：</strong></p><p height="200px"><img data-src="/posts/703dcf9d/narytreeexample1.png" class=""></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]]</code></pre><p><strong>示例 2：</strong></p><p height="200px"><img data-src="/posts/703dcf9d/narytreeexample2.png" class=""></p><pre><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树的高度不会超过 1000</li><li>树的节点总数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 之间</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>从上到下、逐层遍历二叉树，每层按从左到右顺序遍历</p><p>对于 <strong>N 叉树</strong> 而言，每个节点可能有多个子节点，不失一般性地，指向子节点的指针存放在数组中</p><p>即，N 叉树的每个元素都有两个成员变量：节点的值  <code>val</code>  、存放子节点指针的数组  <code>children</code></p><pre><code class="language-cpp">// N 叉树节点的定义class Node &#123;public:    int val;    vector&lt;Node*&gt; children;    Node() &#123;&#125;    Node(int _val) &#123;        val = _val;    &#125;    Node(int _val, vector&lt;Node*&gt; _children) &#123;        val = _val;        children = _children;    &#125;&#125;;</code></pre><h1 id="method-广度优先搜索"><a class="anchor" href="#method-广度优先搜索">#</a> Method: 广度优先搜索</h1><p>算法思路：</p><ul><li>与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似，利用队列存放待访问的节点</li><li>不同点在于：在 将子节点指针入队 的过程中，需要遍历子节点指针数组  <code>children</code></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    queue&lt;Node*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        vector&lt;int&gt; tmp;        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            Node* cur = que.front();            que.pop();            tmp.push_back(cur-&gt;val);            for (Node* child : cur-&gt;children) &#123; // 子节点                if (child) que.push(child);            &#125;        &#125;        res.push_back(tmp);    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 637. 二叉树的层平均值</title>
      <link href="/posts/3c63380e/"/>
      <url>/posts/3c63380e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hdmVyYWdlLW9mLWxldmVscy1pbi1iaW5hcnktdHJlZS8=">LeetCode 637. Average of Levels in Binary Tree</span></p><p>给定一个非空二叉树的根节点  <code>root</code>  , 以数组的形式返回每一层节点的平均值。与实际答案相差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/3c63380e/avg1-tree.jpg" class=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/3c63380e/avg2-tree.jpg" class=""></p><pre><code>输入：root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数量范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>层次遍历</p><p>对于每一层，只需将 该层所有节点的平均值 添加到目标数组</p><p>注意，均值为  <code>double</code>  型</p><h1 id="method-广度优先搜索"><a class="anchor" href="#method-广度优先搜索">#</a> Method: 广度优先搜索</h1><p>算法流程：与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a>  类似，区别在于，只需记录每一层节点值的平均值</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;    vector&lt;double&gt; res;    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        int size = que.size();        double sum = 0;               // double 型        for (int i = 0; i &lt; size; i++) &#123;            TreeNode* node = que.front();            que.pop();            sum += node-&gt;val;            if (node-&gt;left) que.push(node-&gt;left);            if (node-&gt;right) que.push(node-&gt;right);        &#125;        res.push_back(sum / size);    // 仅记录每一层节点的平均值    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 199. 二叉树的右视图</title>
      <link href="/posts/3e207964/"/>
      <url>/posts/3e207964/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">LeetCode 199. Binary Tree Right Side View</span></p><p>给定一个二叉树的根节点  <code>root</code> ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/3e207964/tree.jpg" class=""></p><pre><code>输入：root = [1,2,3,null,5,null,4]输出：[1,3,4]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,null,3]输出：[1,3]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>逐层、从左到右遍历，利用队列存放待访问的节点</p><p>在遍历过程中，只需将 每层最右侧节点的值 添加到目标数组</p><h1 id="method-广度优先搜索"><a class="anchor" href="#method-广度优先搜索">#</a> Method: 广度优先搜索</h1><p>算法流程：与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似，区别在于，只需记录每一层最右侧节点的值</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; rightSideView(TreeNode* root) &#123;    vector&lt;int&gt; res;    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        int size = que.size();        TreeNode* node = nullptr;        // 当前遍历节点的指针        for (int i = 0; i &lt; size; i++) &#123; // for 循环结束时，node 指向该层最右侧节点            node = que.front();            que.pop();            if (node-&gt;left) que.push(node-&gt;left);            if (node-&gt;right) que.push(node-&gt;right);        &#125;        res.push_back(node-&gt;val);    // 仅记录每一层最右侧节点的值    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-深度优先搜索"><a class="anchor" href="#method-深度优先搜索">#</a> Method: 深度优先搜索</h2><p>可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcvc29sdXRpb24vZXItY2hhLXNodS1kZS15b3Utc2hpLXR1LWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：二叉树的右视图</span> 的方法一</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 107. 二叉树的层序遍历 II</title>
      <link href="/posts/78cba97a/"/>
      <url>/posts/78cba97a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwtaWkv">LeetCode 107. Binary Tree Level Order Traversal II</span></p><p>给你二叉树的根节点  <code>root</code>  ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/78cba97a/tree1.jpg" class=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 不同，本题的遍历是从二叉树底层向上遍历</p><h2 id="method-广度优先搜索"><a class="anchor" href="#method-广度优先搜索">#</a> Method: 广度优先搜索</h2><p>算法流程：</p><ol><li><p>按照 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 算法自上而下遍历二叉树</p></li><li><p>反转目标数组</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    queue&lt;TreeNode*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        int size = que.size();        vector&lt;int&gt; tmp;        for (int i = 0; i &lt; size; i++) &#123;            TreeNode* node = que.front();            que.pop();            tmp.push_back(node-&gt;val);            if (node-&gt;left) que.push(node-&gt;left);            if (node-&gt;right) que.push(node-&gt;right);        &#125;        res.push_back(tmp);    &#125;    reverse(res.begin(), res.end()); // 反转二维数组    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 102. 二叉树的层序遍历</title>
      <link href="/posts/c7ba20f5/"/>
      <url>/posts/c7ba20f5/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">LeetCode 102. Binary Tree Level Order Traversal</span></p><p>给你二叉树的根节点  <code>root</code>  ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/c7ba20f5/1.jpg" class=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>逐层遍历二叉树，其中，每层按从左到右顺序遍历</p><p>由于队列具有先进先出特性，本题可利用队列来存放 待访问的节点，即，按从左到右的顺序将待访问的节点依次加入到队列中</p><p>注意本题要求输出一个二维数组，其中，二维数组中的每一个一维数组，表示 二叉树每一层上所有节点的值。因此，一维数组的长度 即为 对应层上的二叉树节点数，亦为 上一层访问结束后的队列长度</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="二叉树的层序遍历" height="400px" /></p><h2 id="method-广度优先搜索"><a class="anchor" href="#method-广度优先搜索">#</a> Method: 广度优先搜索</h2><p>算法思路：</p><ol><li><p>将根节点入队</p></li><li><p>当队列不为空，执行以下循环：</p><ul><li>求当前队列的长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>依次从队列中取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个元素：<ul><li>读取其值，将值临时存放到一维数组  <code>tmp</code>  中</li><li>将非空的左、右子节点依次入队</li></ul></li><li>将一维数组  <code>tmp</code>  添加到目标数组  <code>res</code></li></ul></li></ol><blockquote><p>普通的广度优先搜索每次只取 1 个元素拓展，而这里每次取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个元素，即，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 次迭代就得到了二叉树的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个元素</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    queue&lt;TreeNode*&gt; que; // 队列存放的是待展开的二叉树节点    if (root != nullptr) que.push(root);    while (!que.empty()) &#123;        vector&lt;int&gt; tmp;        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            TreeNode* node = que.front();            que.pop();            tmp.push_back(node-&gt;val);            if (node-&gt;left != nullptr) que.push(node-&gt;left);            if (node-&gt;right != nullptr) que.push(node-&gt;right);        &#125;        res.push_back(tmp);    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每个点入队出队各一次，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为树的所有节点的个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，队列中元素的个数不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDIuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU1JUIxJTgyJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2Lmh0bWw=">代码随想录：二叉树的层序遍历</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 145. 二叉树的后序遍历</title>
      <link href="/posts/4e96229e/"/>
      <url>/posts/4e96229e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">LeetCode 145. Binary Tree Postorder Traversal</span></p><p>给你一棵二叉树的根节点  <code>root</code>  ，返回其节点值的 后序遍历 。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/4e96229e/1.jpg" class=""></p><pre><code>输入：root = [1,null,2,3]输出：[3,2,1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>按照左子树 —— 右子树 —— 根节点的顺序，对二叉树的每个节点进行遍历</p><h2 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    postorder(root, res);         // 中序遍历    return res;&#125;void postorder(TreeNode* root, vector&lt;int&gt; &amp;res) &#123;    if (root == nullptr) return;    postorder(root-&gt;left, res);   // 左子树    postorder(root-&gt;right, res);  // 右子树    res.push_back(root-&gt;val);     // 根节点&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h2><h3 id="方案一"><a class="anchor" href="#方案一">#</a> 方案一</h3><p>算法流程：</p><ol><li><p>按照 “根 - 右 - 左” 的顺序访问节点，并依次将节点值添加到目标数组（类似于 <a href="https://jiankychen.github.io/posts/1e967892">LeetCode 144. 二叉树的前序遍历</a> ，仅仅是访问 左子节点 和 右子节点 的先后顺序不同而已）</p></li><li><p>将目标数组反转，即可得按 “左 - 右 - 根” 顺序访问的结果</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    if (root == nullptr) return res;    stack&lt;TreeNode*&gt; stk;    stk.push(root);    while (!stk.empty()) &#123;           // 按照 根-右-左 的顺序遍历        TreeNode* cur = stk.top();        stk.pop();        res.push_back(cur-&gt;val);     // 访问根节点，并将其出栈        if (cur-&gt;left) stk.push(cur-&gt;left);   // 左子节点先入栈，后访问        if (cur-&gt;right) stk.push(cur-&gt;right); // 右子节点后入栈，先访问    &#125;    reverse(res.begin(), res.end()); // 将数组反转，可得 左-右-根 遍历顺序的结果    return res;&#125;</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSVFNyU5QSU4NCVFOCVCRiVBRCVFNCVCQiVBMyVFOSU4MSU4RCVFNSU4RSU4Ni5odG1sIyVFNSU5MCU4RSVFNSVCQSU4RiVFOSU4MSU4RCVFNSU4RSU4Ni0lRTglQkYlQUQlRTQlQkIlQTMlRTYlQjMlOTU=">代码随想录：二叉树的后序遍历（迭代法）</span></p><h3 id="方案二"><a class="anchor" href="#方案二">#</a> 方案二</h3><p>可以采取类似 <a href="https://jiankychen.github.io/posts/803071b8">LeetCode 94. 二叉树的中序遍历</a> 的迭代法</p><p>不过，这里有些许不同：</p><ul><li>对于中序遍历，从栈中弹出节点时，其左子树已访问完，可以直接访问该节点，然后访问右子树</li><li>对于后序遍历，从栈中弹出节点时，只能确定其左子树已访问完，无法确定右子树是否被访问过</li></ul><p>于是，引入一个指针  <code>prev</code>  来记录子树的访问情况：</p><ul><li>当一个节点及其左右子树均已访问过，令  <code>prev</code>  指向该节点</li><li>回溯到父节点后，可以根据其右子节点指针是否等于  <code>prev</code>  ，来判断右子节点是否被访问过</li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;    vector&lt;int&gt; res;    stack&lt;TreeNode*&gt; stk;    TreeNode *node = root;     // 当前遍历节点    TreeNode *prev = nullptr;  // 已访问过的子节点    while (!stk.empty() || node != nullptr) &#123; // 节点未遍历完        while (node != nullptr) &#123;     // 遍历至 node 左子树的最底部            stk.push(node);            node = node-&gt;left;        &#125;        node = stk.top();       // 左子树最底部的节点        stk.pop();        if (node-&gt;right == nullptr || node-&gt;right == prev) &#123; // 右子树为空 或 右子树已访问过            res.push_back(node-&gt;val); // 将当前节点的值添加到目标数组            prev = node;              // 用 prev 标记当前节点及其子节点已访问            node = nullptr;           // 左子树已访问过，下次循环无需再次访问        &#125; else &#123;                // 未访问过右子树            stk.push(node);     // node 重新入栈，待右子树访问结束后才访问 node             node = node-&gt;right; // 访问 node 的右子树        &#125;    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcG9zdG9yZGVyLXRyYXZlcnNhbC9zb2x1dGlvbi9lci1jaGEtc2h1LWRlLWhvdS14dS1iaWFuLWxpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：二叉树的后序遍历（迭代法）</span></p><blockquote><p>针对前、中、后序三种遍历方式，也可以采用 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSVFNyU5QSU4NCVFNyVCQiU5RiVFNCVCOCU4MCVFOCVCRiVBRCVFNCVCQiVBMyVFNiVCMyU5NS5odG1s">代码随想录：二叉树的统一迭代法</span> 思路：</p><ul><li>对于 已经遍历过、但并未把其值添加到目标数组 的节点（根节点），将其放入栈，并紧接着放入一个空指针作为标记；对于未曾遍历过的节点（左右子节点），直接放入栈，无需添加空指针标记</li><li>于是，在后续操作过程中，若栈顶为空指针，将其弹出后，所得的新栈顶元素则为 已经遍历过、但未把值添加到目标数组的节点</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 94. 二叉树的中序遍历</title>
      <link href="/posts/803071b8/"/>
      <url>/posts/803071b8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv">LeetCode 94. Binary Tree Inorder Traversal</span></p><p>给定一个二叉树的根节点  <code>root</code>  ，返回 它的 <strong>中序</strong> 遍历 。</p><p><strong>示例 1：</strong><br /><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/1.jpg" alt="" height="200px" /></p><pre><code>输入：root = [1,null,2,3]输出：[1,3,2]</code></pre><p><strong>示例 2：</strong><br /><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/2.jpg" alt="" height="200px" /></p><pre><code>输入：root = [1,2]输出：[2,1]</code></pre><p><strong>示例 3：</strong><br /><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/3.jpg" alt="" height="200px" /></p><pre><code>输入：root = [1,null,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围  <code>[0, 100]</code>  内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>按照访问左子树 —— 根节点 —— 右子树的方式遍历这棵树，左子树或者右子树按照同样的方式遍历</p><h2 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    inorder(root,res);         // 中序遍历    return res;&#125;void inorder(TreeNode* root, vector&lt;int&gt; &amp;res) &#123;    if (root == nullptr) return;    inorder(root-&gt;left, res);   // 左子树    res.push_back(root-&gt;val);   // 当前节点    inorder(root-&gt;right, res);  // 右子树&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈的开销，这里忽略了目标数组所需空间</p><h2 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h2><p>按照中序遍历规则，遍历到某个节点时，并不直接获取它的值，而是先遍历它的左子树，然后才将它本身的值加入到目标数组中，然后再遍历右子树（注意，左、右子树的遍历规则也是如此）</p><p>换而言之，中序遍历首先要一层一层向下访问，直到到达左子树的最底部，才开始获取节点的值</p><p>算法流程：</p><ol><li><p>定义一个空的栈  <code>stk</code>  ，定义一个指针  <code>cur</code>  指向当前遍历的节点</p></li><li><p>执行循环（直到  <code>stk</code>  为空 且  <code>cur</code>  为空指针）：</p><ul><li>执行以下循环，直到  <code>cur</code>  为空指针（此时，栈顶 是 指向最底层节点的指针）<ul><li>将  <code>cur</code>  压入栈</li><li>令  <code>cur</code>  指向 左子节点，即， <code>cur = cur-&gt;left;</code></li></ul></li><li>更新  <code>cur = stk.top()</code>  ，使得  <code>cur</code>  指向最底层节点</li><li>将节点的值添加到目标数组，并将栈顶元素弹出</li><li>更新  <code>cur = cur-&gt;right</code>  ，即，令  <code>cur</code>  指向其右子节点，以继续遍历</li></ul></li><li><p>循环结束时，所有节点均已被访问，返回目标数组</p></li></ol><p>有点抽象，建议根据实例模拟一遍，例如：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="" height="400px" /></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    stack&lt;TreeNode*&gt; stk;    TreeNode* cur = root;    while (!stk.empty() || cur != nullptr) &#123;        while (cur != nullptr) &#123; // 遍历至 cur 左子树的最底部            stk.push(cur);            cur = cur-&gt;left;        &#125;        cur = stk.top();         // 最左侧的节点（它不存在左子节点）        res.push_back(cur-&gt;val); // 将节点的值加入到目标数组        stk.pop();               // 出栈        cur = cur-&gt;right;        // 遍历右子树    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwvc29sdXRpb24vZXItY2hhLXNodS1kZS16aG9uZy14dS1iaWFuLWxpLWJ5LWxlZXRjb2RlLXNvbHV0aW8v">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSVFNyU5QSU4NCVFOCVCRiVBRCVFNCVCQiVBMyVFOSU4MSU4RCVFNSU4RSU4Ni5odG1s">代码随想录</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 144. 二叉树的前序遍历</title>
      <link href="/posts/1e967892/"/>
      <url>/posts/1e967892/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==">LeetCode 144. Binary Tree Preorder Traversal</span></p><p>给你二叉树的根节点  <code>root</code>  ，返回它节点值的 前序 遍历。</p><p><strong>示例 1：</strong><br /><img data-src="/posts/1e967892/1.jpg" class=""></p><pre><code>输入：root = [1,null,2,3]输出：[1,2,3]</code></pre><p><strong>示例 2：</strong><br /><img data-src="/posts/1e967892/2.jpg" class=""></p><pre><code>输入：root = [1,2]输出：[1,2]</code></pre><p><strong>示例 3：</strong><br /><img data-src="/posts/1e967892/3.jpg" class=""></p><pre><code>输入：root = [1,null,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归算法很简单，你可以通过迭代算法完成吗？</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>按照访问根节点 —— 左子树 —— 右子树的方式遍历这棵树，左子树或者右子树按照同样的方式遍历</p><p>注意二叉树节点的定义：</p><pre><code class="language-cpp">struct TreeNode &#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;</code></pre><h1 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h1><p>算法流程：</p><p>定义递归函数  <code>preorder(root, res)</code>  ，将遍历到的  <code>root</code>  节点的结果添加到目标数组  <code>res</code>  ：</p><ul><li>按照定义，首先将  <code>root</code>  节点的值加入数组</li><li>递归调用  <code>preorder(root.left)</code>  来遍历  <code>root</code>  节点的左子树</li><li>递归调用  <code>preorder(root.right)</code>  来遍历  <code>root</code>  节点的右子树</li></ul><p>递归终止的条件为碰到空节点</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    preorder(root,res);         // 前序遍历，调用递归函数    return res;&#125;void preorder(TreeNode* root, vector&lt;int&gt; &amp;res) &#123;    if (root == nullptr) return;    res.push_back(root-&gt;val);    // 当前节点    preorder(root-&gt;left, res);   // 左子树    preorder(root-&gt;right, res);  // 右子树&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数，每一个节点恰好被遍历一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，为递归过程中栈的开销，这里忽略了目标数组所需空间</p><ul><li>平均情况下，栈所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下树呈现链状，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h1 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h1><blockquote><p>递归的实现：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，递归返回时再从栈顶弹出上一次递归的各项参数，故而递归可以返回到上一层</p></blockquote><p>不同于递归法，迭代法 显式地 维护一个栈，以实现遍历</p><p>由于栈的后进先出特性，要想先访问左子树、后访问右子树，需要先将右子树入栈、后将左子树入栈</p><p>算法思路：</p><ol><li><p>设计一个栈，用于存放将访问的树的根节点（只放入非空节点）</p></li><li><p>将根节点入栈，然后重复以下过程，直到栈为空</p><ul><li>从栈中取出一个节点，记录节点的值</li><li>将右子节点放入栈</li><li>将左子节点放入栈</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; res;    if(root == nullptr) return res;    stack&lt;TreeNode*&gt; stk;          // 栈存放二叉树节点的指针    stk.push(root);                // 根节点入栈    while (!stk.empty()) &#123;         // 栈不为空，节点未遍历完        TreeNode* cur = stk.top(); // 栈顶元素（根节点）        stk.pop();                 // 出栈        res.push_back(cur-&gt;val);             // 将节点的值加入到目标数组        if(cur-&gt;right) stk.push(cur-&gt;right); // 将右子节点压入栈        if(cur-&gt;left) stk.push(cur-&gt;left);   // 将左子节点压入栈    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈的开销，这里忽略了目标数组所需空间</p><p>事实上，迭代法也可以如下实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; ans;    stack&lt;TreeNode*&gt; st;    TreeNode* node = root;    while (!st.empty() || node != nullptr) &#123;        while (node != nullptr) &#123;     // 遍历 node ，直到到达最底部            ans.push_back(node-&gt;val); // 将 node 的值添加到目标数组            st.push(node);            // 之后还需访问 node 右子节点，故而将 node 放入栈            node = node-&gt;left;        // 更新 node 为左子节点，继续遍历        &#125;        node = st.top();              // 循环结束时，栈顶指向最底层节点        st.pop();        node = node-&gt;right;           // 遍历右子节点    &#125;    return ans;&#125;</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwvc29sdXRpb24vZXItY2hhLXNodS1kZS1xaWFuLXh1LWJpYW4tbGktYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：二叉树的前序遍历</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 347. 前 K 个高频元素</title>
      <link href="/posts/f382432a/"/>
      <url>/posts/f382432a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90b3Atay1mcmVxdWVudC1lbGVtZW50cy8=">347. Top K Frequent Elements</span></p><p>给你一个整数数组  <code>nums</code>  和一个整数  <code>k</code>  ，请你返回其中出现频率前  <code>k</code>  高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,1,2,2,3], k = 2输出：[1,2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1], k = 1输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>k</code>  的取值范围是  <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前  <code>k</code>  个高频元素的集合是唯一的</li></ul><p><strong>进阶</strong>：你所设计算法的时间复杂度 必须 优于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组大小。</p><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>解题基本思路：</p><ul><li>统计元素出现频率：利用 <strong>哈希 map</strong> 来统计数组中各元素出现的次数</li><li>对频率排序：利用 <strong>优先级队列</strong> 来对频率进行排序</li><li>根据排序结果找出前 K 个高频元素</li></ul><p>题目只需找出前 K 个高频元素，因此可采用固定大小为 K 的 优先级队列 维护一个长为 K 的有序序列即可，而无需采用 vector 容器对所有元素的频次进行排序</p><p>由于优先级队列（堆）只能移除队首元素，本题采用 <strong>最小化堆（小顶堆）</strong> ，以便移除频次最少的元素</p><p>最小化堆的定义：</p><pre><code class="language-cpp">class comp &#123;public:    bool operator() (const pair&lt;int, int&gt; &amp;LHS, const pair&lt;int, int&gt; &amp;RHS) &#123;        return LHS.second &gt; RHS.second;    &#125;&#125;;priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, comp&gt; que;</code></pre><blockquote><p>对于堆， <code>LHS.second &gt; RHS.second</code>  建立的是小顶堆， <code>LHS.second &lt; RHS.second</code>  建立的是大顶堆</p><p>对于  <code>sort</code>  函数， <code>LHS.second &gt; RHS.second</code>  得到的是降序排列， <code>LHS.second &lt; RHS.second</code>  得到的是升序排列</p></blockquote><h1 id="method-哈希-map-优先级队列"><a class="anchor" href="#method-哈希-map-优先级队列">#</a> Method: 哈希 map + 优先级队列</h1><p>算法思路：</p><p>定义一个哈希表（ <code>unordered_map</code> ），用于统计数组元素的出现频次，其中，key 为元素值，value 为频次</p><p>定义一个优先级队列，遍历哈希表：</p><ul><li>将哈希表的键值对添加到队列</li><li>若队列长度大于 K ，则从队列中移除频次最少的元素</li></ul><p>从优先级队列中提取出前 K 个高频元素的元素值，将其填充到目标数组中</p><p>代码实现：</p><pre><code class="language-cpp">// 最小化堆的比较函数class comp &#123;public:    bool operator() (const pair&lt;int, int&gt; &amp;LHS, const pair&lt;int, int&gt; &amp;RHS) &#123;        return LHS.second &gt; RHS.second;    &#125;&#125;;class Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        // 统计数字出现的频次        unordered_map&lt;int, int&gt; hash;        for (int i = 0; i &lt; nums.size(); i++)            hash[nums[i]]++;        // 利用固定大小为 K 的优先队列扫描哈希表        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, comp&gt; que;        for (auto it = hash.begin(); it != hash.end(); it++) &#123;            que.push(*it);            if (que.size() &gt; k)                que.pop();        &#125;        // 提取出前 K 个高频元素（升序填充到目标数组）        vector&lt;int&gt; res(k, 0);        for (int i = 0; i &lt; k; i++) &#123;            res[i] = que.top().first;            que.pop();        &#125;        return res;    &#125;&#125;;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 为输出高频元素数</p><ul><li>遍历哈希表的最坏时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>优先级队列的入队 / 出队时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9xdWV1ZS9wcmlvcml0eV9xdWV1ZS8=">cplusplus：std::priority_queue</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzNDcuJUU1JTg5JThESyVFNCVCOCVBQSVFOSVBQiU5OCVFOSVBMiU5MSVFNSU4NSU4MyVFNyVCNCVBMC5odG1s">代码随想录：前 K 个高频元素</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 239. 滑动窗口最大值</title>
      <link href="/posts/3ba13828/"/>
      <url>/posts/3ba13828/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">239. Sliding Window Maximum</span></p><p>给你一个整数数组  <code>nums</code> ，有一个大小为  <code>k</code>  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的  <code>k</code>  个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                 最大值---------------               ------[1  3  -1]  -3  5  3  6  7       31  [3  -1  -3]  5  3  6  7       31  3  [-1  -3  5]  3  6  7       51  3  -1  [-3  5  3]  6  7       51  3  -1  -3  [5  3  6]  7       61  3  -1  -3  5  [3  6  7]       7</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1], k = 1输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路：</h2><p>数组长为  <code>nums.size()</code>  ，窗口长为  <code>k</code>  ，一共有  <code>nums.size() - k + 1</code>  个窗口</p><p>若采用暴力法，对每个窗口求最大值需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 的时间复杂度，则总时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p><p>针对本题的数据，暴力法会超时</p><p>本题有三种求解思路：可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">力扣官方题解</span></p><ul><li>优先队列（堆）</li><li>单调队列</li><li>分块 + 预处理</li></ul><h2 id="method-1-优先队列"><a class="anchor" href="#method-1-优先队列">#</a> Method 1: 优先队列</h2><p>可以利用 最大化堆，即，根节点元素值最大的二叉堆， 来维护窗口的最大值</p><blockquote><p>有关 最大化堆 ，可参考 <a href="https://jiankychen.github.io/posts/a21107fc">优先级队列</a></p></blockquote><p>算法流程：</p><ol><li><p>定义一个 优先队列 ，其中，队列每个元素都是一个二元组，存储了  <code>nums</code>  数组元素值和元素下标，即： <code>priority_queue&lt;pair&lt;int, int&gt;&gt; que;</code></p></li><li><p>将  <code>nums</code>  数组的前  <code>k</code>  个元素（及下标）加入到优先队列中</p></li><li><p>遍历  <code>nums</code>  数组元素下标  <code>i</code> （从第  <code>k</code>  位元素开始），即，窗口的右边界</p><ul><li>将  <code>(nums[i], i)</code>  加入到  <code>que</code>  中</li><li>若  <code>que</code>  根节点所对应的数组元素下标（即， <code>que.top().second</code> ） 小于 窗口的左边界（即， <code>i - k + 1</code> ），则这个最大值不在窗口范围内，而是在窗口左侧，将其从  <code>que</code>  中移除</li><li>将  <code>que</code>  根节点所对应的数组元素（即， <code>que.top().first</code> ）加入到目标数组中</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;    priority_queue&lt;pair&lt;int, int&gt;&gt; que;    vector&lt;int&gt; res(nums.size() - k + 1, 0);    // 将前 k 个元素添加到优先队列    for (int i = 0; i &lt; k; i++)        que.emplace(nums[i], i);    // 将当前窗口最大值添加到目标数组    res[0] = que.top().first;    for (int i = k; i &lt; nums.size(); i++) &#123;        // 将当前元素添加到优先队列        que.emplace(nums[i], i);        // 当前队列的最大值不在窗口内，将其移除        while (que.top().second &lt; i - k + 1)            que.pop();        // 将当前窗口最大值添加到目标数组        res[i - k + 1] = que.top().first;    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组  <code>nums</code>  的长度</p><ul><li>遍历数组的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>将元素添加到优先队列的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> （在最坏情况下，数组  <code>nums</code>  中的元素单调递增，优先队列中包含了所有元素）</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，这里仅考虑了优先队列所需空间，忽略了目标数组所需空间</p><p>参考</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">力扣官方题解：滑动窗口最大值</span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9xdWV1ZS9wcmlvcml0eV9xdWV1ZS8/a3c9cHJpb3JpdHlfcXVldWU=">cplusplus：std::priority_queue</span></li></ul><h2 id="method-2-单调队列"><a class="anchor" href="#method-2-单调队列">#</a> Method 2: 单调队列</h2><p>双向队列：队列的两端都可以 入队 / 出队</p><p>单调队列：从队首到队尾，元素单调递减，或递增</p><p>本题可定义一个 元素单调递减的单调队列 ，以维护窗口内的最大值（即，队列的首端元素为队列最大值）</p><ul><li>若队首元素不在窗口内（即，对应数组下标小于窗口左边界），将其移除</li><li>若队首元素在窗口内，则该元素即为窗口内元素的最大值</li></ul><p>为实现队列元素的单调递减，我们在添加元素时，需做以下考虑：</p><ul><li>若队列尾端元素小于等于当前元素，则将队尾元素移除（因为队尾元素对应的数组下标在当前元素的左侧，当队尾元素小于当前元素时，其不可能成为当前窗口及后续滑动窗口的最大值，可将其从队列中永久移除）</li><li>直到队列尾端元素大于当前元素时，才将当前元素添加到队列中</li></ul><p>算法流程：</p><ol><li>定义一个双向队列： <code>deque&lt;int&gt; que;</code>  ，用以实现单调队列</li><li>遍历数组  <code>nums</code>  数组元素下标，定义为窗口的右边界  <code>right</code><ul><li>若队列不为空且当前元素大于等于队尾元素，将队尾元素移除，直到队列为空或当前元素小于新的队尾元素</li><li>将当前元素添加到队尾</li><li>若队首元素的下标小于滑动窗口左侧边界，将其从队首移除，直到队首元素在窗口中为止</li><li>若长为  <code>k</code>  的窗口已形成（即， <code>right &gt;= k - 1</code> ），则将窗口最大值（即，队首元素）添加到目标数组</li></ul></li></ol><blockquote><p>特别地，为便于操作，我们可将数组元素的下标存放在队列中</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;    deque&lt;int&gt; que;     // 单调队列（从队首到队尾，元素单调递减）    vector&lt;int&gt; res;    // 目标数组    for (int left = 0, right = 0; right &lt; nums.size(); right++) &#123;        // 队列不为空且当前考察元素大于等于队尾元素，将队尾元素移除        while (!que.empty() &amp;&amp; nums[que.back()] &lt;= nums[right])            que.pop_back();        // 将当前元素的下标添加到队尾        que.push_back(right);        // 窗口左边界        left = right - k + 1;        // 将小于 left 的元素下标从队列移除        while (que.front() &lt; left)            que.pop_front();        // 队列首端对应元素就是窗口最大值        if (right &gt;= k -1)            res.push_back(nums[que.front()]);    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 为窗口长度</p><ul><li>队列最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素，故，队列所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li><li>忽略了目标数组所需空间</li></ul><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">力扣官方题解：滑动窗口最大值</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">编程狂想曲：动画演示 单调队列 239. 滑动窗口最大值</span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9kZXF1ZS9kZXF1ZS8=">cplusplus：std::deque</span></li></ul><h2 id="method-3-分块-预处理"><a class="anchor" href="#method-3-分块-预处理">#</a> Method 3: 分块 + 预处理</h2>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 150. 逆波兰表达式求值</title>
      <link href="/posts/7936534f/"/>
      <url>/posts/7936534f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1yZXZlcnNlLXBvbGlzaC1ub3RhdGlvbi8=">LeetCode 150. Evaluate Reverse Polish Notation</span></p><p>给你一个字符串数组  <code>tokens</code>  ，表示一个根据 <strong>逆波兰表示法</strong> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>注意：</p><ul><li>有效的算符为  <code>'+'</code> 、 <code>'-'</code> 、 <code>'*'</code>  和  <code>'/'</code>  。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 向零截断 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p></p><p><strong>示例 1：</strong></p><pre><code>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：((2 + 1) * 3) = 9</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：(4 + (13 / 5)) = 6</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>tokens.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>tokens[i]</code>  是一个算符 （ <code>&quot;+&quot;</code> 、  <code>&quot;-&quot;</code> 、  <code>&quot;*&quot;</code>  或  <code>&quot;/&quot;</code> ），或是在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>200</mn><mo separator="true">,</mo><mn>200</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-200, 200]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内的一个整数</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>逆波兰表达式，即，<strong>后缀表达式</strong>（运算符写在两个操作数的后面）</p><p>日常使用的是中缀表达式（运算符写在两个操作数的中间）</p><p>例如， <code>2 + 3</code>  就是中缀表达式，对应的后缀表达式是  <code>2 3 +</code></p><p>由此，本题的求解思路为：</p><ol><li><p>定义一个 栈</p></li><li><p>遍历数组  <code>tokens</code>  ，若遇到的是数字，则将数字压入栈，若遇到的是  <code>&quot;+&quot;</code>  、 <code>&quot;-&quot;</code>  、 <code>&quot;*&quot;</code>  、 <code>&quot;/&quot;</code>  运算符，则从栈内取出两个数字进行计算，然后将计算结果压入栈中</p></li><li><p>遍历结束时，栈内剩余元素即为整个后缀表达式的计算结果</p></li></ol><p>注意，数组  <code>tokens</code>  内的元素是  <code>string</code>  类型的对象，<strong>将  <code>string</code>  型的数字压入栈前需将其转换成  <code>int</code>  型</strong></p><ul><li>调用  <code>stoi</code>  函数即可，参考 <span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdHJpbmcvc3RvaS8/a3c9c3RvaQ==">cplusplus：std::stoi</span></li></ul><h2 id="method-栈"><a class="anchor" href="#method-栈">#</a> Method: 栈</h2><p>代码实现：</p><pre><code class="language-cpp">// 计算后缀表达式，并将结果压入栈void compute(stack&lt;int&gt; &amp;stk, string c) &#123;    int right = stk.top(); // 右操作数    stk.pop();    int left = stk.top();  // 左操作数    stk.pop();    if (c == &quot;+&quot;) stk.push(left + right);    else if (c == &quot;-&quot;) stk.push(left - right);    else if (c == &quot;*&quot;) stk.push(left * right);    else if (c == &quot;/&quot;) stk.push(left / right);&#125;int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;    stack&lt;int&gt; stk;    for (auto c : tokens) &#123;        if (c == &quot;+&quot; || c == &quot;-&quot; || c == &quot;*&quot; || c == &quot;/&quot;)            compute(stk, c);        else            stk.push(stoi(c)); // 将 string 类型转成 int 型    &#125;    int ans = stk.top();    stk.pop();    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为  <code>tokens</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈所需空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1047. 删除字符串中的所有相邻重复项</title>
      <link href="/posts/7fd44fa1/"/>
      <url>/posts/7fd44fa1/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtYWxsLWFkamFjZW50LWR1cGxpY2F0ZXMtaW4tc3RyaW5nLw==">1047. Remove All Adjacent Duplicates In String</span></p><p>给出由小写字母组成的字符串  <code>S</code> ，<strong>重复项删除操作</strong> 会选择两个相邻且相同的字母，并删除它们。</p><p>在  <code>S</code>  上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;azxxzy&quot;输出：&quot;ay&quot;</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  仅由小写英文字母组成</li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p>匹配问题 都是 栈 的强项</p><p>基本思路：遍历字符串，若当前字符与栈顶元素相等，将栈顶元素移除，否则，将字符压入栈中。遍历完字符串以后，栈内不再含有连续的重复字符，将栈内元素依次弹出、并填充到目标字符串即可</p><h1 id="method-1-栈"><a class="anchor" href="#method-1-栈">#</a> Method 1: 栈</h1><p>由于栈顶元素对应的是字符串的尾端，填充目标字符串时需按从右往左顺序填充</p><p>代码实现：</p><pre><code class="language-cpp">string removeDuplicates(string s) &#123;    // 将字符依次压入栈，若遇连续相同字符，则将栈顶元素移除    stack&lt;int&gt; stk;    for (auto c : s) &#123;        if (!stk.empty() &amp;&amp; c == stk.top()) stk.pop();        else stk.push(c);    &#125;    // 将栈内字符添加到新字符串中（最先出栈的放到字符串末尾）    int size = stk.size();    string res(size, ' ');    for (int i = size - 1; i &gt;= 0; i--) &#123;        res[i] = stk.top();        stk.pop();    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈所需空间（这里没有把目标字符串所需空间考虑在内）</p><blockquote><p>也可以将栈内元素按从左往右顺序填充到目标字符串，然后再对目标字符串进行翻转</p></blockquote><h1 id="method-2-字符串"><a class="anchor" href="#method-2-字符串">#</a> Method 2: 字符串</h1><p>在 C++ 中，由于标准库类型  <code>string</code>  本身就提供了类似 入栈 和 出栈 的接口，可直接将目标字符串作为栈</p><p>代码实现：</p><pre><code class="language-cpp">string removeDuplicates(string s) &#123;    string res = &quot;&quot;;    for (auto c : s) &#123; // 从目标字符串尾部移除与 c 相同的字符        if (!res.empty() &amp;&amp; c == res.back())            res.pop_back();        else           // 将字符 c 添加到目标字符串尾部            res.push_back(c);    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，没有把目标字符串所需空间考虑在内</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzEwNDcuJUU1JTg4JUEwJUU5JTk5JUE0JUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTg5JTgwJUU2JTlDJTg5JUU3JTlCJUI4JUU5JTgyJUJCJUU5JTg3JThEJUU1JUE0JThEJUU5JUExJUI5Lmh0bWw=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtYWxsLWFkamFjZW50LWR1cGxpY2F0ZXMtaW4tc3RyaW5nL3NvbHV0aW9uL3NoYW4tY2h1LXppLWZ1LWNodWFuLXpob25nLWRlLXN1by15b3UteGktNG9oci8=">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 20. 有效的括号</title>
      <link href="/posts/2998838f/"/>
      <url>/posts/2998838f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy8=">LeetCode 20. Valid Parentheses</span></p><p>给定一个只包括  <code>'('</code> ， <code>')'</code> ， <code>'&#123;'</code> ， <code>'&#125;'</code> ， <code>'['</code> ， <code>']'</code>  的字符串  <code>s</code>  ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;()&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;(]&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  仅包含括号  <code>'()[]&#123;&#125;'</code></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>从左往右遍历字符串时，后遇到的左括号需要先匹配，与栈后进先出的特点不谋而合</p><p>因此，<strong>括号匹配问题可以使用 栈 来解决</strong></p><p>基本思路：遍历字符串，若遇到左括号，则将其入栈，若遇到右括号，则将对应栈顶左括号出栈</p><p>考察 括号不匹配 的三种情况：</p><ul><li>存在多余的左括号：在这种情况下，待字符串遍历结束后，栈不为空</li><li>存在多余的右括号：字符串未遍历完，栈已经为空</li><li>括号没有多余，但是括号的方向不对应：在遍历字符串过程中，遍历到的右括号无法与栈顶左括号匹配</li></ul><p>若字符串遍历结束后，栈为空，则说明括号全部匹配</p><h2 id="method-1-栈-map"><a class="anchor" href="#method-1-栈-map">#</a> Method 1: 栈 + map</h2><p>栈 存储的是 待匹配的左括号</p><p>哈希 map 用来存储可以匹配的括号类型，即：哈希表的 key 为右括号，value 为相同类型的左括号，这样查询 2 个括号是否对应只需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间复杂度</p><p>具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9zb2x1dGlvbi95b3UteGlhby1kZS1ndWEtaGFvLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：有效的括号</span> 和 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9zb2x1dGlvbi92YWxpZC1wYXJlbnRoZXNlcy1mdS16aHUtemhhbi1mYS1ieS1qaW40MDc4OTEwODAv">Krahets：有效的括号</span></p><h2 id="method-2-栈"><a class="anchor" href="#method-2-栈">#</a> Method 2: 栈</h2><p>遍历字符串过程中，若遇到左括号，可将对应的右括号压入栈，后续遇到右括号时，只需将其与栈顶元素进行比较即可，若相等，则匹配，否则不匹配</p><p>即，栈 存储的是 与左括号对应的右括号</p><p>代码实现：</p><pre><code class="language-cpp">bool isValid(string s) &#123;    if (s.size() % 2) return false; // 括号数为奇数，直接返回 false    stack&lt;int&gt; stk;    for (auto c : s) &#123; // 范围 for        // 当 c 为 左括号 时，把对应的 右括号 压入栈        if (c == '(') stk.push(')');        else if (c == '[') stk.push(']');        else if (c == '&#123;') stk.push('&#125;');        // 当栈为空，或者，c 是 右括号 但 不等于栈顶元素，匹配失败        else if (stk.empty() || c != stk.top()) return false;        // c 是 右括号 且 等于栈顶元素，匹配成功，从栈顶移除左括号        else stk.pop();    &#125;    // 所有括号均已遍历完成，若栈为空，则匹配成功    return stk.empty();&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，遍历字符串</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈所需空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMjAuJUU2JTlDJTg5JUU2JTk1JTg4JUU3JTlBJTg0JUU2JThCJUFDJUU1JThGJUI3Lmh0bWwjJUU5JUEyJTk4JUU1JUE0JTk2JUU4JUFGJTlE">代码随想录：有效的括号</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 225. 用队列实现栈</title>
      <link href="/posts/5a1b1370/"/>
      <url>/posts/5a1b1370/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3RhY2stdXNpbmctcXVldWVzLw==">LeetCode 225. Implement Stack using Queues</span></p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（ <code>push</code> 、 <code>top</code> 、 <code>pop</code>  和  <code>empty</code> ）。</p><p>实现 MyStack 类：</p><ul><li><code>void push(int x)</code>  将元素  <code>x</code>  压入栈顶。</li><li><code>int pop()</code>  移除并返回栈顶元素。</li><li><code>int top()</code>  返回栈顶元素。</li><li><code>boolean empty()</code>  如果栈是空的，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列，只要是标准的队列操作即可。</li></ul><p></p><p><strong>示例 1：</strong></p><pre><code>输入[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出[null, null, null, 2, 2, false]ExplanationMyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>x</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></li><li>最多调用 100 次  <code>push</code> 、 <code>pop</code> 、 <code>top</code>  和  <code>empty</code></li><li>每次调用  <code>pop</code>  和  <code>top</code>  都保证栈不为空</li></ul><p><strong>进阶：</strong> 你能否仅用一个队列来实现栈。</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>栈 的特点是 后进先出 ，队列 的特点是 先进先出</p><p>可定义一个队列，使得 最先入栈的元素 放在 队首 ，最后入栈的元素 放在 队尾</p><ul><li><p>对于入栈操作，只需将元素添加到队尾</p></li><li><p>对于出栈操作，需将队尾元素移除并返回</p></li><li><p>为获取栈顶元素，可先将栈顶元素出栈，并记录其值（本题定义的 出栈 函数具有返回值），然后再将其压入栈</p></li><li><p>判断栈是否为空，只需判断用来存储栈元素的队列是否为空</p></li></ul><p>特别地，出栈操作可通过两个队列协同实现，也可仅用一个队列实现</p><h2 id="method-两个队列"><a class="anchor" href="#method-两个队列">#</a> Method: 两个队列</h2><p>定义队列  <code>que1</code>  ，用于存储 栈 的数据（ 最先入栈的元素 放在 队首 、最后入栈的元素 放在 队尾 ）</p><p>定义队列  <code>que2</code>  ，在 出栈 操作中，用于临时存放队列  <code>que1</code>  的前  <code>que1.size() - 1</code>  个元素，以便将  <code>que1</code>  队尾元素移除</p><p>时间复杂度：入栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，出栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，读取栈顶元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，判断栈是否为空 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是元素个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-一个队列"><a class="anchor" href="#method-一个队列">#</a> Method: 一个队列</h2><p>由于队列具有先进先出的特性，无需额外定义一个队列  <code>que2</code>  来实现 出栈 过程中元素的临时存放，即，直接将元素重新入队  <code>que1</code>  即可，这样就能使得最初的队尾元素出现在队首</p><p>代码实现：</p><pre><code class="language-cpp">class MyStack &#123;public:    queue&lt;int&gt; que; // 最先入栈的放在 que 队首，最后入栈的放在 que 队尾    MyStack() &#123;    &#125;        void push(int x) &#123;        que.push(x);    &#125;        int pop() &#123;        int length = que.size(); // 记录 que1 的长度，注意，不能直接将 que.size() 作为 for 循环的判定条件        // 将 que 前 length - 1 个元素依次移出，然后放入队尾，使得最初的队尾元素出现在队首        for (int i = 0; i &lt; length - 1; i++) &#123;            int temp = que.front();            que.pop();            que.push(temp);        &#125;        // 记录最初的队尾元素值，并将其移除        int ans = que.front();        que.pop();        return ans;    &#125;        int top() &#123;        int ans = pop(); // 复用已经定义的 MyStack 类别的 pop() 函数，将栈顶元素弹出        push(ans);       // 再将其压入栈        return ans;    &#125;        bool empty() &#123;        return que.empty() ? true : false;    &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */</code></pre><p>时间复杂度：入栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，出栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，读取栈顶元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，判断栈是否为空 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是元素个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>事实上，也可以将 最后入栈的元素 放在 队首 、最先入栈的元素 放在 队尾 ，即，队列 的 前端 和 后端 分别对应 栈顶 和 栈底 。<br />但是，这种情况下的 入栈 操作则会复杂很多，对应的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，而 出栈 和 读取栈顶元素 则会简单很多，对应的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><br /> 可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3RhY2stdXNpbmctcXVldWVzL3NvbHV0aW9uL3lvbmctZHVpLWxpZS1zaGkteGlhbi16aGFuLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：用队列实现栈</span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 232. 用栈实现队列</title>
      <link href="/posts/81d08953/"/>
      <url>/posts/81d08953/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtcXVldWUtdXNpbmctc3RhY2tzLw==">LeetCode 232. Implement Queue using Stacks</span></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（ <code>push</code> 、 <code>pop</code> 、 <code>peek</code> 、 <code>empty</code> ）：</p><p>实现  <code>MyQueue</code>  类：</p><ul><li><code>void push(int x)</code>  将元素  <code>x</code>  推到队列的末尾</li><li><code>int pop()</code>  从队列的开头移除并返回元素</li><li><code>int peek()</code>  返回队列开头的元素</li><li><code>boolean empty()</code>  如果队列为空，返回  <code>true</code>  ；否则，返回  <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出[null, null, null, 1, 1, false]ExplanationMyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>x</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></li><li>最多调用 100 次  <code>push</code> 、 <code>pop</code> 、 <code>peek</code>  和  <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用  <code>pop</code>  或者  <code>peek</code>  操作）</li></ul><p><strong>进阶：</strong> 你能否实现每个操作均摊时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的队列？换句话说，执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个操作的总时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，即使其中一个操作可能花费较长时间。</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>栈具有后进先出的特性</p><p>若将一个栈的所有元素移入到另一个栈中，元素的排列顺序会变得与之前相反</p><h2 id="method"><a class="anchor" href="#method">#</a> Method</h2><p>解题思路：</p><ol><li><p>定义两个栈， <code>stk1</code>  和  <code>stk2</code></p><ul><li>栈  <code>stk1</code>  用来作为存储队列，即，最先入队的在  <code>stk1</code>  栈顶，最后入队的在  <code>stk1</code>  栈底</li><li>栈  <code>stk2</code>  作为临时存储空间，用来协助实现队列的功能</li></ul></li><li><p><code>void push(int x)</code>  函数的实现：</p><ul><li>若  <code>stk1</code>  非空：先将  <code>stk1</code>  内的所有元素都移出来，放进  <code>stk2</code>  ，然后将  <code>x</code>  压入栈  <code>stk1</code>  ，将  <code>stk2</code>  内的元素移回  <code>stk1</code></li><li>若  <code>stk1</code>  为空，直接将  <code>x</code>  压入栈  <code>stk1</code>  即可</li></ul></li><li><p><code>int pop()</code>  函数的实现：</p><ul><li>记录  <code>stk1</code>  栈顶元素值，并弹出  <code>stk1</code>  栈顶元素，返回其值</li></ul></li><li><p><code>int peek()</code>  函数的实现：</p><ul><li>直接返回  <code>stk1</code>  栈顶元素值即可</li></ul></li><li><p><code>bool empty()</code>  函数的实现：</p><ul><li>判断  <code>stk1</code>  是否为空即可</li></ul></li></ol><blockquote><p>另，也可以 “将最先入队的放  <code>stk1</code>  栈底，最后入队的在  <code>stk1</code>  栈顶” ，此时：入队操作可直接将  <code>x</code>  压入栈  <code>stk1</code>  ；出队操作需将  <code>stk1</code>  栈底以上的元素全都临时存放到  <code>stk2</code>  ，待  <code>stk1</code>  栈底元素弹出后，再将  <code>stk2</code>  所有元素移回  <code>stk1</code></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">class MyQueue &#123;public:    stack&lt;int&gt; stk1;    stack&lt;int&gt; stk2;    MyQueue() &#123;    &#125;        void push(int x) &#123;        if (!stk1.empty()) &#123; // stk1 非空            while (!stk1.empty()) &#123; // 将 stk1 元素压入栈 stk2                stk2.push(stk1.top());                stk1.pop();            &#125;            stk1.push(x);    // 将 x 压入栈 stk1            while (!stk2.empty()) &#123; // 将 stk2 元素放回栈 stk1                stk1.push(stk2.top());                stk2.pop();            &#125;        &#125;        else  // stk1 为空，直接将 x 压入栈 stk1            stk1.push(x);    &#125;        int pop() &#123;        int ans = stk1.top();        stk1.pop();        return ans;    &#125;        int peek() &#123;        int ans = stk1.top();        return ans;    &#125;        bool empty() &#123;        if (stk1.empty()) return true;        return false;    &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */</code></pre><p>注意，标准库实现的栈和队列，其成员函数  <code>pop()</code>  没有返回值，不能作为右值； <code>top()</code>  具有返回值，可以作为右值</p><p>另外，关于  <code>peek()</code>  函数的实现，可以直接调用已经定义了的  <code>MyQueue</code>  类别的  <code>pop()</code>  函数，即，通过函数的复用来实现。这样可以降低出错的可能性</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 459. 重复的子字符串</title>
      <link href="/posts/e28abd31/"/>
      <url>/posts/e28abd31/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXBlYXRlZC1zdWJzdHJpbmctcGF0dGVybi8=">LeetCode 459. Repeated Substring Pattern</span></p><p>给定一个非空的字符串  <code>s</code>  ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abab&quot;输出：true解释：可由子串 &quot;ab&quot; 重复两次构成</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;aba&quot;输出：false</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;abcabcabcabc&quot;输出：true解释：可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  由小写英文字母组成</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>检查字符串是否由重复的子串组成，即，验证字符串  <code>s</code>  的周期性</p><p>可以通过构造 next 数组，获取字符串  <code>s</code>  的周期信息</p><p>next 数组最后一位元素记录了整个字符串的 最长相同前后缀 的长度，记作  <code>next[s.size() - 1]</code>  。若字符串具有周期性， <code>next[s.size() - 1]</code>  就应该是周期的整数倍，且应该是 <em>字符串的总周期数 - 1</em> 倍。换而言之， <code>s.size() - next[s.size() - 1]</code>  就是周期的长度</p><p>有关 next 数组及其构造，可参阅 <a href="https://jiankychen.github.io/posts/36b55f59/">KMP 算法</a></p><p>以字符串 &quot;abcabcabc&quot; 为例，其 next 数组为：</p><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">字符串</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td></tr><tr><td style="text-align:center">next 数组</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table><p>其周期长度 = 字符串总长度 - next 数组最后一位元素值 = 9 - 6 = 3</p><p>因此，可以作出以下结论：若 <strong> <code>next[s.size() - 1]</code>  非零</strong> 且 <strong>字符串总长度  <code>s.size()</code>  能够被  <code>s.size() - next[s.size() - 1]</code>  整除</strong> ，则，字符串具有周期性，即，可以由子串重复多次而构成</p><p>有关该方法正确性的理论证明，可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXBlYXRlZC1zdWJzdHJpbmctcGF0dGVybi9zb2x1dGlvbi96aG9uZy1mdS1kZS16aS16aS1mdS1jaHVhbi1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：重复的子字符串（方法三）</span></p><h2 id="methodkmp-算法"><a class="anchor" href="#methodkmp-算法">#</a> Method：KMP 算法</h2><p>解题流程：</p><ol><li>构造 next 数组</li><li>找到 next 数组最后一位元素，即， <code>next[s.size() - 1]</code></li><li>判断  <code>next[s.size() - 1]</code>  是否为 0<ul><li>若  <code>next[s.size() - 1] == 0</code>  ，字符串不存在周期， <code>return false</code></li><li>若  <code>next[s.size() - 1] != 0</code>  ，判断  <code>s.size()</code>  是否能被  <code>s.size() - next[s.size() - 1]</code>  整除<ul><li>若能够被整除，字符串具有周期性， <code>return true</code></li><li>若不能被整除， <code>return false</code></li></ul></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">// 构造 next 数组void getNext(vector&lt;int&gt; &amp;next, string s) &#123; // 注意，要对 next 加引用符 &amp;    int prefix = 0;    next[0] = 0;    for (int suffix = 1; suffix &lt; s.size(); suffix++) &#123;        while (prefix &gt; 0 &amp;&amp; s[prefix] != s[suffix])            prefix = next[prefix - 1];        if (s[prefix] == s[suffix])            prefix++;        next[suffix] = prefix;    &#125;&#125;bool repeatedSubstringPattern(string s) &#123;    vector&lt;int&gt; next(s.size(), 0);    getNext(next, s);    // for (auto c : next)  // 打印 next 数组    //     cout &lt;&lt; c &lt;&lt; &quot; &quot;;    // cout &lt;&lt; endl;    int temp = next[s.size() - 1];    if (temp != 0 &amp;&amp; s.size() % (s.size() - temp) == 0)        return true;    return false;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串  <code>s</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以通过打印 next 数组来检查 next 数组的构造是否正确，并帮助理解做题思路</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP 算法</title>
      <link href="/posts/36b55f59/"/>
      <url>/posts/36b55f59/</url>
      
        <content type="html"><![CDATA[<p>Knuth-Morris-Pratt 算法，简称 KMP 算法，由 Donald Knuth、James H. Morris 和 Vaughan Pratt 三人于 1977 年联合发表</p><p>KMP 算法主要应用于 <strong>字符串匹配</strong></p><p>基本思想：当出现字符串不匹配时，可以利用前面已经匹配的那些字符中的信息，避免从头再做匹配</p><p>以 在文本串中查找是否出现过一个模式串 为例：</p><p>检测文本串 &quot;aabaabaaf&quot; 中是否含有 模式串 &quot;aabaaf&quot;，KMP 算法的查找过程如下所示</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP算法运行过程的示意图" /></p><p>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 表示文本串长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 表示模式串长度，暴力匹配的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，而 KMP 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><ul><li>计算模式串的前缀表的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li><li>与文本串进行匹配的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h1 id="前缀表"><a class="anchor" href="#前缀表">#</a> 前缀表</h1><p>前缀表（prefix table）是用来回退的，它记录了之前已经匹配的文本中的信息，并告诉我们：当文本串中的字符  <code>x</code>  与模式串中的字符  <code>y</code>  匹配失败时，下一步应该将模式串中的哪个字符与文本串中的字符  <code>x</code>  重新进行匹配</p><p>&lt;!-- 前缀表中，下标为  <code>i</code>  的元素，记录了 “ 在模式串里边，以下标  <code>i</code>  结束的子串有多大长度的相同前缀后缀，即，相同前后缀的最大长度 ” --&gt;</p><p>对于长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 的字符串  <code>s</code>  ，前缀表下标为  <code>i</code>  的元素记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi (i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi (i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 表示  <code>s</code>  的子串  <code>s[0:i]</code>  的最长的相同前后缀的长度</p><p>next 数组就是一个前缀表</p><h2 id="前缀与后缀"><a class="anchor" href="#前缀与后缀">#</a> 前缀与后缀</h2><p>字符串的 <strong>前缀</strong> (prefix)：<strong>不包含最后一个字符</strong> 的、<strong>以第一个字符开头</strong> 的连续子串</p><ul><li>例如，字符串 &quot;aabaaf&quot; 的前缀有：&quot;a&quot;、&quot;aa&quot;、&quot;aab&quot;、&quot;aaba&quot; 和 &quot;aabaa&quot;</li></ul><p>字符串的 <strong>后缀</strong> (suffix)：<strong>不包含第一个字符</strong> 的、<strong>以最后一个字符结尾</strong> 的连续子串</p><ul><li>例如，字符串 &quot;aabaaf&quot; 的后缀有：&quot;f&quot;、&quot;af&quot;、&quot;aaf&quot;、&quot;baaf&quot; 和 &quot;abaaf&quot;</li></ul><h2 id="最长相同前后缀"><a class="anchor" href="#最长相同前后缀">#</a> 最长相同前后缀</h2><p>针对某一字符串，使得 前缀和后缀相同 的前缀 / 后缀长度的最大值，即为所谓的 相同前后缀的最大长度，对应的前缀 / 后缀即为 最长相同前后缀</p><p>例如，字符串 &quot;aabaa&quot; 的前缀有 &quot;a&quot;、&quot;aa&quot;、&quot;aab&quot;、&quot;aaba&quot;，后缀有 &quot;a&quot;、&quot;aa&quot;、&quot;baa&quot;、&quot;abaa&quot;，其中，相同前后缀的最大长度为 2，最长相同前后缀为 &quot;aa&quot;</p><h2 id="前缀表元素"><a class="anchor" href="#前缀表元素">#</a> 前缀表元素</h2><p>以模式串中位置  <code>i</code>  为结尾的子串  <code>s[0:i]</code> ，其相同前后缀最大长度，就是前缀表元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi (i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \le i \le m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>以模式串 &quot;aabaaf&quot; 为例：</p><ul><li>子串 &quot;a&quot; 的相同前后缀最大长度为 0（没有前缀，也没有后缀），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi (0) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li><li>子串 &quot;aa&quot; 的相同前后缀最大长度为 1（前缀为 &quot;a&quot;，后缀也为 &quot;a&quot;），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pi (1) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>子串 &quot;aab&quot; 的相同前后缀最大长度为 0（前缀不含 'b'，后缀一定含 'b' ，不存在相同前后缀），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi (2) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li><li>子串 &quot;aaba&quot; 的相同前后缀最大长度为 1（最长相同前后缀为 &quot;a&quot;），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pi (3) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>子串 &quot;aabaa&quot; 的相同前后缀最大长度为 2（最长相同前后缀为 &quot;aa&quot;），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\pi (4) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li><li>子串 &quot;aabaaf&quot; 的相同前后缀最大长度为 0（前缀不含 'f'，后缀一定含 'f' ，不存在相同前后缀），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi (5) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li></ul><p>即，</p><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">模式串</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">f</td></tr><tr><td style="text-align:center">前缀表</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table><p>在字符串匹配过程中，如果模式串的  <code>f</code>  与文本串匹配失败，则需找到  <code>f</code>  前一位所对应的前缀表元素，其值为  <code>2</code>  ，因此，可以将模式串下标为  <code>2</code>  的字符与文本串重新匹配</p><ul><li>字符  <code>f</code>  之前的这部分字符串（也就是字符串 &quot;aabaa&quot; ）的最长相等前后缀字符串是 &quot;aa&quot; ，匹配失败的位置是后缀子串的下一位，那么我们找到相同前缀的下一位继续匹配即可</li></ul><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="利用前缀表进行匹配的过程" /></p><h1 id="next-数组"><a class="anchor" href="#next-数组">#</a> next 数组</h1><p>next 数组，即，前缀表的一种实现</p><p>确定字符串的 next 数组，也就是在 寻找最长相同前后缀</p><h2 id="基本思想"><a class="anchor" href="#基本思想">#</a> 基本思想</h2><p>针对每一个以索引  <code>suffixEnd</code>  结尾的子串，将  <code>suffixEnd</code>  作为后缀的末尾索引，寻找末尾字符为  <code>s[suffixEnd]</code>  的前缀（即，寻找能够与后缀匹配的前缀）</p><h2 id="算法流程"><a class="anchor" href="#算法流程">#</a> 算法流程</h2><p>初始化前缀末尾  <code>prefixEnd</code>  为  <code>0</code>  ，初始化 next 数组的第  <code>0</code>  位元素为  <code>0</code></p><ul><li>因为以第 0 位为结尾的子串没有前缀，也没有后缀，最大相同前后缀长度为 0</li></ul><p>遍历以  <code>suffixEnd</code>  为结尾的子串（即，遍历  <code>suffixEnd</code>  ），执行以下操作：</p><ul><li><p>若  <code>s[prefixEnd] != s[suffixEnd]</code>  ，即，前缀末尾字符与后缀末尾字符不相同，执行循环（直到  <code>s[prefixEnd] == s[suffixEnd]</code>  或者  <code>prefixEnd == 0</code>  ）：收缩前缀，将前缀末尾回退到  <code>next[prefixEnd - 1]</code>  位置</p></li><li><p>若  <code>s[prefixEnd] == s[suffixEnd]</code>  ，即，前缀末尾字符与后缀末尾字符相同，执行  <code>prefixEnd++</code>  ，将前缀末尾向右移</p><ul><li>向右移有两方面的原因：1）当前找到前缀的长度为  <code>prefixEnd + 1</code> ，故，最长相同前后缀的长度为  <code>prefixEnd + 1</code>  ；2）对于  <code>suffixEnd</code>  下一位的 next 数组元素而言，其最大取值为  <code>next[suffixEnd] + 1</code>  （前缀表的性质：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>π</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pi (i) \le \pi (i - 1) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><mi>π</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i] = s[\pi (i - 1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> 时，等号成立）</li></ul></li><li><p>更新 next 数组：执行  <code>next[suffixEnd] = prefixEnd</code></p></li></ul><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">void getNext(vector&lt;int&gt;&amp; next, const string&amp; s) &#123;    int prefixEnd = 0;  // prefixEnd 表示前缀的末尾（前缀从第 0 位开始）    next[0] = 0;    // 计算最长相同前后缀的长度    for(int suffixEnd = 1; suffixEnd &lt; s.size(); suffixEnd++) &#123; // suffixEnd 表示后缀的末尾（后缀从第 1 位开始）        // 比较前缀末尾字符与后缀末尾字符        while (prefixEnd &gt; 0 &amp;&amp; s[suffixEnd] != s[prefixEnd]) &#123; // prefixEnd 大于 0 ，因为后续要将 prefixEnd - 1 作为下标            prefixEnd = next[prefixEnd - 1]; // 前缀末尾与后缀末尾不相同，要将前缀收缩到与后缀相同的情况        &#125;        if (s[suffixEnd] == s[prefixEnd]) &#123;            prefixEnd++; // 前缀末尾字符与后缀末尾字符相同，前缀长度为 prefixEnd + 1，将 prefixEnd 右移        &#125;        next[suffixEnd] = prefixEnd; // 以 suffixEnd 为结尾的子串的最长相同前后缀的长度为 prefixEnd    &#125;&#125;</code></pre><blockquote><p>建议结合实例来理解 next 数组的获取过程，例如，考虑字符串 &quot;aabaaf&quot; 的 next 数组</p></blockquote><h1 id="利用前缀表进行字符串匹配"><a class="anchor" href="#利用前缀表进行字符串匹配">#</a> 利用前缀表进行字符串匹配</h1><p>这里介绍如何使用 next 数组（直接利用上述构造的 next 数组），完成模式串  <code>t</code>  与文本串  <code>s</code>  的匹配</p><h2 id="算法流程-2"><a class="anchor" href="#算法流程-2">#</a> 算法流程</h2><p>定义  <code>j</code>  指向模式串  <code>t</code>  的起始位置</p><pre><code>int j = 0;</code></pre><p>定义  <code>i</code>  指向文本串  <code>s</code>  的起始位置， <code>i</code>  从 0 开始遍历文本串</p><ul><li><p>若  <code>s[i] != t[j]</code>  ，需要从 next 数组中寻找下一个位置进行匹配</p><pre><code>  while (j &gt; 0 &amp;&amp; s[i] != t[j])      j = next[j - 1];</code></pre></li><li><p>若  <code>s[i] == t[j]</code>  ，将  <code>i</code>  和  <code>j</code>  同时向右移动一位</p><pre><code>  if (s[i] == t[j])      j++;</code></pre></li><li><p>若  <code>j</code>  最终指向模式串  <code>t</code>  的尾后，说明，模式串  <code>t</code>  完全匹配文本串  <code>s</code></p></li></ul><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">bool IsSubString (string s, string t) &#123;    if (s.size() == 0) return false;    vector&lt;int&gt; next(t.size());    getNext(next, t);    int j = 0;    for (int i = 0; i &lt; s.size(); i++) &#123;        while (j &gt; 0 &amp;&amp; s[i] != t[j])            j = next[j - 1];        if (s[i] == t[j])            j++;        if (j == t.size)            return true;    &#125;    return false;&#125;</code></pre><p>具体实例可见 <a href="https://jiankychen.github.io/posts/8f083358">LeetCode 28. 实现 strStr ()</a></p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMjguJUU1JUFFJTlFJUU3JThFJUIwc3RyU3RyLmh0bWw=">KMP 算法实现：代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3Ryc3RyL3NvbHV0aW9uL3NoaS14aWFuLXN0cnN0ci1ieS1sZWV0Y29kZS1zb2x1dGlvbi1kczZ5Lw==">KMP 算法理论：力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 28. 实现 strStr()</title>
      <link href="/posts/8f083358/"/>
      <url>/posts/8f083358/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3Ryc3RyLw==">LeetCode 28. Implement strStr()</span></p><p>给你两个字符串  <code>haystack</code>  和  <code>needle</code>  ，请你在  <code>haystack</code>  字符串中找出  <code>needle</code>  字符串的第一个匹配项的下标（下标从 0 开始）。如果  <code>needle</code>  不是  <code>haystack</code>  的一部分，则返回  -1 。</p><p><strong>Clarification:</strong></p><ul><li><p>当  <code>needle</code>  是一个空字符串时，我们应该返回什么？</p></li><li><p>当  <code>needle</code>  是空字符串时，我们将返回 0。这与 C 语言的  <code>strstr()</code>  和 Java 的  <code>indexOf()</code>  一致。</p></li></ul><p></p><p><strong>示例 1：</strong></p><pre><code>输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>haystack.length</code> ,  <code>needle.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>haystack</code>  and  <code>needle</code>  consist of only lowercase English characters.</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>本题是经典的字符串单模匹配的模型，可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等</p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3Ryc3RyL3NvbHV0aW9uL3NoaS14aWFuLXN0cnN0ci1ieS1sZWV0Y29kZS1zb2x1dGlvbi1kczZ5Lw==">力扣官方题解：实现 strStr ()</span></p><h2 id="method-1-暴力搜索"><a class="anchor" href="#method-1-暴力搜索">#</a> Method 1: 暴力搜索</h2><p>基本思路：让字符串  <code>needle</code>  与字符串  <code>haystack</code>  中所有长度为  <code>m</code>  的子串均匹配一次，其中， <code>m</code>  为字符串  <code>needle</code>  的长度</p><pre><code class="language-cpp">// 检查字符串 haystack 中以索引 start 开头的一连串字符是否与 needle 字符串匹配bool isSubStr(string haystack, int start, string needle) &#123;    for (auto c : needle) &#123;        if (haystack[start] != c)            return false;        start++;    &#125;    return true;&#125;int strStr(string haystack, string needle) &#123;    for (int i = 0; i &lt; haystack.size(); i++) &#123;        if (isSubStr(haystack, i, needle))            return i;     &#125;    return -1;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串  <code>haystack</code>  的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 为字符串  <code>needle</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-kmp-算法"><a class="anchor" href="#method-2-kmp-算法">#</a> Method 2: KMP 算法</h2><p>文本串为  <code>haystack</code>  ，模式串为  <code>needle</code>  ，利用 KMP 算法进行字符串匹配</p><p>算法流程：</p><ol><li><p>构造 next 数组，用于查找回退位置</p></li><li><p>利用 next 数组进行匹配，定义  <code>i</code>  为文本串索引， <code>j</code>  为模式串索引，执行循环：</p><ul><li>若模式串字符  <code>needle[j]</code>  与文本串字符  <code>haystack[i]</code>  相同，则将  <code>i</code>  和  <code>j</code>  同时右移</li><li>若不相同，连续执行  <code>j = next[j - 1]</code>  ，直到  <code>needle[j] == haystack[i]</code>  或  <code>j == 0</code></li></ul></li></ol><p>具体原理及步骤可参阅 <a href="https://jiankychen.github.io/posts/36b55f59/">KMP 算法</a></p><p>代码实现：</p><pre><code class="language-cpp">// 计算 next 数组void getNext(vector&lt;int&gt; &amp;next, string s) &#123;    int prefix = 0;    next[0] = 0;    for (int suffix = 1; suffix &lt; s.size(); suffix++) &#123;        while (prefix &gt; 0 &amp;&amp; s[prefix] != s[suffix])            prefix = next[prefix - 1];        if (s[prefix] == s[suffix])            prefix++;        next[suffix] = prefix;    &#125;&#125;// 字符串匹配int strStr(string haystack, string needle) &#123;    vector&lt;int&gt; next(needle.size(), 0);    getNext(next, needle);    int j = 0;    for (int i = 0; i &lt; haystack.size(); i++) &#123;        while (j &gt; 0 &amp;&amp; needle[j] != haystack[i]) // needle[j] 与 haystack[i] 不同，回退 j            j = next[j - 1];        if (needle[j] == haystack[i])       // needle[j] 与 haystack[i] 相同，右移 i 和 j            j++;        if (j == needle.size())             // 匹配完成            return (i - needle.size() + 1); // 正确匹配的起点索引为 i - needle.size() + 1    &#125;    return -1;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，使用额外空间存储 next 数组</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMjguJUU1JUFFJTlFJUU3JThFJUIwc3RyU3RyLmh0bWw=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3Ryc3RyL3NvbHV0aW9uL3NoaS14aWFuLXN0cnN0ci1ieS1sZWV0Y29kZS1zb2x1dGlvbi1kczZ5Lw==">力扣官方题解</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 58-II. 左旋转字符串</title>
      <link href="/posts/5c5f7907/"/>
      <url>/posts/5c5f7907/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy96dW8teHVhbi16aHVhbi16aS1mdS1jaHVhbi1sY29mLw==">剑指 Offer 58-II. 左旋转字符串</span></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串 &quot;abcdefg&quot; 和数字 2，该函数将返回左旋转两位得到的结果 &quot;cdefgab&quot;。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;cdefgab&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;lrloseumgh&quot;, k = 6输出：&quot;umghlrlose&quot;</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">\le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：你能想出一个仅使用常数空间的原地操作算法吗？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>解题思路：</p><ol><li>将整个字符串  <code>s</code>  反转</li><li>将前  <code>s.size() - n</code>  个字符反转</li><li>将后  <code>n</code>  个字符反转</li></ol><p>以  <code>s = &quot;abcdefg&quot;</code>  ， <code>n = 2</code>  为例：</p><ul><li>反转整个字符串，得到：&quot;gfedcba&quot;</li><li>反转前 5 个字符串，得到：&quot;cdefgba&quot;</li><li>反转后 2 个字符串，得到：&quot;cdefgab&quot;</li></ul><h2 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h2><p>采用双指针法实现字符串的反转</p><p>代码实现：</p><pre><code class="language-cpp">void reverse(string &amp;s, int left, int right) &#123;    while (left &lt; right)        swap(s[left++], s[right--]);&#125;string reverseLeftWords(string s, int n) &#123;    reverse(s, 0, s.size() - 1);    reverse(s, 0, s.size() - n - 1);    reverse(s, s.size() - n, s.size() - 1);    return s;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为字符串长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 151. 颠倒字符串中的单词</title>
      <link href="/posts/2b58e836/"/>
      <url>/posts/2b58e836/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLw==">LeetCode 151. Reverse Words in a String</span></p><p>给你一个字符串  <code>s</code>  ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。 <code>s</code>  中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意</strong>：输入字符串  <code>s</code>  中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p></p><p>示例 1：</p><pre><code>输入：s = &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot;</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;  hello world  &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;a good   example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个</code></pre><p></p><p>提示：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  包含英文大小写字母、数字和空格  <code>' '</code></li><li><code>s</code>  中 至少存在一个 单词</li></ul><p><strong>进阶</strong>： 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h1 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><ol><li><p>移除字符串中多余的空格，包括字符串首部和尾部的空格以及单词之间的多个空格</p></li><li><p>翻转整个字符串</p></li><li><p>逐个翻转每个单词</p></li></ol><p>以 &quot;a good   example&quot; 为例：</p><ul><li>移除多余空格：&quot;a good example&quot;</li><li>翻转字符串：&quot;elpmaxe doog a&quot;</li><li>翻转单词：&quot;example good a&quot;</li></ul><p>可参考</p><ul><li><a href="https://jiankychen.github.io/posts/c425967e/">LeetCode 27. 移除元素</a></li><li><a href="https://jiankychen.github.io/posts/d9baf118/">LeetCode 344. 反转字符串</a></li><li><a href="https://jiankychen.github.io/posts/e1635286/">LeetCode 557. 反转字符串中的单词 III</a></li></ul><h2 id="算法流程"><a class="anchor" href="#算法流程">#</a> 算法流程</h2><ol><li><p>去除多余空格</p><ul><li>定义快慢指针  <code>fast</code>  和  <code>slow</code>  ， <code>slow</code>  指向  <code>0</code>  ， <code>fast</code>  指向从左往右的第一个非空格字符</li><li>将  <code>s[fast]</code>  赋给  <code>s[slow]</code>  ，然后移动  <code>fast</code>  和  <code>slow</code>  指针，重复该过程，特别地，如果  <code>fast</code>  遇到连续的多个空格，只需将一个空格赋给  <code>s[left]</code></li><li>当  <code>fast</code>  移动到字符串的尾后时， <code>slow</code>  指向的是原字符串的最后一个字符。如果  <code>s[slow]</code>  是空字符，将  <code>slow</code>  指针向左移动，直到  <code>slow</code>  指向非空字符</li></ul></li><li><p>调整字符串  <code>s</code>  的长度：上一步中的  <code>slow</code>  指向最后一个有效字符，故，有效字符串的长度为  <code>slow + 1</code></p></li><li><p>翻转整个字符串</p><ul><li>定义  <code>reverse</code>  函数，实现左右指针  <code>left</code>  和  <code>right</code>  之间所有字符的翻转：交换  <code>s[left]</code>  与  <code>s[right]</code>  ，并将  <code>left</code>  向右移动、将  <code>right</code>  向左移动</li></ul></li><li><p>翻转字符串中的每个单词</p><ul><li>定义  <code>start</code>  和  <code>end</code>  指针， <code>start</code>  指向单词的起始位置，当  <code>end</code>  指向单词后的空格时或者指向字符串的尾后时，调用  <code>reverse</code>  函数翻转  <code>start</code>  到  <code>end - 1</code>  之间的字符</li></ul></li></ol><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">// 将 left 到 right 之间的所有字符反转void reverse(string &amp;s, int left, int right) &#123;    while (left &lt; right)        swap(s[left++], s[right--]);&#125;// 双指针，去掉多余空格void removeExtraSpaces(string &amp;s) &#123; // 双指针法    int slow = 0, fast = 0;    while (fast &lt; s.size() &amp;&amp; s[fast] == ' ') fast++; // 跳过字符串首部的空格    for (; fast &lt; s.size(); fast++) &#123;        if (s[fast] == ' ' &amp;&amp; s[fast - 1] == ' ')     // 跳过重复的空格            continue;        s[slow++] = s[fast];       // 移动元素    &#125;    slow--;                        // slow 指向元素移动后的末尾字符    while (s[slow] == ' ') slow--; // slow 移到最后一个非空格字符的位置（排除字符串尾部的空格）    s.resize(slow + 1);            // 调整 s 的大小&#125;// 翻转字符串中的单词string reverseWords(string s) &#123;    removeExtraSpaces(s);        // 移除多余空格    reverse(s, 0, s.size() - 1); // 反转整个字符串    int start = 0, end = 0;    while (end &lt;= s.size()) &#123;    // 双指针法，反转每个单词        if (s[end] == ' ' || end == s.size()) &#123; // end 遇到空格或者到达尾后，反转单词            reverse(s, start, end - 1);            start = end + 1;     // 下一个单词的起点        &#125;        end++;    &#125;    return s;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p>有关 多余空格的去除 ，还可以参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxNTEuJUU3JUJGJUJCJUU4JUJEJUFDJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyJUU5JTg3JThDJUU3JTlBJTg0JUU1JThEJTk1JUU4JUFGJThELmh0bWw=">代码随想录：翻转字符串里的单词</span> 中的思路</p></blockquote><h1 id="method-2-一次遍历"><a class="anchor" href="#method-2-一次遍历">#</a> Method 2: 一次遍历</h1><p>代码实现：</p><pre><code class="language-cpp">string reverseWords(string s) &#123;    reverse(s.begin(), s.end()); // 反转整个字符串（库函数）    int index = 0;    for (int start = 0; start &lt; s.size(); ++start) &#123; // start 用于寻找每个单词的第一个字母        if (s[start] != ' ') &#123; // 遇到单词的第一个字母            if (index != 0) s[index++] = ' ';  // 添加空格，然后将 index 移动到下一个单词的开头位置            int end = start;   // 单词的最后一个字母            while (end &lt; s.size() &amp;&amp; s[end] != ' ') s[index++] = s[end++]; // 寻找单词的最后一个字母            reverse(s.begin() + index - (end - start), s.begin() + index); // 反转整个单词            start = end;        &#125;    &#125;    s.resize(index); // 修改字符串 s 的长度（提取有效字符）    return s;&#125;</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nL3NvbHV0aW9uL2Zhbi16aHVhbi16aS1mdS1jaHVhbi1saS1kZS1kYW4tY2ktYnktbGVldGNvZGUtc29sLw==">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 541. 反转字符串 II</title>
      <link href="/posts/bd781faa/"/>
      <url>/posts/bd781faa/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1zdHJpbmctaWkv">LeetCode 541. Reverse String II</span></p><p>给定一个字符串  <code>s</code>  和一个整数  <code>k</code> ，从字符串开头算起，每计数至  <code>2k</code>  个字符，就反转这  <code>2k</code>  字符中的前  <code>k</code>  个字符。</p><ul><li>如果剩余字符少于  <code>k</code>  个，则将剩余字符全部反转。</li><li>如果剩余字符小于  <code>2k</code>  但大于或等于  <code>k</code>  个，则反转前  <code>k</code>  个字符，其余字符保持原样。</li></ul><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot;</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  仅由小写英文组成</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>直接按题意进行模拟：</p><p>反转每个下标从  <code>2k</code>  的倍数开始的、长度为  <code>k</code>  的子串，若该子串长度不足  <code>k</code> ，则反转整个子串</p><h2 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h2><p>解题步骤：</p><p>将字符串  <code>s</code>  分成若干段长为  <code>2k</code>  的区间（最后一段不足  <code>2k</code>  也同样视为一个区间），针对每个区间执行以下操作</p><ul><li>若区间内的字符多于  <code>k</code>  个，反转前  <code>k</code>  个字符，反转操作与 <a href="https://jiankychen.github.io/posts/d9baf118/">LeetCode 344. 反转字符串</a> 一致</li><li>若区间内的字符少于  <code>k</code>  个，反转所有字符</li></ul><p>其中，针对区间的遍历，只需遍历区间的起点，即，以  <code>i = 0</code>  为起点，每次按照  <code>i = i + 2 * k</code>  更新  <code>i</code>  ，当  <code>i &gt;= s.size()</code>  时结束遍历</p><p>代码实现：</p><pre><code class="language-cpp">// 反转 left 到 right 之间的字符void reverse(string &amp;s, int left, int right) &#123;    while (left &lt; right)        swap(s[left++], s[right--]);&#125;// 反转字符串string reverseStr(string s, int k) &#123;    for (int i = 0; i &lt; s.size(); i += 2 * k) &#123; // 每 2k 个字符，进行一次 前 k 个字符的反转        if (i + k - 1 &lt; s.size()) &#123;  // 剩余字符多于 k 个，反转前 k 个字符            reverse(s, i, i + k - 1);            continue;        &#125;        reverse(s, i, s.size() - 1); // 剩余字符少于 k 个，将全部剩余字符反转    &#125;    return s;&#125;</code></pre><p>特别地，可以将上述  <code>for</code>  循环写成：</p><pre><code>for (int i = 0; i &lt; s.size(); i += 2 * k)    reverse(s, i, min(i + k - 1, num.size() - 1));</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串长度</p><ul><li>遍历  <code>i</code>  的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n / k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li><li>每反转  <code>k</code>  个字符的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p>当需要以固定规律对字符串逐段处理时，可试着在  <code>for</code>  循环的表达式上做做文章</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1zdHJpbmctaWkvc29sdXRpb24vZmFuLXpodWFuLXppLWZ1LWNodWFuLWlpLWJ5LWxlZXRjb2RlLXNvbC11YTdzLw==">力扣官方题解：反转字符串 II</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 18. 四数之和</title>
      <link href="/posts/bb4f52a2/"/>
      <url>/posts/bb4f52a2/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvNHN1bS8=">LeetCode 18. Four Sum</span></p><p>给你一个由  <code>n</code>  个整数组成的数组  <code>nums</code>  ，和一个目标值  <code>target</code>  。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组  <code>[nums[a], nums[b], nums[c], nums[d]]</code>  （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code> 、 <code>b</code> 、 <code>c</code>  和  <code>d</code>  <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>需注意区分本题与 <a href="https://jiankychen.github.io/posts/40552b28">LeetCode 454. 四数相加 II</a></p><p>本题的解题方法与 <a href="https://jiankychen.github.io/posts/1b6e2437/">LeetCode 15. 三数之和</a> 基本一致，这里采用 排序 + 双指针 解法</p><h2 id="method-排序-双指针"><a class="anchor" href="#method-排序-双指针">#</a> Method: 排序 + 双指针</h2><p>解题思路：</p><ol><li><p>对数组  <code>nums</code>  排序</p></li><li><p>采用两个  <code>for</code>  循环分别遍历  <code>i</code>  和  <code>j</code>  ，其中， <code>i</code>  从  <code>0</code>  开始遍历， <code>j</code>  从  <code>i + 1</code>  开始遍历（注意，要分别对  <code>nums[i]</code>  和  <code>nums[j]</code>  进行去重）</p></li><li><p>采用双指针法在  <code>[j + 1, nums.size() - 1]</code>  区间内查找所有能与  <code>nums[i]</code>  ,  <code>nums[j]</code>  组成四元组的元素  <code>nums[left]</code>  和  <code>nums[right]</code>  ，其中，指针  <code>left</code>  从  <code>j + 1</code>  位置开始向右遍历，指针  <code>right</code>  从  <code>nums.size() - 1</code>  位置开始向左遍历</p></li></ol><p>具体步骤可参考 <a href="https://jiankychen.github.io/posts/1b6e2437/">LeetCode 15. 三数之和</a></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;    sort(nums.begin(), nums.end());    vector&lt;vector&lt;int&gt;&gt; res;    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; // 对 nums[i] 去重        for (int j = i + 1; j &lt; nums.size(); j++) &#123;            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; // 对 nums[j] 去重            int left = j + 1, right = nums.size() - 1;            int temp = nums[i] + nums[j]; // 直接计算 nums[i] + nums[j] + nums[left] + nums[right] 会溢出            while (left &lt; right) &#123;                if (nums[left] + nums[right] &lt; target - temp) left++;                else if (nums[left] + nums[right] &gt; target - temp) right--;                else &#123;                    res.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);                    while (left &lt; right &amp;&amp; nums[left] == nums[++left]); // 对 nums[left] 去重                    while (left &lt; right &amp;&amp; nums[right] == nums[--right]); // 对 nums[right] 去重                &#125;            &#125;        &#125;    &#125;    return res;&#125;</code></pre><p>其中，需要注意  <code>nums[i] + nums[j] + nums[left] + nums[right]</code>  会溢出，因此，不能直接将  <code>nums[i] + nums[j] + nums[left] + nums[right]</code>  与  <code>target</code>  比较，可比较  <code>nums[left] + nums[right]</code>  与  <code>target - nums[i] - nums[j]</code></p><p>另外，当  <code>temp2 &lt; target - temp1</code>  时，可跳过重复的  <code>nums[left]</code>  ，当  <code>temp2 &gt; target - temp1</code>  时，可跳过重复的  <code>nums[right]</code>  ，即，将第 12 至 13 行代码改写为：</p><pre><code>if (temp2 &lt; target - temp1)    while (left &lt; right &amp;&amp; nums[left] == nums[++left]);else if (temp2 &gt; target - temp1)    while (left &lt; right &amp;&amp; nums[right] == nums[--right]);</code></pre><p>具体可见 <a href="https://jiankychen.github.io/posts/1b6e2437/">LeetCode 15. 三数之和</a></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><ul><li>遍历  <code>i</code>  和  <code>j</code>  ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>双指针查找：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，这里不考虑存储结果的数组，仅考虑排序所需栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMTguJUU1JTlCJTlCJUU2JTk1JUIwJUU0JUI5JThCJUU1JTkyJThDLmh0bWw=">代码随想录：四数之和</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 15. 三数之和</title>
      <link href="/posts/1b6e2437/"/>
      <url>/posts/1b6e2437/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS8=">LeetCode 15. Three Sum</span></p><p>给你一个整数数组  <code>nums</code>  ，判断是否存在三元组  <code>[nums[i]</code>  ,  <code>nums[j]</code>  ,  <code>nums[k]]</code>  满足  <code>i != j</code>  、 <code>i != k</code>  且  <code>j != k</code>  ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code>  。请你返回所有和为 0 且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：    nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。    nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。    nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。    不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。    注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = []输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [0]输出：[]解释：唯一可能的三元组和为 0 。</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>暴力法查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，考虑用低复杂度算法</p><p>注意：题目要求 “  <code>i != j</code> ,  <code>i != k</code> ,  <code>j != k</code>  ” 并且 “任意两个三元组不能相同” ，故而需要在查找时进行剪枝以避免重复，或是查找结束后剔除重复三元组</p><p>本题的难点也在于如何去除重复解</p><p>首先，可以对数组进行排序（最终只需要输出元素值即可，无需输出元素索引，故而可以打乱原数组顺序），将重复的元素值集中，便于去重</p><p>于是，有以下两种方法可以用于查找：</p><ol><li><p>哈希法：采用两层  <code>for</code>  循环分别遍历  <code>i</code>  和  <code>j</code>  （按照从左往右的顺序），并采用哈希法检查  <code>[i, j]</code>  区间范围内是否有元素能与  <code>nums[i]</code>  ， <code>nums[j]</code>  组成三元组</p></li><li><p>双指针法：采用一个  <code>for</code>  循环遍历  <code>i</code>  ，并采用双指针法在  <code>[i + 1, nums.size() - 1]</code>  区间内查找所有能与  <code>nums[i]</code>  组成三元组的元素  <code>nums[left]</code>  和  <code>nums[right]</code>  ，其中，指针  <code>left</code>  从  <code>i + 1</code>  位置开始向右遍历，指针  <code>right</code>  从  <code>nums.size() - 1</code>  位置开始向左遍历</p></li></ol><p>两种方法都能实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的时间复杂度，但哈希法不便进行去重操作，因此，建议使用排序与双指针法解题</p><h2 id="method-排序-双指针"><a class="anchor" href="#method-排序-双指针">#</a> Method: 排序 + 双指针</h2><p>解题步骤：</p><ol><li><p>对数组进行排序（从小到大排序）</p></li><li><p>遍历数组下标  <code>i</code></p><ul><li><p>若  <code>nums[i] &gt; 0</code>  ，则  <code>i</code>  右侧不存在能与  <code>nums[i]</code>  组成三元组的元素，直接返回结果</p></li><li><p>若  <code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]</code>  ，当前  <code>i</code>  能找到的三元组与  <code>i - 1</code>  时找到的完全相同，为避免产生重复解，跳过当前  <code>i</code></p></li><li><p>定义指针  <code>left</code>  指向  <code>i + 1</code>  位置，指针  <code>right</code>  指向  <code>nums.size() - 1</code>  位置，当  <code>left &lt; right</code>  时，执行循环：</p><ul><li>计算  <code>sum = nums[i] + nums[left] + nums[right]</code></li><li>若  <code>sum &gt; 0</code>  ，则  <code>nums[right]</code>  偏大，将  <code>right</code>  左移</li><li>若  <code>sum &lt; 0</code>  ，则  <code>nums[left]</code>  偏小，将  <code>left</code>  右移</li><li>若  <code>sum == 0</code>  ，记录结果，并将  <code>left</code>  右移、将  <code>right</code>  左移，以跳过重复的  <code>nums[left]</code>  和  <code>nums[right]</code></li></ul></li></ul></li></ol><blockquote><p>注意：同一个  <code>i</code>  可以与不同的元素组成多个不同的三元组，因此，在找到一对可行的  <code>nums[left]</code>  和  <code>nums[right]</code>  后仍需继续查找，直到  <code>left &lt; right</code>  不满足</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end()); // 排序    vector&lt;vector&lt;int&gt;&gt; res;        // 存储结果    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (nums[i] &gt; 0) break;        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;        int left = i + 1, right = nums.size() - 1;        int sum = 0;        while (left &lt; right) &#123;            sum = nums[i] + nums[left] + nums[right];            if (sum &gt; 0) right--;            if (sum &lt; 0) left++;            if (sum == 0) &#123;                res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);                // 将 left 右移（注意，++left 至少执行一次）                while (left &lt; right &amp;&amp; nums[left] == nums[++left]);                // 将 right 左移（注意，--right 至少执行一次）                while (left &lt; right &amp;&amp; nums[right] == nums[--right]);            &#125;        &#125;    &#125;    return res;&#125;</code></pre><p>需要注意的第一个地方：</p><pre><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code></pre><p>这里不能改成  <code>if (nums[i] == nums[i + 1]) continue;</code>  ，否则，以数组  <code>nums = [-1, 0, 1, 2, -1, -4]</code>  为例（排序后， <code>nums = [-4, -1, -1, 0, 1, 2]</code>  ），查找时将会遗漏  <code>[-1, -1, 2]</code>  这一个三元组。因为当  <code>i = 1</code>  时  <code>nums[1] == nums[2]</code>  条件成立，因此不会进行双指针查找；而当  <code>i = 2</code>  时，只会查找  <code>i</code>  右侧的元素，故而遗失了对  <code>[-1, -1, x]</code>  这几种情况的查找， <code>x</code>  为第二个  <code>-1</code>  右侧的任意值</p><p>&lt;!-- 上述的 Method 1 也是类似道理 --&gt;</p><p>需要注意的第二个地方：</p><pre><code>if (sum == 0) &#123;    res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);    while (left &lt; right &amp;&amp; nums[left] == nums[++left]);    while (left &lt; right &amp;&amp; nums[right] == nums[--right]);&#125;</code></pre><p>这里的  <code>++left</code>  和  <code>--right</code>  都至少执行一次：执行一次是因为找到了一个三元组，需要同时移动双指针，以进行下一次的查找；执行多次则是为了跳过重复的  <code>nums[left]</code>  和  <code>nums[right]</code></p><p>并且，注意这里的  <code>nums[left] == nums[++left]</code>  语句，将当前  <code>left</code>  对应元素值与  <code>left</code>  右移之后对应元素值进行比较，不能将其改成  <code>nums[++left] == nums[left]</code>  ，也不能改成  <code>nums[left] == nums[left++]</code>  。语句  <code>nums[right] == nums[--right]</code>  同理</p><p>特别地，第二个地方可以改写成</p><pre><code>if (sum == 0) &#123;    res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);    // 先将 left 移到最靠右的一个 nums[left]    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;    // 先将 right 移到最靠左的一个 nums[right]    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;    // 再分别移动一次 left 和 right ，以进行下一次查找    left++;    right--;&#125;</code></pre><p>另外，当  <code>sum &gt; 0</code>  时，可对  <code>nums[right]</code>  进行去重，以跳过重复的  <code>nums[right]</code>  ，即，将  <code>if (sum &gt; 0) right--;</code>  改写为</p><pre><code>if (sum &gt; 0)    while (left &lt; right &amp;&amp; nums[right] == nums[--right]);</code></pre><p>或者改写为</p><pre><code>if (sum &gt; 0) &#123;    right--;    while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;&#125;</code></pre><p>类似地，当  <code>sum &lt; 0</code>  时，也可对  <code>nums[left]</code>  进行去重，以跳过重复的  <code>nums[left]</code></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><ul><li>遍历  <code>i</code>  ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>双指针查找：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><ul><li>不考虑存储结果的数组</li><li>仅考虑排序所需栈空间</li></ul><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMTUuJUU0JUI4JTg5JUU2JTk1JUIwJUU0JUI5JThCJUU1JTkyJThDLmh0bWwjJUU1JTkzJTg4JUU1JUI4JThDJUU4JUE3JUEzJUU2JUIzJTk1">代码随想录：三数之和</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS9zb2x1dGlvbi8zc3VtcGFpLXh1LXNodWFuZy16aGktemhlbi15aS1kb25nLWJ5LWp5ZC8=">Krahets：三数之和（排序 + 双指针，易懂图解）</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 383. 赎金信</title>
      <link href="/posts/579713f1/"/>
      <url>/posts/579713f1/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuc29tLW5vdGUv">LeetCode 383. Ransom Note</span></p><p>给你两个字符串： <code>ransomNote</code>  和  <code>magazine</code>  ，判断  <code>ransomNote</code>  能不能由  <code>magazine</code>  里面的字符构成。</p><p>如果可以，返回  <code>true</code>  ；否则返回  <code>false</code>  。</p><p><code>magazine</code>  中的每个字符只能在  <code>ransomNote</code>  中使用一次。</p><p><strong>示例 1：</strong></p><pre><code>输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>ransomNote.length</code> ,  <code>magazine.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>ransomNote</code>  和  <code>magazine</code>  由小写英文字母组成</li></ul><h2 id="method-哈希"><a class="anchor" href="#method-哈希">#</a> Method: 哈希</h2><p>由于字符串中只有小写字母，可以考虑用 数组 实现哈希法</p><p>解题步骤如下：</p><ol><li><p>定义数组  <code>count</code>  ，数组元素的下标表示字符相当于  <code>a</code>  的距离，元素值表示字符在字符串  <code>magazine</code>  中出现的次数</p></li><li><p>依据数组  <code>count</code>  判断  <code>ransomNote</code>  的每个字符是否都在字符串  <code>magazine</code>  内</p><ul><li>由于  <code>magazine</code>  中每个字符只能在  <code>ransomNote</code>  中用一次，在遍历字符串  <code>ransomNote</code>  中的每个字符时，需要维护字符所对应的  <code>count</code>  元素值，即，“用一次就会少一次”</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool canConstruct(string ransomNote, string magazine) &#123;    vector&lt;int&gt; count(26, 0); // record the letters and their frequency in string magazine    for (auto c : magazine)        count[c - 'a']++;    for (auto c : ransomNote) &#123;        if (count[c - 'a'])            count[c - 'a']--; // since each letter in string magazine can only be used once        else            return false;     // c cannot be found in string magazine    &#125;    return true;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p>由于  <code>ransomNote</code>  和  <code>magazine</code>  都由字母组成， <code>key</code>  分布较为集中。与 set 和 map 相比，采用数组更为省时</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 454. 四数相加II</title>
      <link href="/posts/40552b28/"/>
      <url>/posts/40552b28/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvNHN1bS1paS8=">LeetCode 454. 4Sum II</span></p><p>给你四个整数数组  <code>nums1</code> 、 <code>nums2</code> 、 <code>nums3</code>  和  <code>nums4</code>  ，数组长度都是  <code>n</code>  ，请你计算有多少个元组  <code>(i, j, k, l)</code>  能满足：</p><ul><li><p><code>0 &lt;= i, j, k, l &lt; n</code></p></li><li><p><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></p></li></ul><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：    1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0    2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1</code></pre><p></p><p><strong>提示：</strong></p><ul 28=""><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>28</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 2^{28} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1[i]</code> ,  <code>nums2[i]</code> ,  <code>nums3[i]</code> ,  <code>nums4[i]</code>  \le 2^</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>统计  <code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code>  成立的  <code>(i, j, k, l)</code>  的个数，不用考虑是否有重复的元素值相加</p><p>可以采用  <code>unordered_map</code>  容器记录 任意  <code>nums1[i]</code>  与  <code>nums2[j]</code>  相加的和，将其作为  <code>key</code> ，同时记录 该  <code>key</code>  值出现的次数，将其作为对应的  <code>value</code></p><p>然后遍历  <code>nums3[k]</code>  和  <code>nums4[l]</code>  ，看  <code>unordered_map</code>  容器中是否能找到值为  <code>0 - num3[k] - num4[l]</code>  的  <code>key</code>  ，将找到的所有  <code>key</code>  对应的  <code>value</code>  进行求和，即为所求</p><h2 id="哈希-map"><a class="anchor" href="#哈希-map">#</a> 哈希 map</h2><p>解题步骤：</p><ol><li>定义一个  <code>unordered_map</code>  容器，命名为  <code>map</code></li><li>遍历数组  <code>nums1</code>  的元素 <code>a</code>  和 数组  <code>nums2</code>  的元素  <code>b</code> ，将  <code>a + b</code>  作为哈希  <code>map</code>  的  <code>key</code>  ，将值  <code>a + b</code>  出现的次数作为对应的  <code>value</code></li><li>定义变量  <code>count</code>  ，用来记录答案</li><li>遍历数组  <code>nums3</code>  元素  <code>c</code>  和数组  <code>nums4</code>  元素  <code>d</code>  ，如果在哈希  <code>map</code>  中找到  <code>0 - (c + d)</code>  ，把对应的  <code>value</code>  累加到  <code>count</code></li></ol><p>代码实现：</p><pre><code class="language-cpp">int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;    // 统计 nums1 和 nums2 数组中任意两元素之和    unordered_map&lt;int, int&gt; map;    for (auto a : nums1)        for (auto b : nums2)            map[a + b]++;    // 统计 a + b + c + d = 0 的次数    int count = 0;    for (auto c : nums3)        for (auto d : nums4)            if (map.find(0 - c - d) != map.end())                count += map[0 - c - d];    return count;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><ul><li>两个  <code>for</code>  循环，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>每次哈希查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，哈希  <code>map</code>  所需要的空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0NTQuJUU1JTlCJTlCJUU2JTk1JUIwJUU3JTlCJUI4JUU1JThBJUEwSUkuaHRtbCMlRTUlODUlQjYlRTQlQkIlOTYlRTglQUYlQUQlRTglQTglODAlRTclODklODglRTYlOUMlQUM=">代码随想录：四数相加 II</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1. 两数之和</title>
      <link href="/posts/3da9e18f/"/>
      <url>/posts/3da9e18f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">LeetCode 1. Two Sum</span></p><p>给定一个整数数组  <code>nums</code>  和一个整数目标值  <code>target</code> ，请你在该数组中找出 <strong>和为目标值</strong>  <code>target</code>   的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,4], target = 6输出：[1,2]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> &lt;=  <code>nums.length</code>  &lt;= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">- 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> &lt;=  <code>nums[i]</code>  &lt;= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">- 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> &lt;=  <code>target</code>  &lt;= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>只存在一个有效答案</li></ul><p><strong>进阶</strong>：你可以想出一个时间复杂度小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的算法吗？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>解题思路：遍历数组的下标  <code>i</code>  ，判断  <code>target - nums[i]</code>  是否存在，若存在，返回  <code>i</code>  以及 数组中值为  <code>target - nums[i]</code>  的元素的下标</p><p>本题不仅要判读数值是否存在，还要记录其下标，因此采用哈希 map ，其中，元素值 作为  <code>key</code>  ，元素在数组中的索引下标作为  <code>value</code></p><h2 id="method-哈希-map"><a class="anchor" href="#method-哈希-map">#</a> Method: 哈希 map</h2><p>由于并不需要  <code>key</code>  有序，可以选择  <code>unordered_map</code></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfbWFwL3Vub3JkZXJlZF9tYXAvP2t3PXVub3JkZXJlZF9tYXA=">std::unoredered_map</span></p><p>解题步骤：</p><ol><li><p>定义  <code>unodered_map</code>  容器，命名为  <code>map</code></p></li><li><p>遍历数组下标  <code>i</code></p><ul><li>查找  <code>target - nums[i]</code>  是否存在于  <code>map</code>  当中</li><li>若存在，返回下标  <code>i</code>  以及 与键值  <code>target - nums[i]</code>  对应的  <code>value</code></li><li>否则，将  <code>nums[i]</code>  以及  <code>i</code>  作为键值对添加到  <code>map</code></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    unordered_map&lt;int, int&gt; map;    for (int i = 0; i &lt; nums.size(); i++) &#123;        auto temp = map.find(target - nums[i]); // find 返回的是迭代器类型        if (temp != map.end())                  // 找到 target - nums[i]            return &#123;temp-&gt;second, i&#125;;           // 返回 i 以及 temp 的第二个值                                                // temp-&gt;first 是 key ，temp-&gt;second 是 value        map.insert(pair&lt;int, int&gt;(nums[i], i)); // 将 nums[i], i 作为键值对插入到 map    &#125;    return &#123;&#125;;&#125;</code></pre><blockquote><p><code>unordered_map</code>  的成员函数  <code>find</code>  的返回值是  <code>iterator</code>  类型，解引用后的第一个成员为  <code>key</code>  ，第二个成员为  <code>value</code>  ，详见 <span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfbWFwL3Vub3JkZXJlZF9tYXAvZmluZC8=">std::unordered_map::find</span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 202. 快乐数</title>
      <link href="/posts/76ed881c/"/>
      <url>/posts/76ed881c/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFwcHktbnVtYmVyLw==">LeetCode 202. Happy Number</span></p><p>编写一个算法来判断一个数  <code>n</code>  是不是快乐数。</p><p><strong>快乐数</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为 1</strong>，那么这个数就是快乐数。</li></ul><p>如果  <code>n</code>  是 快乐数 就返回  <code>true</code>  ；不是，则返回  <code>false</code>  。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：n = 19输出：true解释：    1 + 81 = 82    64 + 4 = 68    36 + 64 = 100    1 + 0 + 0 = 1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 2输出：false</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>注意到题目说明：</p><ul><li>若各位平方和最终等于 1 ，则  <code>n</code>  为快乐数</li><li>若各位平方和的值循环出现，则  <code>n</code>  不是快乐数</li></ul><p>因此，本题的解题关键在于，在求和过程中，判断数字是否重复出现</p><ul><li>若重复出现，则该数字必定不是快乐数</li><li>若求和结果为 1，则该数字是快乐数</li></ul><h2 id="method-1-哈希-set"><a class="anchor" href="#method-1-哈希-set">#</a> Method 1: 哈希 set</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfc2V0L3Vub3JkZXJlZF9zZXQvP2t3PXVub3JkZXJlZF9zZXQ=">std::unordered_set</span></p><p>考虑用哈希表  <code>unordered_set</code>  记录求和过程中出现的数字，并判断其是否重复出现</p><p>另，需注意  <code>n</code>  的各位数字平方和的计算</p><ul><li>计算个位数字的平方</li><li>取个位以外的部分</li><li>重复以上两步</li></ul><p>代码实现：</p><pre><code class="language-cpp">int getSum(int n) &#123; // 计算 n 中各位的平方和    int sum = 0;    while (n) &#123;        sum += (n % 10) * (n % 10); // 取 n 的个位数，求其平方，再累加到 sum 上        n /= 10;                    // 取个位数以外的部分    &#125;    return sum;&#125;bool isHappy(int n) &#123;    unordered_set&lt;int&gt; record;    while (1) &#123;        int sum = getSum(n);        if (sum == 1)            return 1;        if (record.find(sum) != record.end()) // sum 重复出现            return 0;        else            record.insert(sum);               // sum 第一次出现        n = sum;                              // 更新当前计算数字    &#125;&#125;</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMDIuJUU1JUJGJUFCJUU0JUI5JTkwJUU2JTk1JUIwLmh0bWw=">代码随想录：快乐数</span></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><ul><li>查找给定数字的下一个值的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，因为数字的位数由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>10</mn></msub><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{10}{n}) = O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 确定</li><li>总体的时间复杂度还需考虑循环过程中的数字个数，这里简单起见仅考虑计算下一个值的时间复杂度</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-快慢指针"><a class="anchor" href="#method-2-快慢指针">#</a> Method 2: 快慢指针</h2><p>可以采用类似于 <a href="https://jiankychen.github.io/posts/fe4aea2">LeetCode 142. 环形链表 II</a> 的方法，定义快慢指针，判断是否存在环</p><ul><li>若存在环，则快慢指针一定会在环内相遇，即，数  <code>n</code>  不是快乐数</li><li>否则，快指针会比慢指针先到达数字 1 ，即，数  <code>n</code>  是快乐数</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFwcHktbnVtYmVyL3NvbHV0aW9uL2t1YWktbGUtc2h1LWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：快乐数</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 349. 两个数组的交集</title>
      <link href="/posts/c10e195a/"/>
      <url>/posts/c10e195a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1hcnJheXMv">LeetCode 349. Intersection of Two Arrays</span></p><p>给定两个数组  <code>nums1</code>  和  <code>nums2</code>  ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1.length</code> ,  <code>nums2.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums1[i]</code> ,  <code>nums2[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>由于数组  <code>nums1</code>  和  <code>nums2</code>  的元素值可能比较分散，使用数组来实现哈希法会造成空间的浪费，故而可以采用  <code>set</code></p><p>注意到题目要求输出的每个元素必须唯一，且不考虑输出结果的顺序，故而选用  <code>unordered_set</code></p><blockquote><p>注：相比于数组而言，直接使用 set 不仅占用空间比数组大，而且速度慢。因此，在 数组元素大小有限 且 哈希值比较集中 时，应尽量用 数组 ，而如果哈希值比较少、特别分散、跨度非常大，则考虑用 set</p></blockquote><h2 id="unordered_set"><a class="anchor" href="#unordered_set">#</a> unordered_set</h2><p>解题步骤：</p><ol><li><p>定义  <code>unordered_set</code>  容器  <code>record</code>  和  <code>ans</code>  ，前者存放第一个数组  <code>nums1</code>  的元素，后者记录两数组的交集</p></li><li><p>遍历数组  <code>nums2</code>  ：若  <code>nums2</code>  数组的元素  <code>a</code>  能够在  <code>record</code>  中找到（即， <code>record.find(a) != record.end()</code>  ），则说明  <code>a</code>  是两数组的公共元素，将其添加到  <code>ans</code>  中</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    unordered_set&lt;int&gt; record(nums1.begin(), nums1.end());  // 将 nums1 拷贝到 unordered_set 容器    unordered_set&lt;int&gt; ans;             // 存放结果（两数组的交集）    for (auto a : nums2)        if (record.find(a) != record.end())   // nums2 的元素 a 在 nums1 中出现过            ans.insert(a);              // 将 a 添加到结果    return vector&lt;int&gt;(ans.begin(), ans.end());   // 返回（先拷贝到 vector ，因为返回值的类型是 vector&lt;int&gt;）&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 242. 有效的字母异位词</title>
      <link href="/posts/30250b0/"/>
      <url>/posts/30250b0/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS8=">LeetCode 242. Valid Anagram</span></p><p>给定两个字符串  <code>s</code>  和  <code>t</code>  ，编写一个函数来判断  <code>t</code>  是否是  <code>s</code>  的字母异位词。</p><p>注意：若  <code>s</code>  和  <code>t</code>  中每个字符出现的次数都相同，则称  <code>s</code>  和  <code>t</code>  互为字母异位词。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;rat&quot;, t = &quot;car&quot;输出：false</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code> ,  <code>t.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  和  <code>t</code>  仅包含小写字母</li></ul><p><strong>进阶</strong>：如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>字母异位词，等价于，两个字符串中字符出现的种类和次数均相等</p><p>利用数组  <code>cnt</code>  来实现一个简单的哈希表，将字符 a 到 z 映射为数组的下标 0 到 25 ，数组的元素值表示相应字符在字符串  <code>s</code>  和  <code>t</code>  里出现的次数的差值</p><p>若  <code>cnt</code>  所有元素值均为 0，字符串  <code>s</code>  和  <code>t</code>  是字母异位词</p><p>代码实现：</p><pre><code class="language-cpp">bool isAnagram(string s, string t) &#123;    vector&lt;int&gt; cnt(26, 0);     // 计算 s 和 t 各个字母出现次数的差值    for (auto c : s)        cnt[c - 'a']++;         // 记录字符串 s 中字符出现的次数    for (auto c : t)        cnt[c - 'a']--;         // 记录字符串 t 中字符出现次数的相反数    for (int i = 0; i &lt; 26; i++)        if (cnt[i] != 0)        // cnt 元素不为 0 ，则字符串 s 和 t 中的字符不同，不是字母异位词            return 0;    return 1;                   // 所有字符出现次数相同，是 s 和 t 是字母异位词&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，常量大小的辅助数组</p><blockquote><p>这一题使用数组来实现哈希法，是因为题目限制了只有 26 个小写字母，哈希值比较集中</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/posts/ee040603/"/>
      <url>/posts/ee040603/</url>
      
        <content type="html"><![CDATA[<p>图 由 顶点集 和 边集 组成，即，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 是顶点的集合，顶点代表数据元素</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 是连接顶点的边的集合，边代表元素间的关系</li></ul><p>根据边的方向性，可将图分为 有向图 和 无向图</p><ul><li>有向图：边有方向，边用  <code>&lt;&gt;</code>  表示，例如， <code>&lt;A, B&gt;</code>  表示从 A 出发到 B 的一条边</li><li>无向图：边无方向，用  <code>()</code>  表示，例如， <code>(A, B)</code>  表示顶点 A 和 B 之间有一条边</li></ul><p>另外，可以根据顶点之间的关系为边设置权重</p><ul><li>加权图：边被赋予一个权值  <code>W</code></li><li>加权有向图：边表示为  <code>&lt;A, B, W&gt;</code></li><li>加权无向图：边表示为  <code>(A, B, W)</code></li></ul><h2 id="图的操作"><a class="anchor" href="#图的操作">#</a> 图的操作</h2><p>基本操作：</p><ul><li>构造一个由若干个节点、0 条边组成的图</li><li>判断两个节点之间是否有边存在</li><li>在图中添加或删除一条边</li><li>返回图中的节点数或边数</li><li>按某种规则遍历图中的所有节点</li></ul><p>一些与应用密切关联的操作</p><ul><li>拓扑排序</li><li>关键路径</li><li>找最小生成树</li><li>找最短路径等</li></ul><h2 id="图的抽象类"><a class="anchor" href="#图的抽象类">#</a> 图的抽象类</h2><p>以加权有向图为例</p><pre><code class="language-cpp">template &lt;class TypeOfVer, class TypeOfEdge&gt; // 数据元素的类型 TypeOfVer ，边的权值的类型 TypeOfEdgeclass graph &#123;    public:        virtual void insert(TypeOfVer x, TypeOfVer y, TypeOfEdge w) = 0;        virtual void remove(TypeOfVer x, TypeOfVer y) = 0;        virtual bool exist(TypeOfVer x, TypeOfVer y) const = 0;        virtual ~graph() &#123;&#125;        int numOfVer() const &#123;return Vers;&#125;        int numOfEdge() const &#123;return Edges;&#125;    protected:        int Vers, Edges;&#125;;</code></pre><h2 id="图的术语"><a class="anchor" href="#图的术语">#</a> 图的术语</h2><p>度：图中连接于某一节点的边的总数</p><ul><li>入度：有向图中进入某一节点的边数</li><li>出度：有向图中离开某一节点的边数</li></ul><p>子图：设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G&#x27; = (V&#x27;, E&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊂</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">V&#x27; \subset V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊂</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">E&#x27; \subset E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> ，则称 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">G&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> 的子图</p><p>路径：顶点的序列</p><ul><li>简单路径：如果一条路径上的所有节点，除了起始节点和终止节点可能相同外，其余的节点都不相同</li><li>环：环是一条简单路径，其起始节点和终止节点相同，且路径长度至少为 1</li></ul><p>路径长度</p><ul><li>非加权的路径长度：组成路径的边数</li><li>加权路径长度：路径上所有边的权值之和</li></ul><p>连通性：两点之间存在路径</p><ul><li>无向图<ul><li>连通：顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 之间有路径存在</li><li>连通图：任意两点之间都连通的无向图，例如，左下图是一个连通图，右下图不是</li><li>连通分量：非连通图中的极大连通子图，例如，右下图的两个红圈就是连通分量</li></ul></li></ul><p><img data-src="/posts/ee040603/1.jpg" class="" title="左侧是连通图，右侧是非连通图"></p><ul><li>有向图<ul><li><p>强连通图：顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 之间有路径存在，例如，左下图是一个强连通图，右下图不是</p></li><li><p>强连通分量：非强连通图中的极大连通子图，例如，右下图的三个红圈就是连通分量</p></li><li><p>弱连通图：如有向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> 不是强连通的，但如果把它看成是无向图时是连通的，则它是一个弱连通图，例如右下图</p></li></ul></li></ul><p><img data-src="/posts/ee040603/2.jpg" class="" title="左侧是强连通图，右侧是弱连通图"></p><p>完全图</p><ul><li>无向完全图：任意两个节点之间都有边的无向图，例如左下图</li><li>有向完全图：任意两个节点之间都有弧的有向图，例如右下图</li></ul><p><img data-src="/posts/ee040603/3.jpg" class="" title="左侧是无向完全图，右侧是有向完全图"></p><p>生成树：连通图的极小连通子图，如下图中右侧两图就是左图的生成树</p><ul><li>包含图的所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 条边</li><li>在生成树中添加一条边之后，必定会形成回路或环</li></ul><p><img data-src="/posts/ee040603/4.jpg" class="" title="生成树"></p><p>最小生成树：加权无向图的所有生成树中 边的权值和最小的生成树 ，如下图中右图就是左图的最小生成树</p><p><img data-src="/posts/ee040603/5.jpg" class="" title="最小生成树"></p><h2 id="图的存储"><a class="anchor" href="#图的存储">#</a> 图的存储</h2><p>图的顶点集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 存储在一个数组或者链表中</p><p>边的集合的表示方式通常有两种</p><ul><li>邻接矩阵</li><li>邻接表</li></ul><h3 id="邻接矩阵"><a class="anchor" href="#邻接矩阵">#</a> 邻接矩阵</h3><p>边的集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 用一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的矩阵表示</p><p>对于有向图，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 存在有向边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A[i, j] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ；如果不存在有向边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A[i, j] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><ul><li>节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的出度：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行元素之和</li><li>节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 的入度：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 列元素之和</li></ul><p><img data-src="/posts/ee040603/6.jpg" class="" title="有向图的邻接矩阵"></p><p>对于无向图，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 存在一条边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A[i, j] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ；如果不存在一条边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A[i, j] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><ul><li>矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 是一个对称矩阵</li><li>节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的度：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行 或者 第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 列 元素之和</li></ul><p><img data-src="/posts/ee040603/7.jpg" class="" title="无向图的邻接矩阵"></p><p>对于加权图，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 有一条边并且权值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> ，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A[i, j] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ；如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 没有边，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[i, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 为空或其他标志（例如，定义为 正无穷 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+ \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span> ）</p><p><img data-src="/posts/ee040603/8.jpg" class="" title="加权图的邻接矩阵"></p><p>性能分析</p><ul><li><p>优点：基本操作都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间复杂度，不仅能找到出发的边，也能找到到达的边</p></li><li><p>缺点：即使边的数量远小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，也需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个单元的内存 （大多数的图的边数都远小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ）</p></li></ul><h3 id="邻接表"><a class="anchor" href="#邻接表">#</a> 邻接表</h3><p>邻接表是图的标准存储方式</p><p>顶点集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> ：用数组或单链表的形式存放所有的节点值，如果节点数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 固定，则采用数组形式，否则可采用单链表的形式</p><p>边集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> ：同一个节点出发的所有边组成一个单链表</p><ul><li>如果是加权图，单链表的每个节点中还要保存权值</li></ul><p><img data-src="/posts/ee040603/9.jpg" class="" title="邻接表"></p><p>优点：</p><ul><li>内存 = 节点数 + 边数</li><li>处理时间：节点数 + 边数，即，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert V \vert + \vert E \vert )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></li></ul><p>缺点：</p><ul><li>确定从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 是否有边，最坏需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度</li><li>有向图中寻找进入某节点的边，非常困难</li><li>无向图同一条边表示两次，边表空间浪费一倍</li></ul><h4 id="链式前向星"><a class="anchor" href="#链式前向星">#</a> 链式前向星</h4><p>邻接表通过一条链表来记录每个顶点的所有邻边，然而，这些邻边之间是没有逻辑关系的（前后关系）</p><p>前向星可以让每个顶点的所有邻边具有逻辑关系：如果知道某个顶点的第一条边，就可以知道这个顶点的所有邻边</p><pre><code class="language-cpp">// 建立边结构体struct Edge &#123;    int w;     // 边的权值    int to;    // 边的终点    int next;  // 同起点的下一条边的的编号&#125;;Edge edges[N]; // N 为边的条数（针对无向图中的边 u -- v，需添加两条相反的边）               // edges[i].to 表示第 i 条边的终点               // edges[i].next 表示与第 i 条边同起点的下一条边的编号               // edges[i].w 表示第 i 条边的权值vector&lt;int&gt; head(N, -1);  // head[i] 表示以 i 为起点的第一条边的编号                          // 也可以理解成：以 i 为起点的编号最大的边，因为前向星是使用的头插法，在最前面的就是最后插入的边int cnt = 0;void add(int u, int v, int w) &#123; // 添加一条起点为 u 、终点为 v 、权值为 w 的边    edges[cnt].w = w;    edges[cnt].to = v;    edges[cnt].next = head[u];    head[u] = cnt++;&#125;// 遍历（遍历是逆序的）for (int j = head[i]; j != -1; j = edge[j].next) &#123; // 输出节点 i 的所有邻居节点    cout &lt;&lt; edges[j].to &lt;&lt; endl;&#125;</code></pre><p>以下图为例</p><p><img data-src="https://img-blog.csdn.net/20131123160056593" alt="" /></p><p>依次输入边的起点和终点：</p><pre><code>1 22 33 41 34 11 54 5</code></pre><p>对应 edges 和 head 数组的变化如下：</p><pre><code>edge[0].to = 2;     edge[0].next = -1;      head[1] = 0;edge[1].to = 3;     edge[1].next = -1;      head[2] = 1;edge[2].to = 4;     edge[2],next = -1;      head[3] = 2;edge[3].to = 3;     edge[3].next = 0;       head[1] = 3;edge[4].to = 1;     edge[4].next = -1;      head[4] = 4;edge[5].to = 5;     edge[5].next = 3;       head[1] = 5;edge[6].to = 5;     edge[6].next = 4;       head[4] = 6;</code></pre><p>参考：<a href="https://blog.csdn.net/ACdreamers/article/details/16902023">深度理解链式前向星<br /></a></p><h3 id="其他方法"><a class="anchor" href="#其他方法">#</a> 其他方法</h3><ol><li>逆邻接表：将进入同一节点的边组织成一个单链表</li></ol><p><img data-src="/posts/ee040603/10.jpg" class="" title="逆邻接表"></p><ol start="2"><li>十字链表：既记录前驱又记录后继，而且每条边只存储一次</li></ol><p><img data-src="/posts/ee040603/11.jpg" class="" title="十字链表"></p><ol start="3"><li>邻接多重表：解决无向图中边存储两次的问题。每个边的链表节点中存储与这条边相关的两个顶点，以及分别依附于这两个顶点下一条的边</li></ol><p><img data-src="/posts/ee040603/12.jpg" class="" title="邻接多重表"></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYm95dWFpLmNvbS9sZWFybi9jb3Vyc2VzLzE1Mi9sZXNzb25zLzIzNzUvc3RlcHMvMD9mcm9tPXF6">青舟智学：图的定义与存储</span></p><h2 id="图的遍历"><a class="anchor" href="#图的遍历">#</a> 图的遍历</h2><h3 id="深度优先遍历"><a class="anchor" href="#深度优先遍历">#</a> 深度优先遍历</h3><h3 id="广度优先遍历"><a class="anchor" href="#广度优先遍历">#</a> 广度优先遍历</h3><h3 id="欧拉回路"><a class="anchor" href="#欧拉回路">#</a> 欧拉回路</h3>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/posts/850f2080/"/>
      <url>/posts/850f2080/</url>
      
        <content type="html"><![CDATA[<p>哈希表（Hash table ，也被称为散列表）是根据关键码而直接进行访问的数据结构</p><blockquote><p>一般把搜索的数据称为关键字（Key），和关键字对应的称为值（Value），将其称之为 &lt;Key, value&gt; 的键值对</p></blockquote><p>哈希表可以近似理解成数组，哈希表中的关键码就是数组的索引下标，通过下标可以直接访问数组的元素</p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合当中</strong></p><p>哈希表 <strong>以空间换时间</strong> ，因为需要额外的  <code>数组</code>  、 <code>set</code>  或  <code>map</code>  来存放数据，才能实现快速查找</p><h2 id="哈希函数"><a class="anchor" href="#哈希函数">#</a> 哈希函数</h2><p>哈希函数（hash function）将关键码映射为哈希表的索引</p><p>构造哈希函数的要求：</p><ul><li>定义域必须包含全部需要存储的关键码，而值域的范围则依赖于散列表的大小或地址范围。</li><li>函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生</li><li>函数应尽量简单，能够在较短的时间内计算出任一关键码对应的散列地址</li></ul><p>常用的哈希函数</p><ul><li>直接地址法<ul><li>直接将关键码值作为地址  <code>H(key) = key</code>  或 做一个简单的线性映射  <code>H(key) = a × key + b</code></li></ul></li><li>除留取余法<ul><li>最常用的一种哈希函数</li><li>保证函数值是一个合法的下标</li><li><code>H(key) = key MOD p</code>  ，其中  <code>p</code>  是数组的大小， <code>p</code>  最好为质数，这样可以使得函数值分布更均匀</li></ul></li><li>数字分析法<ul><li>适用于关键码值范围比较大的情况（并非每一位都有区分意义）</li><li>对所有关键码，分析每一位上的数字分布。取数字分布均匀的位作为地址的组成部分</li></ul></li><li>平方取中法<ul><li>适用于关键码中各位的分布都比较均匀，但关键码的值域比数组规模大（每一位都有区分意义）</li><li>将关键码平方后，取其结果的中间各位作为散列函数值</li><li>由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大</li><li>中间部分究竟要选取几位，依赖于哈希表的单元总数</li></ul></li><li>折叠法<ul><li>如果关键字相当长，以至于和哈希表的单元总数相比大得多时，可采用此法</li><li>选取一个长度后，将关键码按此长度分组相加</li></ul></li></ul><h2 id="哈希碰撞"><a class="anchor" href="#哈希碰撞">#</a> 哈希碰撞</h2><p>哈希碰撞是指：不同的关键码映射到同一个地址</p><ul><li>也称之为 冲突</li></ul><p>两类解决方案：</p><ol><li>闭散列表：利用当前散列表中的空余单元<ul><li>线性探测法：H<sub>i</sub> = (H<sub>i-1</sub> + 1) mod size<ul><li>H<sub>i-1</sub> 是最近计算到的探测点（ H<sub>0</sub> 是原始的散列位置），H<sub>i</sub> 是要计算的新的探测点</li></ul></li><li>二次探测法：H<sub>i</sub> = (H<sub>0</sub> + i<sup>2</sup>) mod size</li><li>再次散列法：H<sub>i</sub> = (H<sub>0</sub> + i * hash<sup>2</sup>(x)) mod size</li></ul></li><li>开散列表：将散列到同一地址的节点组织成一个单链表，存储散列表的数组中保存的是每个单链表的起始地址</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVWFuRHVlWmkzTXdsY0tZR01OUVBHZw==">CodeSheep：哈希表详解</span></p><p>理想情况下，哈希查找的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="常见的哈希结构"><a class="anchor" href="#常见的哈希结构">#</a> 常见的哈希结构</h2><p>三种哈希结构</p><ul><li>数组</li><li>set （集合）</li><li>map （映射）</li></ul><p>set 只存储  <code>key</code>  ，而 map 存储了  <code>&lt;key, value&gt;</code>  的键值对</p><h3 id="集合-set"><a class="anchor" href="#集合-set">#</a> 集合 set</h3><p>在 set 中，元素的  <code>key</code>  就是它的  <code>value</code></p><blockquote><p>键值对  <code>&lt;key, value&gt;</code>  ：用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量  <code>key</code>  和  <code>value</code>  ， <code>key</code>  代表键值， <code>value</code>  表示与  <code>key</code>  对应的信息</p></blockquote><p>在 set 中，不能修改元素的值，但是可以从容器中插入或删除</p><p>C++ 的 set 实现：</p><ul><li><code>std::set</code>  ：底层实现为红黑树， <code>key</code>  是有序的</li><li><code>std::multiset</code>  ：底层实现是红黑树， <code>key</code>  有序</li><li><code>std::unordered_set</code>  ：底层实现是哈希表， <code>key</code>  无序</li></ul><table><thead><tr><th style="text-align:center">set</th><th style="text-align:center">底层实现</th><th style="text-align:center"><code>key</code>  是否有序</th><th style="text-align:center"><code>key</code>  是否可以重复</th><th style="text-align:center">能否更改  <code>key</code></th><th style="text-align:center">查询效率</th><th style="text-align:center">增删效率</th></tr></thead><tbody><tr><td style="text-align:center"><code>std::set</code></td><td style="text-align:center">红黑树</td><td style="text-align:center">有序</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log {n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log {n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center"><code>std::multiset</code></td><td style="text-align:center">红黑树</td><td style="text-align:center">有序</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center"><code>std::unordered_set</code></td><td style="text-align:center">哈希表</td><td style="text-align:center">无序</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><blockquote><p><strong>红黑树</strong> 是一种平衡二叉搜索树，所以  <code>key</code>  是有序的，但  <code>key</code>  不可以修改，改动  <code>key</code>  会导致整棵树的错乱，所以只能删除和增加</p></blockquote><ol><li><p>若要使用集合来解决哈希问题，优先使用  <code>unordered_set</code>  ，因为它的查询和增删效率是最优的</p></li><li><p>如果需要集合是有序的，那就用  <code>set</code></p></li><li><p>如果不仅要求有序还要有重复数据，那么就用  <code>multiset</code></p></li></ol><p>虽然  <code>std::set</code>  、 <code>std::multiset</code>  的底层实现是红黑树，不是哈希表，但是  <code>std::set</code> 、 <code>std::multiset</code>  依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法（map 也是同样的道理）</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5MyU4OCVFNSVCOCU4QyVFOCVBMSVBOCVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MC5odG1sIyVFNSVCOCVCOCVFOCVBNyU4MSVFNyU5QSU4NCVFNCVCOCU4OSVFNyVBNyU4RCVFNSU5MyU4OCVFNSVCOCU4QyVFNyVCQiU5MyVFNiU5RSU4NA==">代码随想录：哈希表理论基础</span></p><h4 id="stdset"><a class="anchor" href="#stdset">#</a>  <code>std::set</code></h4><p>所有的元素都会被自动排序，不允许出现键值  <code>key</code>  重复</p><ul><li>总是按照其内部比较对象（类型比较）所指示的特定严格弱排序准则进行排序</li></ul><p>set 容器通过  <code>key</code>  访问单个元素的速度通常比 unordered_set 容器慢，但 set 容器允许根据顺序对子集进行直接迭代</p><p>头文件： <code>#include &lt;set&gt;</code></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zZXQvc2V0Lz9rdz1zZXQ=">cplusplus：std::set</span></p><h4 id="stdmultiset"><a class="anchor" href="#stdmultiset">#</a>  <code>std::multiset</code></h4><p>所有的元素都会被自动排序，允许键值重复</p><ul><li>multiset 底层存储的是  <code>&lt;value, value&gt;</code>  的键值对</li></ul><p>multiset 容器通过  <code>key</code>  访问单个元素的速度通常 unordered_multiset 容器慢，但当使用迭代器遍历时会得到一个有序序列</p><p>头文件： <code>#include &lt;set&gt;</code></p><p>multiset 的接口与 set 接口基本一致</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zZXQvbXVsdGlzZXQvP2t3PW11bHRpc2V0">cplusplus：std::multiset</span></p><h4 id="stdunordered_set"><a class="anchor" href="#stdunordered_set">#</a>  <code>std::unordered_set</code></h4><p>元素不会被自动排序，不允许出现键值重复</p><p>头文件： <code>#include &lt;unordered_set&gt;</code></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfc2V0L3Vub3JkZXJlZF9zZXQvP2t3PXVub3JkZXJlZF9zZXQ=">cplusplus：std::unordered_set</span></p><h3 id="映射-map"><a class="anchor" href="#映射-map">#</a> 映射 map</h3><p>map 容器按照特定的次序（按照  <code>key</code>  来比较）存储由键值  <code>key</code>  和值  <code>value</code>  组合而成的元素</p><p>在 map 中，键值  <code>key</code>  通常用于排序和标识元素，而值  <code>value</code>  中存储与此键值  <code>key</code>  关联的内容</p><ul><li>键值  <code>key</code>  和值  <code>value</code>  的类型可能不同，并且在 map 的内部， <code>key</code>  与  <code>value</code>  通过成员类型  <code>value_type</code>  绑定在一起</li></ul><p>在 map 中，不允许修改  <code>key</code>  ，但可以修改  <code>key</code>  对应的  <code>value</code></p><p>C++ 的 map 实现：</p><ul><li><code>std::map</code>  ：底层实现是红黑树， <code>key</code>  有序</li><li><code>std::multimap</code>  ：底层实现是红黑树， <code>key</code>  有序</li><li><code>std::unordered_map</code>  ：底层实现为哈希表， <code>key</code>  无序</li></ul><table><thead><tr><th style="text-align:center">map</th><th style="text-align:center">底层实现</th><th style="text-align:center"><code>key</code>  是否有序</th><th style="text-align:center"><code>key</code>  是否可以重复</th><th style="text-align:center">能否更改  <code>key</code></th><th style="text-align:center">查询效率</th><th style="text-align:center">增删效率</th></tr></thead><tbody><tr><td style="text-align:center"><code>std::map</code></td><td style="text-align:center">红黑树</td><td style="text-align:center">有序</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log {n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log {n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center"><code>std::multimap</code></td><td style="text-align:center">红黑树</td><td style="text-align:center">有序</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log {n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log {n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center"><code>std::unordered_map</code></td><td style="text-align:center">哈希表</td><td style="text-align:center">无序</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>另， <code>hash_set</code>  、 <code>hash_map</code>   和  <code>unordered_set</code>  、 <code>unordered_map</code>  功能一致，区别在于是否被引入标准库</p><ul><li><code>unordered_set</code>  和  <code>unordered_map</code>  被引入了  C++ 11 标准库</li><li><code>hash_set</code>  和  <code>hash_map</code>  并未被引入 C++ 11 标准库</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5MyU4OCVFNSVCOCU4QyVFOCVBMSVBOCVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MC5odG1sIyVFNSVCOCVCOCVFOCVBNyU4MSVFNyU5QSU4NCVFNCVCOCU4OSVFNyVBNyU4RCVFNSU5MyU4OCVFNSVCOCU4QyVFNyVCQiU5MyVFNiU5RSU4NA==">代码随想录：哈希表理论基础</span></p><h4 id="stdmap"><a class="anchor" href="#stdmap">#</a>  <code>std::map</code></h4><p>map 中的元素总是按照键值  <code>key</code>  进行自动排序， <code>key</code>  不可重复</p><p>map 通过键值访问单个元素的速度通常比 unordered_map 容器慢，但 map 允许根据顺序对元素进行直接迭代（即对 map 中的元素进行迭代时，可以得到一个有序的序列）</p><p>map 支持下标访问符，即， <code>map[key]</code>  可以找到与  <code>key</code>  对应的  <code>value</code></p><p>头文件： <code>#include &lt;map&gt;</code></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9tYXAvbWFwLw==">cplusplus：std::map</span></p><h4 id="stdmultimap"><a class="anchor" href="#stdmultimap">#</a>  <code>std::multimap</code></h4><p>元素会被自动排序，键值  <code>key</code>  可以重复</p><p>multimap 不支持下标访问符</p><p>multimap 的接口与 map 类似</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9tYXAvbXVsdGltYXAv">cplusplus：std::multimap</span></p><p>头文件： <code>#include &lt;map&gt;</code></p><h4 id="stdunordered_map"><a class="anchor" href="#stdunordered_map">#</a>  <code>std::unordered_map</code></h4><p>元素不被自动排序，键值  <code>key</code>  不可以重复</p><p>支持下标访问符</p><p>头文件： <code>#include &lt;unordered_map&gt;</code></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfbWFwL3Vub3JkZXJlZF9tYXAv">cplusplus：std::unordered_map</span></p><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>数组是简单的哈希表</p><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组会造成空间的极大浪费</li></ul><p>当哈希值分布较为集中时，可以直接采用数组实现哈希法，例如，<a href="https://jiankychen.github.io/posts/30250b0/">LeetCode 242. 有效的字母异位词</a>，<a href="https://jiankychen.github.io/posts/579713f1/">LeetCode 383. 赎金信</a></p><p>而当哈希值比较少、特别分散、跨度非常大的时候，则考虑用 set 实现哈希法，例如，<a href="https://jiankychen.github.io/posts/c10e195a/">LeetCode 349. 两个数组的交集</a>，<a href="https://jiankychen.github.io/posts/76ed881c/">LeetCode 202. 快乐数</a></p><p>与集合 set 中每个元素只能是一个  <code>key</code>  相比， <code>map</code>  还可以存放与  <code>key</code>  对应的  <code>value</code>  ，因此不仅可以用来保存元素值，还可以保存元素值的下标，例如，<a href="https://jiankychen.github.io/posts/3da9e18f/">LeetCode 1. 两数之和</a>，<a href="https://jiankychen.github.io/posts/40552b28/">LeetCode 454. 四数相加 II</a></p><p>虽然 map 可以适用所有哈希法的场景，但 map 要维护红黑树或者符号表，还要做哈希函数的运算，相比之下，在某些场景下采用 数组 或 set 会效率更高，因此，需要根据实际需要来选择 数组 或 set 或 map</p><p>另外，关于 set 和 map 的具体实现：</p><ol><li><p><code>std::set</code>  和  <code>std::multiset</code>  的底层实现是红黑树，而 <code>std::unordered_set</code>  的底层实现是哈希表</p></li><li><p><code>std::map</code>  和  <code>std::multimap</code>  的底层实现是红黑树，而 <code>std::unordered_map</code>  的底层实现是哈希表</p></li><li><p>基于红黑树实现的， <code>key</code>  是有序的，而基于哈希表的， <code>key</code>  是无序的</p></li><li><p>只有  <code>std::multiset</code>  和  <code>std::multimap</code>  允许  <code>key</code>  重复，其余的都不允许</p></li><li><p>在同样满足需求的情况下， <code>std::unordered_set</code>  是效率最高的 set ；类似的，在同样满足需求的情况下， <code>std::unordered_map</code>  是效率最高的 map</p></li></ol><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5MyU4OCVFNSVCOCU4QyVFOCVBMSVBOCVFNiU4MCVCQiVFNyVCQiU5My5odG1s">代码随想录：哈希表总结</span></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列</title>
      <link href="/posts/a21107fc/"/>
      <url>/posts/a21107fc/</url>
      
        <content type="html"><![CDATA[<p>队列是一个先进先出的线性表</p><p>优先级队列：结点之间的关系是由结点的优先级决定的，而不是由入队的先后次序决定。优先级高的先出队，优先级低的后出队</p><p>优先级队列可以基于线性结构实现</p><ul><li>按照 <strong>优先级</strong> 排序<ul><li>入队：按照优先级插入在合适的位置 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>出队：队头元素 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul></li><li>按照 <strong>到达时间</strong> 排序<ul><li>入队：插入到队尾 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>出队：寻找优先级最高的并删除 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p>优先级队列也可以基于 <strong>二叉堆</strong> 实现</p><ul><li><p>二叉堆指的是父子之间的大小满足一定约束的完全二叉树</p><ul><li>最小化堆：父结点的值小于等于儿子结点，也被称之为 小顶堆</li><li>最大化堆：父结点的值大于等于儿子结点，也被称之为 大顶堆</li></ul></li><li><p>出队：删除根结点 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span><span class="mclose">)</span></span></span></span></p></li><li><p>入队：在最后一层的第一个空位置上添加一个元素，但添加后要调整元素的位置，以保持堆的有序性 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span><span class="mclose">)</span></span></span></span></p></li></ul><blockquote><p>在优先队列运行的过程中，其本身结构一直为完全二叉树</p></blockquote><h2 id="stl中的优先级队列"><a class="anchor" href="#stl中的优先级队列">#</a> STL 中的优先级队列</h2><p>头文件： <code>&lt;queue&gt;</code></p><p>类模板： <code>priority_queue</code></p><p>优先级队列的声明为  <code>priority_queue&lt;type,container,function&gt;</code></p><ul><li><p>type: 数据类型</p></li><li><p>container: 实现优先队列的底层容器，要求必须是以数组形式实现的容器</p></li><li><p>function: 元素之间的比较方式</p></li></ul><p>其中，第一个参数不可以省略，后两个参数可以省略</p><p>常用的成员函数：</p><ul><li><code>empty()</code></li><li><code>size()</code></li><li><code>top()</code></li><li><code>pop()</code></li><li><code>push()</code></li></ul><p>参考：<span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9xdWV1ZS9wcmlvcml0eV9xdWV1ZS8=">std::priority_queue</span></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 142. 环形链表 II</title>
      <link href="/posts/fe4aea2/"/>
      <url>/posts/fe4aea2/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv">LeetCode 142. Linked List Cycle II</span></p><p>给定一个链表的头节点  <code>head</code>  ，返回链表开始入环的第一个节点。 如果链表无环，则返回  <code>null</code> 。</p><p>如果链表中有某个节点，可以通过连续跟踪  <code>next</code>  指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数  <code>pos</code>  来表示链表尾连接到链表中的位置（索引从 0 开始）。如果  <code>pos</code>  是 -1，则在该链表中没有环。注意： <code>pos</code>  不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/fe4aea2/1.png" class="" title="示例 1"></p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/fe4aea2/2.png" class="" title="示例 2"></p><pre><code>输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点</code></pre><p><strong>示例 3：</strong></p><p><img data-src="/posts/fe4aea2/3.png" class="" title="示例 3"></p><pre><code>输入：head = [1], pos = -1输出：返回 null解释：链表中没有环</code></pre><p></p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>pos</code>  为 -1 或者链表中的一个 有效索引</li></ul><p><strong>进阶</strong>：你是否可以使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 空间解决此题？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><h3 id="判断是否有环"><a class="anchor" href="#判断是否有环">#</a> 判断是否有环</h3><p>定义  <code>fast</code>  和  <code>slow</code>  指针，从头结点出发， <code>fast</code>  指针每次移动两个节点， <code>slow</code>  指针每次移动一个节点，如果  <code>fast</code>  和  <code>slow</code>  指针在途中相遇 ，说明这个链表有环</p><ul><li><p>若  <code>fast</code>  与  <code>slow</code>  相遇，则一定有环：因为  <code>fast</code>  超前  <code>slow</code>  ，相遇时二者一定都在环内</p></li><li><p>若链表有环，则  <code>fast</code>  与  <code>slow</code>  一定相遇：当  <code>slow</code>  步入到环内时，由于  <code>fast</code>  指针每次移动相对于  <code>slow</code>  指针而言都是移动一位，故而一定会相遇</p></li></ul><h3 id="确定环的入口"><a class="anchor" href="#确定环的入口">#</a> 确定环的入口</h3><blockquote><p><code>slow</code>  指针在第一次遍历链表环时，就一定会与  <code>fast</code>  指针相遇。具体证明过程见 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxNDIuJUU3JThFJUFGJUU1JUJEJUEyJUU5JTkzJUJFJUU4JUExJUE4SUkuaHRtbCMlRTYlODAlOUQlRTglQjclQUY=">环形链表：补充</span></p></blockquote><p>假设从 头结点 到 环形入口节点 的节点数为  <code>x</code>  ，从 环形入口节点 到  <code>fast</code>  指针与  <code>slow</code>  指针相遇节点 的节点数为 y ，从 相遇节点 再到 环形入口节点 的节点数为  <code>z</code></p><p><img data-src="/posts/fe4aea2/4.png" class=""></p><p>相遇时  <code>slow</code>  指针走过的节点数为  <code>x + y</code>  ， <code>fast</code>  指针走过的节点数为  <code>x + y + n (y + z)</code> ，其中  <code>n</code>  为  <code>fast</code>  指针在环内走过的圈数</p><p>由于  <code>fast</code>  指针一步两节点， <code>slow</code>  指针一步一节点，则  <code>fast</code>  走过节点数为  <code>slow</code>  指针走过节点数的  <code>2</code>  倍，即： <code>2 (x + y) = x + y + n (y + z)</code></p><p>故而，环形的入口节点  <code>x</code>  应满足 <strong> <code>x = (n - 1) (y + z) + z</code> </strong> ，注意  <code>n</code>  一定大于等于  <code>1</code>  （否则， <code>fast</code>  不可能与  <code>slow</code>  相遇）</p><p>这意味着，<strong>指针  <code>index1</code>  从头结点出发，与此同时，指针  <code>index2</code>  从相遇节点出发，两指针每次均只走一个节点，这两个指针相遇的节点就是环形入口的节点</strong></p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif" alt="" /></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxNDIuJUU3JThFJUFGJUU1JUJEJUEyJUU5JTkzJUJFJUU4JUExJUE4SUkuaHRtbCMlRTYlODAlOUQlRTglQjclQUY=">代码随想录：环形链表 II</span></p><h2 id="method-快慢指针"><a class="anchor" href="#method-快慢指针">#</a> Method: 快慢指针</h2><pre><code class="language-cpp">ListNode *detectCycle(ListNode *head) &#123;    ListNode *fast = head, *slow = head;    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; // fast 到达链表最后一个节点时，循环结束        // fast 指针每步走两节点，slow 指针每步走一节点        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow) &#123; // fast 与 slow 相遇            // index1 指针从 head 出发，index2 指针从 fast 与 slow 相遇点出发，找出 index1 与 index2 的相遇位置            ListNode *index1 = head, *index2 = fast;            while (index1 != index2) &#123;                index1 = index1-&gt;next;                index2 = index2-&gt;next;            &#125;            return index1;  // index1 与 index2 的相遇点即为环形入口        &#125;    &#125;    // fast 不与 slow 相遇，不存在环形    return NULL;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，指针  <code>slow</code>  与指针  <code>index1</code>  走过的长度均不超过链表节点数目 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，仅使用指针</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 160. 相交链表</title>
      <link href="/posts/fd7c45a8/"/>
      <url>/posts/fd7c45a8/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMv">LeetCode 160. Intersection of Two Linked Lists</span></p><p>给你两个单链表的头节点  <code>headA</code>  和  <code>headB</code>  ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回  <code>null</code>  。</p><p>图示两个链表在节点  <code>c1</code>  开始相交：</p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="" height="200px" /></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li><code>intersectVal</code>  - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li><li><code>listA</code>  - 第一个链表</li><li><code>listB</code>  - 第二个链表</li><li><code>skipA</code>  - 在  <code>listA</code>  中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code>  - 在  <code>listB</code>  中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点  <code>headA</code>  和  <code>headB</code>  传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="" height="200px" /></p><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="" height="200px" /></p><pre><code>输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt="" /></p><pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p><ul><li><code>listA</code>  中节点数目为  <code>m</code></li><li><code>listB</code>  中节点数目为  <code>n</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code> ,  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>skipA</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">&lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"> </span><span class="mord mathnormal">m</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>skipB</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">&lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"> </span><span class="mord mathnormal">n</span></span></span></span></li><li>如果  <code>listA</code>  和  <code>listB</code>  没有交点， <code>intersectVal</code>  为  <code>0</code></li><li>如果  <code>listA</code>  和  <code>listB</code>  有交点， <code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶</strong>：你能否设计一个时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 、仅用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 内存的解决方案？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>两链表的交点是指两链表对应 <strong>节点的指针相等</strong> （而不是数值相等），因此，需要找出两个链表相交节点的指针</p><p><strong>若两链表相交，则两链表的交点及以后节点均对应相等</strong></p><p>可将两链表 “尾端对齐” ，从较短链表的头节点开始检查，比较两链表对应节点是否相等</p><h2 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h2><p>算法流程：</p><ol><li><p>求出两个链表的长度  <code>m</code>  和  <code>n</code></p></li><li><p>定义指针  <code>curA</code>  指向长链表的头节点，指针  <code>curB</code>  指向短链表的头节点</p><p><img data-src="/posts/fd7c45a8/1.png" class=""></p></li><li><p>将指针  <code>curA</code>  移动到第  <code>m - n + 1</code>  个节点，使得两个指针后续可移动步数相同（类似于两链表尾端对齐）</p><p><img data-src="/posts/fd7c45a8/2.png" class=""></p></li><li><p>比较  <code>curA</code>  是否与  <code>curB</code>  相同</p><ul><li>若相同，则找到交点</li><li>若不相同，则同时将  <code>curA</code>  和  <code>curB</code>  向后移动，直到  <code>curA</code>  和  <code>curB</code>  到达链表末尾</li></ul></li><li><p>若未找到交点，返回空指针</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int getSize(ListNode *head) &#123; // 计算链表的长度    int num = 0;    ListNode *cur = head;    while (cur != nullptr) &#123;        num++;        cur = cur-&gt;next;    &#125;    return num;&#125;ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;    int m = getSize(headA);    int n = getSize(headB);    ListNode *curA = headA, *curB = headB;    if (m &lt; n) &#123;              // curA 指向长链，curB 指向短链        swap(m, n);        swap(curA, curB);    &#125;    for (int i = 0; i &lt; m - n; i++) // 令 curA 和 curB 的起点一致        curA = curA-&gt;next;    while (curA != nullptr) &#123; // 遍历 curA 和 curB ，看两者是否相等        if (curA == curB)            return curA;        curA = curA-&gt;next;        curB = curB-&gt;next;    &#125;    return NULL;    // curA 已经移动到尾后，此时仍未找到交点&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为两链表长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFOSU5RCVBMiVFOCVBRiU5NSVFOSVBMiU5ODAyLjA3LiVFOSU5MyVCRSVFOCVBMSVBOCVFNyU5QiVCOCVFNCVCQSVBNC5odG1sIyVFNiU4MCU5RCVFOCVCNyVBRg==">代码随想录：相交链表</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 24. 两两交换链表中的节点</title>
      <link href="/posts/f84c47a9/"/>
      <url>/posts/f84c47a9/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3dhcC1ub2Rlcy1pbi1wYWlycy8=">LeetCode 24. Swap Nodes in Pairs</span></p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/f84c47a9/Example1.jpg" class=""></p><pre><code>输入：head = [1,2,3,4]输出：[2,1,4,3]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = [1]输出：[1]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围  <code>[0, 100]</code>  内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h1 id="思路"><a class="anchor" href="#思路">#</a> 思路</h1><p><strong>一定要先画图模拟</strong></p><p>下面以交换  <code>cur</code>  与  <code>latter1</code>  为例，示意交换两个链表节点的过程：</p><ol><li>初始时：</li></ol><pre class="mermaid graph"><svg id="mermaid-1697907378999" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="55" style="max-width: 392.125px;" viewBox="0 0 392.125 55"><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-pre LE-cur" id="L-pre-cur" style="opacity: 1;"><path class="path" d="M52.140625,27.5L77.140625,27.5L102.140625,27.5" marker-end="url(#arrowhead17)" style="fill:none"></path><defs><marker id="arrowhead17" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-cur LE-latter1" id="L-cur-latter1" style="opacity: 1;"><path class="path" d="M145.8125,27.5L170.8125,27.5L195.8125,27.5" marker-end="url(#arrowhead18)" style="fill:none"></path><defs><marker id="arrowhead18" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-latter1 LE-latter2" id="L-latter1-latter2" style="opacity: 1;"><path class="path" d="M264.96875,27.5L289.96875,27.5L314.96875,27.5" marker-end="url(#arrowhead19)" style="fill:none"></path><defs><marker id="arrowhead19" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g></g><g class="nodes"><g class="node default" id="flowchart-pre-6" transform="translate(30.0703125,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-22.0703125" y="-19.5" width="44.140625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-12.0703125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">pre</tspan></text></g></g></g><g class="node default" id="flowchart-cur-7" transform="translate(123.9765625,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-21.8359375" y="-19.5" width="43.671875" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-11.8359375,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">cur</tspan></text></g></g></g><g class="node default" id="flowchart-latter1-9" transform="translate(230.390625,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter1</tspan></text></g></g></g><g class="node default" id="flowchart-latter2-11" transform="translate(349.546875,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter2</tspan></text></g></g></g></g></g></g></svg></pre><ol><li>令  <code>pre</code>  的  <code>next</code>  指针指向  <code>latter1</code></li></ol><pre class="mermaid graph"><svg id="mermaid-1697907381031" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="90" style="max-width: 392.125px;" viewBox="0 -7.75 392.125 90"><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-pre LE-cur" id="L-pre-cur" style="opacity: 1;"><path class="path" d="M52.140625,40.27697095435685L77.140625,54.75L102.140625,54.75" marker-end="url(#arrowhead20)" style="fill:none;stroke-width:2px;stroke-dasharray:3;"></path><defs><marker id="arrowhead20" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 0 0 L 0 0 z" style="fill: #333"></path></marker></defs></g><g class="edgePath LS-pre LE-latter1" id="L-pre-latter1" style="opacity: 1;"><path class="path" d="M52.140625,14.723029045643154L77.140625,0.25L123.9765625,0.25L170.8125,0.25L195.8125,11.68456595856281" marker-end="url(#arrowhead21)" style="fill:none"></path><defs><marker id="arrowhead21" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-cur LE-latter1" id="L-cur-latter1" style="opacity: 1;"><path class="path" d="M145.8125,54.75L170.8125,54.75L195.8125,43.315434041437186" marker-end="url(#arrowhead22)" style="fill:none"></path><defs><marker id="arrowhead22" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-latter1 LE-latter2" id="L-latter1-latter2" style="opacity: 1;"><path class="path" d="M264.96875,27.5L289.96875,27.5L314.96875,27.5" marker-end="url(#arrowhead23)" style="fill:none"></path><defs><marker id="arrowhead23" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g></g><g class="nodes"><g class="node default" id="flowchart-pre-8" transform="translate(30.0703125,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-22.0703125" y="-19.5" width="44.140625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-12.0703125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">pre</tspan></text></g></g></g><g class="node default" id="flowchart-cur-9" transform="translate(123.9765625,54.75)" style="opacity: 1;"><rect rx="0" ry="0" x="-21.8359375" y="-19.5" width="43.671875" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-11.8359375,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">cur</tspan></text></g></g></g><g class="node default" id="flowchart-latter1-11" transform="translate(230.390625,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter1</tspan></text></g></g></g><g class="node default" id="flowchart-latter2-15" transform="translate(349.546875,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter2</tspan></text></g></g></g></g></g></g></svg></pre><ol><li>保存指向  <code>latter2</code>  的指针  <code>temp</code> ，并且，令  <code>latter1</code>  的  <code>next</code>  指针指向  <code>cur</code></li></ol><pre class="mermaid graph"><svg id="mermaid-1697907382976" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="144" style="max-width: 298.453125px;" viewBox="0 0 298.453125 144"><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-pre LE-latter1" id="L-pre-latter1" style="opacity: 1;"><path class="path" d="M52.140625,62L77.140625,62L102.140625,62" marker-end="url(#arrowhead15)" style="fill:none"></path><defs><marker id="arrowhead15" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-cur LE-latter1" id="L-cur-latter1" style="opacity: 1;"><path class="path" d="M234.0390625,40.14457120377655L196.296875,62L171.296875,62" marker-end="url(#arrowhead16)" style="fill:none"></path><defs><marker id="arrowhead16" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-latter1 LE-cur" id="L-latter1-cur" style="opacity: 1;"><path class="path" d="M162.82601825842696,42.5L196.296875,17.5L234.0390625,23.834906897456072" marker-end="url(#arrowhead17)" style="fill:none"></path><defs><marker id="arrowhead17" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-latter1 LE-latter2" id="L-latter1-latter2" style="opacity: 1;"><path class="path" d="M158.03569380733944,81.5L196.296875,116.5L221.296875,116.5" marker-end="url(#arrowhead18)" style="fill:none;stroke-width:2px;stroke-dasharray:3;"></path><defs><marker id="arrowhead18" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 0 0 L 0 0 z" style="fill: #333"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g></g><g class="nodes"><g class="node default" id="flowchart-pre-8" transform="translate(30.0703125,62)" style="opacity: 1;"><rect rx="0" ry="0" x="-22.0703125" y="-19.5" width="44.140625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-12.0703125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">pre</tspan></text></g></g></g><g class="node default" id="flowchart-latter1-9" transform="translate(136.71875,62)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter1</tspan></text></g></g></g><g class="node default" id="flowchart-cur-10" transform="translate(255.875,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-21.8359375" y="-19.5" width="43.671875" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-11.8359375,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">cur</tspan></text></g></g></g><g class="node default" id="flowchart-latter2-15" transform="translate(255.875,116.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter2</tspan></text></g></g></g></g></g></g></svg></pre><ol start="4"><li>令  <code>cur</code>  的  <code>next</code>  指针指向  <code>latter2</code></li></ol><pre class="mermaid graph"><svg id="mermaid-1697907385067" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="55" style="max-width: 392.125px;" viewBox="0 0 392.125 55"><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-pre LE-latter1" id="L-pre-latter1" style="opacity: 1;"><path class="path" d="M52.140625,27.5L77.140625,27.5L102.140625,27.5" marker-end="url(#arrowhead19)" style="fill:none"></path><defs><marker id="arrowhead19" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-latter1 LE-cur" id="L-latter1-cur" style="opacity: 1;"><path class="path" d="M171.296875,21.696170993968003L196.296875,17.5L221.296875,22.837781484570474" marker-end="url(#arrowhead20)" style="fill:none"></path><defs><marker id="arrowhead20" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-cur LE-latter1" id="L-cur-latter1" style="opacity: 1;"><path class="path" d="M221.296875,32.16221851542952L196.296875,37.5L171.296875,33.303829006032" marker-end="url(#arrowhead21)" style="fill:none;stroke-width:2px;stroke-dasharray:3;"></path><defs><marker id="arrowhead21" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 0 0 L 0 0 z" style="fill: #333"></path></marker></defs></g><g class="edgePath LS-cur LE-latter2" id="L-cur-latter2" style="opacity: 1;"><path class="path" d="M264.96875,27.5L289.96875,27.5L314.96875,27.5" marker-end="url(#arrowhead22)" style="fill:none"></path><defs><marker id="arrowhead22" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g></g><g class="nodes"><g class="node default" id="flowchart-pre-8" transform="translate(30.0703125,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-22.0703125" y="-19.5" width="44.140625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-12.0703125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">pre</tspan></text></g></g></g><g class="node default" id="flowchart-latter1-9" transform="translate(136.71875,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter1</tspan></text></g></g></g><g class="node default" id="flowchart-cur-11" transform="translate(243.1328125,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-21.8359375" y="-19.5" width="43.671875" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-11.8359375,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">cur</tspan></text></g></g></g><g class="node default" id="flowchart-latter2-15" transform="translate(349.546875,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter2</tspan></text></g></g></g></g></g></g></svg></pre><ol start="5"><li>通过以上步骤，实现节点  <code>cur</code>  与节点  <code>latter1</code>  的交换，所得链表为：</li></ol><pre class="mermaid graph"><svg id="mermaid-1697907387137" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="55" style="max-width: 392.125px;" viewBox="0 0 392.125 55"><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-pre LE-latter1" id="L-pre-latter1" style="opacity: 1;"><path class="path" d="M52.140625,27.5L77.140625,27.5L102.140625,27.5" marker-end="url(#arrowhead17)" style="fill:none"></path><defs><marker id="arrowhead17" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-latter1 LE-cur" id="L-latter1-cur" style="opacity: 1;"><path class="path" d="M171.296875,27.5L196.296875,27.5L221.296875,27.5" marker-end="url(#arrowhead18)" style="fill:none"></path><defs><marker id="arrowhead18" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-cur LE-latter2" id="L-cur-latter2" style="opacity: 1;"><path class="path" d="M264.96875,27.5L289.96875,27.5L314.96875,27.5" marker-end="url(#arrowhead19)" style="fill:none"></path><defs><marker id="arrowhead19" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g></g><g class="nodes"><g class="node default" id="flowchart-pre-6" transform="translate(30.0703125,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-22.0703125" y="-19.5" width="44.140625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-12.0703125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">pre</tspan></text></g></g></g><g class="node default" id="flowchart-latter1-7" transform="translate(136.71875,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter1</tspan></text></g></g></g><g class="node default" id="flowchart-cur-9" transform="translate(243.1328125,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-21.8359375" y="-19.5" width="43.671875" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-11.8359375,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">cur</tspan></text></g></g></g><g class="node default" id="flowchart-latter2-11" transform="translate(349.546875,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-34.578125" y="-19.5" width="69.15625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-24.578125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">latter2</tspan></text></g></g></g></g></g></g></svg></pre><h1 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h1><p>维护  <code>pre</code>  指针和  <code>cur</code>  指针，依照上述步骤完成  <code>cur</code>  和  <code>cur</code>  下个节点  <code>cur-&gt;next</code>  的交换</p><p>遍历  <code>cur</code>  指针，直到  <code>cur</code>  为空 或  <code>cur-&gt;next</code>  为空</p><ul><li>若  <code>cur</code>  为空，则链表节点数为偶数，此前的两两交换刚好完成所有节点交换</li><li>若  <code>cur</code>  不为空但  <code>cur-&gt;next</code>  为空，则链表节点数为奇数，两两交换后还剩最后一个节点，此时无需再进行交换</li></ul><p>代码实现：</p><pre><code class="language-cpp">// 省略了结构体 ListNode 的定义ListNode* swapPairs(ListNode* head) &#123;    ListNode* dummyHead = new ListNode(); // 设置虚拟头节点，以便交换 head 节点及其下个节点    dummyHead-&gt;next = head;    ListNode* cur = head;                 // 当前遍历节点    ListNode* pre = dummyHead;            // 当前遍历节点 cur 的上个节点    while (cur != nullptr &amp;&amp; cur-&gt;next != nullptr) &#123; // 交换 cur 及其下个节点        // 拷贝指向 cur 下下个节点的指针（因为后续会修改 cur-&gt;next-&gt;next）        ListNode* temp = cur-&gt;next-&gt;next;        // 令 pre 的 next 指针指向 cur 的下个节点        pre-&gt;next = cur-&gt;next;        // 令 cur 下个节点的 next 指针指向 cur        cur-&gt;next-&gt;next = cur;        // 令 cur 的 next 指针指向 temp        cur-&gt;next = temp;        // pre 与 cur 同时向后移动        pre = cur;        cur = cur-&gt;next;    &#125;    return dummyHead-&gt;next;               // 返回 dummyHead-&gt;next&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 206. 反转链表</title>
      <link href="/posts/7c5d77fa/"/>
      <url>/posts/7c5d77fa/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">LeetCode 206. Reverse Linked List</span></p><p>给你单链表的头节点  <code>head</code>  ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/7c5d77fa/1.png" class=""></p><pre><code>输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/posts/7c5d77fa/2.png" class=""></p><pre><code>输入：head = [1,2]输出：[2,1]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = []输出：[]</code></pre><p></p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>5000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 5000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h2><p>要实现链表的反转，只需改变链表节点  <code>next</code>  指针的指向</p><p>算法流程：</p><ol><li>定义  <code>cur</code>  指向当前处理节点，初始指向头节点；定义  <code>pre</code>  指向  <code>cur</code>  的上一个节点，初始化为  <code>NULL</code></li><li>遍历  <code>cur</code> ，直到  <code>cur</code>  为空<ul><li>存储  <code>cur</code>  的下一个节点指针（因为接下来要改变  <code>cur-&gt;next</code>  ），记作  <code>tmp = cur-&gt;next</code></li><li>修改  <code>cur</code>  的  <code>next</code>  指针的指向，令其指向上一个节点  <code>pre</code>  ，即， <code>cur-&gt;next = pre</code>  ，实现反转</li><li><code>pre</code>  和  <code>cur</code>  同时向后移动：执行  <code>pre = cur</code>  ,  <code>cur = tmp</code></li></ul></li><li>遍历结束时， <code>pre</code>  指向的是原链表的最后一个节点，同时也是反转之后新链表的头节点，因此，返回  <code>pre</code>  即可</li></ol><p>代码实现：</p><pre><code class="language-cpp">ListNode* reverseList(ListNode* head) &#123;    ListNode* temp;    ListNode* pre = NULL;  // 前置节点    ListNode* cur = head;  // 当前处理节点    while(cur) &#123;        temp = cur-&gt;next;  // 保存 cur 的下一个节点        cur-&gt;next = pre;   // 反转        pre = cur;         // 更新 pre 指针        cur = temp;        // 更新 cur 指针    &#125;    return pre;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为链表长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-递归"><a class="anchor" href="#method-2-递归">#</a> Method 2: 递归</h1><p>可以利用递归算法实现上述双指针算法的逻辑，代码如下：</p><pre><code class="language-cpp">ListNode* reverse(ListNode* pre, ListNode* cur)&#123;    if(cur == NULL) return pre; // 递归终止条件，返回的是反转链表的头节点    ListNode* temp = cur-&gt;next;    cur-&gt;next = pre; // 修改 cur 的 next 指针，指向 pre    return reverse(cur,temp); // 递归，使 temp 的 next 指针指向 cur&#125;ListNode* reverseList(ListNode* head) &#123;    return reverse(NULL, head);&#125;</code></pre><p>上述算法实质上都是沿着链表的方向 <strong>从前往后</strong> 翻转指针指向</p><p>也可以 <strong>从后往前</strong> 翻转 next 指针的指向</p><p>代码实现：</p><pre><code class="language-cpp">ListNode* reverseList(ListNode* head) &#123; // 翻转 head-&gt;next 的 next 指针，使其指向 head    if (!head || !head-&gt;next) return head; // 递归终止条件    ListNode* newHead = reverseList(head-&gt;next); // 递归，使 head-&gt;next-&gt;next 的下一个节点变为 head-&gt;next    head-&gt;next-&gt;next = head; // 使 head-&gt;next 的下一个节点变为 head    head-&gt;next = nullptr; // 此时的 head 节点为反转链表的尾节点，next 指针应为空指针    return newHead;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为链表长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归调用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMDYuJUU3JUJGJUJCJUU4JUJEJUFDJUU5JTkzJUJFJUU4JUExJUE4Lmh0bWw=">代码随想录：翻转链表</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 707. 设计链表</title>
      <link href="/posts/f8927f54/"/>
      <url>/posts/f8927f54/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGVzaWduLWxpbmtlZC1saXN0Lw==">LeetCode 707. Design Linked List</span></p><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性： <code>val</code>  和  <code>next</code>  。 <code>val</code>  是当前节点的值， <code>next</code>  是指向下一个节点的指针 / 引用。</p><p>如果是双向链表，则还需要属性  <code>prev</code>  以指示链表中的上一个节点。假设链表中的所有节点下标从  <code>0</code>  开始。</p><p>实现  <code>MyLinkedList</code>  类：</p><ul><li><code>MyLinkedList()</code>  初始化  <code>MyLinkedList</code>  对象。</li><li><code>int get(int index)</code>  获取链表中下标为  <code>index</code>  的节点的值。如果下标无效，则返回  <code>-1</code>  。</li><li><code>void addAtHead(int val)</code>  将一个值为  <code>val</code>  的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code>  将一个值为  <code>val</code>  的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code>  将一个值为  <code>val</code>  的节点插入到链表中下标为  <code>index</code>  的节点之前。如果  <code>index</code>  等于链表的长度，那么该节点会被追加到链表的末尾。如果  <code>index</code>  比长度更大，该节点将 不会插入 到链表中。</li><li><code>void deleteAtIndex(int index)</code>  如果下标有效，则删除链表中下标为  <code>index</code>  的节点。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]输出：[null, null, null, null, 2, null, 3]解释：MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1);              // 返回 2myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3myLinkedList.get(1);              // 返回 3</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>index</code> ,  <code>val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li>请不要使用内置的 LinkedList 库</li><li>调用  <code>get</code>  、 <code>addAtHead</code>  、 <code>addAtTail</code>  、 <code>addAtIndex</code>  和  <code>deleteAtIndex</code>  的次数不超过 2000</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>旨在设计链表的五个接口，以实现链表的常见操作：</p><ul><li>获取链表第  <code>index</code>  个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第  <code>index</code>  个节点前面插入一个节点</li><li>删除链表的第  <code>index</code>  个节点</li></ul><p>链表操作的两种方式：</p><ul><li>直接使用原来的链表来进行操作</li><li>设置一个虚拟头结点再进行操作</li></ul><h2 id="method-单链表"><a class="anchor" href="#method-单链表">#</a> Method: 单链表</h2><p>接下来以设计单链表的五个接口为例，采用设置虚拟头节点的方式执行相关操作</p><pre><code class="language-cpp">// 定义链表的结构体struct LinkedNode &#123;    int val;    LinkedNode *next;    LinkedNode() : val(0), next(nullptr) &#123;&#125;    LinkedNode(int x) : val(x), next(nullptr) &#123;&#125;&#125;;class MyLinkedList &#123;    LinkedNode* dummyHead = new LinkedNode();    int size;public:    // 初始化链表    MyLinkedList() &#123;        dummyHead = new LinkedNode(0);    // 虚拟头节点        size = 0;    &#125;        // 获取链表第 index 个节点的值    int get(int index) &#123;        if (index &lt; 0 || index &gt; (size - 1))            return -1;        LinkedNode* cur = dummyHead-&gt;next;        while (index) &#123; // 循环结束时 cur 指向第 index 个节点            cur = cur-&gt;next;            index--;        &#125;        return cur-&gt;val;    &#125;        // 在链表的第一个元素之前插入值为 val 的节点，注意要更新链表长度    void addAtHead(int val) &#123;        LinkedNode* newHead = new LinkedNode(val);        newHead-&gt;next = dummyHead-&gt;next;        dummyHead-&gt;next = newHead;        size++;    &#125;        // 在链表的末尾添加值为 val 的节点，注意要更新链表长度    void addAtTail(int val) &#123;        LinkedNode* cur = dummyHead;        while (cur-&gt;next != nullptr)            cur = cur-&gt;next;        LinkedNode* newTail = new LinkedNode(val);        cur-&gt;next = newTail;        size++;    &#125;        // 在链表中的第 index 个节点之前添加值为 val 的节点，注意要更新链表长度    void addAtIndex(int index, int val) &#123;        if (index &gt; size)            return;        LinkedNode* cur = dummyHead;        while (index) &#123; // 循环结束时 cur 指向第 index - 1 个节点            cur = cur-&gt;next;            index--;        &#125;        LinkedNode* newNode = new LinkedNode(val);        newNode-&gt;next = cur-&gt;next;        cur-&gt;next = newNode;        size++;    &#125;    // 删除第 index 个节点，注意要更新链表长度    void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;= size) &#123;            return;        &#125;        LinkedNode* cur = dummyHead;        while(index) &#123; // 循环结束时 cur 指向第 index - 1 个节点            cur = cur-&gt;next;            index--;        &#125;        LinkedNode* tmp = cur-&gt;next;        cur-&gt;next = cur-&gt;next-&gt;next;        delete tmp;        size--;    &#125;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */</code></pre><h2 id="method-双链表"><a class="anchor" href="#method-双链表">#</a> Method: 双链表</h2>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 203. 移除链表元素</title>
      <link href="/posts/c5f901bc/"/>
      <url>/posts/c5f901bc/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWxpbmtlZC1saXN0LWVsZW1lbnRzLw==">LeetCode 203. Remove Linked List Elements</span></p><p>给你一个链表的头节点  <code>head</code>  和一个整数  <code>val</code>  ，请你删除链表中所有满足  <code>Node.val == val</code>  的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/c5f901bc/1.png" class=""></p><pre><code>输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = [], val = 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = [7,7,7,7], val = 7输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>用  <code>cur</code>  表示当前节点：如果  <code>cur</code>  的下一个节点不为空 且 下一个节点的值等于给定的  <code>val</code>  ，即， <code>cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val == val</code>  ，则需要移除  <code>cur</code>  的下一个节点，即： <code>cur-&gt;next = cur-&gt;next-&gt;next</code></p><p><img data-src="/posts/c5f901bc/2.png" class=""></p><p>但如果要移除的节点是头节点（它没有上个节点）怎么办？</p><ul><li>Method 1：直接将头节点向后移动</li><li>Method 2：在头节点前添加一个虚拟节点，使得原链表的所有节点均可按照常规的方式进行移除</li></ul><h2 id="method-1-直接使用原链表来进行删除操作"><a class="anchor" href="#method-1-直接使用原链表来进行删除操作">#</a> Method 1: 直接使用原链表来进行删除操作</h2><ol><li><p>若要移除头节点，只需将头节点向后移动一位</p><p><img data-src="/posts/c5f901bc/3.png" class=""></p></li><li><p>考虑到新的头节点也可能是值为  <code>val</code>  ，需要用循环来对头节点进行处理，直到头节点值不为  <code>val</code></p></li><li><p>对头节点以后的其他节点进行遍历，若需移除则按常规方式处理即可</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">struct ListNode &#123;    int val;    ListNode *next;    ListNode() : val(0), next(nullptr) &#123;&#125;    ListNode(int x) : val(x), next(nullptr) &#123;&#125;    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;;ListNode* removeElements(ListNode* head, int val) &#123;    // 删除值为 val 的头节点    while (head != nullptr &amp;&amp; head-&gt;val == val) &#123;        ListNode* tmp = head;        head = head-&gt;next;        delete tmp;    &#125;    // 删除值为 val 的非头节点    ListNode* cur = head;   // 遍历 cur 节点    while(cur != nullptr &amp;&amp; cur-&gt;next != nullptr) &#123; // cur 非空且 cur 的下一个节点非空        if (cur-&gt;next-&gt;val == val) &#123;    // 当 cur 的下一个节点的值为 val 时，删除 cur 的下一个节点            ListNode* tmp = cur-&gt;next;            cur-&gt;next = cur-&gt;next-&gt;next;            delete tmp;        &#125;        else            cur = cur-&gt;next;  // cur 向后移动    &#125;    // 返回新的头节点    return head;&#125;</code></pre><blockquote><p>注意要从内存中删除移除的节点，清理节点内存</p></blockquote><h2 id="method-2-设置虚拟头节点再进行删除操作"><a class="anchor" href="#method-2-设置虚拟头节点再进行删除操作">#</a> Method 2: 设置虚拟头节点再进行删除操作</h2><p>设置一个虚拟头结点，原链表的所有节点便都可按照统一的方式进行移除</p><p>例如，给链表添加一个虚拟头结点为新的头结点，若要移除这个旧的头结点元素 1 时，只需将虚拟头节点的  <code>next</code>  指向旧的头节点的下一个节点，然后从内存中删除旧的头节点即可：<br /><img data-src="/posts/c5f901bc/4.png" class=""></p><p>注意，在  <code>return</code>  头节点 时， <code>return</code>  的应该是虚拟头节点的下一个节点，即， <code>return dummyHead-&gt;next;</code></p><p>最后也需要将添加的虚拟头节点  <code>dummyHead</code>  从内存中删掉</p><p>代码实现：</p><pre><code class="language-cpp">struct ListNode &#123;    int val;    ListNode *next;    ListNode() : val(0), next(nullptr) &#123;&#125;    ListNode(int x) : val(x), next(nullptr) &#123;&#125;    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;;ListNode* removeElements(ListNode* head, int val) &#123;    // 设置虚拟头节点    ListNode* dummyHead = new ListNode(0);  // 创建虚拟头节点    dummyHead-&gt;next = head;                 // 令虚拟头节点指向 head    // 移除操作    ListNode* cur = dummyHead;    while (cur-&gt;next != nullptr) &#123;        if (cur-&gt;next-&gt;val == val) &#123;            ListNode* tmp = cur-&gt;next;            cur-&gt;next = cur-&gt;next-&gt;next;            delete tmp;        &#125;        else            cur = cur-&gt;next;    &#125;    // 返回虚拟头节点的下个节点，并删除虚拟头节点    head = dummyHead-&gt;next;    delete dummyHead;    return head;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 59. 螺旋矩阵 II</title>
      <link href="/posts/6b429da4/"/>
      <url>/posts/6b429da4/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3BpcmFsLW1hdHJpeC1paS8=">LeetCode 59. Spiral Matrix II</span></p><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/6b429da4/1.jpg" class="" title="示例 1"></p><pre><code>输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1输出：[[1]]</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-模拟"><a class="anchor" href="#method-模拟">#</a> Method: 模拟</h2><p>思路：<strong>模拟</strong> 顺时针画矩阵的过程，即</p><ul><li><p>填充上行从左到右</p></li><li><p>填充右列从上到下</p></li><li><p>填充下行从右到左</p></li><li><p>填充左列从下到上</p></li></ul><p>由外向内一圈一圈这么画下去</p><p>注意：每画一条边都要坚持一致的 <strong>左闭右开</strong> ，或者 <strong>左开又闭</strong> 的原则，这样这一圈才能按照统一的规则画下来</p><blockquote><p>坚持 <strong>循环不变量</strong> 原则</p></blockquote><p>下图以左闭右开原则为例：每一种颜色，代表一条边，注意每一个拐角处的处理规则，拐角处让给新的一条边来继续画（即，每条边都遵循左闭右开原则）</p><p><img data-src="/posts/6b429da4/2.png" class=""></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;    vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0));    int num = 1;                        // 填充的数字    for (int i = 0; i &lt; n / 2; ++i) &#123;   // 每次循环填充一圈        int start = i;                  // 填充的起点        int len = n - i * 2 - 1;        // 每个方向的填充长度        for (int j = 0; j &lt; len; ++j) &#123; // 上面一行，从左往右填充            matrix[start][start + j] = num++;        &#125;        for (int j = 0; j &lt; len; ++j) &#123; // 右边一列，从上往下填充            matrix[start + j][start + len] = num++;        &#125;        for (int j = len; j &gt;= 1; --j) &#123; // 下面一行，从右往左填充            matrix[start + len][start + j] = num++;        &#125;        for (int j = len; j &gt;= 1; --j) &#123; // 左边一列，从下往上填充            matrix[start + j][start] = num++;        &#125;    &#125;    if (n % 2) matrix[n / 2][n / 2] = n * n; // n 为奇数，数组最中间的位置需要单独处理    return matrix;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，需要填充 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个元素</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNTkuJUU4JTlFJUJBJUU2JTk3JThCJUU3JTlGJUE5JUU5JTk4JUI1SUkuaHRtbCMlRTYlODAlOUQlRTglQjclQUY=">代码随想录：螺旋矩阵 II</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 209. 长度最小的子数组</title>
      <link href="/posts/cfd138c6/"/>
      <url>/posts/cfd138c6/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1zaXplLXN1YmFycmF5LXN1bS8=">LeetCode 209. Minimum Size Subarray Sum</span></p><p>给定一个含有  <code>n</code>  个正整数的数组和一个正整数  <code>target</code>  。</p><p>找出该数组中满足其和 <strong>大于或等于  <code>target</code> </strong> 的长度最小的 <strong>连续子数组</strong>  <code>[nums_&#123;l&#125;, nums_&#123;l+1&#125;, ..., nums_&#123;r-1&#125;, nums_&#123;r&#125;]</code>  ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：target = 4, nums = [1,4,4]输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p>进阶： 如果你已经实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 时间复杂度的解法，请尝试设计一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度的解法。</p><h2 id="method-1-暴力法"><a class="anchor" href="#method-1-暴力法">#</a> Method 1: 暴力法</h2><p>思路：</p><ol><li><p>对每个下标  <code>i</code>  ，找出 以  <code>i</code>  为起点、元素和大于等于  <code>target</code>  的子数组的最小长度</p></li><li><p>从所有的  <code>i</code>  中，找到长度最小值</p></li></ol><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-前缀和-二分查找"><a class="anchor" href="#method-2-前缀和-二分查找">#</a> Method 2: 前缀和 + 二分查找</h2><p>思路：</p><ol><li><p>计算数组  <code>nums</code>  的前缀和，存入新数组  <code>sum</code>  ，其中， <code>sum[i]</code>  表示  <code>nums[0]</code>  到  <code>nums[i - 1]</code>  的元素和</p></li><li><p>初始化所求长度为  <code>ans = INT32_MAX</code></p></li><li><p>对每个下标  <code>i</code></p><ul><li>利用二分查找算法，找出  <code>sum</code>  数组中大于或等于  <code>sum[i - 1] + target</code>  的最小下标  <code>bound</code></li><li>更新满足条件的子数组的最小长度为  <code>ans = min(ans, bound - (i - 1))</code></li></ul></li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1zaXplLXN1YmFycmF5LXN1bS9zb2x1dGlvbi9jaGFuZy1kdS16dWkteGlhby1kZS16aS1zaHUtenUtYnktbGVldGNvZGUtc29sdXRpby8=">长度最小的子数组：前缀和 + 二分查找</span></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中，遍历  <code>i</code>  的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，对每个  <code>i</code>  进行二分查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，额外创建了一个前缀和数组</p><h2 id="method-3-滑动窗口"><a class="anchor" href="#method-3-滑动窗口">#</a> Method 3: 滑动窗口</h2><p>解题思路：</p><ol><li><p>定义指针  <code>left</code>  和  <code>right</code>  分别表示滑动窗口的左端点和右端点，初始化为  <code>0</code></p></li><li><p>初始化所求长度为  <code>res = INT32_MAX</code></p></li><li><p>迭代，窗口右端点  <code>right</code>  向右移动，直到  <code>right == nums.size()</code></p><ul><li>更新窗口内所有元素之和  <code>sum += nums[right]</code></li><li>如果  <code>sum &gt;= target</code>  ，左端点  <code>left</code>  不断向右移（收缩窗口），直到  <code>sum &lt; target</code>  。在此过程中，须不断更新  <code>sum</code>  和窗口长度  <code>sublength</code>  ，并记录满足条件的最小长度  <code>res = (res &lt; sublength) ? res : sublength</code></li></ul></li><li><p>判断  <code>res</code>  是否为初值  <code>INT32_MAX</code>  ：若是，则返回  <code>0</code>  （不存在满足条件的子数组）；否则，返回  <code>res</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; // 滑动窗口法    int res = INT32_MAX;    // 所求的最小长度    int sum = 0;            // 窗口所有元素值之和    int sublength = 0;      // 窗口长度    int left = 0;           // 窗口左端    for (int right = 0; right &lt; nums.size(); right++) &#123; // 遍历窗口右端        sum += nums[right];        while (sum &gt;= target) &#123; // 窗口左端点向右移动，直到窗口所有元素值之和小于 target            sublength = right - left + 1;   // 更新窗口长度            res = res &lt; sublength ? res : sublength;    // 更新满足条件的最小长度            sum -= nums[left++];            // 窗口左端向右移动        &#125;    &#125;    return res == INT32_MAX ? 0 : res;      // 若不存在满足条件的子数组，返回 0&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，指针  <code>left</code>  和  <code>right</code>  最多各移动 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/posts/a80d0031/"/>
      <url>/posts/a80d0031/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a class="anchor" href="#动态规划">#</a> 动态规划</h1><p>动态规划（Dynamic Programming，DP），一种解决某种最优化问题的方法</p><p>动态规划的基本思想：把原问题分解为相对简单的子问题</p><ul><li>将原问题分成若干 <strong>阶段</strong> ，每个阶段对应若干个子问题，提取这些子问题的特征（<strong>状态</strong>）</li><li>寻找各状态间的相互转移方式（<strong>状态转移方程</strong>）</li><li>按顺序求解每一个阶段的问题</li></ul><blockquote><p>动态规划中每一个状态一定是由上一个状态推导出来的</p><p>贪心算法没有状态推导，而是从局部直接选最优的</p></blockquote><p>用动态规划解决问题的三个条件（了解即可）：最优子结构、无后效性、子问题重叠</p><ul><li>最优子结构：原问题的最优解，必然是通过子问题的最优解得到的（最优子结构保证了我们能够通过选取子问题的最优解最终拼成原问题的解）</li><li>无后效性：前面状态的决策不会限制到后面的决策 （旅行商问题就是有后效性的场景，因为每个城市只能访问一次）</li><li>重复子问题：一个子问题可以被重复利用到多个父亲状态中</li></ul><p>动态规划解题思路：</p><ol><li>明确 <strong>状态</strong> ：确定 dp 数组以及下标的含义</li><li>确定 <strong>状态转移方程</strong> ：用于描述不同状态之间的关系</li><li>dp 数组如何 <strong>初始化</strong> ：即，初始状态</li><li>确定 <strong>转移方向</strong> ：转移方向描述的是推导出不同状态的解的先后关系</li><li>举例推导 dp 数组</li></ol><blockquote><p>动规不仅仅只有状态转移方程，也需要弄清楚 dp 数组应该如何初始化，以及正确的转移方向</p><p>初始状态描述的是整个转移方程推导的开始，是不需要经由别的状态就知道结果的状态</p><p>之所以要明确转移方向，是因为我们不希望 &quot; 已知 B 状态只能由 A 状态推导过来，但是当我们想推导 B 时，发现 A 状态的结果我们还不知道” 类似事情发生</p></blockquote><p>解动规题的一个很不好的习惯：不清楚 dp 数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改</p><p><strong>做动规的题目，写代码之前一定要把状态转移在 dp 数组上的具体情况模拟一遍，确定最后推出的是想要的结果，然后再写代码</strong></p><p>写动规题目，代码出问题很正常，<strong>找问题的最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的</strong></p><ul><li>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了</li><li>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题</li></ul><p>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU4QSVBOCVFNiU4MCU4MSVFOCVBNyU4NCVFNSU4OCU5MiVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MC5odG1sIyVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRiVFNSU4QSVBOCVFNiU4MCU4MSVFOCVBNyU4NCVFNSU4OCU5Mg==">代码随想录：动态规划理论基础</span></p><h2 id="数字金字塔"><a class="anchor" href="#数字金字塔">#</a> 数字金字塔</h2><p>给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 层的金字塔，求一条从最高点到底层任意点的路径，使得路径上数字之和最大。其中，每一步可以从当前点走到其左下方的点，也可以走到其右下方的点</p><p><img data-src="/posts/a80d0031/%E9%87%91%E5%AD%97%E5%A1%94.jpg" class=""></p><p>比如，在上面的样例中，从 7 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 8 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 7 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 5 的路径经过数字的和最大</p><h3 id="二维数组解法"><a class="anchor" href="#二维数组解法">#</a> 二维数组解法</h3><p>基本思想：分别求出到达每个点的最大路径，然后在所有点里面取最大值即可</p><p>动态规划解题思路：</p><ol><li><p><strong>状态</strong> 设计：用  <code>a[i][j]</code>  存储数字金字塔第  <code>i</code>  行第  <code>j</code>  列的数字，用 <strong> <code>dp[i][j]</code> </strong> 表示 <strong>从顶点到达第  <code>i</code>  行第  <code>j</code>  列的最大数字和</strong>， <code>i</code>  和  <code>j</code>  均从  <code>0</code>  开始</p></li><li><p><strong>状态转移方程</strong> ：到达  <code>(i, j)</code>  的路径只可能从  <code>(i - 1, j - 1)</code>  或者  <code>(i - 1, j)</code>  走过来（如果在三角形的最左边或者最右边，那么它的上一个节点就只有一种情况），从中选择能使数字和最大的</p><pre><code> dp[i][j] = dp[i - 1][j] + a[i][j]；    // i &gt;= 1, j = 0 dp[i][j] = dp[i - 1][j - 1] + a[i][j]；// i &gt;= 1, j = i dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + a[i][j]；// i &gt;= 1, 0 &lt; j &lt; i</code></pre></li><li><p><strong>初始化</strong>  <code>dp</code>  数组： <code>dp[0][0] = a[0][0]</code></p><ul><li>根据状态转移方程可知， <code>dp[i][j]</code>  由  <code>dp[i - 1][j - 1]</code>  和  <code>dp[i - 1][j]</code>  推出，只要初始化顶点的状态，令  <code>dp[0][0] = a[0][0]</code>  即可</li></ul></li><li><p>确定 <strong>转移方向</strong> ：按照  <code>i</code>  从小到大， <code>j</code>  从小到大的顺序推导</p><ul><li>根据状态转移方程知， <code>i</code>  层节点的状态依赖于  <code>i - 1</code>  层节点的状态，所以  <code>i</code>  从小到大遍历</li><li><code>j</code>  按照 从小到大的顺序 或者 从大到小的顺序 均可</li></ul></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>最后，找出底层节点状态的最大值即可</p><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int Tower(vector&lt;vector&lt;int&gt;&gt; &amp;a) &#123; // 动态规划求解数字金字塔问题    int n = a.size();   // 金字塔的层数    if (n == 0) return -1;    // 定义及初始化 dp 数组    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt; (n, 0)); // 定义 dp 数组    dp[0][0] = a[0][0]; // 初始状态    // 根据状态转移方程进行遍历    for (int i = 1; i &lt; n; i++) &#123;        dp[i][0] = dp[i - 1][0] + a[i][0];        for (int j = 1; j &lt; i; j++) &#123;            dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + a[i][j];        &#125;        dp[i][i] = dp[i - 1][i - 1] + a[i][i]; // 因为 dp[i - 1][i] = 0    &#125;    // // 打印 dp 数组    // cout &lt;&lt; &quot;The dp result is : &quot; &lt;&lt; endl;    // for (int i = 0; i &lt; n; i++) &#123;    //     for (int j = 0; j &lt;= i; j++)    //         cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;    //     cout &lt;&lt; endl;    // &#125;    // 找最大值    int ans = 0;    for (int i = 0; i &lt; n; i++)        ans = max(ans, dp[n - 1][i]);    return ans;&#125;int main() &#123;    // 输入    int n = 0;    cin &gt;&gt; n;    vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt; (n, 0));    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt;= i; j++)            cin &gt;&gt; a[i][j];    // 输出数字金字塔问题的结果    cout &lt;&lt; Tower(a) &lt;&lt; endl;    return 0;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm95dWFpLmNvbS9sZWFybi9jb3Vyc2VzLzE0OS9sZXNzb25zLzI2MzMvc3RlcHMvMD9mcm9tPXF6">青舟智学：动态规划</span></p><p>事实上，我们可以采用 <strong>滚动数组</strong> 优化上述动态规划算法，从而降低空间复杂度</p><h3 id="滚动数组解法"><a class="anchor" href="#滚动数组解法">#</a> 滚动数组解法</h3><p><strong>滚动数组</strong> 的基本思想：在 dp 数组中，用新的数据不断覆盖旧的数据，从而降低 dp 数组的维度</p><p>类似于 “踩石头过河” ：如果只有两块石头，可以一边走一边挪动石头，这样就可以顺利过河</p><p><img data-src="/posts/a80d0031/%E8%B8%A9%E7%9F%B3%E5%A4%B4%E8%BF%87%E6%B2%B3.jpg" class="" title="踩石头过河"></p><p>在数字金字塔问题中，第  <code>i</code>  层状态仅仅依赖于第  <code>i - 1</code>  层状态，因此可以用一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2 \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的二维数组  <code>dp</code>  来记录状态</p><ul><li>通过计算  <code>i &amp; 1</code>  来判断  <code>i</code>  的奇偶性</li><li>奇数行的节点状态填入  <code>dp[1]</code></li><li>偶数行的节点状态填入  <code>dp[0]</code></li></ul><p>代码实现：</p><pre><code class="language-cpp">int Tower(vector&lt;vector&lt;int&gt;&gt; a) &#123; // 滚动数组优化    int n = a.size();    if (n &lt;= 0)        return -1;    // 定义及初始化 dp 数组    vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt; (n, 0));    dp[0][0] = a[0][0]; // 初始状态    // // 打印 dp 数组    // cout &lt;&lt; &quot; The dp result is : &quot; &lt;&lt; endl;    // cout &lt;&lt; dp[0][0] &lt;&lt; endl;    // 根据状态转移方程进行遍历    for (int i = 1; i &lt; n; i++) &#123;        dp[i &amp; 1][0] = dp[(i - 1) &amp; 1][0] + a[i][0]; // // i &amp; 1 是为了取 i 的奇偶性        for (int j = 1; j &lt; i; j++) &#123;            dp[i &amp; 1][j] = max(dp[(i - 1) &amp; 1][j - 1], dp[(i - 1) &amp; 1][j]) + a[i][j];        &#125;        dp[i &amp; 1][i] = dp[(i - 1) &amp; 1][i - 1] + a[i][i];        // // 打印 dp 数组        // for (int j = 0; j &lt;= i; j++)        //     cout &lt;&lt; dp[i &amp; 1][j] &lt;&lt; &quot; &quot;;        // cout &lt;&lt; endl;    &#125;    // 找最大值    int ans = 0;    for (int i = 0; i &lt; n; i++)        ans = max(ans, dp[(n - 1) &amp; 1][i]);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="一维数组解法"><a class="anchor" href="#一维数组解法">#</a> 一维数组解法</h3><p>进一步，可以发现  <code>(i, j)</code>  的状态仅依赖于  <code>(i - 1, j - 1)</code>  和  <code>(i - 1, j)</code>  的状态，所以，我们可以仅用一个大小为  <code>n</code>  的一维数组  <code>dp</code>  来记录状态，并按照 <strong>从右到左</strong> 的顺序更新数组即可</p><ul><li><p>状态设计：在计算  <code>(i, j)</code>  节点的状态前， <code>dp[j]</code>  表示从顶点到  <code>(i - 1, j)</code>  节点的最大数字和；按状态转移方程更新后， <code>dp[j]</code>  表示从顶点到  <code>(i, j)</code>  节点的最大数字和</p></li><li><p>状态转移方程：</p><pre><code> dp[j] = dp[j - 1] + a[i][j]; // j = i dp[j] = max(dp[j - 1], dp[j]) + a[i][j]; // 0 &lt; j &lt; i dp[j] = dp[j] + a[i][j];     // j = 0</code></pre></li><li><p>初始化  <code>dp</code>  数组：所有元素均初始化为  <code>0</code></p></li><li><p>转移方向： <code>i</code>  从小到大， <code>j</code>  从大到小</p></li></ul><p>以  <code>i = 3</code>  为例：</p><p height="200px"><img data-src="/posts/a80d0031/%E4%BC%98%E5%8C%96%E5%88%B0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84.png" class=""></p><p>代码实现：</p><pre><code class="language-cpp">int Tower(vector&lt;vector&lt;int&gt;&gt; a) &#123; // 动规：一维 dp 数组解法    int n = a.size();    if (n &lt;= 0)        return -1;    // 定义及初始化 dp 数组    vector&lt;int&gt; dp(n, 0);   // 长度为 n ，所有元素值为 0   dp[0] = a[0][0];    // // 打印 dp 数组    // cout &lt;&lt; &quot; The dp result is : &quot; &lt;&lt; endl;    // cout &lt;&lt; dp[0] &lt;&lt; endl;    // 根据状态转移方程进行遍历    for (int i = 1; i &lt; n; i++) &#123; // i 从小到大        dp[i] = dp[i - 1] + a[i][i];        for (int j = i - 1; j &gt;= 1; j--) // j 从大到小            dp[j] = max(dp[j - 1], dp[j]) + a[i][j];        dp[0] = dp[0] + a[i][0];        // // 打印 dp 数组        // for (int j = 0; j &lt;= i; j++)        //     cout &lt;&lt; dp[j] &lt;&lt; &quot; &quot;;        // cout &lt;&lt; endl;    &#125;    // 找最大值    int ans = 0;    for (int j = 0; j &lt; n; j++)        ans = max(ans, dp[j]);    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="0-1-背包"><a class="anchor" href="#0-1-背包">#</a> 0-1 背包</h1><p>0-1 背包问题：给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 件物品和一个容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个物品的体积为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">v[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，价值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 。每件物品只能用一次。如何选择装入背包的物品，使得获得的总价值最大？</p><p>考虑到每一件物品只有两个状态，选或者不选，以第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个物品为例</p><ul><li>不选取第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个物品，原问题变成 “从余下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 件物品中选择，放入容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包”</li><li>选取第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个物品，原问题变成 “从余下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 件物品中选择，放入容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>−</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V - v[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的背包”</li></ul><p>原问题的解可以由子问题的最优解拼接得到，故而可以采用动态规划算法求解</p><h2 id="二维数组解法-2"><a class="anchor" href="#二维数组解法-2">#</a> 二维数组解法</h2><p>解题思路：</p><ol><li><p><strong>状态</strong> 设计：定义一个二维数组  <code>dp</code>  ， <code>dp[i][j]</code>  表示：<strong>在前  <code>i</code>  个物品中选择物品，放进容量为  <code>j</code>  的背包内，其最大价值为  <code>dp[i][j]</code> </strong> ，其中， <code>i</code>  和  <code>j</code>  均从  <code>0</code>  开始索引</p></li><li><p>确定 <strong>状态转移方程</strong> ： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + p[i])</code></p><ul><li>若不放物品  <code>i</code>  ：选择前  <code>i - 1</code>  件物品时的可用容量为  <code>j</code> ，其最大价值为  <code>dp[i - 1][j]</code>  ，所以  <code>dp[i][j] = dp[i - 1][j]</code></li><li>若放物品  <code>i</code>  ：选择前  <code>i - 1</code>  件物品时的可用容量为  <code>j - v[i]</code>  ，其最大价值为  <code>dp[i - 1][j - 1]</code>  ，所以，总价值为  <code>dp[i][j] = dp[i - 1][j - v[i]] + p[i]</code></li><li>综合两种情况，从中选择总价值更大的，即， <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + p[i])</code></li></ul></li><li><p><strong>初始化</strong>  <code>dp</code>  数组：</p><ul><li>若背包容量  <code>j</code>  为  <code>0</code>  ，则背包总价值一定为  <code>0</code>  ，即  <code>dp[i][0] = 0</code></li><li>根据状态转移方程知， <code>i</code>  由  <code>i - 1</code>  推导出，故而需要初始化  <code>i = 0</code>  的情况，即，初始化所有的  <code>dp[0][j]</code>  ：若  <code>j &lt; v[0]</code>  ，编号为  <code>0</code>  的物品的体积超出背包可用容量，总价值为  <code>0</code>  ，即， <code>dp[0][j] = 0</code>  ；若  <code>j &gt;= v[0]</code>  ，编号为  <code>0</code>  的物品可以放进背包，此时背包最大价值一定为  <code>p[0]</code>  ，即，  <code>dp[0][j] = p[0]</code></li></ul><pre><code class="language-cpp">// 定义及初始化 dp 数组vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(V + 1, 0)); // 所有元素均初始化为 0for (int j = v[0]; j &lt;= V; j++) &#123;   // 处理 j &gt;= v[0] 时的 dp[0][j]    dp[0][j] = p[0];&#125;</code></pre></li><li><p>确定 <strong>遍历顺序</strong> ：有两个遍历的维度，物品 和 背包容量 。那么，外层的遍历是遍历 物品 还是 背包容量 呢？在本例中，外层遍历 物品 或 背包容量 均可</p><ul><li>根据状态转移方程， <code>dp[i][j]</code>  由  <code>dp[i-1][j]</code>  和  <code>dp[i - 1][j - weight[i]]</code>  推导出来，而这两者都在  <code>dp[i][j]</code>  的左上角方向（包括正上方向），所以外层遍历  <code>i</code>  或者  <code>j</code>  都不影响  <code>dp[i][j]</code>  的递推</li></ul><pre><code class="language-cpp">// 外层遍历 物品for (int i = 1; i &lt; n; i++) &#123;      // 遍历物品（物品 0 已经在初始化 dp 数组时处理过）    for (int j = 0; j &lt;= V; j++) &#123; // 遍历背包容量        if (j &lt; v[i])              // 容量不足以放下物品 i            dp[i][j] = d[i - 1][j];        else            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + p[i]);    &#125;&#125;// 外层遍历 背包容量for (int j = 0; j &lt;= V; j++) &#123;    // 遍历背包容量    for (int i = 1; i &lt; n; i++) &#123; // 遍历物品        if (j &lt; v[i])            dp[i][j] = dp[i - 1][j];        else            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + p[i]);    &#125;&#125;</code></pre></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>最后所求结果为  <code>dp[n - 1][V]</code></p><blockquote><p><code>dp</code>  数组的初始化，一定要和  <code>dp</code>  数组的定义吻合</p><p><strong>理清背包问题的遍历顺序，关键在于根据状态转移方程确定递推方向</strong></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int Package(int n, int V, vector&lt;int&gt; v, vector&lt;int&gt; p)&#123;  // 二维数组解法    // 定义 dp 数组及其初始化    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(V + 1, 0));    for (int j = v[0]; j &lt;= V; j++) &#123;        dp[0][j] = p[0];    &#125;    // 动态规划的遍历    for (int i = 1; i &lt; n; i++) &#123;        for (int j = 0; j &lt;= V; j++) &#123;            if (j &lt; v[i])                dp[i][j] = dp[i - 1][j];            else                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + p[i]);        &#125;    &#125;    return dp[n - 1][V];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为物品数量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 为背包最大容量</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFOCU4MyU4QyVFNSU4QyU4NSVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MDAxJUU4JTgzJThDJUU1JThDJTg1LTEuaHRtbA==">代码随想录：0-1 背包的二维数组解法</span></p><p>类似地，可以采用 <strong>滚动数组</strong> 对该动态规划算法进行优化</p><h2 id="滚动数组解法-2"><a class="anchor" href="#滚动数组解法-2">#</a> 滚动数组解法</h2><p>类似于此前的数字金字塔问题，这里不再赘述</p><h2 id="一维数组解法-2"><a class="anchor" href="#一维数组解法-2">#</a> 一维数组解法</h2><p>将 dp 数组定义为一维数组，降低空间复杂度</p><p>解题思路：</p><ol><li><p>定义一维数组  <code>dp</code>  ： <code>dp[j]</code>  表示 容量为  <code>j</code>  的背包的最大价值， <code>0 &lt;= j &lt;= V</code></p></li><li><p>递推公式：当  <code>j &gt;= nums[i]</code>  时， <code>dp[j] = max(dp[j], dp[j - v[i]] + p[i])</code></p><ul><li>若  <code>j &lt; nums[i]</code>  ， <code>i</code>  不可被选取，故而  <code>dp[j]</code>  维持不变</li><li>若  <code>j &gt;= nums[i]</code>  ，有以下两种情况<ul><li>不选物品  <code>i</code>  ： <code>dp[j]</code>  维持不变，等价于二维数组解法中的  <code>dp[i][j] = dp[i - 1][j]</code></li><li>选物品  <code>i</code>  ：更新  <code>dp[j] = dp[j - v[i]] + p[i]</code> ，等价于二维数组解法中的  <code>dp[i][j] = dp[i - 1][j - v[i]] + p[i]</code></li><li>综合两种情况，从中选择总价值更大的，即， <code>dp[j] = max(dp[j], dp[j - v[i]] + p[i])</code></li></ul></li></ul></li><li><p>初始化  <code>dp</code>  数组：所有元素均初始化为  <code>0</code></p></li><li><p>一维  <code>dp</code>  数组遍历顺序：</p><ul><li><strong>外层遍历 物品 ，内层遍历 背包容量</strong> （不可交换）</li><li><strong>物品</strong> 按 <strong>从小到大</strong> 的顺序遍历，<strong>背包容量</strong> 按 <strong>从大到小</strong> 的顺序遍历</li></ul></li><li><p>举例推导  <code>dp</code>  数组</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int Package(int n, int V, vector&lt;int&gt; v, vector&lt;int&gt; p)&#123; // 一维数组解法    // 定义 dp 数组及其初始化    vector&lt;int&gt; dp(V + 1, 0);    // 遍历    for (int i = 1; i &lt; n; i++) // 遍历物品        for (int j = V; j &gt;= v[i]; j--) // 遍历背包容量（ j 逆序遍历至 v[i] 即可，因为 j &lt; v[i] 时，dp[j] 不会更新）            dp[j] = max(dp[j], dp[j - v[i]] + p[i]);    // 返回结果    return dp[V];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为物品数量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 为背包最大容量</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p><p>当遍历顺序为 “外层遍历背包容量  <code>j</code>  ，内层遍历物品  <code>i</code> ” 时：</p><ul><li>若按从大到小顺序遍历  <code>j</code>  ：由  <code>dp[j] = max(dp[j], dp[j - v[i]] + p[i])</code>  知，每个  <code>dp[j]</code>  对应的背包只会放置一个物品。因为在更新  <code>dp[j]</code>  时，对任意物品  <code>i</code> ，状态  <code>d[j - v[i]]</code>  始终为  <code>0</code>  （自初始化之后  <code>d[j - v[i]]</code>  尚未被更新过），所以只会选择（在容量允许范围内）价值最大的一件物品</li><li>若按从小到大顺序遍历  <code>j</code>  ：由  <code>dp[j] = max(dp[j], dp[j - v[i]] + p[i])</code>  知，物品会被多次放入背包。例如，令  <code>v[] = &#123;1, 2, 3&#125;</code>  ， <code>p[] = &#123;15, 20, 30&#125;</code>  ，则：更新  <code>dp[1]</code>  时，会将物品  <code>0</code>  放入背包；更新  <code>dp[2]</code>  时，执行  <code>dp[2] = max(dp[2], dp[2 - v[0]] + p[0])</code>  时会再次将物品  <code>0</code>  放入背包，即，物品  <code>0</code>  被多次加入背包</li></ul><p>当遍历顺序为 “外层遍历物品  <code>i</code> ，内层遍历背包容量  <code>j</code> ”，但如果按照 从小到大顺序 遍历  <code>j</code>  ：物品同样会被多次放入背包</p><p>上述结论是通过 &quot; 模拟  <code>dp</code>  数组更新过程 &quot; 得出的，究其本质，都是由状态转移方程所决定的</p><p>因此，<strong>在用一维  <code>dp</code>  数组解 0-1 背包问题时，需要注意其遍历顺序与二维数组解法具有很大差异</strong>。所以最好是先根据实际数据，<strong>模拟一遍  <code>dp</code>  数组的更新</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFOCU4MyU4QyVFNSU4QyU4NSVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MDAxJUU4JTgzJThDJUU1JThDJTg1LTIuaHRtbCMlRTQlQjglODAlRTclQkIlQjRkcCVFNiU5NSVCMCVFNyVCQiU4NC0lRTYlQkIlOUElRTUlOEElQTglRTYlOTUlQjAlRTclQkIlODQ=">代码随想录：0-1 背包的一维数组解法</span></p><h1 id="完全背包"><a class="anchor" href="#完全背包">#</a> 完全背包</h1><p>完全背包问题：有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 件物品和一个最多能背重量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包，其中，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 件物品的重量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">v[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，得到的价值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 。每件物品都有无限个（也就是可以放入背包多次）。如何选择装入背包的物品，使得获得的总价值最大？</p><p>完全背包与 0-1 背包的不同点：</p><ul><li>完全背包问题中的每种物品都有无限个（也就是可以重复放入背包）</li><li>0-1 背包问题中的每种物品只有一个（也就是只能放入一次）</li></ul><p>对于一维 dp 数组而言，为实现物品的重复放入，<strong>背包容量应按从小到大的顺序遍历</strong></p><pre><code class="language-cpp">for(int i = 0; i &lt; n; i++) &#123;         // 遍历物品    for(int j = v[i]; j &lt;= V; j++) &#123; // 遍历背包容量        dp[j] = max(dp[j], dp[j - v[i]] + p[i]);    &#125;&#125;</code></pre><p>在 <strong>纯完全背包问题</strong> 中，若定义的是一维 dp 数组，遍历顺序可以是外层遍历物品、内层遍历背包容量，也可以是外层遍历背包容量、内层遍历物品</p><p>但如果题目稍稍有点变化，就可能会有特定的遍历顺序</p><ul><li>如果求的是组合数，外层 for 遍历物品，内层 for 遍历背包</li><li>如果求的是排列数，外层 for 遍历背包，内层 for 遍历物品</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFOCU4MyU4QyVFNSU4QyU4NSVFOSU5NyVBRSVFOSVBMiU5OCVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MCVFNSVBRSU4QyVFNSU4NSVBOCVFOCU4MyU4QyVFNSU4QyU4NS5odG1sIyVFNSVBRSU4QyVFNSU4NSVBOCVFOCU4MyU4QyVFNSU4QyU4NQ==">代码随想录：完全背包</span></p><h1 id="多重背包"><a class="anchor" href="#多重背包">#</a> 多重背包</h1><p>多重背包问题：有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 种物品和一个容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包，其中，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 种物品最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">m[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 件可用，每件耗费的空间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">v[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，价值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 。如何选择装入背包的物品，使得获得的总价值最大？</p><h2 id="解法一"><a class="anchor" href="#解法一">#</a> 解法一</h2><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 种物品有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">m[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 件，可以将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">m[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 件摊开，即</p><pre><code class="language-cpp">for (int i = 0; i &lt; n; i++) &#123;    while (m[i] &gt; 1) &#123; // m[i] 保留到1，把其他物品都展开        v.push_back(v[i]);        p.push_back(p[i]);        m[i]--;    &#125;&#125;</code></pre><p>由此，多重背包问题就转换成了 0-1 背包问题，后续按 0-1 背包求解即可</p><h2 id="解法二"><a class="anchor" href="#解法二">#</a> 解法二</h2><p>可以直接在 0-1 背包问题的遍历中，添加一层循环，对每种物品的选取件数进行遍历，即</p><pre><code class="language-cpp">for (int i = 1; i &lt; n; i++) // 遍历物品    for (int j = V; j &gt;= v[i]; j--) // 遍历背包容量        for (int k = 1; k &lt;= m[i] &amp;&amp; k * v[i] &lt;= j; k++) // 遍历选取物品 i 的件数            dp[j] = max(dp[j], dp[j - k * v[i]] + k * p[i]);</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFOCU4MyU4QyVFNSU4QyU4NSVFOSU5NyVBRSVFOSVBMiU5OCVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MCVFNSVBNCU5QSVFOSU4NyU4RCVFOCU4MyU4QyVFNSU4QyU4NS5odG1s">代码随想录：多重背包</span></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递推与递归</title>
      <link href="/posts/afade57b/"/>
      <url>/posts/afade57b/</url>
      
        <content type="html"><![CDATA[<h2 id="递推"><a class="anchor" href="#递推">#</a> 递推</h2><p>递推的基本思想：根据已有信息推出未知信息</p><p>递推解题思路：</p><ol><li>数学建模</li><li>找出递推式与初始条件</li></ol><h3 id="青蛙跳台阶"><a class="anchor" href="#青蛙跳台阶">#</a> 青蛙跳台阶</h3><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcWluZy13YS10aWFvLXRhaS1qaWUtd2VuLXRpLWxjb2Yv">剑指 Offer 10- II. 青蛙跳台阶问题</span></p><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个  <code>n</code>  级的台阶总共有多少种跳法。结果须对  <code>1000000007</code>  取模</p><p>递推解题思路：</p><ol><li><p>假设  <code>f[n]</code>  表示 青蛙从第一个石头跳到第  <code>n</code>  个石头一共有  <code>f[n]</code>  种方案</p></li><li><p>递推式： <code>f[n] = f[n - 1] + f[n - 2]</code></p><ul><li>从  <code>n - 1</code>  台阶，一次跳 1 级到  <code>n</code></li><li>从  <code>n - 2</code>  台阶，一次跳 2 级到  <code>n</code></li></ul></li><li><p>初始条件： <code>f[0] = 1</code>  ,  <code>f[1] = 1</code>  ,  <code>f[2] = 2</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">// 青蛙跳台阶问题int numWays(int n) &#123;    if (n &lt;= 1)        return 1;    const int MOD = 1000000007;    vector&lt;int&gt; f(n + 1, 0);    f[0] = f[1] = 1;    for (int i = 2; i &lt;= n; i++)        f[i] = (f[i - 1] + f[i - 2]) % MOD; // 取模 1e9+7    return f[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>另，本题本质上等价于 <strong>斐波那契数列</strong> 问题，唯一差异在于起始数字不同</p><ul><li>青蛙跳台阶问题： <code>f(0) = 1</code>  ,  <code>f(1) = 1</code>  ,  <code>f(2) = 2</code></li><li>斐波那契数列问题： <code>f(0) = 0</code>  ,  <code>f(1) = 1</code>  ,  <code>f(2) = 1</code></li></ul><h3 id="卡特兰数"><a class="anchor" href="#卡特兰数">#</a> 卡特兰数</h3><p>由  <code>n</code>  对括号组成的括号序列，有多少种是合法的括号序列？其中，合法的括号序列是指：任何一个左括号都必须有与之对应的右括号，任何一个右括号都必须有与之对应的左括号。答案对  <code>998244353</code>  取模</p><p>递推解题思路：</p><ol><li><p><code>f[n]</code>  表示  <code>n</code>  对括号能够组成  <code>f[n]</code>  种合法的括号序列</p></li><li><p f(k)="" \times="" f(n="" -="" k="" -="" 1)="">递推式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">f(n) = \sum\limits_{k = 0}^{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.503226em;vertical-align:-1.002113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5011130000000001em;"><span style="top:-2.097887em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.000005em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.002113em;"><span></span></span></span></span></span></span></span></span></p><ul><li>括号序列可以表示为  <code>A(B)</code>  ，其中， <code>A</code>  和  <code>B</code>  都是合法括号序列（  <code>A</code>  和  <code>B</code>  可以是空序列）</li><li><code>f(k)</code>  表示包含  <code>k</code>  对括号的合法序列  <code>A</code>  的种类数</li><li><code>f(n - k - 1)</code>  表示包含  <code>n - k - 1</code>  对括号的合法序列  <code>B</code>  的种类数</li></ul></li><li><p>初始条件： <code>f[0] = 1</code></p><ul><li><code>0</code>  对括号能组成一种括号序列（空序列）</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">// 计算卡特兰数int CatalanNumber(int n) &#123;    if (n &lt;= 0)        return 1;    const int MOD = 998244353;    vector&lt;int&gt; f(n + 1, 0);    f[0] = 1; // 初始条件    for (int i = 1; i &lt;= n; i++) &#123; // 求f[i]的值        for (int k = 0; k &lt; i; k++) &#123;            f[i] += int((long long) f[k] * f[i - k - 1] % MOD); // 递推式            // 注意，两个 int 相乘的结果可能爆 int ，因此乘法的过程要转换成 long long 以避免整数溢出            f[i] %= MOD; // 取模        &#125;    &#125;    return f[n];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="错位排列"><a class="anchor" href="#错位排列">#</a> 错位排列</h3><p>有  <code>n</code>  个信封和  <code>n</code>  个信件，第  <code>i</code>  个信件属于第  <code>i</code>  个信封，我们想知道，有多少种不同的方法，使得没有任何一个信件被装入正确的信封中？答案对  <code>998244353</code>  取模</p><p>解题思路：</p><ol><li><p>令  <code>f[i]</code>  表示信件和信封数量为  <code>i</code>  时的总方案数</p></li><li><p>递推式： <code>f[n] = (n - 1) * (f[n - 1] + f[n - 2])</code></p><ul><li>考虑 1 号信件，它不能被装入 1 号信封，不妨假设它被装入了 x 号信封，那么 x 号信件可以装入哪个信封呢？</li><li>第一种情况：x 号信件装入了 1 号信封。此时可以去掉 1 号和 x 号，原问题简化成： <code>n - 2</code>  个信件和信封的错位排列问题，一共有  <code>f[n - 2]</code>  种方案</li><li>第二种情况：x 号信件没有装入 1 号信封。即，x 号信件应与 1 号信封错位，此时原问题等价于一个大小为  <code>n - 1</code>  的错位排列问题，一共有  <code>f[n - 1]</code>  种方案</li><li>并且，x 的选择有  <code>n - 1</code>  种（除了 1 号都可以）</li></ul></li><li><p>初始条件： <code>f[1] = 0</code>  ,  <code>f[2] = 1</code></p><ul><li>只有 1 个信件和信封时，无法错位排列</li><li>有 2 个信件和信封时，只有一种排列方案</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">int SolutionNumber(int n) &#123;    if (n == 0)        return -1;    vector&lt;int&gt; f(n + 1, 0);    const int MOD = 998244353;    f[1] = 0;           // 初始条件    f[2] = 1;    for (int i = 3; i &lt;= n; i++) &#123;        f[i] = ((long long) (i - 1) * (f[i - 1] + f[i - 2])) % MOD;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="杨辉三角二维递推"><a class="anchor" href="#杨辉三角二维递推">#</a> 杨辉三角（二维递推）</h3><p>给定  <code>k</code>  ，你需要输出一个  <code>(k + 1) * (k + 1)</code>  的矩阵，其中，第  <code>i</code>  行第  <code>j</code>  列元素表示：从  <code>i</code>  个不同的物品中选出  <code>j</code>  个的方案数（行和列的标号从 0 开始）。所有答案对  <code>998244353</code>  取模</p><p>比如，当 k = 4 时，输出如下矩阵：</p><pre><code>1 0 0 0 01 1 0 0 01 2 1 0 01 3 3 1 01 4 6 4 1</code></pre><p>解题思路：</p><ol><li><p>二维数组的元素  <code>f[i][j]</code>  表示从  <code>i</code>  个物品中选  <code>j</code>  个的方案数</p></li><li><p>递推式： <code>f[i][j] = f[i - 1][j - 1] + f[i - 1][j]</code></p><ul><li>考虑 1 号物品：选，或者不选</li><li>选 1 号物品：那么接下来还需要从剩下的  <code>i - 1</code>  个物品中选出  <code>j - 1</code>  个，方案数为  <code>f[i - 1][j - 1]</code></li><li>不选 1 号物品：那么需要从  <code>i - 1</code>  个物品中选出  <code>j</code>  个，方案数为  <code>f[i - 1][j]</code></li></ul></li><li><p>边界条件： <code>f[i][0] = f[i][i] = 1</code></p><ul><li>所有  <code>j = 0</code>  的位置和  <code>j = i</code>  的位置都是  <code>1</code>  ， 分别对应 所有物品都不选 和 所有物品都选取</li><li>所有  <code>j &gt; i</code>  的位置都是  <code>0</code>  ，因为选出物品不可能多于  <code>i</code></li></ul></li></ol><p>注意，二维递推不同于一维递推，二维的数据可能存在莫名其妙的依赖关系，因此我们在写二维递推的时候，需要特别注意二维 <strong>递推的顺序</strong></p><p>在此例中， <code>f[i]</code>  这一行的值全部由  <code>f[i - 1]</code>  这一行的值推出，因此，只需要按照行数从小到大的顺序递推即可</p><p>代码实现：</p><pre><code class="language-cpp">void Triangle(int k) &#123;    if (k == 0)        return -1;    const int MOD = 998244353;    int f[k + 1][k + 1] = &#123;0&#125;;  // 初始化二维数组    for (int i = 0; i &lt;= k; i++) &#123;        f[i][0] = f[i][i] = 1;          // 边界条件        for (int j = 1; j &lt; i; j++) &#123;            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % MOD;    // 递推式，需要取模        &#125;        for (int j = 0; j &lt;= k; j++) &#123;            cout &lt;&lt; f[i][j] &lt;&lt; ' ';     // 输出这一整行        &#125;        cout &lt;&lt; endl;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm95dWFpLmNvbS9sZWFybi9jb3Vyc2VzLzE0OS9sZXNzb25zLzI1Mzcvc3RlcHMvMD9mcm9tPXF6">青舟智学：递推与递推思想的应用</span></p><h2 id="递归"><a class="anchor" href="#递归">#</a> 递归</h2><p>递归（Recursion）的基本思想：某个函数直接或者间接地调用自身</p><p>递归有两个显著的特征:</p><ul><li>自身调用：原问题可以分解为 <strong>具有相同解决思路</strong> 的 <strong>子问题</strong> ，即都是调用自身的同一个函数</li><li>终止条件：递归必须有一个 <strong>终止条件</strong> ，而不能无限循环地调用本身</li></ul><p>因此，首先需要根据以上两个特点来判断题目是否可以用递归算法</p><p>递归的经典应用场景：</p><ul><li>阶乘问题</li><li>二叉树深度</li><li>汉诺塔问题</li><li>斐波那契数列</li><li>快速排序、归并排序（分治算法体现递归）</li><li>遍历文件，解析 xml 文件</li></ul><p>递归解题思路：</p><ol><li>定义函数，明确函数的功能：确认并牢记这个递归函数的功能，不要让一个函数干两件事情！</li><li>寻找原问题与子问题的关系：即，确定递推公式</li><li>确定递归终止条件：发现递推关系后，要寻找 <strong>不可再分解的子问题的解</strong> ，即，临界条件，确保子问题不会无限分解下去</li><li>推导时间复杂度，如果发现递归时间复杂度不可接受，则需 <strong>转换思路对其进行改造</strong></li></ol><blockquote><p>只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的</p><p>千万不要尝试研究这个递归的过程是什么样的！</p></blockquote><p>递归算法的时间复杂度：<strong> <code>递归时间复杂度 = 解决一个子问题的时间 * 子问题的个数</code> </strong></p><ul><li>可以将递归过程抽象成一棵 “递归树”，树中每一个节点都是一次递归，所以该递归算法的时间复杂度为  <code>节点数 * 每个节点的时间复杂度</code></li></ul><p>递归算法的空间复杂度：<strong> <code>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度</code> </strong></p><ul><li>每次递归所需的空间都被压到调用栈里，调用栈的最大长度就是递归的深度</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU4OSU4RCVFNSVCQSU4Ri8lRTklODAlOUElRTglQkYlODclRTQlQjglODAlRTklODElOTMlRTklOUQlQTIlRTglQUYlOTUlRTklQTIlOTglRTclOUIlQUUlRUYlQkMlOEMlRTglQUUlQjIlRTQlQjglODAlRTglQUUlQjIlRTklODAlOTIlRTUlQkQlOTIlRTclQUUlOTclRTYlQjMlOTUlRTclOUElODQlRTYlOTclQjYlRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYlRUYlQkMlODEuaHRtbA==">代码随想录：通过一道面试题目，讲一讲递归算法的时间复杂度！</span></p><p>递归存在的问题：</p><ol><li><strong>栈溢出</strong><ul><li>递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。若递归调用层级太多，就会超出栈的容量</li><li>解决方案：减少递归调用次数；改用其他算法</li></ul></li><li><strong>重复计算</strong><ul><li>递归过程中可能会重复求解某些子问题，导致效率低下</li><li>解决方案：记录已经遍历过的状态（记忆化递归）；改用其他算法（例如，迭代算法）</li></ul></li></ol><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU4OSU4RCVFNSVCQSU4Ri8lRTklODAlOTIlRTUlQkQlOTIlRTclQUUlOTclRTYlQjMlOTUlRTclOUElODQlRTYlOTclQjYlRTklOTclQjQlRTQlQjglOEUlRTclQTklQkElRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYlRTUlODglODYlRTYlOUUlOTAuaHRtbCMlRTklODAlOTIlRTUlQkQlOTIlRTYlQjElODIlRTYlOTYlOTAlRTYlQjMlQTIlRTklODIlQTMlRTUlQTUlOTElRTYlOTUlQjAlRTUlODglOTclRTclOUElODQlRTYlODAlQTclRTglODMlQkQlRTUlODglODYlRTYlOUUlOTA=">代码随想录：递归求斐波那契数列的性能分析</span></p><h3 id="阶乘"><a class="anchor" href="#阶乘">#</a> 阶乘</h3><pre><code class="language-cpp">// 递推写法int factorial(int n) &#123; // n 不小于 0    if (n &lt;= 1)        return 1;    int ans = 1;    for (int i = 2; i &lt;= n; i++)        ans = i * ans;    return ans;&#125;// 递归写法int recursion(int n) &#123;  // 计算 n 的阶乘    if (n &lt; = 1)        // 递归终止条件        return 1;    return n * recursion(n - 1);    // 递推公式&#125;</code></pre><p>递推算法</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>递归算法</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，调用栈深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></li></ul><h3 id="青蛙跳台阶-2"><a class="anchor" href="#青蛙跳台阶-2">#</a> 青蛙跳台阶</h3><p>递归的简单实现：</p><pre><code class="language-cpp">// 非记忆化递归int f(int n) &#123; // 计算青蛙跳到 n 级台阶的方案数    if (n &lt; 0)        return -1;    if (n &lt;= 1)        return 1;    return f(n - 1) + f(n - 2);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><ul><li>将递归过程抽象成一颗深度为  <code>n</code>  的 “递归树”（每一个节点都是一次递归），最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个节点，每次递归的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以该递归算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><ul><li>每次递归的空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，递归的深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></li></ul><p>分析发现，在递归过程中， <code>f(n - 1) + f(n - 2)</code>  存在大量的重复计算，因此，可以考虑将已经计算过的结果保存起来，即，带备忘录的递归解法，实现 <strong>以空间换时间</strong></p><p>一般使用一个数组充当这个「备忘录」，当然也可以使用「哈希表」</p><pre><code class="language-cpp">// 数组充当备忘录int fib(int N) &#123;    if (N &lt; 0)        return -1;    vector&lt;int&gt; memo(N + 1, 0);       // 备忘录全初始化为 0        return helper(memo, N);&#125;int helper(vector&lt;int&gt;&amp; memo, int n) &#123;    if (n == 0 || n == 1)        return 1;       // base case     if (memo[n] != 0)        return memo[n]; // 已经计算过    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);    return memo[n];&#125;// 哈希表充当备忘录int f(int n) &#123;    if (n &lt; 0)        return -1;    if (n &lt;= 1)        return 1;    // map 即保存中间态的键值对， key 为 n，value 即 f(n)    if (map.get(n)) &#123;        return map.get(n);    &#125;    return f(n - 1) + f(n - 2);&#125;</code></pre><p>带备忘录的递归解法的时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，“递归树” 一共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点</p><p>带备忘录的递归解法的空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，且用了一个键值对来保存中间的计算结果</p><p>另一种优化方案：用  <code>first</code>  和  <code>second</code>  来记录递推公式中相加的两个数值，此时就不用两次递归，从而减少了递归的调用次数</p><pre><code class="language-cpp">int f(int first, int second, int n) &#123;    if (n &lt; 0)        return -1;    if (n &lt;= 1)        return 1;    else if (n == 2)        return first + second;    else        return f(second, first + second, n - 1);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><h3 id="汉诺塔"><a class="anchor" href="#汉诺塔">#</a> 汉诺塔</h3><p>如下图所示的汉诺塔问题，从左到右有 A、B、C 三根柱子，其中 A 柱子上面有从小叠到大的  <code>n</code>  个圆盘，现要求将 A 柱子上的圆盘移到 C 柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤</p><p><img data-src="/posts/afade57b/hanoid.png" class=""></p><p>递归求解思路：</p><ol><li><p>定义问题的递归函数：函数的功能为 把 A 上面的  <code>n</code>  个圆盘经由 B 移到 C</p></li><li><p>查找问题与子问题的关系</p><ul><li><p>将 A 最上面的  <code>n - 1</code>  个圆盘视为一个整体</p></li><li><p>递归函数的实现步骤为：1） 将 A 上面的  <code>n - 1</code>  个圆盘经由 C 移到 B ；2）将 A 最底下的圆盘移到 C ；3）将 B 上的  <code>n - 1</code>  个圆盘经由 A 移到 C 上</p></li></ul></li><li><p>递归终止条件：A 上不再有圆盘（所有圆盘已经移到 C 上）</p></li></ol><blockquote><p>这里不需要深究 “具体怎么把  <code>n - 1</code>  个圆盘从 A 移到 B ”，只需明白其可以通过递归实现即可</p><p>在确定原问题与子问题的关系时，切忌把子问题层层展开，只要找到一层问题与子问题的关系得出可以用递归表示即可</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">// 将 n 个圆盘从 a 经由 b 移动到 c 上void move(int n, char a, char b, char c) &#123;    if (n &lt;= 0)        return;    move(n - 1, a, c, b);    // 将 a 上面的 n - 1 个圆盘经由 c 移到 b    cout &lt;&lt; a &lt;&lt; &quot; -&gt; &quot; &lt;&lt; b &lt;&lt; endl; // 将 a 底下的那块最大的圆盘移到 c    move(n - 1, b, a, c);    // 再将 b 上的 n-1 个圆盘经由 a 移到 c上&#125;// 求解汉诺塔问题void Hanoi(int n) &#123;    if (n &lt;= 0)        return;    move(n, 'A', 'B', 'C');&#125;</code></pre><blockquote><p>明确函数的功能非常重要，按着函数的功能来理清 / 解释算法思路</p></blockquote><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvSkxianpDZFZsSl9kZTJ1R2dCc1V6dw==">CodeSheep：一文彻底学会递归思路解题</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdHFHS0haelN5REJnRXAtb1dzT3p0UQ==">CodeSheep：死磕程序员必备算法：递归！</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 03. 数组中重复的数字</title>
      <link href="/posts/b5e5ca5b/"/>
      <url>/posts/b5e5ca5b/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LXp1LXpob25nLXpob25nLWZ1LWRlLXNodS16aS1sY29mLw==">剑指 Offer 03</span></p><p>在一个长度为 n 的数组  <code>nums</code>  里，所有数字都在 0 ~ n-1 的范围内，请找出数组中任意一个重复的数字</p><p><strong>示例 1：</strong></p><pre><code>输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 </code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">\le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="stable_sort-函数"><a class="anchor" href="#stable_sort-函数">#</a> stable_sort 函数</h2><pre><code class="language-cpp">int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;    // stable_sort 函数（归并排序的优化实现）    int n = nums.size();    stable_sort(nums.begin(), nums.end());    // 检查是否有重复    for (int i = 1; i &lt; n; i++) &#123;        if (nums[i] == nums[i - 1])            return nums[i];    &#125;    return -1;&#125;</code></pre><p>注：这里若采用快速排序或归并排序，将会超出时间限制</p><h2 id="哈希表"><a class="anchor" href="#哈希表">#</a> 哈希表</h2><p>使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字</p><p>算法流程：</p><ol><li><p>初始化  <code>ordered_map</code>  容器，记为  <code>map</code></p></li><li><p>遍历数组  <code>nums</code>  中的每个数字  <code>num</code>  ：</p><ul><li>当  <code>num</code>  在  <code>map</code>  中，即， <code>map[num] &gt;= 2</code> ，直接返回  <code>num</code></li><li><code>num</code>  不在  <code>map</code>  中， <code>map[num]</code>  加  <code>1</code></li></ul></li><li><p>若遍历结束时未发现重复数字，返回  <code>-1</code></p></li></ol><pre><code class="language-cpp">int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;    unordered_map&lt;int, bool&gt; map;    for (auto num : nums) &#123;        if(map[num]) // 若 map[num] = 1，则数字 num 重复            return num;        map[num]++;    &#125;    return -1;&#125;</code></pre><p>时间复杂度：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，遍历数组</li></ul><p>空间复杂度：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，哈希表占用额外空间</li></ul><h2 id="原地交换"><a class="anchor" href="#原地交换">#</a> 原地交换</h2><p>注意题目说明： <code>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内</code> ，因此，可以通过交换操作，建立数组元素 索引 与 值 的映射关系</p><p>基本思想：遍历数组  <code>nums</code>  ，第一次遇到数字  <code>x</code>  时，将其交换至索引  <code>x</code>  处；而当第二次遇到数字  <code>x</code>  时，一定有  <code>nums[x] = x</code>  ，得到重复数字</p><p>算法流程：</p><ol><li><p>遍历数组  <code>nums</code>  ，设索引初始值为  <code>i = 0</code>  ：</p><ul><li><p>若  <code>nums[i] = i</code>  ：说明此数字已在对应索引位置，无需交换，因此跳过</p></li><li><p>若  <code>nums[nums[i]] = nums[i]</code>  ：代表索引  <code>nums[i]</code>  处和索引  <code>i</code>  处的元素值都为  <code>nums[i]</code>  ，即找到一组重复值，直接返回值  <code>nums[i]</code></p></li><li><p>否则：交换索引为  <code>i</code>  和索引为  <code>nums[i]</code>  的两个元素，将此数字交换至对应索引位置</p></li></ul></li><li><p>若遍历完毕尚未返回，则返回  <code>-1</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;    int i = 0, n = nums.size();    while (i &lt; n) &#123;        if (nums[i] == i) &#123; // 注意：仅这里进行 i++ ，后续两种情况不进行 i++             i++;            continue;        &#125;        else if (nums[nums[i]] == nums[i])  // 直接返回，无需再操作 i            return nums[i];        else                                // 须对 nums[nums[i]] 作进一步的交换操作，将其放至值所对应的索引处，故而此处不进行 i++            swap(nums[i], nums[nums[i]]);    &#125;    return -1;&#125;</code></pre><p>时间复杂度：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，遍历数组</li></ul><p>空间复杂度：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，使用常数复杂度的额外空间</li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LXp1LXpob25nLXpob25nLWZ1LWRlLXNodS16aS1sY29mL3NvbHV0aW9uL21pYW4tc2hpLXRpLTAzLXNodS16dS16aG9uZy16aG9uZy1mdS1kZS1zaHUtemkteXVhLw==">Krahets</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 744. 寻找比目标字母大的最小字母</title>
      <link href="/posts/7e8f6f39/"/>
      <url>/posts/7e8f6f39/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXNtYWxsZXN0LWxldHRlci1ncmVhdGVyLXRoYW4tdGFyZ2V0Lw==">LeetCode 744. Find Smallest Letter Greater Than Target</span></p><p>给你一个字符数组  <code>letters</code>  ，该数组按非递减顺序排序，以及一个字符  <code>target</code>  。 <code>letters</code>  里至少有两个不同的字符。</p><p>返回  <code>letters</code>  中大于  <code>target</code>  的最小的字符。如果不存在这样的字符，则返回  <code>letters</code>  的第一个字符。</p><p><strong>示例 1：</strong></p><pre><code>输入：letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;a&quot;输出：&quot;c&quot;解释：letters 中字典上比 'a' 大的最小字符是 'c'</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;c&quot;输出：&quot;f&quot;解释：letters 中字典顺序上大于 'c' 的最小字符是 'f'</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;d&quot;输出：&quot;f&quot;解释：letters 中没有一个字符在字典上大于 'z'，所以我们返回 letters[0]</code></pre><p><strong>示例 4:</strong></p><pre><code>输入：letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;z&quot;输出：&quot;c&quot;</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>letters.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>letters[i]</code>  是一个小写字母</li><li><code>letters</code>  按非递减顺序排序</li><li><code>letters</code>  最少包含两个不同的字母</li><li><code>target</code>  是一个小写字母</li></ul><h2 id="method-二分查找"><a class="anchor" href="#method-二分查找">#</a> Method: 二分查找</h2><p>旨在找出大于  <code>target</code>  的最小字母，可以考虑二分查找算法</p><p>二分查找的基本思路：</p><ol><li>考虑  <code>while</code>  循环终止条件为  <code>left = right</code><ul><li>如果  <code>letters[mid] &gt; target</code>  ，则所求字母在  <code>[left, mid]</code>  区间，所以更新  <code>right = mid</code></li><li>如果  <code>letters[mid] &lt;= target</code> ，则所求字母在  <code>[mid + 1, right]</code>  区间，所以更新  <code>left = mid + 1</code></li></ul></li><li>循环结束时，需要判断  <code>letters[left]</code>  是否大于  <code>target</code><ul><li>若是，输出  <code>letters[left]</code></li><li>若否，则所有元素均不大于  <code>target</code>  ，输出  <code>letters[0]</code></li></ul></li></ol><pre><code class="language-cpp">// 找出大于目标值的最小元素索引int LowerBoundSearch(vector&lt;char&gt; letters, char target) &#123;    int left = 0, right = letters.size() - 1;    while (left &lt; right) &#123;        int mid = left + ((right - left) &gt;&gt; 1); // 注意：+ 号优先级高于位运算 &gt;&gt; ，需要将 (right - left) &gt;&gt; 1 括起来        if (letters[mid] &gt; target)            right = mid;        else            left = mid + 1;    &#125;    // 判断 letters[left] 是否大于 target    if (letters[left] &gt; target)        return left;    else  // 所有字母都比 target 小（注意：字母在 letters 中依序循环出现，返回 0 ）        return 0;    // // 等价于    // return letters[left] &gt; target ? left : 0;&#125;char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;    int index = LowerBoundSearch(letters, target);    return letters[index];&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/posts/a56851c5/"/>
      <url>/posts/a56851c5/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1hbmQtbGFzdC1wb3NpdGlvbi1vZi1lbGVtZW50LWluLXNvcnRlZC1hcnJheS8=">LeetCode 34. Find First and Last Position of Element in Sorted Array</span></p><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [], target = 0输出：[-1,-1]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><code>nums</code>  是一个非递减数组</li><li>$- 10^9 \le $  <code>target</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-1-while-left-right"><a class="anchor" href="#method-1-while-left-right">#</a> Method 1: while (left &lt; right)</h2><pre><code class="language-cpp">// 寻找元素的第一个位置（找出第一个大于等于 target 的元素）int LowerBoundSearch(vector&lt;int&gt; nums, int target) &#123;    int l = 0, r = nums.size() - 1;    while (l &lt; r) &#123; // 注意：循环结束时 l = r        int mid = l + ((r - l) &gt;&gt; 1);        if (nums[mid] &gt;= target)            // lower bound 一定在区间 [l, mid]            r = mid;        else if (nums[mid] &lt; target)        // lower bound 一定在区间 (mid, r]            l = mid + 1;    &#125;    if (nums[l] == target)        return l;    else        return -1;&#125;// 寻找元素的最后一个位置（找出最后一个小于等于 target 的元素）int UpperBoundSearch(vector&lt;int&gt; nums, int target) &#123;    int l = 0, r = nums.size() - 1;    while (l &lt; r) &#123;        int mid = l + ((r - l + 1) &gt;&gt; 1);   // 避免陷入死循环，mid 向上取整        if (nums[mid] &lt;= target)            // upper bound 一定在区间 [mid, r]            l = mid;        else if (nums[mid] &gt; target)        // upper bound 一定在区间 [l, mid)            r = mid - 1;    &#125;    if (nums[r] == target)        return r;    else        return -1;&#125;vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;    int n = nums.size();    if (n == 0) &#123;   // 空数组        vector&lt;int&gt; ans = &#123;-1,-1&#125;;        return ans;    &#125;    int lb = LowerBoundSearch(nums, target);    int ub = UpperBoundSearch(nums, target);    vector&lt;int&gt; ans = &#123;lb,ub&#125;;    return ans;&#125;</code></pre><h2 id="method-2-while-left-right"><a class="anchor" href="#method-2-while-left-right">#</a> Method 2: while (left &lt;= right)</h2><pre><code class="language-cpp">// 寻找元素的第一个位置int LowerBoundSearch(vector&lt;int&gt; nums, int target) &#123;    int l = 0, r = nums.size() - 1;    while (l &lt;= r) &#123; // 注意：循环结束时 l = r + 1        int mid = l + ((r - l) &gt;&gt; 1);        if (nums[mid] &gt;= target)            r = mid - 1;             // 注意：循环结束时， l 刚好就是 lower bound        else if (nums[mid] &lt; target)            l = mid + 1;    &#125;    if (nums[l] == target)        return l;    else        return -1;&#125;// 寻找元素的最后一个位置int UpperBoundSearch(vector&lt;int&gt; nums, int target) &#123;    int l = 0, r = nums.size() - 1;    while (l &lt;= r) &#123; // 注意：循环结束时 l = r + 1        int mid = l + ((r - l) &gt;&gt; 1);        if (nums[mid] &lt;= target)            l = mid + 1;        else if (nums[mid] &gt; target)            r = mid - 1;            // 注意：循环结束时， r 刚好是 upper bound    &#125;    if (nums[r] == target)        return r;    else        return -1;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/posts/a444b428/"/>
      <url>/posts/a444b428/</url>
      
        <content type="html"><![CDATA[<p>排序算法性能汇总：</p><table><thead><tr><th style="text-align:left">排序算法</th><th style="text-align:left">平均时间复杂度</th><th style="text-align:left">最差时间复杂度</th><th style="text-align:left">空间复杂度</th><th style="text-align:left">稳定性</th></tr></thead><tbody><tr><td style="text-align:left">选择排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">数组不稳定、链表稳定</td></tr><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">不稳定</td></tr><tr><td style="text-align:left">堆排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">不稳定</td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">希尔排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">不稳定</td></tr><tr><td style="text-align:left">计数排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">桶排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">取决桶内排序算法</td></tr><tr><td style="text-align:left">基数排序</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">稳定</td></tr></tbody></table><blockquote><p>稳定的排序算法：在排序前的序列中，有超过一个相同的元素，排序后这两个元素的相对位置依然保持不变</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kb3dhbGxlLmdpdGJvb2suaW8vYWxnby9hbGdvcml0aG0vMi1zdWFuLWZhLWppLWNodS8xLXBhaS14dQ==">https://dowalle.gitbook.io/algo/algorithm/2-suan-fa-ji-chu/1-pai-xu</span></p><p>为便于表述以及理解，作出以下声明:</p><ol><li><p>各排序算法均以  &quot; 将包含  <code>n</code>  个元素的数组按从小到大顺序排列 &quot;  为例</p></li><li><p><code>第 i 个元素</code> 的  <code>i</code>  的范围是  <code>[1, n]</code></p></li><li><p><code>第 i 位元素</code> 的  <code>i</code>  的范围是  <code>[0, n - 1]</code></p></li></ol><p>另，排序算法可以针对 <strong>字符串</strong> 进行排序，<strong>字典序</strong> 就是字符串的大小顺序</p><h2 id="选择排序"><a class="anchor" href="#选择排序">#</a> 选择排序</h2><p><strong>选择</strong> ：选出序列中的最小值，放到序列的首位</p><pre><code class="language-cpp">// 选择：寻找最小值int min_pos = 0;for (int j = 1; j &lt; n; j++) &#123;    if (a[j] &lt; a[min_pos]) &#123;   // 如果当前元素小于之前维护的最小值        min_pos = j;           // 更改最小值出现的位置    &#125;&#125;</code></pre><p><strong>选择排序</strong> 的算法思想：</p><ol><li><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</p></li><li><p>以此类推，直到所有元素均排序完毕</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">void SelectionSort(vector&lt;int&gt;&amp; a) &#123;   // 选择排序    int n = a.size();    for (int i = 0; i &lt; n - 1; i++) &#123;      // 枚举应该归位的第 i 位元素        int min_pos = i;                   // 将最小值位置设置为当前范围 i ~ n - 1 的首位        for (int j = i + 1; j &lt; n; j++) &#123;  // 将第 i 位元素和剩下的元素相比较            if (a[j] &lt; a[min_pos]) &#123;       // 如果当前元素小于之前维护的最小值                min_pos = j;               // 更改最小值出现的位置            &#125;        &#125;        swap(a[i], a[min_pos]);            // 将最小值与第 i 位元素交换    &#125;&#125;</code></pre><p>时间复杂度：</p><ul><li>最优、平均和最坏时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>稳定性：由于  <code>swap</code>  操作的存在，选择排序是一种 <strong>不稳定</strong> 的排序算法</p><h2 id="冒泡排序"><a class="anchor" href="#冒泡排序">#</a> 冒泡排序</h2><p>在算法的执行过程中，较小的元素像是气泡般慢慢浮到数列的顶端，故叫做冒泡排序</p><p><strong>冒泡</strong> ：两个数比较大小，较大的数下沉，较小的数冒起来</p><pre><code>// 冒泡：连续交换过程for (int i = 0; i &lt; n - 1; i++)    // 枚举两两交换的前一个元素序号    if (a[i] &gt; a[i + 1])        swap(a[i], a[i + 1]);      // 如果前一个元素大于后一个，就进行交换</code></pre><p><strong>冒泡排序</strong> 的算法思想：</p><ul><li>针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [0, n - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span> ，通过 <strong>冒泡</strong> 将前  <code>n - i</code>  个元素的最大值移动到第  <code>n - i - 1</code>  位，此时还剩前  <code>n - i - 1</code>  个元素（即，第  <code>0</code>  位到第  <code>n - i - 2</code>  位）未排序</li></ul><p>注：也可以进行第  <code>i = n - 1</code>  阶段结束</p><p>代码实现：</p><pre><code class="language-cpp">void BubbleSort(vector&lt;int&gt;&amp; a) &#123; // 冒泡排序，引用传递    int n = a.size();    for (int i = 0; i &lt; n - 1; i++) &#123; // 在第 i 个阶段，未排序的序列长度从 n - i 变成 n - i - 1 （注：i 的最大值可以设置成 n - 1，也可以设置成 n - 2）        // 将第 0 位到第 n - i - 1 位元素的最大值，移到 n - i - 1 的位置        for (int j = 0; j &lt; n - i - 1; j++) // j 是冒泡操作中的前一个元素的下标，j 的最大值为 n - i - 2，对应 j + 1 最大值为 n - i - 1            if (a[j] &gt; a[j + 1])                swap(a[j], a[j + 1]);    &#125;&#125;</code></pre><p>时间复杂度：</p><ul><li>最优情况 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，序列完全有序时，冒泡排序只需遍历一遍数组</li><li>最坏情况 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，冒泡排序要执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n - 1) n / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 次交换操作</li><li>平均时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>稳定性：冒泡排序是一种 <strong>稳定</strong> 的排序算法</p><h2 id="插入排序"><a class="anchor" href="#插入排序">#</a> 插入排序</h2><p>对于一个有序序列，如果想在其中新加入一个元素，就应通过 <strong>插入操作</strong> 找出正确的插入位置，并且将插入位置空出来，然后插入新元素</p><p><strong>插入</strong> ：将第  <code>i</code>  个元素插入到前  <code>i - 1</code>  个元素的有序序列中，形成长度为  <code>i</code>  的有序序列</p><blockquote><p>假设数组  <code>a</code>  的第  <code>0</code>  位到第  <code>i - 1</code>  位已经有序，插入操作的关键在于搜索插入位置，即：找出一条分界线  <code>j</code>  ，使得  <code>a[j - 1] &lt;= a[i]</code>  且  <code>a[j] &gt; a[i]</code>  成立</p></blockquote><pre><code class="language-cpp">// 插入：找出插入位置，并将该位置及以后的元素向右移动一位int j = i - 1, x = a[i];    // 初始化分界线的位置，并将 a[i] 用临时变量保存防止被修改for (; (j &gt;= 0) &amp;&amp; (a[j] &gt; x); j--) &#123; // 满足循环条件，分界线的位置应向左移    a[j + 1] = a[j];&#125;// 循环结束，找出分界线位置，插入 xa[j + 1] = x;</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VhcmNoLWluc2VydC1wb3NpdGlvbi8=">LeetCode 35. 搜索插入位置</span></p><p><strong>插入排序</strong> 的算法流程为：</p><ol><li><p>待排序序列的第  <code>0</code>  位元素作为初始的有序序列</p></li><li><p>针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [1, n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，依次将第  <code>i</code>  位元素 <strong>插入</strong> 到有序序列中</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">void InsertSort(vector&lt;int&gt;&amp; a) &#123; // 插入排序    int n = a.size();    for (int i = 1; i &lt; n; i++) &#123; // 从左到右遍历，将元素依次插入有序序列中        int j, x = a[i];        for (j = i - 1; (j &gt;= 0) &amp;&amp; (a[j] &gt; x); j--) &#123;               // 满足循环条件，相当于分界线应向左移            a[j + 1] = a[j];                                         &#125;        // 找到分界线位置，插入元素 x        a[j + 1] = x;    &#125;&#125;</code></pre><p>时间复杂度：</p><ul><li>最优时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>平均和最坏时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>稳定性：插入排序是一种 <strong>稳定</strong> 的排序算法</p><h2 id="快速排序重要"><a class="anchor" href="#快速排序重要">#</a> 快速排序（重要）</h2><p>快速排序（Quicksort），又称分区交换排序（partition-exchange sort），简称快排</p><p><strong>快速排序</strong> 基本思想：</p><ol><li>选择基准：从数列中取出一个数作为基准数  <code>pivot</code></li><li><code>partition</code>  过程：将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边</li><li>再对左右区间重复第 2 步，直到各区间只有一个数</li></ol><blockquote><p>选择基准的方式：</p><ul><li>固定位置：取序列的第一个或最后一个元素作为基准（基本的快速排序算法，不利于处理有序或部分有序的数组）</li><li>随机选取基准：取待排序列中任意一个元素作为基准（对于绝大多数输入数据，可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 的期望时间复杂度）</li><li>三数取中（median-of-three）：取第一个、最后一个和中心位置上的三个元素的中位数作为基准（可以避免极端数据（如升序序列或降序序列）带来的退化）</li></ul></blockquote><p>代码实现：</p><pre><code class="language-cpp">void QuickSort(vector&lt;int&gt;&amp; a, int l, int r) &#123; // 将序列分成左右两个子序列，并对子序列分别排序                                        // l 和 r 分别代表当前排序子段在原序列中左右端点的位置    int pivot = a[r];   // 设置最右边的数为基准    int pos = l - 1;    // 分界线 pos 及其左边的元素一定小于 pivot        // partition: 划分子序列，并确定分界线新位置 pos    // partition 包含 swap 操作，故而不是稳定的排序算法    for (int j = l; j &lt; r; j++)        if (a[j] &lt; pivot)             swap(a[j], a[++pos]);    swap(a[r], a[++pos]); // 将 pivot 放到分界线位置        // 对左子段和右子段分别进行排序    if (l &lt; pos - 1)        QuickSort(a, l, pos - 1); // 如果左边子段长度大于 1，排序    if (pos + 1 &lt; r)        QuickSort(a, pos + 1, r); // 如果右边子段长度大于 1，排序&#125;</code></pre><p>时间复杂度：</p><ul><li>最优 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，每一次选择的分界值都是序列的中位数</li><li>最坏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，每一次选择的分界值都是序列的最值</li><li>平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，递归调用时使用栈帧空间</p><p>稳定性：快速排序是一种 <strong>不稳定</strong> 的排序算法</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luc2lzdEdvR28vYXJ0aWNsZS9kZXRhaWxzLzc3ODUwMzg=">三种快速排序以及快速排序的优化</span></p><h3 id="sort-函数"><a class="anchor" href="#sort-函数">#</a> sort 函数</h3><p>C++ 标准模板库（STL）定义了 <strong>排序函数  <code>sort</code> </strong> ，可以用于排序操作（对 <strong>快速排序</strong> 的优化实现）</p><p><code>sort</code>  函数的头文件</p><pre><code>#include&lt;algorithm&gt;</code></pre><p><strong> <code>sort</code>  函数</strong> 有三个参数：<strong>头指针</strong> 、<strong>尾后指针</strong> 和 <strong>比较函数</strong></p><blockquote><p>如果已经针对排序对象定义了小于号（即，定义了小于号何时成立），比较函数可省略</p></blockquote><p>例如，针对数组排序：</p><pre><code class="language-cpp">int a[10] = &#123;2, 3, 1, 5, 4&#125;;int n = 5;sort(a.begin(), a.end());  //sort函数的两个参数，头指针和尾后指针for (int i = 0; i &lt; n; ++i)     cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;</code></pre><p>如果想按照其他标准进行排序，可以定义一个比较函数。例如，按 <strong>从大到小排序</strong> ：</p><pre><code class="language-cpp">int a[10] = &#123;2, 3, 1, 5, 4&#125;;int n = 5;// 比较函数，函数的参数是当前比较的两个数组中的元素bool cmp(int x, int y) &#123; // x 和 y 分别为排序数组中的两个元素    return (x &gt; y);  // 当函数返回值为 true 时，x 应该排在 y 的前面&#125;int main() &#123;    sort(a.begin(), a.end(), cmp); // 比较函数作为第三个参数传入 sort 函数    for (int i = 0; i &lt; n; ++i)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3BsdXNwbHVzLmNvbS9yZWZlcmVuY2UvYWxnb3JpdGhtL3NvcnQvP2t3PXNvcnQ=">sort 排序算法介绍及示例</span></p><h2 id="堆排序"><a class="anchor" href="#堆排序">#</a> 堆排序</h2><h2 id="归并排序重要"><a class="anchor" href="#归并排序重要">#</a> 归并排序（重要）</h2><p><strong>归并排序</strong>（merge sort）是一种采用了 <strong>分治思想</strong> 的排序算法</p><p><strong>归并</strong> ：合并两个有序的序列</p><pre><code class="language-cpp">// 归并操作：按升序合并数组 a 中两个有序的子序列，子序列的区间分别为 [1, (l + r) / 2] 和 [(l + r) / 2 + 1, r]vector&lt;int&gt; temp(a.size(),0);      // 辅助数组 tempvoid Merge (vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;temp, int l, int r) &#123;    int mid = l + ((r - l) &gt;&gt; 1);    int i = l, j = mid + 1;         // 指针 i 和 j 分别指向两个子序列的首个元素    for (int k = l; k &lt;= r; k++) &#123;  // 遍历原序列        // 如果 j 已经移至子段的尾后，或者， i 指向的元素比 j 指向的元素小        // 将 i 指向的元素填充到原序列的 k 位置，并将 i 右移        if ((j &gt; r) || (i &lt;= mid &amp;&amp; a[i] &lt; a[j]))            temp[k] = a[i++];        // 否则，将 j 指向的元素填充到原序列的 k 位置，并将 j 右移        else            temp[k] = a[j++];    &#125;    // 拷贝结果至 a    for (int k = l; k &lt;= r; k++)        a[k] = temp[k];&#125;// 注：在函数外一次性创建 辅助数组 temp ，这样可以避免在每次递归调用时创建数组，以减少内存分配的耗时</code></pre><p><strong>归并排序</strong> 分为三个步骤：</p><ol><li><p>将序列划分为两部分</p></li><li><p>递归地对两个子序列分别进行归并排序</p></li><li><p>合并两个子序列</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; temp(500,0);      // 辅助数组 temp ，根据实际需要另行确定 temp 的维度// 归并排序void MergeSort(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;temp, int l, int r) &#123; // 用来把 a 数组 [l, r] 这一区间的元素排序    // 子段为空或者长度为 1 ，递归结束    if (l &gt;= r) return;        // 将序列均分成两部分（左右长度相差最多为1）    int mid = l + ((r - l) &gt;&gt; 1);    MergeSort(a, temp, l, mid);     // 对 [l, mid] 子段进行归并排序    MergeSort(a, temp, mid + 1, r); // 对 [mid + 1, r] 子段进行归并排序        // 归并操作（结果存储在辅助数组 temp 中）    int i = l, j = mid + 1;         // 指针 i 和 j 分别指向两个子序列的首个元素    for (int k = l; k &lt;= r; k++) &#123;  // 遍历原序列        // 如果 j 已经移至子段的尾后，或者， i 指向的元素比 j 指向的元素小        // 将 i 指向的元素填充到原序列的 k 位置，并将 i 右移        if ((j &gt; r) || (i &lt;= mid &amp;&amp; a[i] &lt; a[j]))            temp[k] = a[i++];        // 否则，将 j 指向的元素填充到原序列的 k 位置，并将 j 右移        else            temp[k] = a[j++];    &#125;    // 拷贝结果至 a    for (int k = l; k &lt;= r; k++)        a[k] = temp[k];&#125;</code></pre><p>时间复杂度：</p><ul><li>最优、平均和最坏时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，因为算法始终有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span> 层，而合并子序列的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，借助了辅助数组（所以是一种非原地排序算法）</p><p>稳定性：归并排序是一种 <strong>稳定</strong> 的排序算法</p><h3 id="stable_sort-函数"><a class="anchor" href="#stable_sort-函数">#</a> stable_sort 函数</h3><p>C++ 标准模板库（STL）中也有对 <strong>归并排序</strong> 的优化实现，函数名为 <strong> <code>stable_sort</code> </strong> ，也在  <code>algorithm</code>  头文件中，使用方法与 <strong> <code>sort</code> </strong> 一样，通过传入 <strong>头指针</strong> 、 <strong>尾后指针</strong> 和 <strong>比较函数</strong> 来对数组中的对象进行排序</p><pre><code class="language-cpp">// 头文件#include &lt;algorithm&gt;// 比较函数bool cmp(int x, int y) &#123; // 函数的参数是当前比较的两个数组中的元素    return (x &gt; y);      // 当函数返回值为 true 时，x 应该排在 y 的前面&#125;// 调用stable_sort(a, a + n, cmp);</code></pre><h2 id="希尔排序"><a class="anchor" href="#希尔排序">#</a> 希尔排序</h2><h2 id="计数排序"><a class="anchor" href="#计数排序">#</a> 计数排序</h2><p><strong>计数排序</strong> 基于一个假设：待排序的 <strong>所有数均为整数，且落在一个很小的区间内</strong> ，例如 0 到 100 之间</p><p><strong>计数排序</strong> 统计待排序序列中每一个值  <code>i</code>  出现的次数，然后从小到大枚举所有  <code>i</code>  ，按照出现次数输出对应数量的  <code>i</code></p><blockquote><p>计数排序不适合按字母顺序排序人名</p><p>计数排序不是比较排序，排序的速度快于任何比较排序算法</p></blockquote><p><strong>计数排序</strong> 的基本流程：</p><ol><li><p>找出待排序数组中的最大值  <code>MaxValue</code> ，创建一个长为  <code>MaxValule + 1</code>  的数组  <code>cnt</code>  ，数组  <code>cnt</code>  元素初始值均为  <code>0</code></p></li><li><p>统计待排序数组中每种值  <code>i</code>  元素的出现次数，存入  <code>cnt[i]</code></p></li><li><p>创建结果数组  <code>ans</code>  ，长度与待排序数组一致</p></li><li><p>遍历  <code>cnt</code>  数组，找出值大于  <code>0</code>  的元素  <code>cnt[i]</code>  ，并将该元素索引  <code>i</code>  填充到数组  <code>ans</code>  中（从左向右填充），每填充一次， <code>cnt[i]</code>  值减  <code>1</code>  ，直到该值不大于  <code>0</code>  ，然后依次处理  <code>cnt</code>  数组的后续元素</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">void CountSort(vector&lt;int&gt; &amp;nums) &#123; // 计数排序的简单实现    // 确保容器非空    int n = nums.size();    if (n == 0) return;    // 找出待排序数组的最大值 MaxValue    int MaxValue = nums[0];    for (int i = 1; i &lt; n; i++)        MaxValue = max(MaxValue, nums[i]);        // 统计每一种值出现的次数    vector&lt;int&gt; cnt(MaxValue + 1, 0);    for (int i = 0; i &lt; n; ++i)        ++cnt[nums[i]];        // 维护最终有序序列    vector&lt;int&gt; ans(n,0);    for (int i = 0, j = 0; i &lt;= MaxValue; i++) // 枚举每一种值 i ，指针 j 指向填充的位置        for (int k = 1; k &lt;= cnt[i]; k++)      // 这里采用 k 自增来记录填充个数，是为了保证排序算法的稳定性            ans[j++] = i;                      // 根据出现次数填充相应数量的 i    // // 不同于上述填充方法，以下填充过程无法保证稳定性    // vector&lt;int&gt; ans(n,0);    // for (int i = 0, j = 0; i &lt;= MaxValue; i++) &#123;    //     while (cnt[i] &gt; 0) &#123;    //         ans[j++] = i;    //         cnt[i]--;    //     &#125;    // &#125;    // 拷贝结果    for (int i = 0; i &lt; n; i++)        nums[i] = ans[i];&#125;</code></pre><p>然而，这里统计的数字范围为  <code>[0, MaxValue]</code>  ，可能存在空间浪费的问题</p><p>事实上，可以找出数组元素的最小值  <code>MinValue</code>  ，仅统计  <code>[MinValue, MaxValue]</code>  区间内的数字。即，用  <code>cnt[0]</code>  记录值  <code>MinValue</code>  的出现次数，用  <code>cnt[MaxValue - MinValue]</code>  记录值  <code>MaxValue</code>  的出现次数</p><pre><code class="language-cpp">void CountSort(vector&lt;int&gt; &amp;nums) &#123; // 计数排序的优化版    // 确保容器非空    int n = nums.size();    if (n == 0) return;    // 找出待排序数组的最大值 MaxValue 和最小值 MinValue    int MaxValue = nums[0];    int MinValue = nums[0];    for (int i = 1; i &lt; n; i++) &#123;        MaxValue = max(MaxValue, nums[i]);        MinValue = min(MinValue, nums[i]);    &#125;        // 统计每一种值出现的次数    int length = MaxValue - MinValue + 1;    vector&lt;int&gt; cnt(length, 0);                // 初始化为 0    for (int i = 0; i &lt; n; i++)        ++cnt[nums[i- MinValue]];        // 维护最终有序序列    vector&lt;int&gt; ans(n,0);    for (int i = 0, j = 0; i &lt; length; i++)    // 指针 j 指向填充的位置        for (int k = 1; k &lt;= cnt[i]; k++)      // 根据出现次数填充相应数量的 i            ans[j++] = i + MinValue;    // 拷贝结果    for (int i = 0; i &lt; n; i++)        nums[i] = ans[i];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中， <code>n</code>  为待排序数组  <code>nums</code>  的长度， <code>m</code>  为数组  <code>nums</code>  中的元素值的种类数（即，数组  <code>cnt</code>  的长度）</p><blockquote><p>所有基于比较的排序算法，其最优时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega (n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span><br /> 计数排序不是基于比较的排序，可以达到比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega (n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 更好的时间复杂度</p></blockquote><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>稳定性：计数排序是 <strong>稳定</strong> 的排序算法</p><p><strong>计数排序</strong> 的基本思想还可以拓展成 <strong>桶排序</strong> 和 <strong>基数排序</strong> 。使用 <strong>桶排序</strong> 和 <strong>基数排序</strong> ，可以对更大范围内的、甚至不是整数的序列进行排序</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhb2NodWFuOTQvcC8xMTE5ODYxMC5odG1s">一文弄懂计数排序算法！</span></p><h2 id="桶排序重要"><a class="anchor" href="#桶排序重要">#</a> 桶排序（重要）</h2><h2 id="基数排序"><a class="anchor" href="#基数排序">#</a> 基数排序</h2><p>参考资料：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZWtHZG5lWnJNYTIzQUx4dDVtdktwUQ==">CodeSheep</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9iYXNpYy9zb3J0LWludHJvLw==">OI Wiki</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dhbGxlLmdpdGJvb2suaW8vYWxnby9hbGdvcml0aG0vMi1zdWFuLWZhLWppLWNodS8xLXBhaS14dQ==">algo</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucWluZ3pob3V6aGl4dWUuY29tL2xlYXJuaW5nLXBhdGgvMT9mdWxsPWZhbHNl">青舟智学</span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 27. 移除元素</title>
      <link href="/posts/c425967e/"/>
      <url>/posts/c425967e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC8=">LeetCode 27. Remove Element</span></p><p>给你一个数组  <code>nums</code>  和一个值  <code>val</code> ，你需要 <strong>原地</strong> 移除所有数值等于  <code>val</code>  的元素，并返回移除后数组的新长度。</p><blockquote><p>由于在某些语言中无法改变数组的长度，必须让结果放在数组  <code>nums</code>  的最前面。因此，如果在去除重复元素后还有 k 个元素，那么应该将结果放在  <code>nums</code>  的前 k 个位置，并返回 k 。</p></blockquote><p>不要使用额外的数组空间，你必须仅使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 额外空间并 <strong>原地</strong> 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以「<strong>引用</strong>」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code class="language-cpp">int[] nums = [...]; // Input arrayint val = ...;      // Value to removeint[] expectedNums = [...]; // The expected answer with correct length.                            // It is sorted with no values equaling val.int k = removeElement(nums, val); // Calls your implementationassert k == expectedNums.length;sort(nums, 0, k);           // Sort the first k elements of numsfor (int i = 0; i &lt; actualLength; i++) &#123;    assert nums[i] == expectedNums[i];&#125;</code></pre><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2,_,_]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3,_,_,_]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p></p><p><strong>限制</strong>:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h2><p><code>slow</code>  对应 将要被覆盖的位置， <code>fast</code>  对应 当前搜索位置，均初始化为  <code>0</code></p><p><code>fast</code>  右移，并进行如下操作，直到  <code>fast == nums.size() - 1</code>  ：</p><ul><li><p>如果  <code>nums[fast] == val</code>  ，跳过该元素</p></li><li><p>如果  <code>nums[fast] != val</code>  ，令  <code>nums[slow] = nums[fast]</code>  ，并让  <code>l</code>  右移一位</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;    int n = nums.size();    int slow = 0;    for (int fast = 0; fast &lt; n; fast++)        if (nums[fast] != val) // 对值不为 val 的元素进行移位，值为 val 则跳过            nums[slow++] = nums[fast];    return slow;               // slow 即为 新数组的长度&#125;</code></pre><p>时间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组的长度</p><p>空间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-双指针优化"><a class="anchor" href="#method-2-双指针优化">#</a> Method 2: 双指针优化</h2><p>如果要移除的元素恰好在数组的开头，方法一需要把每一个元素都左移一位</p><p>可以定义两个指针，初始时分别指向数组的首尾，向中间移动遍历该序列（题目允许改变元素的顺序）</p><p>算法流程：</p><p>执行以下循环，直到  <code>left</code>  与  <code>right</code>  重合</p><ul><li>判断  <code>left</code>  的元素是否等于  <code>val</code><ul><li>若是，将  <code>right</code>  指向的元素复制到  <code>left</code>  的位置，然后  <code>right</code>  左移一位</li><li>若否， <code>left</code>  右移一位</li></ul></li></ul><blockquote><p>注意这里的  <code>right</code>  指向的元素也有可能是  <code>val</code>  ，此时：</p><ul><li>可以选择将  <code>val</code>  赋值给  <code>left</code>  ，然后  <code>right</code>  左移（在这种情况下，赋值后  <code>left</code>  位置的元素仍为  <code>val</code>  ， <code>left</code>  不会移动）</li><li>也可以选择跳过该元素，即，  <code>right</code>  直接左移</li></ul></blockquote><p>代码实现：</p><pre><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;    int left = 0, right = nums.size() - 1;    while (left &lt; right) &#123;        if (nums[left] == val)            nums[left] = nums[right--];        else            left++;    &#125;    return left;&#125;</code></pre><p>时间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>与 Method 1 相比，Method 2 避免了值不为  <code>val</code>  元素的重复赋值操作</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 06. 从尾到头打印链表</title>
      <link href="/posts/3e7ca0d2/"/>
      <url>/posts/3e7ca0d2/</url>
      
        <content type="html"><![CDATA[<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p><p><strong>示例 1：</strong></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><h2 id="method-1-遍历添加"><a class="anchor" href="#method-1-遍历添加">#</a> Method 1: 遍历添加</h2><p>链表长度未知</p><p>先统计链表节点的个数  <code>count</code>  ，然后定义一个数组，逆序记录链表各节点的值</p><pre><code class="language-cpp">vector&lt;int&gt; reversePrint(ListNode* head) &#123;    // 统计链表的节点数    int count = 0;    ListNode *node = head;    while (node != nullptr) &#123;        count++;        node = node-&gt;next;    &#125;    // 创建数组    vector&lt;int&gt; nums(count,0);    // 逆序记录链表节点的值    node = head;    for (int i = count - 1; node != nullptr; i--) &#123;        nums[i] = node-&gt;val;        node = node-&gt;next;    &#125;    return nums;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为链表长度，遍历统计、遍历修改皆使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 时间</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，新建了一个  <code>vector</code>  容器</p><h2 id="method-2-递归"><a class="anchor" href="#method-2-递归">#</a> Method 2: 递归</h2><p>利用递归，先递推至链表末端；回溯时，依次将节点值加入数组，即可实现链表值的逆序输出</p><p>算法流程：</p><ol><li><p>终止条件：当  <code>head == nullptr</code>  时，代表越过了链表尾节点，则返回空列表</p></li><li><p>递推工作：访问下一节点  <code>head-&gt;next</code></p></li><li><p>回溯阶段：将当前节点值  <code>head-&gt;val</code>  加入数组  <code>res</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">class Solution &#123;public:    vector&lt;int&gt; reversePrint(ListNode* head) &#123;        recur(head);        return res;    &#125;private:    vector&lt;int&gt; res;    void recur(ListNode *head) &#123;        if(head == nullptr) return;        recur(head-&gt;next);        res.push_back(head-&gt;val);    &#125;&#125;;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，遍历链表，递归 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，递归需要使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的栈空间</p><p><img data-src="/posts/3e7ca0d2/1.png" class=""><br /> 注：图解是以 Python 代码为例</p><h2 id="method-3-栈"><a class="anchor" href="#method-3-栈">#</a> Method 3: 栈</h2><p>链表只能 从前至后 访问每个节点，而这里要求 <strong>逆序输出</strong> 各节点值，这种 <strong>先入后出</strong> 的需求可以借助 <strong>栈</strong> 来实现</p><p>算法流程：</p><ol><li><p>入栈：遍历链表，将各节点值  <code>push</code>  入栈</p></li><li><p>出栈：将各节点值  <code>pop</code>  出栈，存储于数组并返回</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; reversePrint(ListNode* head) &#123;    stack&lt;int&gt; stk;    while(head != nullptr) &#123;        stk.push(head-&gt;val);        // 入栈，在栈顶增加元素        head = head-&gt;next;    &#125;    vector&lt;int&gt; res;    while(!stk.empty()) &#123;           // 判断堆栈是否为空        res.push_back(stk.top());   // top() 函数返回栈顶元素        stk.pop();                  // 出栈，移除栈顶元素    &#125;    return res;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次的入栈和出栈<br />空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，辅助栈  <code>stack</code>  和数组  <code>res</code>  各使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的额外空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 05. 替换空格</title>
      <link href="/posts/fff72920/"/>
      <url>/posts/fff72920/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdGktaHVhbi1rb25nLWdlLWxjb2Yv">剑指 Offer 05. 替换空格</span></p><p>请实现一个函数，把字符串  <code>s</code>  中的每个空格替换成 &quot;<strong>%20</strong>&quot;</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">\le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-遍历添加"><a class="anchor" href="#method-1-遍历添加">#</a> Method 1: 遍历添加</h2><p>遍历字符串  <code>s</code>  中的每个字符，如果不是空格，直接赋值给新字符串；否则，赋值 “%20” 到新字符串</p><pre><code class="language-cpp">string replaceSpace(string s) &#123;    int i = 0;    string ans = &quot;&quot;;    while (i &lt; s.size()) &#123;        if (isspace(s[i])) ans += &quot;%20&quot;; // 等价于 ans.append(&quot;%20&quot;)        else ans += s[i];                // 等价于 ans.push_back(s[i])        i++;    &#125;    return ans;&#125;</code></pre><p>其中， <code>string</code>  的成员函数：</p><ul><li><p><code>append()</code>  ：向后加入的是  <code>string</code>  类型</p></li><li><p><code>push_back()</code>  ：向后加入的是  <code>char</code>  类型</p></li></ul><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，新建了一个字符串</p><h2 id="method-2-原地修改双指针"><a class="anchor" href="#method-2-原地修改双指针">#</a> Method 2: 原地修改（双指针）</h2><p>基本思路：先统计整个字符串中的空格数目，然后把字符串大小扩充为替换后的大小，用 双指针 方法 <strong>从右向左</strong> 移元素</p><p>解题步骤：</p><ol><li><p>统计空格数量  <code>count</code></p></li><li><p>修改  <code>s</code>  长度：将所有空格都替换成 &quot;%20&quot; 后，新字符串应比原字符串长  <code>2 * count</code></p></li><li><p>定义指针  <code>left</code>  指向原字符串尾部元素，  <code>right</code>  指向新字符串尾部元素</p></li><li><p>从右向左遍历修改  <code>s</code>  ，当  <code>left == right</code>  时（代表左边已没有空格）结束循环</p><ul><li><p>当  <code>s[left]</code>  不是空格时，执行  <code>s[right] = s[left]</code></p></li><li><p>当  <code>s[left]</code>  是空格时，将区间  <code>[right - 2, right]</code>  内的元素修改为 &quot;%20&quot;</p></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">string replaceSpace(string s) &#123;    // 统计空格数量    int count = 0;    for (auto c : s)        if (c == ' ') count++;    // 扩充字符串长度    int oldSize = s.size(), newSize = oldSize + 2 * count;    s.resize(newSize);    // 双指针法    int left = oldSize - 1, right = newSize - 1;    while (left &lt; right) &#123;        if (s[left] == ' ') &#123;            s[right--] = '0';            s[right--] = '2';            s[right--] = '%';            left--;        &#125;        else            s[right--] = s[left--];    &#125;    return s;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，统计空格数量、双指针法修改  <code>s</code>  的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，由于是原地扩展  <code>s</code>  长度，因此使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 额外空间</p><p>很多数组 / 字符串填充类的问题，都可以预先扩充数组的大小，然后再从右向左进行操作</p><p>这样做有两个好处：</p><ol><li>不用申请新数组，降低了空间复杂度</li><li>从右向左填充元素，避免了从左向右填充元素带来的 “每次添加元素都要将该位置右边的元素向后移动” 的问题，既降低了时间复杂度，也简化了算法</li></ol><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU4OSU5MSVFNiU4QyU4N09mZmVyMDUuJUU2JTlCJUJGJUU2JThEJUEyJUU3JUE5JUJBJUU2JUEwJUJDLmh0bWw=">代码随想录</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构简介</title>
      <link href="/posts/b8928e0e/"/>
      <url>/posts/b8928e0e/</url>
      
        <content type="html"><![CDATA[<p>数据结构是为实现对计算机数据有效使用的各种数据组织形式，旨在降低各种算法计算的时间与空间复杂度</p><p>常见的数据结构可分为 <em>线性数据结构</em> 与 <em>非线性数据结构</em> ，具体包括：<strong>数组</strong> 、 <strong>链表</strong> 、 <strong>栈</strong> 、 <strong>队列</strong> 、 <strong>树</strong> 、 <strong>图</strong> 、 <strong>散列表</strong> 、 <strong>堆</strong></p><p><img data-src="/posts/b8928e0e/1.png" class=""></p><blockquote><p>不要对数据结构的使用浅尝辄止，而要深挖起内部原理</p></blockquote><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><p>数组是将相同类型的元素存储于 <strong>连续内存空间</strong> 的数据结构，其长度不可变。构建数组时需要在初始化时给定长度，例如：</p><pre><code class="language-cpp">int array[5];int array[] = &#123;2, 3, 1, 0, 2&#125;;</code></pre><p>详情可见 <a href="https://jiankychen.github.io/2022/03/05/19-shu-zu/">C++：数组</a></p><p><strong>可变数组</strong> （<strong>标准库类型  <code>vector</code> </strong> ）是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：<strong>访问元素</strong>（下标运算符、范围  <code>for</code> 、迭代器）、<strong>添加元素</strong>（成员函数  <code>push_back</code> ）、<strong>删除元素</strong>（成员函数  <code>erase</code>  和  <code>remove</code> ），例如：</p><pre><code class="language-cpp">vector&lt;int&gt; array = &#123;2，3，1，0，2&#125;;array.push_back(2);         // 添加元素 2 到末尾vector&lt;int&gt;::iterator it;   // 迭代器it = array.begin() + 4;     // it 指向第 5 个元素array.erase(it);            // 删除 it 指向的元素</code></pre><p>详情可见于<br /><a href="https://jiankychen.github.io/2022/03/04/17-biao-zhun-ku-lei-xing-vector/"> C++：标准库类型 vector</a><br /><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQU5fWkFORzExMjUvYXJ0aWNsZS9kZXRhaWxzLzEyMDY0MjI0Mz9zcG09MTAwMS4yMTAxLjMwMDEuNjY1MC4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnQubm9uZS10YXNrLWJsb2ctMiU3RWRlZmF1bHQlN0VDVFJMSVNUJTdFUmF0ZS0xLnBjX3JlbGV2YW50X2FhJmFtcDtkZXB0aF8xLXV0bV9zb3VyY2U9ZGlzdHJpYnV0ZS5wY19yZWxldmFudC5ub25lLXRhc2stYmxvZy0yJTdFZGVmYXVsdCU3RUNUUkxJU1QlN0VSYXRlLTEucGNfcmVsZXZhbnRfYWEmYW1wO3V0bV9yZWxldmFudF9pbmRleD0y">vector 删除元素的方法</span></p><h2 id="链表"><a class="anchor" href="#链表">#</a> 链表</h2><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是 <strong>非连续</strong> 的</p><p>每一个节点由两部分组成，一个是数据域，另一个是指针域</p><p>链表的入口节点称为头节点，即， <code>head</code></p><h3 id="链表的类型"><a class="anchor" href="#链表的类型">#</a> 链表的类型</h3><h4 id="单链表"><a class="anchor" href="#单链表">#</a> 单链表</h4><p>单链表中，每个节点的指针域存放的是指向下一个节点的指针，最后一个节点的指针域指向  <code>null</code></p><p><img data-src="/posts/b8928e0e/2-1.png" class=""></p><p>单链表的节点对象具有两个成员变量：<strong>值</strong>  <code>val</code>  、 <strong>后继节点指针</strong>  <code>next</code></p><p>单链表中的节点只能指向节点的下一个节点</p><h4 id="双链表"><a class="anchor" href="#双链表">#</a> 双链表</h4><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点</p><p><img data-src="/posts/b8928e0e/2-2.png" class=""></p><p>双链表既可以向前查询，又可以向后查询</p><h4 id="循环链表"><a class="anchor" href="#循环链表">#</a> 循环链表</h4><p>链表首尾相连</p><p><img data-src="/posts/b8928e0e/2-3.png" class=""></p><p>循环链表可以用来解决约瑟夫环问题</p><h3 id="链表的存储方式"><a class="anchor" href="#链表的存储方式">#</a> 链表的存储方式</h3><p>链表在内存空间中的分布并不是连续的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理</p><p>链表通过指针域的指针来链接在内存中的各个节点</p><h3 id="链表的定义"><a class="anchor" href="#链表的定义">#</a> 链表的定义</h3><p>以单链表为例，定义链表的节点：</p><pre><code class="language-cpp">// 单链表struct ListNode &#123;    int val;        // 节点值    ListNode *next; // 后继节点指针    ListNode(int x) : val(x), next(NULL) &#123;&#125; // 节点的构造函数&#125;;// // Definition for singly-linked list.// struct ListNode &#123;//     int val;//     ListNode *next;//     ListNode() : val(0), next(nullptr) &#123;&#125;//     ListNode(int x) : val(x), next(nullptr) &#123;&#125;//     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;// &#125;;</code></pre><p>C++ 默认会生成一个构造函数，但是这个构造函数不会初始化任何成员变量</p><p>如果不自行定义构造函数，而仅仅使用默认构造函数，那么在初始化的时候就不能直接给变量赋值</p><pre><code class="language-cpp">// 自行定义构造函数时节点的初始化操作ListNode* head = new ListNode(5);// 使用默认构造函数时节点的初始化操作ListNode* head = new ListNode();head-&gt;val = 5;</code></pre><p>建立链表需要实例化每个节点，并构建各节点的引用指向</p><p>注：需要用箭头运算符（ <code>-&gt;</code> ），其含义为 解引用 + 成员访问</p><h3 id="链表的操作"><a class="anchor" href="#链表的操作">#</a> 链表的操作</h3><h4 id="删除节点"><a class="anchor" href="#删除节点">#</a> 删除节点</h4><p>以删除 D 节点为例：只要将 C 节点的  <code>next</code>  指针 指向 E 节点即可</p><p><img data-src="/posts/b8928e0e/2-4.png" class="" title="删除节点"></p><p>注意，D 节点依然留在内存中，只不过是没有在这个链表里而已。可以再手动释放这个 D 节点的这块内存</p><h4 id="插入节点"><a class="anchor" href="#插入节点">#</a> 插入节点</h4><p>以插入 F 节点为例：将 C 节点的  <code>next</code>  指针指向 F 节点，并将 F 节点的  <code>next</code>  指针指向 D 节点<br /> <img data-src="/posts/b8928e0e/2-5.png" class="" title="插入节点"></p><p>可以看出链表的增添和删除都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 操作，也不会影响到其他节点</p><p>但是要注意，若要删除第五个节点，需要从头节点查找到第四个节点通过  <code>next</code>  指针进行删除操作，查找的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="性能分析"><a class="anchor" href="#性能分析">#</a> 性能分析</h3><p>链表与数组的特性对比：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">插入 / 删除操作的时间复杂度</th><th style="text-align:center">查询操作的时间复杂度</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">数组</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">数据量固定，频繁查询，较少增删</td></tr><tr><td style="text-align:center">链表</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">数据量不固定，频繁增删，较少查询</td></tr></tbody></table><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFOSU5MyVCRSVFOCVBMSVBOCVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MC5odG1sIyVFNSU4RCU5NSVFOSU5MyVCRSVFOCVBMSVBOA==">代码随想录：链表理论基础</span></p><h2 id="stl"><a class="anchor" href="#stl">#</a> STL</h2><p>STL 是 Standard Template Library 的简称，即，标准模板库</p><p>STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分</p><p>在 C++ 标准中，STL 被组织为下面的 13 个头文件:  <code>&lt;algorithm&gt;</code>  、 <code>&lt;deque&gt;</code>  、 <code>&lt;functional&gt;</code>  、 <code>&lt;iterator&gt;</code>  、 <code>&lt;vector&gt;</code>  、 <code>&lt;list&gt;</code>  、 <code>&lt;map&gt;</code>  、 <code>&lt;memory&gt;</code>  、 <code>&lt;numeric&gt;</code>  、 <code>&lt;queue&gt;</code>  、 <code>&lt;set&gt;</code>  、 <code>&lt;stack&gt;</code>  和  <code>&lt;utility&gt;</code></p><p>STL 的版本很多，其中，三个最为普遍的 STL 版本：</p><ul><li><p>HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。其他版本的 C++ STL 一般是以 HP STL 为蓝本实现出来的。不过，现在已经很少直接使用此版本的 STL 了</p></li><li><p>PJ STL（全称为 P.J. Plauger STL）由 P.J.Plauger 参照 HP STL 实现出来的，是 HP STL 的一个继承版本。PJ STL 被 Visual C++ 编译器所采用，但不是开源的</p></li><li><p>SGI STL 也是 HP STL 的一个继承版本，和 HP STL 一样，SGI STL 也是开源的，其源代码的可读性可非常好。被 Linux 下的 C++ 编译器 GCC 所采用</p></li></ul><p>接下来介绍的 栈 和 队列 也是 SGI STL 里面的数据结构</p><h2 id="栈"><a class="anchor" href="#栈">#</a> 栈</h2><p>栈（stack）是一种具有 <strong>后进先出</strong>（last in first out）特点的抽象数据结构，使用前需要引入  <code>stack</code>  头文件</p><p>栈不提供迭代器，也不允许遍历</p><p>栈依赖于底层容器完成所有工作，对外提供统一的接口。其中，底层容器是可插拔的，即，我们可以控制使用何种容器来实现栈的功能</p><p>因此，在 STL 中，栈往往不被归类为 容器 ，而被归类为 容器适配器（container adapter）</p><p>栈的底层实现可以是  <code>vector</code>  ， <code>deque</code>  ， <code>list</code>  ，主要使用 数组 和 链表 的底层实现。<strong>对于 SGI STL ，如果不指定，则默认使用  <code>deque</code>  作为底层容器</strong></p><blockquote><p><code>deque</code>  是一个双向队列，，只要封住一端、开通另一端，即可实现栈的逻辑</p></blockquote><p>我们可以指定 vector 为栈的底层实现，其初始化语句为：</p><pre><code>std::stack&lt;int, std::vector&lt;int&gt;&gt; stk; // 使用 vector 为底层容器的栈</code></pre><p>栈常用的成员函数：</p><ul><li><p><code>push()</code>  ：在最顶层加入元素</p></li><li><p><code>pop()</code>  ：移除顶层元素</p></li><li><p><code>top()</code>  ：返回最顶层数据的值，但不移除它</p></li><li><p><code>empty()</code>  ：判断栈是否为空</p></li><li><p><code>size()</code>  ：返回栈的大小</p></li></ul><p>须注意：</p><ul><li><p><strong> <code>pop()</code>  没有返回值</strong></p></li><li><p><strong> <code>top()</code>  具有返回值，并且，可以通过  <code>top()</code>  修改栈顶元素值，即， <code>top()</code>  可以作为左值</strong></p></li></ul><p>参考：<span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGFjay9zdGFjay8/a3c9c3RhY2s=">cplusplus：std::stack</span></p><p>如下图所示，通过 <strong>入栈</strong>  <code>push()</code>  ，<strong>出栈</strong>  <code>pop()</code>  ，展示了栈的先入后出特性</p><pre><code class="language-cpp">stack&lt;int&gt; stk;stk.push(1); // 元素 1 入栈stk.push(2); // 元素 2 入栈stk.pop();   // 元素 2 出栈stk.pop();   // 元素 1 出栈</code></pre><p><img data-src="/posts/b8928e0e/3.png" class=""></p><h2 id="队列"><a class="anchor" href="#队列">#</a> 队列</h2><p>队列（queue）是一种具有 <strong>先进先出</strong>（first in first out）特点的抽象数据结构，使用前需先引入  <code>queue</code>  头文件</p><p>队列不提供迭代器，不允许有遍历行为</p><p>STL 队列 也不被归类为 容器 ，而被归类为 容器适配器（container adapter）</p><p>队列的底层实现可以是  <code>deque</code>  和  <code>list</code>  。<strong>对于 SGI STL ，如果不指定，则默认使用  <code>deque</code>  作为底层容器</strong></p><p>可以指定  <code>list</code>  为栈的底层实现，其初始化语句为：</p><pre><code>std::queue&lt;int, std::list&lt;int&gt;&gt; que; // 使用 list 为底层容器</code></pre><p>队列常用的成员函数：</p><ul><li><p><code>push()</code>  ：在队尾插入元素</p></li><li><p><code>pop()</code>  ：移除队首元素</p></li><li><p><code>front()</code>  ：返回队首元素</p></li><li><p><code>back()</code>  ：返回队尾元素</p></li><li><p><code>empty()</code>  ：判断队列是否为空</p></li><li><p><code>size()</code>  ：返回队列中元素的数量</p></li></ul><p>注意：</p><ul><li><strong> <code>pop()</code>  没有返回值</strong></li><li><strong> <code>front()</code>  具有返回值，并且，可以通过  <code>front()</code>  修改队首元素值，即， <code>front()</code>  可以作为左值</strong></li></ul><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9xdWV1ZS9xdWV1ZS8=">cplusplus：std::queue</span></p><p>如下图所示，通过常用操作 <strong>入队</strong>  <code>push()</code>  ，<strong>出队</strong>  <code>pop()</code>  ，展示了队列的先入先出特性</p><pre><code class="language-cpp">queue&lt;int&gt; que;que.push(1); // 元素 1 入队que.push(2); // 元素 2 入队que.pop();   // 出队 -&gt; 元素 1que.pop();   // 出队 -&gt; 元素 2</code></pre><p><img data-src="/posts/b8928e0e/4.png" class=""></p><p>此外， <code>queue</code>  还提供了一些运算符。较为常用的是：使用赋值运算符  <code>=</code>  为  <code>queue</code>  赋值</p><p>例如</p><pre><code class="language-cpp">queue&lt;int&gt; q1, q2;q1.push(1);q2 = q1;cout &lt;&lt; q2.front() &lt;&lt; endl;</code></pre><h3 id="双端队列"><a class="anchor" href="#双端队列">#</a> 双端队列</h3><h3 id="循环队列"><a class="anchor" href="#循环队列">#</a> 循环队列</h3><p>可参考 <span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9kcy9xdWV1ZS8=">OI Wiki：队列</span></p><h2 id="树"><a class="anchor" href="#树">#</a> 树</h2><p>树是一种非线性数据结构，根据子节点数量可分为 <strong>二叉树</strong> 和 <strong>多叉树</strong> ，最顶层的节点称为 <strong>根节点</strong>  <code>root</code></p><p>以二叉树为例，每个节点包含三个成员变量：<strong>值</strong>  <code>val</code>  、<strong>左子节点</strong>  <code>left</code>  、<strong>右子节点</strong>  <code>right</code></p><p>二叉树节点的定义：</p><pre><code class="language-cpp">struct TreeNode &#123;    int val;         // 节点值    TreeNode *left;  // 左子节点    TreeNode *right; // 右子节点    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;</code></pre><p>访问成员变量时需要用箭头运算符（ <code>-&gt;</code> ），其含义为 解引用 + 成员访问</p><p>建立二叉树需要实例化每个节点，并构建各节点的子节点指针</p><p>例如：</p><pre><code class="language-cpp">// 初始化节点TreeNode *n1 = new TreeNode(3); // 根节点 rootTreeNode *n2 = new TreeNode(4);TreeNode *n3 = new TreeNode(5);// 构建子节点指针n1-&gt;left = n2;n1-&gt;right = n3;</code></pre><p>详情可见 <a href="https://jiankychen.github.io/posts/e85d694a">二叉树</a></p><h2 id="堆"><a class="anchor" href="#堆">#</a> 堆</h2><p>堆是一种基于 <strong>完全二叉树</strong> 的数据结构，可使用数组实现</p><p>以堆为原理的排序算法称为 <strong>堆排序</strong> ，基于堆实现的数据结构为 <strong>优先级队列</strong></p><p><strong>优先级队列</strong> ：结点之间的关系是由结点的优先级决定的，而不是由入队的先后次序决定。优先级高的先出队，优先级低的后出队</p><p>堆分为 <strong>最小化堆</strong> 和 <strong>最大化堆</strong></p><ul><li>最大化堆 ：任意节点的值小于等于其父节点的值（根节点最大）</li><li>最小化堆 ：任意节点的值大于等于其父节点的值（根节点最小）</li></ul><p>通过使用 <strong>优先级队列</strong> 的 <strong>压入</strong>  <code>push()</code>  和 <strong>弹出</strong>  <code>pop()</code>  操作，即可完成 <strong>堆排序</strong></p><pre><code class="language-cpp">// 初始化最小化堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;// 元素入堆heap.push(1);heap.push(4);heap.push(2);heap.push(6);heap.push(8);// 元素出堆（从小到大）heap.pop(); // -&gt; 1heap.pop(); // -&gt; 2heap.pop(); // -&gt; 4heap.pop(); // -&gt; 6heap.pop(); // -&gt; 8</code></pre><p>详情可见 <a href="https://jiankychen.github.io/posts/a21107fc">优先级队列</a></p><h2 id="哈希表"><a class="anchor" href="#哈希表">#</a> 哈希表</h2><p>哈希表（Hash table ，也被称为散列表）是根据关键码的值而直接进行访问的数据结构</p><p>哈希表可以近似理解成数组，哈希表中的关键码就是数组的索引下标，通过下标可以直接访问数组的元素</p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合当中</strong></p><h3 id="哈希函数"><a class="anchor" href="#哈希函数">#</a> 哈希函数</h3><p>哈希函数（hash function）以关键码的值为参数，将关键码映射为哈希表的索引，即，函数的值即为存储元素的下标</p><h3 id="哈希碰撞"><a class="anchor" href="#哈希碰撞">#</a> 哈希碰撞</h3><p>哈希碰撞是指：不同的关键码映射到同一个地址</p><p>两种解决方案：</p><ul><li>线性探测法：当散列发生冲突时，探测下一个单元，直到发现一个空单元，于是元素将存储在该空单元</li><li>拉链法：将碰撞的节点组成一个链表</li></ul><h3 id="常见的哈希结构"><a class="anchor" href="#常见的哈希结构">#</a> 常见的哈希结构</h3><p>三种哈希结构</p><ul><li>数组</li><li>set （集合）</li><li>map （映射）</li></ul><p>详情可见 <a href="https://jiankychen.github.io/posts/850f2080">哈希表</a></p><h2 id="图"><a class="anchor" href="#图">#</a> 图</h2><p>图是一种非线性结构，由 <strong>顶点</strong>  <code>vertex</code>  和 <strong>边</strong>  <code>edge</code>  组成</p><p>根据边是否区分方向，图可分为 <strong>有向图</strong> 和 <strong>无向图</strong> ， 这里以无向图为例进行介绍</p><p>如下图所示，此无向图的 顶点 和 边 集合分别为</p><ul><li><p>顶点集合： <code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></p></li><li><p>边集合： <code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;</code></p></li></ul><p><img data-src="/posts/b8928e0e/6.png" class=""></p><p>表示图的方法通常有两种：</p><ol><li><p>邻接矩阵 ：使用数组  <code>vertices</code>  存储顶点，邻接矩阵  <code>edges</code>  存储边。其中， <code>edges[i][j]</code>  表示节点  <code>vertices[i]</code>  和节点  <code>vertices[j]</code>  之间是否有边</p><pre><code class="language-cpp">int vertices[5] = &#123;1, 2, 3, 4, 5&#125;;int edges[5][5] = &#123;&#123;0, 1, 1, 1, 1&#125;,                    &#123;1, 0, 0, 1, 0&#125;,                    &#123;1, 0, 0, 0, 1&#125;,                    &#123;1, 1, 0, 0, 1&#125;,                    &#123;1, 0, 1, 1, 0&#125;&#125;;</code></pre></li><li><p>邻接表 ：使用数组  <code>vertices</code>  存储顶点，邻接表  <code>edges</code>  存储边。其中， <code>edges</code>  是一个二维容器，第一维的 i 代表顶点  <code>vertices[i]</code>  ，第二维  <code>edges[i]</code>  存储顶点  <code>vertices[i]</code>  对应的边集合，例如， <code>edges[0] = [1,2,3,4]</code>  表示  <code>vertices[0]</code>  的边集合为  <code>[1,2,3,4]</code></p><pre><code class="language-cpp">int vertices[5] = &#123;1, 2, 3, 4, 5&#125;;vector&lt;vector&lt;int&gt;&gt; edges;vector&lt;int&gt; edge_1 = &#123;1, 2, 3, 4&#125;;vector&lt;int&gt; edge_2 = &#123;0, 3&#125;;vector&lt;int&gt; edge_3 = &#123;0, 4&#125;;vector&lt;int&gt; edge_4 = &#123;0, 1, 4&#125;;vector&lt;int&gt; edge_5 = &#123;0, 2, 3&#125;;edges.push_back(edge_1);edges.push_back(edge_2);edges.push_back(edge_3);edges.push_back(edge_4);edges.push_back(edge_5);</code></pre></li></ol><blockquote><p>邻接矩阵的大小只与节点数量有关，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为节点数量</p><p>当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费（此时邻接矩阵为稀疏矩阵）</p><p>因此，<strong>邻接表</strong> 适合存储 <strong>顶点较多、边较少</strong> 的 稀疏图 ，<strong>邻接矩阵</strong> 适合存储 <strong>顶点较少、边较多</strong> 的 稠密图</p></blockquote><p>详情可见 <a href="https://jiankychen.github.io/posts/ee040603">图</a></p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9sZWV0Ym9vay9yZWFkL2lsbHVzdHJhdGlvbi1vZi1hbGdvcml0aG0vNTBlNDQ2Lw==">力扣：图解算法数据结构</span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tLw==">cplusplus</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 217. 存在重复元素</title>
      <link href="/posts/2b0a159a/"/>
      <url>/posts/2b0a159a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udGFpbnMtZHVwbGljYXRlLw==">LeetCode 217. Contains Duplicate</span></p><p>给你一个整数数组  <code>nums</code>  。如果任一值在数组中出现 <strong>至少两次</strong> ，返回  <code>true</code>  ；如果数组中每个元素互不相同，返回  <code>false</code>  。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,1]输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,1,1,3,3,4,3,2,4,2]输出：true</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-1-排序"><a class="anchor" href="#method-1-排序">#</a> Method 1: 排序</h2><p>若采取两个循环嵌套进行暴力查找，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，将超出时间限制</p><p>可以先对数组  <code>nums</code>  进行排序，检查相邻两元素是否相等</p><pre><code class="language-cpp">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end());    int n = nums.size();    for (int i = 0; i &lt; n - 1; i++) &#123;        if (nums[i] == nums[i + 1]) return true;    &#125;    return false;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为数组长度。因为需要对数组排序</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为数组长度。注意我们在这里应当考虑递归调用栈的深度</p><h2 id="method-2-哈希表-set"><a class="anchor" href="#method-2-哈希表-set">#</a> Method 2: 哈希表 set</h2><p>可以尝试将数组中每个元素都插入到哈希表  <code>unordered_set</code>  中：如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素</p><pre><code class="language-cpp">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;    unordered_set&lt;int&gt; set;    for (auto c : set) &#123; // c 是 int 型        if (set.find(c) != set.end()) return true;  // 找到 c 的位置不在尾后，即，哈希表中存在元素 c        set.insert(c);   // 将 c 插入到哈希表中    &#125;    return false;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为数组的长度</p><h2 id="method-3-哈希表-map"><a class="anchor" href="#method-3-哈希表-map">#</a> Method 3: 哈希表 map</h2><p>也可以直接用  <code>unordered_map</code>  容器统计每一个元素出现的次数，然后遍历整个  <code>unordered_map</code>  容器查看是否有元素出现的次数大于等于 2</p><pre><code class="language-cpp">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;    unordered_map&lt;int,int&gt; map;    for(int num : nums) &#123;        map[num]++;        if(map[num] &gt;= 2) return true;    &#125;    return false;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度</title>
      <link href="/posts/7db09267/"/>
      <url>/posts/7db09267/</url>
      
        <content type="html"><![CDATA[<p>算法复杂度旨在描述 输入数据量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 时，算法的 <strong>时间使用</strong> 和 <strong>空间使用</strong> 情况</p><ul><li><p><strong>时间</strong>：假设各操作的运行时间为固定常数，统计算法运行的 <strong>计算操作的数量</strong> ，以代表算法运行所需时间</p></li><li><p><strong>空间</strong>：统计在<strong>最差情况下</strong> ，算法运行所需使用的 <strong>最大空间</strong></p></li></ul><p>输入数据大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 指算法处理的输入数据量，根据不同算法，具有不同的定义，例如：</p><ul><li><strong>排序算法</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 代表需要排序的元素数量</li><li><strong>搜索算法</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 代表搜索范围的元素总数，例如数组大小、矩阵大小、二叉树节点数、图节点和边数等</li></ul><h1 id="时间复杂度"><a class="anchor" href="#时间复杂度">#</a> 时间复杂度</h1><p>统计的是算法的 <strong>计算操作数量</strong> ，而不是 运行的绝对时间</p><blockquote><p>计算操作数量 和 运行绝对时间 呈正相关关系，并不相等。算法运行时间受到「编程语言 、计算机处理器速度、运行环境」等多种因素影响。</p></blockquote><p>体现的是计算操作随数据大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 变化时的变化情况。假设算法运行总共需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次操作、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次操作，此两情况的时间复杂度都为常数级 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次操作、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">100N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次操作 的时间复杂度都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><h2 id="符号表示"><a class="anchor" href="#符号表示">#</a> 符号表示</h2><p>时间复杂度具有 <strong>最差</strong>、<strong>平均</strong>、<strong>最佳</strong> 三种情况，分别使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span> 三种符号表示</p><p>题目：输入长度为  <code>N</code>  的整数数组  <code>nums</code> ，判断此数组中是否有数字  <code>7</code> ，若有则返回  <code>true</code> ，否则返回  <code>false</code></p><p>解题算法：线性查找，即遍历整个数组，遇到  <code>7</code>  则返回  <code>true</code></p><p>代码：</p><pre><code class="language-cpp">bool findSeven(vector&lt;int&gt;&amp; nums) &#123;    for (int num : nums) &#123;        if (num == 7)            return true;    &#125;    return false;&#125;</code></pre><p><strong>最佳情况</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>：当数组首个数字为  <code>7</code>  时，无论  <code>nums</code>  有多少元素，线性查找的循环次数都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次</p><p><strong>最差情况</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>： <code>nums</code>  中所有数字都不为  <code>7</code> ，此时线性查找会遍历整个数组，循环  <code>N</code>  次</p><p><strong>平均情况</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>：需要考虑输入数据的分布情况，计算所有数据情况下的平均时间复杂度。例如本题，需要考虑数组长度、数组元素的取值范围等</p><h2 id="常见种类"><a class="anchor" href="#常见种类">#</a> 常见种类</h2><p>根据从小到大排列，常见的算法时间复杂度主要有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1) &lt; O(\log N) &lt; O(N) &lt; O(N \log N) &lt; O(N^2) &lt; O(2^N) &lt; O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></span></p><p><img data-src="/posts/7db09267/1.png" class="" title="算法时间复杂度常见种类"></p><h2 id="示例解析"><a class="anchor" href="#示例解析">#</a> 示例解析</h2><p>对于以下所有示例，设输入数据大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，计算操作数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span> 。图中每个「蓝色方块」代表一个单元计算操作。</p><h3 id="常数-o1"><a class="anchor" href="#常数-o1">#</a> 常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h3><p>运行次数与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 大小呈常数关系，即不随输入数据大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的变化而变化</p><pre><code class="language-cpp">int algorithm(int N) &#123;    int a = 1;    int b = 2;    int x = a * b + N;    return 1;&#125;</code></pre><p>对于以下代码，无论 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 取多大，都与输入数据大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 无关，因此时间复杂度仍为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">int algorithm(int N) &#123;    int count = 0;    int a = 10000;    for (int i = 0; i &lt; a; i++) &#123;        count++;    &#125;    return count;&#125;</code></pre><p><img data-src="/posts/7db09267/2.png" class="" title="$O(1)$ 时间复杂度"></p><h3 id="线性-on"><a class="anchor" href="#线性-on">#</a> 线性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>循环运行次数与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 大小呈线性关系，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">int algorithm(int N) &#123;    int count = 0;    for (int i = 0; i &lt; N; i++)        count++;    return count;&#125;</code></pre><p>之前一个例子的循环次数并不随 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 改变，而这里的循环次数会随 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 变化</p><p>对于以下代码，虽然是两层循环，但第二层与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 大小无关，因此整体仍与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系</p><pre><code class="language-cpp">int algorithm(int N) &#123;    int count = 0;    int a = 10000;    for (int i = 0; i &lt; N; i++) &#123;        for (int j = 0; j &lt; a; j++) &#123;            count++;        &#125;    &#125;    return count;&#125;</code></pre><p><img data-src="/posts/7db09267/3.png" class="" title="$O(N)$ 时间复杂度"></p><h3 id="平方-on2"><a class="anchor" href="#平方-on2">#</a> 平方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>两层循环相互独立，都与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系，因此总体与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 呈平方关系</p><pre><code class="language-cpp">int algorithm(int N) &#123;    int count = 0;    for (int i = 0; i &lt; N; i++) &#123;        for (int j = 0; j &lt; N; j++) &#123;            count++;        &#125;    &#125;    return count;&#125;</code></pre><p>以 <strong>冒泡排序</strong> 为例，其包含两层独立循环：</p><ul><li>第一层复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；</li><li>第二层平均循环次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，推导过程如下：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\frac{N}{2}) = O(\frac{1}{2})O(N) = O(1)O(N) = O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p><p>因此，冒泡排序的总体时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，代码如下所示</p><pre><code class="language-cpp">vector&lt;int&gt; bubbleSort(vector&lt;int&gt;&amp; nums) &#123;    int N = nums.size();    for (int i = 0; i &lt; N - 1; i++) &#123;        for (int j = 0; j &lt; N - 1 - i; j++) &#123;            if (nums[j] &gt; nums[j + 1]) &#123;                swap(nums[j], nums[j + 1]);            &#125;        &#125;    &#125;    return nums;&#125;</code></pre><p><img data-src="/posts/7db09267/4.png" class="" title="$O(N^2)$ 时间复杂度"></p><h3 id="指数-o2n"><a class="anchor" href="#指数-o2n">#</a> 指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>生物学科中的 “细胞分裂” 即是指数级增长</p><p>算法中，指数阶常出现于 <strong>递归</strong> ，算法原理图与代码如下所示</p><pre><code class="language-cpp">int algorithm(int N) &#123;    if (N &lt;= 0) return 1;    int count_1 = algorithm(N - 1);    int count_2 = algorithm(N - 1);    return count_1 + count_2;&#125;</code></pre><p><img data-src="/posts/7db09267/5.png" class="" title="$O(2^N)$ 时间复杂度"></p><h3 id="阶乘-on"><a class="anchor" href="#阶乘-on">#</a> 阶乘 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h3><p>阶乘阶对应数学上常见的 “全排列”</p><p>如下图与代码所示，阶乘常使用 <strong>递归</strong> 实现，算法原理：第一层分裂出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个，第二层分裂出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个，…… ，直至到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 层时终止并回溯</p><pre><code class="language-cpp">int algorithm(int N) &#123;    if (N &lt;= 0) return 1;    int count = 0;    for (int i = 0; i &lt; N; i++) &#123;        count += algorithm(N - 1);    &#125;    return count;&#125;</code></pre><p><img data-src="/posts/7db09267/6.png" class="" title="$O(N!)$ 时间复杂度"></p><h3 id="对数-olog-n"><a class="anchor" href="#对数-olog-n">#</a> 对数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>对数阶与指数阶相反，指数阶为 “每轮分裂出两倍的情况” ，而对数阶是 “每轮排除一半的情况” 。对数阶常出现于 <strong>二分法</strong> 、<strong>分治</strong> 等算法中，体现着 “一分为二” 或 “一分为多” 的算法思想</p><p>设循环次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> ，则输入数据大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 呈线性关系，两边同时取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span> 对数，则得到循环次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系，即时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">int algorithm(int N) &#123;    int count = 0;    float i = N;    while (i &gt; 1) &#123;        i = i / 2;        count++;    &#125;    return count;&#125;</code></pre><p>如以下代码所示，对于不同 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 的取值，循环次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_a N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_a N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。无论底数 a 取值，时间复杂度都可以记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_a N) = \frac{O(\log_2 N)}{O(\log_2 a)} = O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p><pre><code class="language-cpp">int algorithm(int N) &#123;    int count = 0;    float i = N;    int a = 3;    while (i &gt; 1) &#123;        i = i / a;        count++;    &#125;    return count;&#125;</code></pre><p>如下图所示，为二分查找的时间复杂度示意图，每次二分将搜索区间缩小一半，二分的次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p><img data-src="/posts/7db09267/7.png" class="" title="$O(\log N)$ 时间复杂度"></p><h3 id="线性对数-on-log-n"><a class="anchor" href="#线性对数-on-log-n">#</a> 线性对数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>两层循环相互独立，第一层和第二层时间复杂度分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，则总体时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">int algorithm(int N) &#123;    int count = 0;    float i = N;    while (i &gt; 1) &#123;        i = i / 2;        for (int j = 0; j &lt; N; j++)            count++;    &#125;    return count;&#125;</code></pre><p>线性对数阶常出现于排序算法，例如 <strong>快速排序</strong> 、<strong>归并排序</strong> 、<strong>堆排序</strong> 等，其时间复杂度原理如下图所示</p><p><img data-src="/posts/7db09267/8.png" class="" title="$O(N \log N)$ 时间复杂度"></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU4OSU4RCVFNSVCQSU4Ri9PbiVFNyU5QSU4NCVFNyVBRSU5NyVFNiVCMyU5NSVFNSVCMSU4NSVFNyU4NCVCNiVFOCVCNiU4NSVFNiU5NyVCNiVFNCVCQSU4NiVFRiVCQyU4QyVFNiVBRCVBNCVFNiU5NyVCNiVFNyU5QSU4NG4lRTclQTklQjYlRTclQUIlOUYlRTYlOTglQUYlRTUlQTQlOUElRTUlQTQlQTclRUYlQkMlOUYuaHRtbCMlRTUlODElOUElRTQlQjglQUElRTYlQjUlOEIlRTglQUYlOTUlRTUlQUUlOUUlRTklQUElOEM=">代码随想录：估计计算机在 1s 内能执行多少次操作：</span><br /><img data-src="AL-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%5Ctest.png" alt="" /></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU4OSU4RCVFNSVCQSU4Ri8lRTklODAlOUElRTglQkYlODclRTQlQjglODAlRTklODElOTMlRTklOUQlQTIlRTglQUYlOTUlRTklQTIlOTglRTclOUIlQUUlRUYlQkMlOEMlRTglQUUlQjIlRTQlQjglODAlRTglQUUlQjIlRTklODAlOTIlRTUlQkQlOTIlRTclQUUlOTclRTYlQjMlOTUlRTclOUElODQlRTYlOTclQjYlRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYlRUYlQkMlODEuaHRtbA==">代码随想录：递归算法的时间复杂度分析</span></p><h1 id="空间复杂度"><a class="anchor" href="#空间复杂度">#</a> 空间复杂度</h1><p>空间复杂度涉及的空间类型有：</p><ul><li><p><strong>输入空间</strong> ：存储输入数据所需的空间大小</p></li><li><p><strong>暂存空间</strong> ：算法运行过程中，存储所有中间变量和对象等数据所需的空间大小</p></li><li><p><strong>输出空间</strong> ：算法运行返回时，存储输出数据所需的空间大小</p></li></ul><p>通常情况下，空间复杂度指在输入数据大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 时，算法运行所使用的 <strong>暂存空间 + 输出空间</strong> 的总体大小</p><p><img data-src="/posts/7db09267/9.png" class="" title="空间类型"></p><p>根据不同来源，算法使用的内存空间分为三类：</p><ol><li><p><strong>指令空间</strong> ：编译后，程序指令所使用的内存空间</p></li><li><p><strong>数据空间</strong> ：算法中的各项变量使用的空间，包括：声明的常量、变量、动态数组、动态对象等使用的内存空间</p><pre><code class="language-cpp">struct Node &#123;    int val;    Node *next;    Node(int x) : val(x), next(NULL) &#123;&#125;&#125;;void algorithm(int N) &#123;    int num = N;              // 变量    int nums[N];              // 动态数组    Node* node = new Node(N); // 动态对象&#125;```</code></pre></li><li><p><strong>栈帧空间</strong> ：程序 <strong>调用函数</strong> 是基于 <strong>栈</strong> 实现的，函数在调用期间，占用常量大小的栈帧空间，直至返回后释放。如以下代码所示，在循环中调用函数，每轮调用  <code>test()</code>  返回后，栈帧空间已被释放，因此空间复杂度仍为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">int test() &#123;    return 0;&#125;void algorithm(int N) &#123;    for (int i = 0; i &lt; N; i++) &#123;        test();    &#125;&#125;</code></pre><p>算法中，<strong>栈帧空间的累计常出现于递归调用</strong> 。如以下代码所示，通过递归调用，会同时存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个未返回的函数  <code>algorithm()</code>  ，此时累计使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 大小的栈帧空间</p><pre><code class="language-cpp">int algorithm(int N) &#123;    if (N &lt;= 1) return 1;    return algorithm(N - 1) + 1;&#125;</code></pre></li></ol><h2 id="符号表示-2"><a class="anchor" href="#符号表示-2">#</a> 符号表示</h2><p>通常情况下，空间复杂度统计 <strong>算法在 “最差情况” 下使用的空间大小</strong> ，以体现算法运行所需预留的空间量，使用符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 表示</p><p>最差情况有两层含义，分别为 <strong>最差输入数据</strong> 、算法运行中的 <strong>最差运行点</strong></p><p>例如以下代码：输入整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，取值范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><pre><code class="language-cpp">void algorithm(int N) &#123;    int num = 5;           // O(1)    vector&lt;int&gt; nums(10);  // O(1)    if (N &gt; 10) &#123;        nums.resize(N);    // O(N)    &#125;&#125;</code></pre><ul><li><strong>最差输入数据</strong> ：当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">N \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 时，数组  <code>nums</code>  的长度恒定为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> ，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>O</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(10) = O(1) O(10) = O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&gt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">N &gt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 时，数组  <code>nums</code>  长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。因此，空间复杂度应为最差输入数据情况下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><strong>最差运行点</strong> ：在执行  <code>nums(10)</code>  时，算法仅使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 大小的空间；而当执行  <code>nums.resize(N)</code>  时，算法使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的空间；因此，空间复杂度应为最差运行点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="常见种类-2"><a class="anchor" href="#常见种类-2">#</a> 常见种类</h2><p>根据从小到大排列，常见的算法空间复杂度有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1) &lt; O(\log N) &lt; O(N) &lt; O(N^2) &lt; O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><img data-src="/posts/7db09267/10.png" class="" title="算法空间复杂度常见种类"></p><h2 id="示例解析-2"><a class="anchor" href="#示例解析-2">#</a> 示例解析</h2><p>对于以下所有示例，设输入数据大小为正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，节点类  <code>Node</code>  、函数  <code>test()</code>  如以下代码所示</p><pre><code class="language-cpp">// 节点类 Nodestruct Node &#123;    int val;    Node *next;    Node(int x) : val(x), next(NULL) &#123;&#125;&#125;;// 函数 test()int test() &#123;    return 0;&#125;</code></pre><h3 id="常数-o1-2"><a class="anchor" href="#常数-o1-2">#</a> 常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h3><p>普通常量、变量、对象、元素数量与输入数据大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 无关的集合，皆使用常数大小的空间</p><pre><code class="language-cpp">void algorithm(int N) &#123;    int num = 0;    int nums[10000];    Node* node = new Node(0);    unordered_map&lt;int, string&gt; dic;    dic.emplace(0, &quot;0&quot;);&#125;</code></pre><p>如以下代码所示，虽然函数  <code>test()</code>  调用了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次，但每轮调用后  <code>test()</code>  已返回，无累计栈帧空间使用，因此空间复杂度仍为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">void algorithm(int N) &#123;    for (int i = 0; i &lt; N; i++) &#123;        test();    &#125;&#125;</code></pre><h3 id="线性-on-2"><a class="anchor" href="#线性-on-2">#</a> 线性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>元素数量与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系的任意类型集合（常见于 <strong>一维数组</strong> 、<strong>链表</strong> 、<strong>哈希表</strong> 等），皆使用线性大小的空间</p><pre><code class="language-cpp">void algorithm(int N) &#123;    int nums_1[N];    int nums_2[N / 2 + 1];    vector&lt;Node*&gt; nodes;    for (int i = 0; i &lt; N; i++) &#123;        nodes.push_back(new Node(i));    &#125;    unordered_map&lt;int, string&gt; dic;    for (int i = 0; i &lt; N; i++) &#123;        dic.emplace(i, to_string(i));    &#125;&#125;</code></pre><p>如下图与代码所示，此递归调用期间，会同时存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个未返回的  <code>algorithm()</code>  函数，因此使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 大小的栈帧空间</p><pre><code class="language-cpp">int algorithm(int N) &#123;    if (N &lt;= 1) return 1;    return algorithm(N - 1) + 1;&#125;</code></pre><p><img data-src="/posts/7db09267/11.png" class="" title="$O(N)$ 空间复杂度"></p><h3 id="平方-on2-2"><a class="anchor" href="#平方-on2-2">#</a> 平方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>元素数量与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 呈平方关系的任意类型集合（常见于矩阵），皆使用平方大小的空间</p><pre><code class="language-cpp">void algorithm(int N) &#123;    vector&lt;vector&lt;int&gt;&gt; num_matrix;    for (int i = 0; i &lt; N; i++) &#123;        vector&lt;int&gt; nums;        for (int j = 0; j &lt; N; j++) &#123;            nums.push_back(0);        &#125;        num_matrix.push_back(nums);    &#125;    vector&lt;vector&lt;Node*&gt;&gt; node_matrix;    for (int i = 0; i &lt; N; i++) &#123;        vector&lt;Node*&gt; nodes;        for (int j = 0; j &lt; N; j++) &#123;            nodes.push_back(new Node(j));        &#125;        node_matrix.push_back(nodes);    &#125;&#125;</code></pre><p>如下图与代码所示，递归调用时同时存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个未返回的  <code>algorithm()</code>  函数，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 栈帧空间；每层递归函数中声明了数组，平均长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 空间；因此总体空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">int algorithm(int N) &#123;    if (N &lt;= 0) return 0;    int nums[N];    return algorithm(N - 1);&#125;</code></pre><p><img data-src="/posts/7db09267/12.png" class="" title="$O(N^2)$ 空间复杂度"></p><h3 id="指数-o2n-2"><a class="anchor" href="#指数-o2n-2">#</a> 指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>指数阶常见于 <strong>二叉树</strong> 、<strong>多叉树</strong></p><p>例如，高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的 满二叉树（perfect binary tree） 的节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> ，占用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 大小的空间；同理，高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的 满 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 叉树 的节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">m^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> ，占用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mi>N</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m^N) = O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 大小的空间</p><p><img data-src="/posts/7db09267/13.png" class="" title="$O(2^N)$ 空间复杂度"></p><h3 id="对数-olog-n-2"><a class="anchor" href="#对数-olog-n-2">#</a> 对数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>对数阶常出现于分治算法的栈帧空间累计、数据类型转换等，例如：</p><ul><li><strong>快速排序</strong> ，平均空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，最差空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。拓展知识：通过应用 <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzEwOTc0L3doYXQtaXMtdGFpbC1jYWxsLW9wdGltaXphdGlvbg==">Tail Call Optimization</span> ，可以将快速排序的最差空间复杂度限定至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><strong>数字转化为字符串</strong> ，设某正整数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，则字符串的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。推导如下：正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的位数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>10</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_{10} N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，即转化的字符串长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>10</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_{10} N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，因此空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU4OSU4RCVFNSVCQSU4Ri8lRTklODAlOTIlRTUlQkQlOTIlRTclQUUlOTclRTYlQjMlOTUlRTclOUElODQlRTYlOTclQjYlRTklOTclQjQlRTQlQjglOEUlRTclQTklQkElRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYlRTUlODglODYlRTYlOUUlOTAuaHRtbCMlRTklODAlOTIlRTUlQkQlOTIlRTYlQjElODIlRTYlOTYlOTAlRTYlQjMlQTIlRTklODIlQTMlRTUlQTUlOTElRTYlOTUlQjAlRTUlODglOTclRTclOUElODQlRTYlODAlQTclRTglODMlQkQlRTUlODglODYlRTYlOUUlOTA=">代码随想录：递归算法的性能分析</span></p><h1 id="时空权衡"><a class="anchor" href="#时空权衡">#</a> 时空权衡</h1><p>优良的算法应具备两个特性，即时间和空间复杂度皆较低</p><p>实际上，对于某个算法问题，同时优化时间复杂度和空间复杂度是非常困难的。降低时间复杂度，往往是以提升空间复杂度为代价的，反之亦然</p><blockquote><p>由于当代计算机的内存充足，<em>通常情况下</em>，算法设计中一般会采取「空间换时间」的做法，即 <strong>牺牲部分计算机存储空间，来提升算法的运行速度</strong></p></blockquote><p>以 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">LeetCode 1. 两数之和</span> 为例，暴力枚举 和 辅助哈希表 分别为 空间最优 和 时间最优 的两种算法</p><p>注：以上内容来自于 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vbGVldGJvb2svcmVhZC9pbGx1c3RyYXRpb24tb2YtYWxnb3JpdGhtL3I4eXRvZy8=">https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r8ytog/</span></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 116. 填充每个节点的下一个右侧节点指针</title>
      <link href="/posts/33b5a27e/"/>
      <url>/posts/33b5a27e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcG9wdWxhdGluZy1uZXh0LXJpZ2h0LXBvaW50ZXJzLWluLWVhY2gtbm9kZS8=">LeetCode 116. Populating Next Right Pointers in Each Node</span></p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code>// Definition for a Node.class Node &#123;public:    int val;    Node* left;    Node* right;    Node* next;    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val, Node* _left, Node* _right, Node* _next)        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;</code></pre><p>填充它的每个  <code>next</code>  指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将  <code>next</code>  指针设置为  <code>NULL</code> 。</p><p>初始状态下，所有  <code>next</code>  指针都被设置为  <code>NULL</code> 。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/33b5a27e/1.png" class=""></p><pre><code>输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数量在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>12</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2^{12} - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h1 id="method-1-层序遍历"><a class="anchor" href="#method-1-层序遍历">#</a> Method 1: 层序遍历</h1><p>类似于 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a></p><p>算法思路：</p><ul><li>逐层遍历、每层按从左到右顺序遍历，利用队列存放待访问的节点</li><li>在遍历过程中，将 节点的  <code>next</code>  指针 指向 同一层的后一个节点（即，指向 队列的下一个元素）</li></ul><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;    queue&lt;Node*&gt; que;    if (root) que.push(root);    while (!que.empty()) &#123;        int size = que.size();        for (int i = 0; i &lt; size; i++) &#123;            Node* cur = que.front();            que.pop();            if (i &lt; size - 1) cur-&gt;next = que.front(); // 除最右侧节点外，每个节点的 next 指针均指向右侧节点            if (cur-&gt;left) que.push(cur-&gt;left);            if (cur-&gt;right) que.push(cur-&gt;right);        &#125;    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="method-2-使用已建立的-next-指针"><a class="anchor" href="#method-2-使用已建立的-next-指针">#</a> Method 2: 使用已建立的 next 指针</h1><p>算法思路：</p><p>本题的二叉树为满二叉树，每一层的节点都是满的。针对满二叉树而言， <code>next</code>  指针的连接方式有两种类型：</p><ul height="200px"><li height="200px"><p>所连接的两个节点具有共同的父节点</p><p><img data-src="/posts/33b5a27e/connection1.jpg" class="" title="Connection 1"></p></li><li><p>所连接的两个节点具有不同的父节点，但他们的父节点通过  <code>next</code>  指针连接</p><p><img data-src="/posts/33b5a27e/connection2.jpg" class="" title="Connection 2"></p></li></ul><p>算法流程：</p><ol><li><p>定义  <code>pre</code>  指向根节点，即，令  <code>pre = root</code></p></li><li><p>遍历二叉树的每一层，即，执行以下循环，循环条件是  <code>pre-&gt;left</code>  不为空：</p><ul><li>定义  <code>cur</code>  指向  <code>pre</code>  所在层的节点，初始时指向  <code>pre</code></li><li>遍历  <code>cur</code>  ，建立  <code>cur</code>  下一层节点的  <code>next</code>  指针：<ul><li>若  <code>cur</code>  的左子节点不为空，则右子节点必不为空，通过  <code>cur-&gt;left-&gt;next = cur-&gt;right</code>  连接  <code>cur</code>  的两个子节点</li><li>若  <code>cur</code>  的左子节点不为空 且  <code>cur</code>  的  <code>next</code>  指针不为空，通过  <code>cur-&gt;right-&gt;next = cur-&gt;next-&gt;left</code>  连接  <code>cur</code>  的右子节点与  <code>cur-&gt;next</code>  的左子节点</li><li><code>cur</code>  向右移动，即，更新  <code>cur = cur-&gt;next</code></li></ul></li><li>完成当前层的连接后，进入下一层重复操作，即  <code>pre</code>  向下移动（更新  <code>pre = pre-&gt;left</code>  ）</li></ul></li></ol><p><img data-src="https://pic.leetcode-cn.com/eef065800417742831e8702ef7b45ccb082afa3782470af81491d2b4b6046f40-5.gif" alt="示意图" height="200px" /></p><blockquote><p>需要注意：</p><ul><li><code>pre</code>  表示的是  <code>pre</code>  所在层的最左侧节点</li><li>遍历  <code>cur</code>  时， <code>cur</code>  所在层节点的  <code>next</code>  指针均已建立完成，此时建立的是下一层节点的  <code>next</code>  指针</li></ul></blockquote><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;    if (root == nullptr) return root;    Node* pre = root;    while (pre-&gt;left != nullptr) &#123; // 遍历二叉树的每一层        Node* cur = pre;        while (cur != nullptr) &#123; // 遍历 pre 所在层的节点，建立下一层节点的 next 指针                                 // 注意，外层的 while 循环已确保 cur 的下一层不为空            cur-&gt;left-&gt;next = cur-&gt;right;           // 连接同一个父节点的两个子节点            if (cur-&gt;next != nullptr)                cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; // 连接不同父节点之间子节点            cur = cur-&gt;next;     // 向右移动        &#125;        pre = pre-&gt;left;         // 向下一层移动    &#125;    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每个节点只访问一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不需要额外空间用于存储</p><blockquote><p>以上算法可改写成递归算法（即，深度优先搜索）</p></blockquote><p>递归法的代码实现：</p><pre><code class="language-cpp">void DFS(Node* root) &#123; // 更新 root 左右子节点的 next 指针    if (root == nullptr || root-&gt;left == nullptr) return;    root-&gt;left-&gt;next = root-&gt;right;    if (root-&gt;next != nullptr)        root-&gt;right-&gt;next = root-&gt;next-&gt;left;    DFS(root-&gt;left);    DFS(root-&gt;right);&#125;Node* connect(Node* root) &#123;    DFS(root);    return root;&#125;</code></pre><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDIuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU1JUIxJTgyJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2Lmh0bWwjXzExNi0lRTUlQTElQUIlRTUlODUlODUlRTYlQUYlOEYlRTQlQjglQUElRTglOEElODIlRTclODIlQjklRTclOUElODQlRTQlQjglOEIlRTQlQjglODAlRTQlQjglQUElRTUlOEYlQjMlRTQlQkUlQTclRTglOEElODIlRTclODIlQjklRTYlOEMlODclRTklOTIlODg=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlL3NvbHV0aW9uL3RpYW4tY2hvbmctbWVpLWdlLWppZS1kaWFuLWRlLXhpYS15aS1nZS15b3UtY2UtMi00Lw==">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktc2FuLWNob25nLXNoaS14aWFuLTExNi10aWFuLWNob25nLw==">wang_ni_ma：动画演示 + 三种实现</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 617. 合并二叉树</title>
      <link href="/posts/113bbac/"/>
      <url>/posts/113bbac/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLWJpbmFyeS10cmVlcy8=">LeetCode 617. Merge Two Binary Trees</span></p><p>给你两棵二叉树： <code>root1</code>  和  <code>root2</code>  。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意：</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img data-src="/posts/113bbac/1.jpg" class=""></p><pre><code>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root1 = [1], root2 = [1,2]输出：[2,2]</code></pre><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h1><p>算法思路：</p><ol><li><p>确定递归的参数和返回值</p><ul><li>参数：两棵二叉树的根节点  <code>root1</code>  和  <code>root2</code></li><li>返回值：合并后的根节点</li></ul></li><li><p>递归终止条件</p><ul><li>若  <code>root1</code>  为空，合并结果即为  <code>root2</code>  ，返回  <code>root2</code></li><li>若  <code>root2</code>  为空，合并结果即为  <code>root1</code>  ，返回  <code>root1</code></li></ul></li><li><p>单层递归的逻辑</p><ul><li>合并节点：计算  <code>root1-&gt;val</code>  和  <code>root2-&gt;val</code>  的和</li><li>递归，合并左子树</li><li>递归，合并右子树</li><li>返回合并结果</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;    if (!root1) return root2;    if (!root2) return root1;    TreeNode *root = new TreeNode();    root-&gt;val = root1-&gt;val + root2-&gt;val; // 合并节点    root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left); // 递归，合并左子树    root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right); // 递归，合并右子树    return root;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别是两个二叉树的节点数</p><ul><li>对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><ul><li>递归调用的层数不会超过较小二叉树的高度，最坏情况下，二叉树的高度等于节点数</li></ul><p>参考：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA2MTcuJUU1JTkwJTg4JUU1JUI5JUI2JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录：合并二叉树</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzL3NvbHV0aW9uL2hlLWJpbmctZXItY2hhLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：合并二叉树</span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a/"/>
      <url>/posts/e85d694a/</url>
      
        <content type="html"><![CDATA[<p>树：用来模拟具有树状结构性质的数据集合</p><p>二叉树 （Binary Tree）：每个节点 最多有两个子树 的树结构，通常子树被称作 “左子树” 和 “右子树”</p><blockquote><p>注意：二叉树必须严格区分左右子树，即使只有一棵子树，也要说明它是左子树还是右子树</p></blockquote><h1 id="二叉树的种类"><a class="anchor" href="#二叉树的种类">#</a> 二叉树的种类</h1><h2 id="满二叉树"><a class="anchor" href="#满二叉树">#</a> 满二叉树</h2><p>满二叉树：一棵高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 并具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个节点的二叉树</p><p><img data-src="https://img-blog.csdnimg.cn/20200806185805576.png" alt="" /></p><h2 id="完全二叉树"><a class="anchor" href="#完全二叉树">#</a> 完全二叉树</h2><p>完全二叉树：在满二叉树的最底层自右至左依次（注意：不能跳过任何一个节点）去掉若干个节点得到的二叉树</p><p><img data-src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="完全二叉树的示例" /></p><p>完全二叉树的特点：</p><ul><li>所有的叶节点都出现在最低的两层上</li><li>对任一节点，如果其右子树的高度为 k ，则其左子树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><blockquote><p>满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树</p></blockquote><p>优先队列（堆）就是一棵完全二叉树，并保证了父子节点的顺序关系</p><h2 id="二叉搜索树"><a class="anchor" href="#二叉搜索树">#</a> 二叉搜索树</h2><p>二叉搜索树，也叫作 二叉树查找树 或者 二叉排序树</p><p>二叉搜索树的性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值</li><li>左、右子树也分别为二叉排序树</li></ul><p>即，在二叉搜索树中，左子树都比其根节点小，右子树都比其根节点大，递归定义</p><p>二叉搜索树 的 <strong>中序遍历</strong> 一定是 <strong>从小到大排序</strong> 的</p><p><img data-src="https://img-blog.csdnimg.cn/20200806190304693.png" alt="二叉搜索树" /></p><p>二叉搜索树的搜索性能：</p><ul><li>最好情况下，二叉搜索树的查找效率比较高，是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，其访问性能近似于二分法</li><li>最差情况下，例如插入的元素有序时，生成的二叉搜索树将会是一个链表，搜索的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="平衡二叉树"><a class="anchor" href="#平衡二叉树">#</a> 平衡二叉树</h2><p>平衡二叉树，又被称为 AVL（Adelson-Velsky and Landis）树，是二叉搜索树的一种实现</p><p>平衡二叉树要么是一棵空树，要么保证左右子树的高度差不超过 1，并且左右子树也都必须是一棵平衡二叉树</p><p>平衡二叉树的提出就是为了避免二叉搜索树出现极端情况</p><p><img data-src="https://img-blog.csdnimg.cn/20200806190511967.png" alt="平衡二叉树" /></p><p>平衡二叉树的性能：平衡二叉树在添加和删除时需要进行复杂的旋转保持整个树的平衡，最终，插入、查找的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><p>著名的红黑树就是一种平衡二叉树</p><p>C++ 中， <code>map</code> 、 <code>set</code> 、 <code>multimap</code> 、 <code>multiset</code>  的底层实现都是平衡二叉树</p><h1 id="二叉树的遍历"><a class="anchor" href="#二叉树的遍历">#</a> 二叉树的遍历</h1><p>二叉树有两类遍历方式：深度优先遍历 与 广度优先遍历</p><h2 id="深度优先遍历"><a class="anchor" href="#深度优先遍历">#</a> 深度优先遍历</h2><p>深度优先遍历 可分为：前序遍历、中序遍历、后序遍历</p><ul><li><p><strong>前序遍历</strong> ：首先访问 / 处理根节点，然后访问 / 处理左子树，最后访问 / 处理右子树</p></li><li><p><strong>中序遍历</strong> ：先访问 / 处理左子树，然后处理根节点，然后访问 / 处理右子树</p></li><li><p><strong>后序遍历</strong> ：先访问 / 处理左子树，然后访问 / 处理右子树，最后处理树的根节点</p></li></ul><blockquote><p>严格来说，遍历时一定是先访问根节点，然后根据根节点访问左子节点、右子节点，所谓的 前序、中序、后序遍历 讲的是处理根节点（即，do something with root）的顺序。例如，对于中序遍历，根节点的处理是在处理完左子节点之后才进行的。可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy9zb2x1dGlvbi90dS1qaWUtZXItY2hhLXNodS1kZS1zdW8teW91LWx1LWppbmctYnkteGlhb19iZW5fei8=">前、中、后序遍历的区别</span></p></blockquote><p>前、中、后序遍历只针对于根节点，而左右子节点永远都是先左后右的顺序</p><ul><li>前序：根左右</li><li>中序：左根右</li><li>后序：左右根</li></ul><p>以下图为例</p><p><img data-src="/posts/e85d694a/1.png" class=""></p><p>其遍历的结果为：</p><table><thead><tr><th style="text-align:center">遍历方式</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">前序遍历</td><td style="text-align:center">F</td><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">D</td><td style="text-align:center">C</td><td style="text-align:center">E</td><td style="text-align:center">G</td><td style="text-align:center">I</td><td style="text-align:center">H</td></tr><tr><td style="text-align:center">中序遍历</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center">E</td><td style="text-align:center">F</td><td style="text-align:center">G</td><td style="text-align:center">H</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">后序遍历</td><td style="text-align:center">A</td><td style="text-align:center">C</td><td style="text-align:center">E</td><td style="text-align:center">D</td><td style="text-align:center">B</td><td style="text-align:center">H</td><td style="text-align:center">I</td><td style="text-align:center">G</td><td style="text-align:center">F</td></tr></tbody></table><p>使用：</p><ul><li><p>中序常用来在二叉搜索树中得到递增的有序序列</p></li><li><p>删除节点的过程将按照后序遍历的顺序进行</p></li><li><p>后序可用于数学中的后缀表示法，结合栈处理表达式，每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中</p></li></ul><p>深度优先遍历 通常可以用 <strong>递归法</strong> 和 <strong>迭代法</strong> 实现（如果采用迭代法，则需要借助 <strong>栈</strong> 这一数据结构）</p><p>具体实现：</p><ul><li><p><a href="https://jiankychen.github.io/posts/1e967892">LeetCode 144. 二叉树的前序遍历</a></p></li><li><p><a href="https://jiankychen.github.io/803071b8">LeetCode 94. 二叉树的中序遍历</a></p></li><li><p><a href="https://jiankychen.github.io/4e96229e">LeetCode 145. 二叉树的后序遍历</a></p></li></ul><h2 id="广度优先遍历"><a class="anchor" href="#广度优先遍历">#</a> 广度优先遍历</h2><p>二叉树的广度优先遍历是指 层次遍历</p><p>即，逐层地、从左到右访问所有节点</p><p>上述例子的层序遍历结果为：</p><table><thead><tr><th style="text-align:center">遍历方式</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">层序遍历</td><td style="text-align:center">F</td><td style="text-align:center">B</td><td style="text-align:center">G</td><td style="text-align:center">A</td><td style="text-align:center">D</td><td style="text-align:center">I</td><td style="text-align:center">C</td><td style="text-align:center">E</td><td style="text-align:center">H</td></tr></tbody></table><p>广度优先遍历 一般借助 <strong>队列</strong> 这一数据结构、采用 <strong>迭代法</strong> 实现</p><p>具体实现：<a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a></p><h1 id="二叉树的定义"><a class="anchor" href="#二叉树的定义">#</a> 二叉树的定义</h1><p>已知二叉树的前序遍历序列和中序遍历序列，可以确定一棵二叉树</p><ul><li>根据前序遍历序列找出根节点，再根据中序遍历序列区分左右子树</li><li>分别找出左右子树的前序、中序遍历序列</li><li>分别对左右子树重复这个过程</li></ul><p>例：</p><p>前序序列：A B D E F C<br /> 中序序列：D B E F A C</p><p>根据前序序列确定二叉树的根节点为 A ，在中序序列中找到 A ，此时，中序序列中 A 左边的 D B E F 即为 A 的左子树，A 右边的 C 为 A 的右子树</p><ul><li>针对 A 的左子树，一共包含 D B E F 四个节点，其对应的前序遍历为 B D E F ，中序遍历为 D B E F 。因此， A 的左子树的根节点为 B ，节点 B 的左子树为 D ，右子树为 E F<ul><li>针对 B 的右子树，一共包含 E F 两个节点，其前序遍历为 E F ，中序遍历为 E F<ul><li>根节点为 E ，右子树为 F</li></ul></li></ul></li><li>针对 A 的右子树，前序遍历和中序遍历均为 C，故 C 为叶节点</li></ul><p><img data-src="/posts/e85d694a/2.png" class=""></p><p>已知二叉树的中序遍历序列和后序遍历序列，可以确定一棵二叉树</p><ul><li>根据后序遍历确定根节点，根据中序遍历确定其左右子树</li></ul><p>已知二叉树的前序遍历序列和后序遍历序列，无法唯一确定一棵二叉树</p><ul><li>可以根据前序遍历序列确定根节点，但无法分清其左子树和右子树</li></ul><h1 id="二叉树的性质"><a class="anchor" href="#二叉树的性质">#</a> 二叉树的性质</h1><ol><li><p>一棵非空二叉树的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 层上最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>≥</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i \ge 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li><li><p>一棵高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的二叉树，最多具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个节点</p></li><li><p>一棵非空二叉树，如果叶节点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，度数为 2 的节点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0 = n_2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 成立</p><ul><li>二叉树所有节点的度数均小于或等于 2，所以有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n = n_0 + n_1 + n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>除根节点外，每个节点都有唯一的一个树枝（父节点与子节点之间的线段）进入本节点，则二叉树的树枝总数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">B = n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>度为 1 的节点发出一个树枝，度为 2 的节点发出两个树枝，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B = n_1 + 2 n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>联立以上三式，得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0 = n_2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul></li><li><p>具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点的完全二叉树的高度 $ k = \lfloor \log_2 {n} \rfloor + 1$</p><ul><li>高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的完全二叉树，其节点总数满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1} - 1 &lt; n \le 2^k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，化简得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>≤</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">k - 1 \le \log_2{n} &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是整数，所以有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = \lfloor \log_2{n} \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul></li><li><p><strong>完全二叉树的按层编号</strong>：对一棵有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点的完全二叉树中的节点按层自上而下（从第 1 层到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor \log_2{n} \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 层）、每一层层按自左至右依次编号，若设根节点的编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，则对任一编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的节点，有：</p><ul><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，则节点为二叉树的根节点；若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，则其父节点的编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor i/2 \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">i</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span></li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2 i &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，则编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的节点为叶节点，没有子节点；否则，其左子节点编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2 i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span></span></span></span></li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2 i + 1 &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，则编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的节点无右子节点；否则，其右子节点编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul></li></ol><h1 id="二叉树的存储"><a class="anchor" href="#二叉树的存储">#</a> 二叉树的存储</h1><h2 id="顺序存储"><a class="anchor" href="#顺序存储">#</a> 顺序存储</h2><h3 id="完全二叉树的顺序存储"><a class="anchor" href="#完全二叉树的顺序存储">#</a> 完全二叉树的顺序存储</h3><p>按层编号，把节点的层次关系映射到线性关系</p><p>并且，根据 完全二叉树的按层编号 性质，可以得知各节点的父节点和子节点</p><p>例如：</p><p><img data-src="/posts/e85d694a/3.jpg" class="" title="完全二叉树的顺序存储"></p><h3 id="非完全二叉树的顺序存储"><a class="anchor" href="#非完全二叉树的顺序存储">#</a> 非完全二叉树的顺序存储</h3><p>将非完全二叉树修补成完全二叉树</p><ul><li>用特殊标记 （对应于类定义中的  <code>flag</code>  ）表示虚拟节点</li></ul><p>然后按层编号</p><p>例如：</p><p><img data-src="/posts/e85d694a/4.jpg" class="" title="非完全二叉树的顺序存储"></p><p>非完全二叉树顺序存储的特点：浪费空间（极端情况：只有右子节点的高为 3 的二叉树，其需要 7 个节点的存储空间，但是有效的节点只有 3 个）</p><p>一般只用于一些特殊的场合，如静态的并且节点个数已知的完全二叉树或接近完全二叉树的二叉树</p><h2 id="链接存储"><a class="anchor" href="#链接存储">#</a> 链接存储</h2><h3 id="二叉链表"><a class="anchor" href="#二叉链表">#</a> 二叉链表</h3><p>指明子节点，类似于单链表</p><p>每个节点存储 数据元素、指向左子节点的指针、指向右子节点的指针</p><p>例如：</p><p><img data-src="/posts/e85d694a/5.jpg" class="" title="二叉链表"></p><h3 id="三叉链表"><a class="anchor" href="#三叉链表">#</a> 三叉链表：</h3><p>同时指明父节点和子节点，类似于双链表</p><p>每个节点存储 数据元素、指向左子节点的指针、指向右子节点的指针、指向父节点的指针</p><p><img data-src="/posts/e85d694a/6.jpg" class="" title="三叉链表"></p><p>由于在二叉树中很少通过子节点找父节点，因此，我们<strong>常使用二叉链表进行存储</strong>，二叉链表也被称作二叉树的标准存储方式</p><h1 id="二叉树节点的定义"><a class="anchor" href="#二叉树节点的定义">#</a> 二叉树节点的定义</h1><p>使用二叉链表来定义二叉树</p><pre><code class="language-cpp">struct TreeNode &#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;</code></pre><p>注意，在 Leetcode 中，数据结构都是定义了的，而在笔试 / 面试时可能需要自行定义数据结构，例如，链表、二叉树等</p><p>因此，一定要掌握数据结构的定义</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm95dWFpLmNvbS9sZWFybi9jb3Vyc2VzLzE1Mi9sZXNzb25zLzIzNjMvc3RlcHMvMD9mcm9tPXF6">青州智学</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MC5odG1s">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9sZWV0Ym9vay9yZWFkL2lsbHVzdHJhdGlvbi1vZi1hbGdvcml0aG0vNTBlNDQ2Lw==">图解算法数据结构</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 695. 岛屿的最大面积</title>
      <link href="/posts/edd44cd5/"/>
      <url>/posts/edd44cd5/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWFyZWEtb2YtaXNsYW5kLw==">LeetCode 695. Max Area of Island</span></p><p>给你一个大小为  <code>m x n</code>  的二进制矩阵  <code>grid</code>  。</p><p>岛屿 是由一些相邻的  <code>1</code>  (代表土地) 构成的组合，这里的「相邻」要求两个  <code>1</code>  必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设  <code>grid</code>  的四个边缘都被  <code>0</code> （代表水）包围着。</p><p>岛屿的面积是岛上值为  <code>1</code>  的单元格的数目。</p><p>计算并返回  <code>grid</code>  中最大的岛屿面积。如果没有岛屿，则返回面积为  <code>0</code>  。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/edd44cd5/1.png" class=""></p><pre><code>输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]输出：6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[0,0,0,0,0,0,0,0]]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code> ,  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><code>grid[i][j]</code>  为 0 或 1</li></ul><h2 id="method-1-深度优先搜索"><a class="anchor" href="#method-1-深度优先搜索">#</a> Method 1: 深度优先搜索</h2><p>计算网格中每个连通形状的面积，然后取最大值。</p><p>在一个土地上，向 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积</p><p><strong>为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为  <code>0</code> </strong></p><pre><code class="language-cpp">private:    int DFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int cur_i, int cur_j) &#123;  // 深度优先搜索        if (cur_i &lt; 0 || cur_i == grid.size() || cur_j &lt; 0 || cur_j == grid[0].size() || grid[cur_i][cur_j] == 0) return 0;                       // cur_i cur_j 超出边界或grid[cur_i][cur_j]为0时，返回0        grid[cur_i][cur_j] = 0; // 已经访问过的位置置0，以免重复访问        int ans = 1;            // 岛屿面积        const int di[4] = &#123;-1,1,0,0&#125;;        const int dj[4] = &#123;0,0,-1,1&#125;;        for (int index = 0; index &lt; 4; index++) &#123;            int next_i = cur_i + di[index], next_j = cur_j + dj[index];            ans += DFS(grid,next_i,next_j);        &#125;        return ans;    &#125;public:    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans = 0;        for (int i = 0; i &lt; grid.size(); i++)            for (int j = 0; j&lt; grid[0].size(); j++)                ans = max(ans, DFS(grid,i,j));        return ans;    &#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(R \times C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>。其中  <code>R</code>  是给定网格中的行数， <code>C</code>  是列数。访问每个网格最多一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(R \times C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>，递归的深度最大可能是整个网格的大小，因此最大可能使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(R \times C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> 的栈空间</p><h2 id="method-2-深度优先搜索-栈"><a class="anchor" href="#method-2-深度优先搜索-栈">#</a> Method 2: 深度优先搜索 + 栈</h2><h2 id="method-3-广度优先搜索"><a class="anchor" href="#method-3-广度优先搜索">#</a> Method 3: 广度优先搜索</h2><p>把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法</p><pre><code class="language-cpp">int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    int ans = 0;    for (int i = 0; i != grid.size(); ++i) &#123;        for (int j = 0; j != grid[0].size(); ++j) &#123;            int cur = 0;            queue&lt;int&gt; queuei;            queue&lt;int&gt; queuej;            queuei.push(i);            queuej.push(j);            while (!queuei.empty()) &#123;                int cur_i = queuei.front(), cur_j = queuej.front();                queuei.pop();                queuej.pop();                if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) &#123;                    continue;                &#125;                ++cur;                grid[cur_i][cur_j] = 0;                int di[4] = &#123;0, 0, 1, -1&#125;;                int dj[4] = &#123;1, -1, 0, 0&#125;;                for (int index = 0; index != 4; ++index) &#123;                    int next_i = cur_i + di[index], next_j = cur_j + dj[index];                    queuei.push(next_i);                    queuej.push(next_j);                &#125;            &#125;            ans = max(ans, cur);        &#125;    &#125;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(R \times C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>。其中  <code>R</code>  是给定网格中的行数， <code>C</code>  是列数，访问每个网格最多一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(R \times C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>，队列中最多会存放所有的土地，土地的数量最多为  <code>R × C</code>  块</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 733. 图像渲染</title>
      <link href="/posts/67cb564f/"/>
      <url>/posts/67cb564f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxvb2QtZmlsbC8=">LeetCode 733. Flood Fill</span></p><p>有一幅以  <code>m x n</code>  的二维整数数组表示的图画  <code>image</code>  ，其中  <code>image[i][j]</code>  表示该图画的像素值大小（索引  <code>i</code>  和  <code>j</code>  均从 0 开始）。</p><p>你也被给予三个整数  <code>sr</code>  ， <code>sc</code>  和  <code>newColor</code>  。你应该从像素  <code>image[sr][sc]</code>  开始对图像进行 上色填充 。</p><p>为了完成 <strong>上色工作</strong> ，从初始像素开始，记录初始坐标的 <strong>上下左右四个方向上</strong> 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 <strong>四个方向上</strong> 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为  <code>newColor</code>  。</p><p>最后返回 经过上色渲染后的图像 。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/67cb564f/1.png" class=""></p><pre><code>输入：image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2输出：[[2,2,2],[2,2,0],[2,0,1]]解释：在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2输出：[[2,2,2],[2,2,2]]</code></pre><p><strong>提示：</strong></p><ul 16=""><li><code>m == image.length</code></li><li><code>n == image[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>m</code>  ,  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>image[i][j]</code>  ,  <code>newColor</code>  &lt; 2^</li></ul><h2 id="method-1-广度优先搜索"><a class="anchor" href="#method-1-广度优先搜索">#</a> Method 1: 广度优先搜索</h2><p>每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并<strong>将该方格的颜色更新，以防止重复入队</strong>。</p><p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p><p>注意：<strong>当目标颜色和初始颜色相同时，我们无需对原数组进行修改</strong>。</p><pre><code class="language-cpp">const int dx[4] = &#123;1, 0, 0, -1&#125;;                // 四个方向const int dy[4] = &#123;0, 1, -1, 0&#125;;vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;    int currColor = image[sr][sc];    if (currColor == newColor) return image;    // 目标颜色和初始颜色相同    int n = image.size(), m = image[0].size();    queue&lt;pair&lt;int, int&gt;&gt; que;                  // 待搜索位置的队列    que.emplace(sr, sc);                        // 初始化    image[sr][sc] = newColor;    while (!que.empty()) &#123;        int x = que.front().first, y = que.front().second;        que.pop();        for (int i = 0; i &lt; 4; i++) &#123;            int mx = x + dx[i], my = y + dy[i];            if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;                que.emplace(mx, my);                image[mx][my] = newColor;            &#125;        &#125;    &#125;    return image;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中  <code>n</code>  和  <code>m</code>  分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，主要为队列的开销。</p><h2 id="method-2-深度优先搜索"><a class="anchor" href="#method-2-深度优先搜索">#</a> Method 2: 深度优先搜索</h2><p>从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。</p><pre><code class="language-cpp">const int dx[4] = &#123;1, 0, 0, -1&#125;;const int dy[4] = &#123;0, 1, -1, 0&#125;;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int color, int newColor) &#123;    if (image[x][y] == color) &#123;        image[x][y] = newColor;        for (int i = 0; i &lt; 4; i++) &#123;            int mx = x + dx[i], my = y + dy[i];            if (mx &gt;= 0 &amp;&amp; mx &lt; image.size() &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; image[0].size()) &#123;                dfs(image, mx, my, color, newColor);    // 递归，深度优先搜索            &#125;        &#125;    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;    int currColor = image[sr][sc];    if (currColor != newColor) &#123;        dfs(image, sr, sc, currColor, newColor);    &#125;    return image;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，最坏情况下需要遍历所有的方格一次。</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，主要为栈空间的开销。</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 567. 字符串的排列</title>
      <link href="/posts/9f11d9b/"/>
      <url>/posts/9f11d9b/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb24taW4tc3RyaW5nLw==">LeetCode 567. Permutation in String</span></p><p>给你两个字符串  <code>s1</code>  和  <code>s2</code>  ，写一个函数来判断  <code>s2</code>  是否包含  <code>s1</code>  的排列。如果是，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>换句话说， <code>s1</code>  的排列之一是  <code>s2</code>  的 子串 。</p><p><strong>示例 1：</strong></p><pre><code>输入：s1 = &quot;ab&quot;, s2 = &quot;eidbaooo&quot;输出：true解释：s2 包含 s1 的排列之一 (&quot;ba&quot;)</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s1 = &quot;ab&quot;, s2 = &quot;eidboaoo&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s1.length</code> ,  <code>s2.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s1</code>  和  <code>s2</code>  仅包含小写字母</li></ul><h2 id="method-1-滑动窗口"><a class="anchor" href="#method-1-滑动窗口">#</a> Method 1: 滑动窗口</h2><blockquote><p>两个字符串经过排序之后相等，可以说明一个字符串是另一个的排列。（时间复杂度高）</p></blockquote><blockquote><p>只有当两个字符串每个字符的个数均相等时，一个字符串才是另一个字符串的排列</p></blockquote><p>记  <code>s1</code>  的长度为  <code>n</code> ，可以遍历  <code>s2</code>  中每个长度为  <code>n</code>  的子串，判断子串和  <code>s1</code>  中每个字符的个数是否相等，若相等则说明该子串是  <code>s1</code>  的一个排列</p><p>数组  <code>cnt1</code>  统计  <code>s1</code>  中各个字符的个数， <code>cnt2</code>  统计当前遍历的子串中各个字符的个数</p><p>由于需要遍历的子串长度均为  <code>n</code> ，可以使用一个固定长度为  <code>n</code>  的滑动窗口来维护  <code>cnt2</code> ：滑动窗口每向右滑动一次，就多统计一次进入窗口的字符，少统计一次离开窗口的字符。然后，判断  <code>cnt1</code> ​ 是否与  <code>cnt2</code>  ​相等，若相等则意味着  <code>s1</code>  的排列之一是  <code>s2</code>  的子串。</p><pre><code class="language-cpp">bool checkInclusion(string s1, string s2) &#123;    int n1 = s1.size(), n2 = s2.size();    if (n1 &gt; n2) return false;    vector&lt;int&gt; cnt1(26),cnt2(26);    for (int i = 0; i &lt; n1; i++) &#123;  // 统计s1每个字符的出现次数，s2中首个长为n1子串每个字符的出现次数        ++cnt1[s1[i] - 'a'];        ++cnt2[s2[i] - 'a'];    &#125;    if (cnt1 == cnt2) return true;    for (int i = n1; i &lt; n2; i++) &#123; // 滑动窗口法（窗长为n1），更新窗口内每个字符的出现次数        ++cnt2[s2[i] - 'a'];        // 进入窗口的字符        --cnt2[s2[i- n1] - 'a'];    // 离开窗口的字符        if (cnt1 == cnt2) return true;    &#125;    return false;&#125;</code></pre><h2 id="method-2-滑动窗口"><a class="anchor" href="#method-2-滑动窗口">#</a> Method 2: 滑动窗口</h2><p>注意到每次窗口滑动时，只统计了一进一出两个字符，却比较了整个  <code>cnt1</code>  和  <code>cnt2</code>  数组。因此可对上述算法进行优化：用一个变量  <code>diff</code>  来记录  <code>cnt1</code>  与  <code>cnt2</code>  的不同值的个数，这样判断  <code>cnt1</code>  和  <code>cnt2</code>  是否相等就转换成了判断  <code>diff</code>  是否为  <code>0</code></p><p>为简化上述逻辑，可以只用一个数组  <code>cnt</code> ，其中  <code>cnt[x]=cnt2[x]−cnt1[x]</code> ，将  <code>cnt1[x]</code>  与  <code>cnt2[x]</code>  的比较替换成  <code>cnt[x]</code>  与  <code>0</code>  的比较</p><pre><code class="language-cpp">bool checkInclusion(string s1, string s2) &#123;    int n1 = s1.size(), n2 = s2.size();    if (n1 &gt; n2) return false;    // 数组cnt记录的是s1字符串与s2窗口中，每个字符出现次数的差异值：若cnt1 cnt2分别记录s1字符串与s2窗口中每个字符出现次数，则cnt=cnt2-cnt1    vector&lt;int&gt; cnt(26);        // s1 s2仅包含小写字母    for (int i = 0; i &lt; n1; i++) &#123;        --cnt[s1[i] - 'a'];        ++cnt[s2[i] - 'a'];    &#125;    int diff = 0;               // 记录cnt非零元素的个数，即，cnt1与cnt2不相等元素的个数    for (auto c : cnt)        if (c != 0)            ++diff;    if (diff == 0) return true; // diff等于0，即cnt1与cnt2相同，输出true    for (int i = n1; i &lt; n2; i++) &#123;        int x = s2[i] - 'a', y = s2[i - n1] - 'a'; // x对应进入窗口的字符，y对应离开窗口的字符        if (x == y) continue;           // x等于y时，无需修改cnt和diff        if (cnt[x] == 0) ++diff;        // cnt1[x]原本等于cnt2[x]，新进入的x导致diff加1        ++cnt[x];        if (cnt[x] == 0) --diff;        // 进入窗口的x使得cnt1[x]等于cnt2[x]，故diff减1（该if语句是上一条if语句是互斥的）        if (cnt[y] == 0) ++diff;        --cnt[y];        if (cnt[y] == 0) --diff;        if (diff == 0) return true;    &#125;    return false;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m + \vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串  <code>s1</code>  的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是字符串  <code>s2</code>  的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 是字符集，这道题中的字符集是小写字母，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>26</mn></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert =26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p><h2 id="method-3-双指针"><a class="anchor" href="#method-3-双指针">#</a> Method 3: 双指针</h2><p>方法一的思路：在保证区间长度为  <code>n</code>  的情况下，去考察是否存在一个区间使得  <code>cnt</code>  的值全为  <code>0</code> 。反过来，还可以在保证  <code>cnt</code>  的值不为正的情况下，去考察是否存在一个区间，其长度恰好为  <code>n</code></p><p>初始时，仅统计  <code>s1</code>  中的字符，则  <code>cnt</code>  的值均不为正，且元素值之和为  <code>- n</code></p><p>用指针  <code>left</code>  和  <code>right</code>  表示考察的区间  <code>[left,right]</code> 。 <code>right</code>  每向右移动一次，就统计一次进入区间的字符  <code>x</code> 。为保证  <code>cnt</code>  的值不为正，若此时  <code>cnt[x] &gt; 0</code> ，则向右移动左指针，减少离开区间的字符的  <code>cnt</code>  值直到  <code>cnt[x] ≤ 0</code></p><p>注意到  <code>[left,right]</code>  的长度每增加  <code>1</code> ， <code>cnt</code>  的元素值之和就增加  <code>1</code> 。当  <code>[left,right]</code>  的长度恰好为  <code>n</code>  时，就意味着  <code>cnt</code>  的元素值之和为  <code>0</code> 。由于  <code>cnt</code>  的值不为正，元素值之和为  <code>0</code>  就意味着所有元素均为  <code>0</code> ，这样我们就找到了一个目标子串</p><pre><code class="language-cpp">bool checkInclusion(string s1, string s2) &#123;    int n1 = s1.size(), n2 =s2.size();    if (n1 &gt; n2) return false;    vector&lt;int&gt; cnt(26);    for (int i = 0; i &lt; n1; i++)        --cnt[s1[i] - 'a'];     // cnt的元素值之和为-n1    int l = 0;    // 在保证 cnt 的值不为正（所有元素均不为正）的情况下，去考察是否存在一个区间，其长度恰好为 n1    for (int r = 0; r &lt; n2; r++) &#123;        int x = s2[r] - 'a';        ++cnt[x];        while (cnt[x] &gt; 0) &#123; // x出现次数多，l右移，并更新cnt            --cnt[s2[l] - 'a'];            ++l;        &#125;        if (r - l + 1 == n1) return true;   // cnt各元素均不为正，且区间[l,r]长度刚好为n1，找到目标    &#125;    return false;    &#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m + \vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> ，创建  <code>cnt</code>  需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 的时间。遍历  <code>s1</code>  需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间。双指针遍历  <code>s2</code>  时，由于  <code>left</code>  和  <code>right</code>  都只会向右移动，故这一部分需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 的时间</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3. 无重复字符的最长子串</title>
      <link href="/posts/3deb1e70/"/>
      <url>/posts/3deb1e70/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">3. Longest Substring Without Repeating Characters</span></p><p>给定一个字符串  <code>s</code>  ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abcabcbb&quot;输出：3解释：因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;bbbbb&quot;输出：1解释：因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;pwwkew&quot;输出：3解释：因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h1 id="method-滑动窗口"><a class="anchor" href="#method-滑动窗口">#</a> Method: 滑动窗口</h1><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>使用两个指针表示字符串中的某个子串（或窗口）的左右边界，该窗口容纳无重复字符的子串</p><p>分别定义  <code>left</code>  和  <code>right</code>  作为滑动窗口的左端点和右端点（初始化为 0 ），定义一个  <code>unordered_set</code>  对象  <code>hash</code>  来记录滑动窗口内的元素，利用  <code>ans</code>  记录窗口的最大长度（即，目标值）</p><p>向右移动  <code>right</code>  ：</p><ul><li>若窗口内不存在  <code>s[right]</code>  字符（即， <code>hash.find(s[right]) != hash.end()</code>  ），可直接将  <code>s[right]</code>  放入窗口</li><li>若窗口内已经存在  <code>s[right]</code>  字符，需移动  <code>left</code>  ，将窗口内已有的  <code>s[right]</code>  字符及其左侧字符全都移除出去，然后再将  <code>s[right]</code>  放入窗口</li><li>计算窗口的长度，即， <code>right - left + 1</code>  ，并将其与  <code>ans</code>  比较，以更新最大窗口长度</li></ul><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int lengthOfLongestSubstring(string s) &#123;    unordered_set&lt;char&gt; hash;                       // 记录滑动窗口内的元素    int left = 0;    int right = 0;    int ans = 0;    while (right &lt; s.size()) &#123;        while (hash.find(s[right]) != hash.end()) &#123; // s[right] 在窗口内            hash.erase(s[left]);            ++left;        &#125;        hash.insert(s[right]);                      // 将 s[right] 加入窗口        ans = max(ans, right - left + 1);           // 更新滑动窗口的最大长度        ++right;    &#125;    return ans;&#125;</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串  <code>s</code>  的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 为字符集的大小</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 19. 删除链表的倒数第 N 个结点</title>
      <link href="/posts/bcf47f8f/"/>
      <url>/posts/bcf47f8f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLW50aC1ub2RlLWZyb20tZW5kLW9mLWxpc3Qv">LeetCode</span></p><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="/posts/bcf47f8f/1.png" class=""></p><pre><code>输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = [1], n = 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = [1,2], n = 1输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中结点的数目为  <code>sz</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>sz</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>sz</code></li></ul><p><strong>进阶</strong>：你能尝试使用一趟扫描实现吗？</p><h2 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h2><p>解题思路如下：</p><ol><li><p>添加一个<strong>哑节点</strong>（dummy node），即，虚拟头节点，它的  <code>next</code>  指针指向链表的头节点</p></li><li><p>定义快慢指针  <code>fast</code>  和  <code>slow</code>  ，初始值为哑结点，然后让  <code>fast</code>  指针移动  <code>n</code>  步，使得  <code>fast</code>  比  <code>slow</code>  超前  <code>n</code>  个节点</p></li><li><p>同时移动  <code>fast</code>  和  <code>slow</code>  指针，当  <code>fast</code>  遍历到链表的最后一个节点时（ <code>fast != nullptr &amp;&amp; fast-&gt;next == nullptr</code> ）， <code>slow</code>  的下一个节点就是需要删除的节点</p></li><li><p>修改指针，即， <code>slow-&gt;next = slow-&gt;next-&gt;next</code>  ，完成删除操作</p></li></ol><blockquote><p>因为添加了哑结点，如果需要删除的是头节点，同样可以采用上述步骤进行</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">ListNode* removeNthFromEnd(ListNode* head, int n) &#123;    ListNode* dummyHead = new ListNode(0, head);   // 创建哑结点    ListNode *fast = dummyHead, *slow = dummyHead; // 初始化 fast 指针和 slow 指针    for (int i = 0; i &lt; n; i++)        fast = fast-&gt;next;          // fast 指针前进 n 步，即，比 slow 超前 n 步    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; // 两指针同时移动，直到 fast 走到最后一个节点        fast = fast-&gt;next;        slow = slow-&gt;next;    &#125;    ListNode* node = slow-&gt;next;    // 暂存待删除节点    slow-&gt;next = slow-&gt;next-&gt;next;  // 在链表中删除节点    delete node;                    // 清除已删除节点的内存    ListNode* ans = dummyHead-&gt;next;    delete dummyHead;               // 清除哑结点    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 704. 二分查找</title>
      <link href="/posts/4a298fcf/"/>
      <url>/posts/4a298fcf/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">LeetCode 704. Binary Search</span></p><p>给定一个  <code>n</code>  个元素有序的（升序）整型数组  <code>nums</code>  和一个目标值  <code>target</code>  ，写一个函数，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度下搜索  <code>nums</code>  中的  <code>target</code>  ，如果目标值存在返回下标，否则返回  <code>-1</code>  。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,3,5,9,12], target = 9输出：4解释：9 exists in nums and its index is 4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [-1,0,3,5,9,12], target = 2输出：-1解释：2 does not exist in nums so return -1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">- 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> &lt;  <code>nums[i]</code> ,  <code>target</code>  &lt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>nums</code>  中的所有元素不重复</li><li><code>nums</code>  升序排列</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>有序数组，且数组中无重复元素，考虑用二分法</p><p>然而，二分查找涉及的很多的 <strong>边界条件</strong> ，例如，是  <code>while(left &lt; right)</code>  还是  <code>while(left &lt;= right)</code>  呢，是  <code>right = middle</code>  还是  <code>right = middle - 1</code>  呢？</p><blockquote><p>在二分查找的过程中，要保持不变量，就是在  <code>while</code>  寻找中每一次边界的处理都要坚持根据 <strong>区间的定义</strong> 来操作，这就是 <strong>循环不变量</strong> 规则</p></blockquote><p>写二分法，区间的定义一般为两种，<strong>左闭右闭</strong>，即  <code>[left, right]</code> ，或者 <strong>左闭右开</strong>，即  <code>[left, right)</code></p><h2 id="method-1"><a class="anchor" href="#method-1">#</a> Method 1</h2><p>定义  <code>target</code>  是在一个在 <strong>左闭右闭</strong> 的区间里，也就是  <code>[left, right]</code>  ，所以有：</p><ul><li><p><code>right</code>  初值赋为  <code>nums.size() - 1</code>  ，因为  <code>target</code>  定义在  <code>[left, right]</code>  区间内</p></li><li><p><code>while (left &lt;= right)</code>  循环控制条件使用  <code>&lt;=</code>  ：因为  <code>left == right</code>  是依然可行的</p></li><li><p><code>if (nums[middle] &gt; target)</code>  的执行语句中， <code>right</code>  要赋值为  <code>middle - 1</code>  ：因为当前这个  <code>nums[middle]</code>  一定不是  <code>target</code> ，可以更新区间右端点为  <code>nums[middle]</code></p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int search(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]    while (left &lt;= right) &#123;      // 当left==right，区间[left, right]依然有效，所以用 &lt;=        int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2        if (nums[middle] &gt; target)            right = middle - 1;  // target 在左区间，所以[left, middle - 1]        else if (nums[middle] &lt; target)            left = middle + 1;   // target 在右区间，所以[middle + 1, right]        else                     // nums[middle] == target            return middle;       // 数组中找到目标值，直接返回下标    &#125;    // 未找到目标值    return -1;&#125;</code></pre><h2 id="method-2"><a class="anchor" href="#method-2">#</a> Method 2</h2><p>如果定义  <code>target</code>  在一个在 <strong>左闭右开</strong> 的区间里，也就是  <code>[left, right)</code>  ：</p><ul><li><p><code>right</code>  初值赋为  <code>nums.size()</code>  ，因为  <code>target</code>  定义在  <code>[left, right)</code>  区间内</p></li><li><p><code>while (left &lt; right)</code>  循环控制条件使用  <code>&lt;</code>  ：因为  <code>left == right</code>  在区间  <code>[left, right)</code>  是不可行的</p></li><li><p><code>if (nums[middle] &gt; target)</code>  的执行语句中， <code>right</code>  更新为  <code>middle</code>  ：因为搜索区间是 左闭右开 区间，而当前的  <code>nums[middle]</code>  不等于  <code>target</code>  ，所以  <code>right</code>  更新为  <code>middle</code>  时，下一个搜索区间就不会再去比较  <code>nums[middle]</code>  （注意，这里不能将  <code>right</code>  更新为  <code>middle - 1</code>  ：若  <code>right</code>  赋值为  <code>middle - 1</code>  ，则排除了  <code>middle - 1</code>  的可能性）</p></li></ul><pre><code class="language-cpp">int search(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int right = nums.size();    // 定义target在左闭右开的区间里，即：[left, right)    while (left &lt; right) &#123;      // 因为left == right在区间[left, right)是不可行的，所以使用 &lt;        int middle = left + ((right - left) &gt;&gt; 1); // 等同于left + ((right - left) / 2)        if (nums[middle] &gt; target)            right = middle;     // target 在左区间，在[left, middle)中        else if (nums[middle] &lt; target)            left = middle + 1;  // target 在右区间，在[middle + 1, right)中        else                    // nums[middle] == target            return middle;      // 数组中找到目标值，直接返回下标    &#125;    // 未找到目标值    return -1;&#125;</code></pre><blockquote><p>在循环中要坚持根据搜索区间的定义来做边界处理</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDQuJUU0JUJBJThDJUU1JTg4JTg2JUU2JTlGJUE1JUU2JTg5JUJFLmh0bWwjXzcwNC0lRTQlQkElOEMlRTUlODglODYlRTYlOUYlQTUlRTYlODklQkU=">代码随想录：704. 二分查找</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 876. 链表的中间结点</title>
      <link href="/posts/ccf16d67/"/>
      <url>/posts/ccf16d67/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC8=">LeetCode 876. Middle of the Linked List</span></p><p>给你单链表的头结点  <code>head</code>  ，请你找出并返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><pre><code>输入：head = [1,2,3,4,5]输出：[3,4,5]解释：链表只有一个中间结点，值为 3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = [1,2,3,4,5,6]输出：[4,5,6]解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点</code></pre><p><strong>提示：</strong></p><ul><li>链表的结点数范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>Node.val</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-数组"><a class="anchor" href="#method-1-数组">#</a> Method 1: 数组</h2><p>对链表进行遍历，同时将遍历到的元素依次放入数组  <code>A</code>  中。如果我们遍历到了  <code>N</code>  个元素，那么链表以及数组的长度也为  <code>N</code>  ，对应的中间节点即为  <code>A[N/2]</code></p><pre><code class="language-cpp">ListNode* middleNode(ListNode* head) &#123;    vector&lt;ListNode*&gt; A = &#123;head&#125;;    while (A.back()-&gt;next != NULL)        A.push_back(A.back()-&gt;next);    return A[A.size() / 2];&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中  <code>N</code>  是给定链表中的结点数目。</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，即数组  <code>A</code>  用去的空间。</p><h2 id="method-2-单指针"><a class="anchor" href="#method-2-单指针">#</a> Method 2: 单指针</h2><p>对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数  <code>N</code>  ；第二次遍历时，我们遍历到第  <code>N/2</code>  个元素（链表的首节点为第  <code>0</code>  个元素）时，将该元素返回即可</p><blockquote><p>注意，题目要求「两个中间结点的时候，返回<strong>第二个中间结点</strong>」。此时，快指针可以前进的条件是：<strong>当前快指针和当前快指针的下一个结点都非空</strong>。</p><p>如果题目要求「在两个中间结点的时候，返回<strong>第一个中间结点</strong>」，快指针可以前进的条件是：<strong>当前快指针的下一个结点和当前快指针的下下一个结点都非空</strong>。</p></blockquote><pre><code class="language-cpp">ListNode* middleNode(ListNode* head) &#123;    ListNode *current = head;    int n = 0;    while (current != nullptr)      // 统计链表的节点数    &#123;        n++;        current = current-&gt;next;    &#125;    current = head;    for (int i = 0; i &lt; n / 2; i++) // 寻找链表的中间节点        current = current-&gt;next;    return current;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中  <code>N</code>  是给定链表的结点数目</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只需要常数空间存放变量和指针</p><h2 id="method-3-快慢指针"><a class="anchor" href="#method-3-快慢指针">#</a> Method 3: 快慢指针</h2><p>用两个指针 <code>slow</code>  与 <code>fast</code>  一起遍历链表。 <code>slow</code>  一次走一步， <code>fast</code>  一次走两步。那么当 <code>fast</code>  到达链表的末尾时， <code>slow</code>  必然位于中间</p><pre><code class="language-cpp">ListNode* middleNode(ListNode* head) &#123;    // 快慢指针，快指针一次前进两步，慢指针一次前进一步    ListNode *fast = head, *slow = head;    // 判断条件为：快指针当前节点非空且下一节点都非空。这样才能保证返回第二个中间节点（存在两个中间节点时）    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr)        &#123;        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;    &#125;    return slow;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中  <code>N</code>  是给定链表的结点数目。</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只需要常数空间存放  <code>slow</code>  和  <code>fast</code>  两个指针。</p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9saWFuLWJpYW8tZGUtemhvbmctamlhbi1qaWUtZGlhbi1ieS1sZWV0Y29kZS1zb2x1dC8=">题解：链表的中间结点</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9rdWFpLW1hbi16aGktemhlbi16aHUteWFvLXphaS15dS1kaWFvLXNoaS1ieS1saXdlaS8=">题解：快慢指针（注意链表长度为偶数时，返回第 2 个结点的细节）</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1491. 去掉最低工资和最高工资后的平均工资</title>
      <link href="/posts/b3858f6e/"/>
      <url>/posts/b3858f6e/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXZlcmFnZS1zYWxhcnktZXhjbHVkaW5nLXRoZS1taW5pbXVtLWFuZC1tYXhpbXVtLXNhbGFyeS8=">LeetCode 1491. Average Salary Excluding the Minimum and Maximum Salary</span></p><p>给你一个整数数组  <code>salary</code>  ，数组里每个数都是 <strong>唯一</strong> 的，其中  <code>salary[i]</code>  是第  <code>i</code>  个员工的工资。</p><p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：salary = [4000,3000,1000,2000]输出：2500.00000解释：最低工资和最高工资分别是 1000 和 4000 。去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：salary = [1000,2000,3000]输出：2000.00000解释：最低工资和最高工资分别是 1000 和 3000 。去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：salary = [6000,5000,4000,3000,2000,1000]输出：3500.00000</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：salary = [8000,9000,2000,3000,6000,1000]输出：4750.00000</code></pre><p>提示：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">3 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>salary.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">10^3 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>salary[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></li><li><code>salary[i]</code>  是唯一的</li><li>与真实值误差在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> 以内的结果都将视为正确答案</li></ul><h2 id="method前缀和"><a class="anchor" href="#method前缀和">#</a> Method：前缀和</h2><p>逐个比较，更新最大值和最小值，并累加求和，最后再减去最大值和最小值。注意，求平均值时，被除数或者除数要转换成  <code>double</code>  型，这样才能保留小数点后的计算结果。</p><pre><code class="language-cpp">double average(vector&lt;int&gt;&amp; salary) &#123;    int min = salary[0], max = salary[0], sum = 0;    for (int i = 0; i &lt; salary.size(); i++)    &#123;        if (salary[i] &gt; max) max = salary[i];        else if (salary[i] &lt; min) min = salary[i];        sum += salary[i];    &#125;;    double ans = double(sum - max - min) / (salary.size() - 2); // 注意这里被除数或除数要变成double型    return ans;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，选取最大值、最小值和求和的过程的时间代价都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，故渐进时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，这里只用到了常量级别的辅助空间。</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1523. 在区间范围内统计奇数数目</title>
      <link href="/posts/933a3849/"/>
      <url>/posts/933a3849/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtb2RkLW51bWJlcnMtaW4tYW4taW50ZXJ2YWwtcmFuZ2Uv">LeetCode 1523. Count Odd Numbers in an Interval Range</span></p><p>给你两个非负整数  <code>low</code>  和  <code>high</code>  。请你返回  <code>low</code>  和  <code>high</code>  之间（包括二者）奇数的数目。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：low = 3, high = 7输出：3解释：3 到 7 之间奇数数字为 [3,5,7]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：low = 8, high = 10输出：1解释：8 到 10 之间奇数数字为 [9]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>low</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>high</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-前缀和"><a class="anchor" href="#method-前缀和">#</a> Method: 前缀和</h2><blockquote><p>暴力枚举  <code>[low,high]</code>  中的所有元素会超出时间限制。</p></blockquote><p>可以使用前缀和思想来解决这个问题，定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pre(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 为区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 中奇数的个数，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">pre(x) = (x + 1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span> 之间的奇数数目为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pre(high) - pre(low - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">int pre(int x)&#123; // 返回[0,x]之间的奇数数目    return (x + 1) / 2;&#125;int countOdds(int low, int high) &#123; // [low,high]之间的奇数数目=[0,high]之间的奇数数目-[0,low-1]之间的奇数数目    return pre(high) - pre(low - 1);&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 表达式</title>
      <link href="/posts/2d2eedc7/"/>
      <url>/posts/2d2eedc7/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式基础"><a class="anchor" href="#表达式基础">#</a> 表达式基础</h1><p><strong>表达式</strong> 通常由 <strong>运算符</strong> 和 <strong>运算对象</strong> 组成</p><p><strong>字面值</strong> 和 <strong>变量</strong> 是最简单的表达式</p><h2 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h2><p>一元运算符：作用于一个运算对象的运算符，如取地址符  <code>&amp;</code>  和解引用符  <code>*</code></p><p>二元运算符：作用于两个运算对象的运算符，如相等运算符  <code>==</code>  和乘法运算符 <code>*</code></p><p>三元运算符：作用于三个运算对象，如条件运算符  <code>_ ? _ : _</code></p><h3 id="组合运算符和运算对象"><a class="anchor" href="#组合运算符和运算对象">#</a> 组合运算符和运算对象</h3><p>表达式的求值结果，依赖于运算符的 <strong>优先级</strong> 、<strong>结合律</strong> 以及 <strong>运算对象的求值顺序</strong></p><ul><li>优先级：例如， <code>*</code>  优先级高于  <code>+</code></li><li>结合律：通常是从左往右，遇到括号时则是由内到外</li><li>求值顺序：例如， <code>f1() + f2()</code> ，对于  <code>f1()</code>  和  <code>f2()</code>  的计算，没有明确的顺序</li></ul><h3 id="重载运算符"><a class="anchor" href="#重载运算符">#</a> 重载运算符</h3><p>C++ 定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作</p><p>当运算符作用于类类型的运算对象时，用户可以自行定义其含义</p><p>这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载运算符（overloaded operator）</p><p><code>IO</code>  库的  <code>&gt;&gt;</code>  和  <code>&lt;&lt;</code>  运算符以及  <code>string</code>  对象、 <code>vector</code>  对象和迭代器使用的运算符都是重载的运算符</p><p>使用重载运算符时，运算对象的类型和返回值的类型都由该运算符定义</p><p><strong>运算对象的个数、运算符的优先级和结合律都是无法改变的</strong></p><h3 id="左值和右值"><a class="anchor" href="#左值和右值">#</a> 左值和右值</h3><p>C++ 的表达式要么是右值（rvalue，读作 “are-value”），要么就是左值（lvalue，读作 “ell-value”），即，非左即右</p><p>对于 C 语言：左值可以位于赋值语句的左侧，右值则不能</p><p>相比于 C 语言的左值和右值，C++ 会复杂很多：</p><ul><li>右值：取不到地址的表达式</li><li>左值：能取到地址的表达式</li><li>常量对象为代表的左值不能作为赋值语句的左侧运算对象（即，不能修改常量对象的值）</li><li>某些表达式的求值结果是对象，但它们是右值（例如，临时的对象  <code>1 + a</code>  无法取地址，故而是右值）</li></ul><p><strong>当一个对象被用作右值时，用的是对象的值（内容）</strong></p><p><strong>当对象被用作左值时，用的是对象的身份（在内存中的位置）</strong></p><p>在需要右值的地方可以用左值来代替，当一个左值被当成右值使用时，实际使用的是它的内容（值）</p><p>但是，不能把右值当成左值（也就是位置）使用</p><p>常见的运算符：</p><ul><li><p>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也依然是一个左值</p></li><li><p>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值</p></li><li><p>内置解引用运算符、下标运算符、迭代器解引用运算符、 <code>string</code>  和 <code>vector</code>  的下标运算符的求值结果都是左值</p></li><li><p>内置类型和迭代器的递增递减运算符作用于左值运算对象</p></li></ul><p>使用关键字  <code>decltype</code>  时：如果表达式的求值结果是左值， <code>decltype</code>  作用于该表达式（不是变量）将会得到一个引用类型</p><blockquote><p>例如，对于  <code>int *p</code>  ，因为解引用运算符（即， <code>*p</code>  ）生成左值，所以  <code>decltype(*p)</code>  的结果是引用类型，即  <code>int&amp;</code>  ；另一方面，因为取地址运算符（即， <code>&amp;p</code>  ）生成右值，所以  <code>decltype(&amp;p)</code>  的结果是  <code>int**</code>  ，即，一个指向整型指针的指针</p></blockquote><h2 id="优先级与结合律"><a class="anchor" href="#优先级与结合律">#</a> 优先级与结合律</h2><p>复合表达式（compound expression）是指含有两个或多个运算符的表达式</p><p>计算复合表达式的值，要根据优先级与结合律决定运算符和运算对象的组合方式</p><p>高优先级运算符的运算对象 比 低优先级运算符的运算对象 更为紧密地组合在一起</p><ul><li>例如，乘法和除法的优先级相同且都高于加法的优先级，因此，乘法和除法的运算对象会首先组合在一起，然后才能轮到加法和减法的运算对象</li></ul><p>如果优先级相同，则其组合规则由结合律确定</p><ul><li>算术运算符满足左结合律，即，如果运算符的优先级相同，将按照从左向右的顺序组合运算对象</li></ul><h3 id="括号无视优先级与结合律"><a class="anchor" href="#括号无视优先级与结合律">#</a> 括号无视优先级与结合律</h3><p>括号无视普通的组合规则：在表达式中，括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合</p><pre><code class="language-cpp">// parentheses result in alternative groupingscout &lt;&lt; (6 + 3) *  (4 / 2 + 2) &lt;&lt; endl;    // prints 36cout &lt;&lt; ((6 + 3) *  4) / 2 + 2 &lt;&lt; endl;    // prints 20cout &lt;&lt; 6 + 3 * 4  / (2 + 2) &lt;&lt; endl;      // prints 9</code></pre><h3 id="优先级与结合律有何影响"><a class="anchor" href="#优先级与结合律有何影响">#</a> 优先级与结合律有何影响</h3><p>优先级会影响程序的正确性</p><pre><code class="language-cpp">int ia[] = &#123;0,2,4,6,8&#125;; // array with five elements of type intint last = *(ia + 4);   // initializes last to 8, the value of ia [4]last = *ia + 4;          // last = 4, equivalent to ia [0] + 4</code></pre><p>结合律对表达式产生影响的一个典型示例是输入输出运算：IO 相关的运算符满足左结合律，因此，可以把几个 IO 运算组合在一条表达式当中</p><pre><code class="language-cpp">cin &gt;&gt; v1 &gt;&gt; v2; // read into v1 and then into v2</code></pre><h2 id="求值顺序"><a class="anchor" href="#求值顺序">#</a> 求值顺序</h2><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，并且，在大多数情况下，不会明确指定求值的顺序</p><p>例如，对于下列表达式，我们知道 f1 和 f2 一定会在执行乘法之前被调用，但是我们无法知道到底是先调用 f1 还是先调用 f2</p><pre><code class="language-cpp">int i = f1() * f2();</code></pre><p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为</p><p>例如， <code>&lt;&lt;</code>  运算符没有明确规定何时以及如何对运算对象求值，因此，下面的输出表达式是未定义的</p><pre><code class="language-cpp">int i = 0;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i &lt;&lt; endl; // undefined</code></pre><p>特别地，有 4 种运算符明确规定了运算对象的求值顺序：</p><ul><li>逻辑与（ <code>&amp;&amp;</code> ）运算符：先求左侧运算对象的值，只有当左侧运算对象的值为真时，才继续求右侧运算对象的值</li><li>逻辑或（ <code>||</code> ）运算符</li><li>条件（ <code>? : </code> ）运算符</li><li>逗号（ <code>,</code> ）运算符</li></ul><h3 id="求值顺序-优先级-结合律"><a class="anchor" href="#求值顺序-优先级-结合律">#</a> 求值顺序、优先级、结合律</h3><p>运算对象的求值顺序与优先级和结合律无关</p><p>例如，对于 f () + g () * h () + j () 这一表达式而言</p><ul><li>优先级规定：g () 的返回值和 h () 的返回值相乘</li><li>结合律规定：f () 的返回值先与 g () 和 h () 的乘积相加，所得结果再与 j () 的返回值相加</li><li>这些函数的调用顺序并没有明确规定</li></ul><p>如果 f 、g 、h 和 j 是无关函数，并且，不会改变同一对象的状态，也不执行 IO 任务，那么函数的调用顺序不受限制；反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为</p><p>建议：</p><ul><li>在不确定优先级和结合律的时候，最好加上括号来限定表达式的组合关系</li><li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用该运算对象</li></ul><blockquote><p>特别地，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时，第二条规则无效</p><p>例如，在表达式  <code>*++iter</code>  中，递增运算符改变 iter 的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算</p><p>显然，这是一种很常见的用法，不会造成什么问题</p></blockquote><h1 id="算术运算符"><a class="anchor" href="#算术运算符">#</a> 算术运算符</h1><p>如下所示，<strong>在算术运算符中，优先级最高的是正号和负号，其次是乘法和除法，最低是加法和减法</strong></p><p><img data-src="/posts/2d2eedc7/pic1.png" class=""></p><p>优先级高的运算符比优先级低的运算符组合得更紧密</p><p>以上所有算术运算符都满足 <strong>左结合律</strong> ，即，当优先级相同时，按照从左向右的顺序组合运算对象</p><p>除非另做特殊说明，算术运算符都能作用于任意算术类型以及任意能转换为算术类型的类型</p><p>算术运算符的运算对象和求值结果都是右值</p><p>一元正号运算符、加法运算符和减法运算符都能作用于指针</p><ul><li><p>When applied to a pointer or arithmetic value, unary plus returns a (possibly promoted) copy of the value of its operand.</p></li><li><p>The unary minus operator returns the result of negating a (possibly promoted) copy of the value of its operand.</p></li></ul><pre><code class="language-cpp">int i = 1024;int k = -i; // i is -1024bool b = true;bool b2 = -b; // b2 is true!</code></pre><p>对大多数运算符而言，布尔类型的运算对象将被提升为  <code>int</code>  类型</p><p>如上所示，布尔变量 b 的值为真，参与运算时将被提升成整数值 1 ，对它求负后的结果是 -1</p><blockquote><p>算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是 0 的情况；另外一部分则源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时就会产生溢出</p></blockquote><p>除法运算符  <code>/</code>  作用于两个整数时，所得结果仍为整数（向 0 取整，即直接切除小数部分）</p><pre><code class="language-cpp">int ival1 = 21/6;  // ival1 is 3; result is truncated; remainder is discardedint ival2 = 21/7;  // ival2 is 3; no remainder; result is an integral value</code></pre><p>在除法运算中，如果两个运算对象的符号相同则商为正（如果不为 0 的话），否则商为负</p><p>运算符  <code>%</code>  俗称 “取余” 或 “取模” 运算符，计算两个整数相除所得的余数，其中，参与取余运算的运算对象必须是整数类型</p><pre><code class="language-cpp">int ival = 42;double dval = 3.14;ival % 12;   // ok: result is 6ival % dval; // error: floating-point operand</code></pre><p>根据取余运算的定义，如果 m 和 n 是整数且 n 非 0 ，则表达式  <code>(m / n) * n + m % n</code>  的求值结果与 m 相等，隐含的意思是，<strong>如果 m % n 不等于 0 ，则它的符号和 m 相同</strong></p><pre><code class="language-cpp"> 21 % 6;   /*  result is 3   */ 21 / 6;   /*  result is 3   */ 21 % 7;   /*  result is 0   */ 21 / 7;   /*  result is 3   */-21 % -8;  /*  result is -5  */-21 / -8;  /*  result is 2   */ 21 % -5;  /*  result is 1   */ 21 / -5;  /*  result is -4  */</code></pre><blockquote><p>C++ 语言的早期版本允许 m % n 的符号匹配 n 的符号，而且 m /n 的结果向负无穷一侧取整，这一方式在新标准中已经被禁止使用了。除了 - m 导致溢出的特殊情况，其他时候 (- m) /n 和 m / (- n) 都等于 - (m /n) ，(- m) % n 和 m % (- n) 都等于 - (m % n)</p></blockquote><h1 id="逻辑和关系运算符"><a class="anchor" href="#逻辑和关系运算符">#</a> 逻辑和关系运算符</h1><p>关系运算符作用于算术类型或指针类型</p><p>逻辑运算符作用于任意能转换成布尔值的类型</p><p>逻辑运算符和关系运算符的返回值都是布尔类型，并且，运算对象和求值结果都是右值</p><p><img data-src="/posts/2d2eedc7/pic2.png" class=""></p><h2 id="逻辑运算符"><a class="anchor" href="#逻辑运算符">#</a> 逻辑运算符</h2><h3 id="逻辑与-逻辑或"><a class="anchor" href="#逻辑与-逻辑或">#</a> 逻辑与、逻辑或</h3><p>逻辑与运算符（ <code>&amp;&amp;</code> ）：当且仅当两个运算对象都为真时，结果为真</p><p>逻辑或运算符（ <code>||</code> ）：只要两个运算对象中的任意一个为真，结果就为真</p><p>逻辑与运算符、逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值</p><ul><li>对于逻辑与运算符，当且仅当左侧运算对象为真时才对右侧运算对象求值</li><li>对于逻辑或运算符，当且仅当左侧运算对象为假时才对右侧运算对象求值</li></ul><blockquote><p>这种策略称为短路求值（short-circuit evaluation</p></blockquote><h3 id="逻辑非"><a class="anchor" href="#逻辑非">#</a> 逻辑非</h3><p>逻辑非运算符（ <code>!</code> ）：将运算对象的值取反后返回</p><h2 id="关系运算符"><a class="anchor" href="#关系运算符">#</a> 关系运算符</h2><p>关系运算符：比较运算对象的大小关系并返回布尔值</p><p>关系运算符都满足左结合律</p><p>由于关系运算符的求值结果是布尔值，将几个关系运算符连写在一起则会产生意想不到的结果：</p><pre><code class="language-cpp">// oops! this condition compares k to the bool result of i &lt; jif (i &lt; j &lt; k) // true if k is greater than 1!</code></pre><p>在以上  <code>if</code>  语句的条件中，首先把 i、j 和第一个  <code>&lt;</code>  运算符组合在一起，然后将返回的布尔值作为第二个  <code>&lt;</code>  运算符的左侧运算对象</p><p>正确的用法应该是</p><pre><code class="language-cpp">// ok: condition is true if i is smaller than j and j is smaller than kif (i &lt; j &amp;&amp; j &lt; k) &#123; /* ...  */ &#125;</code></pre><h3 id="相等性测试与布尔字面值"><a class="anchor" href="#相等性测试与布尔字面值">#</a> 相等性测试与布尔字面值</h3><p>如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为  <code>if</code>  语句的条件：</p><pre><code class="language-cpp">if (val)  &#123; /*  ...  */ &#125; // true if val is any nonzero valueif (!val) &#123; /*  ...  */ &#125; // true if val is zero</code></pre><p>在上面的两个条件中，编译器都将 val 转换成布尔值。如果 val 非 0 则第一个条件为真，如果 val 值为 0 则第二个条件为真</p><p>有时会试图将上面的真值测试写成如下形式：</p><pre><code class="language-cpp">if (val == true) &#123; /* ...   */ &#125; // true only if val is equal to 1!</code></pre><p>但是这种写法存在两个问题：首先，与之前的代码相比，这种写法较长而且不太直接；更重要的一点是，如果 val 不是布尔值，这样的比较就失去了原来的意义</p><p>如果 val 不是布尔值，那么在比较之前会首先把 true 转换成 val 的类型，即，如果 val 不是布尔值，代码可以改写成如下形式：</p><pre><code class="language-cpp">if (val == 1) &#123; /* ... */ &#125;</code></pre><p>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象</p><blockquote><p>当布尔值转换成其他算术类型时，false 会转换成 0 ，而 true 会转换成 1</p></blockquote><h1 id="赋值运算符"><a class="anchor" href="#赋值运算符">#</a> 赋值运算符</h1><p><strong>赋值运算符的左侧运算对象必须是一个可修改的左值</strong></p><pre><code class="language-cpp">int i = 0, j = 0, k = 0; // initializations, not assignmentconst int ci = i;        // initialization, not assignment 1024 = k;      // error: literals are rvaluesi + j = k;     // error: arithmetic expressions are rvaluesci = k;        // error: ci is a const (nonmodifiable) lvalue</code></pre><p><strong>赋值运算的结果是它的左侧运算对象</strong>，并且，结果的类型就是左侧运算对象的类型</p><p>如果赋值运算符的左右两个运算对象的类型不同，则右侧运算对象将转换成左侧运算对象的类型</p><pre><code class="language-cpp">int k = 0;k = 3.14159;    //  result: type int, value 3</code></pre><p>C++ 11 新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象</p><ul><li><p>如果左侧运算对象是内置类型，初始值列表最多只能包含一个值。而且，即使进行类型转换的话，该值所占空间不应该大于目标类型的空间</p></li><li><p>对于类类型而言，赋值运算的细节由类本身决定。例如，vector 模板重载了赋值运算符，并且允许接收初始值列表（当赋值发生时，用右侧运算对象的元素替换左侧运算对象的元素）</p></li></ul><pre><code class="language-cpp">int k = 0;k = &#123;3.14&#125;;                 // error: narrowing conversionvector&lt;int&gt; vi;             // initially emptyvi = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // vi now has ten elements, values 0 through 9</code></pre><p>无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量，并将其赋给左侧运算对象</p><h2 id="赋值运算满足右结合律"><a class="anchor" href="#赋值运算满足右结合律">#</a> 赋值运算满足右结合律</h2><p>与其他二元运算符不同的是，<strong>赋值运算符满足右结合律</strong></p><pre><code class="language-cpp">int ival, jval;ival = jval = 0; // ok: each assigned 0</code></pre><p>在上例中，靠右赋值运算  <code>jval = 0</code>  作为靠左赋值运算符的右侧运算对象，因为赋值运算返回的是其左侧运算对象，靠右赋值运算的结果（即 jval ）将会被赋给 ival</p><p>对于多重赋值语句中的每一个对象，它的类型要么与右边对象的类型相同、要么可由右边对象的类型转换得到</p><pre><code class="language-cpp">int ival, *pval; // ival is an int; pval is a pointer to intival = pval = 0; // error: cannot assign the value of a pointer to an intstring s1, s2;s1 = s2 = &quot;OK&quot;;  // string literal &quot;OK&quot; converted to string</code></pre><p>上例中，ival 和 pval 的类型不同，而且 pval 的类型（ <code>int*</code> ）无法转换成 ival 的类型（ <code>int</code> ），因此，尽管 0 能赋给任何对象，但第一条赋值语句依然是非法的。与之相反，第二条赋值语句是合法的，这是因为字符串字面值可以转换成  <code>string</code>  对象并赋给 s2 ，而 s2 和 s1 的类型相同，所以 s2 的值可以继续赋给 s1</p><h2 id="赋值运算优先级较低"><a class="anchor" href="#赋值运算优先级较低">#</a> 赋值运算优先级较低</h2><p>赋值运算的优先级相对较低，通常需要给赋值部分加上括号使其符合我们的原意</p><p>例如，以下代码</p><pre><code class="language-cpp">// a verbose and therefore more error-prone way to write this loopint i = get_value();  // get the first valuewhile (i != 42) &#123;    // do something ...    i = get_value();  // get remaining values&#125;</code></pre><p>可改写为</p><pre><code class="language-cpp">// a better way to write our loop---what the condition does is now clearerint i;while ((i = get_value()) != 42) &#123;    // do something ...&#125;</code></pre><p>与第一个版本相比，第二个版本的  <code>while</code>  条件更容易表达我们的真实意图：不断循环读取数据直至遇到 42 为止。其处理过程为，首先将 get_value 函数的返回值赋给 i ，然后比较 i 和 42 是否相等</p><p>注意，如果不加括号的话，含义会有很大变化：比较运算符  <code>!=</code>  会将 get_value 函数的返回值与 42 进行比较</p><blockquote><p>赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号</p></blockquote><h2 id="切勿混淆相等运算符和赋值运算符"><a class="anchor" href="#切勿混淆相等运算符和赋值运算符">#</a> 切勿混淆相等运算符和赋值运算符</h2><p>C++ 语言允许用赋值运算作为条件</p><p>例如以下语句，在条件部分中，首先把 j 的值赋给 i ，然后检查 i 是否为真。如果 j 不为 0 ，条件将为真</p><pre><code class="language-cpp">if (i = j)</code></pre><p>然而，下列代码</p><pre><code class="language-cpp">if (i == j)</code></pre><p>则是在判断 i 与 j 是否相等</p><h2 id="复合赋值运算符"><a class="anchor" href="#复合赋值运算符">#</a> 复合赋值运算符</h2><p>我们经常需要对某个对象施以某种运算，然后再把计算的结果赋给该对象，例如：</p><pre><code class="language-cpp">int sum = 0;// sum values from 1 through 10 inclusivefor (int val = 1; val &lt;= 10; ++val)    sum += val; //  equivalent to sum = sum + val</code></pre><p><strong>复合赋值操作常常应用于算术运算符或者位运算符</strong></p><pre><code class="language-cpp">+=   -=    *=   /=   %=         // 算术运算符&lt;&lt;=  &gt;&gt;=   &amp;=   ^=   |=         // 位运算符</code></pre><p>其中，任意一种复合运算符都等价于</p><pre><code class="language-cpp">a = a operator b;</code></pre><p>唯一区别在于左侧运算对象的求值次数：</p><ul><li>使用复合运算符只求值一次</li><li>使用普通的运算符则求值两次<ul><li>一次是作为右边子表达式的一部分求值</li><li>另一次是作为赋值运算的左侧运算对象求值</li></ul></li></ul><p>当然，这种区别除了对程序性能有些许影响外，几乎可以忽略不计</p><h1 id="递增和递减运算符"><a class="anchor" href="#递增和递减运算符">#</a> 递增和递减运算符</h1><p>递增运算符（ <code>++</code> ）和递减运算符（ <code>--</code> ）分别对运算对象执行加 1 和减 1 操作</p><p>递增运算符和递减运算符可应用于迭代器</p><blockquote><p>很多迭代器本身不支持算术运算，但可以通过递增运算符和递减运算符移动迭代器</p></blockquote><p>递增和递减运算符有两种形式：</p><ul><li>前置版本（prefix）：运算符首先将运算对象加 1（或减 1），然后将改变后的对象作为求值结果</li><li>后置版本（postfix）：将运算对象加 1（或减 1），但是求值结果是运算对象改变之前那个值的副本</li></ul><pre><code class="language-cpp">int i = 0, j;j = ++i; // j = 1, i = 1j = i++; // j = 1, i = 2</code></pre><p>这两种运算符必须作用于左值运算对象</p><ul><li>前置版本将对象本身作为左值返回</li><li>后置版本将对象原始值的副本作为右值返回</li></ul><p>建议：<strong>尽可能使用前置版本的递增和递减运算符</strong></p><ul><li>前置版本的递增运算符把值加 1 后直接返回，避免了不必要的工作</li><li>后置版本需要将原始值存储下来，以便于返回这个未修改的内容</li></ul><blockquote><p>如果我们不需要递增（递减）运算符修改前的值，那么后置版本的操作就是一种浪费</p></blockquote><h2 id="解引用和递增运算符的结合"><a class="anchor" href="#解引用和递增运算符的结合">#</a> 解引用和递增运算符的结合</h2><p>如果在一个表达式中，我们既希望将变量加 1（或减 1）、又希望使用它原来的值，可以使用递增和递减运算符的后置版本</p><pre><code class="language-cpp">auto pbeg = v.begin();// 输出元素，直到到达尾后或者遇到第一个负数while (pbeg != v.end() &amp;&amp; *beg &gt;= 0)    cout &lt;&lt; *pbeg++ &lt;&lt; endl; // 输出当前值，并将 pbeg 向前移动</code></pre><p>由于 <strong>后置递增运算符的优先级高于解引用运算符</strong> ，在上例中，*pbeg++ 等价于 *(pbeg++)：pbeg++ 把 pbeg 的值加 1，然后返回 pbeg 初始值的副本作为其求值结果，即，解引用运算符的运算对象是 pbeg 未增加时的值</p><p>形如 *pbeg++ 的表达式，可能一开始不太容易理解，但其实这是一种被广泛使用的、有效的写法</p><p>例如， <code>cout &lt;&lt; *iter++ &lt;&lt; endl;</code>  要比下面的等价语句更简洁、也更少出错</p><pre><code class="language-cpp">cout &lt;&lt; *iter &lt;&lt; endl;++iter;</code></pre><h3 id="运算对象可按任意顺序求值"><a class="anchor" href="#运算对象可按任意顺序求值">#</a> 运算对象可按任意顺序求值</h3><p>大多数运算符都没有规定运算对象的求值顺序，这在一般情况下不会有什么影响。但是，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了</p><p>递增运算符和递减运算符会改变运算对象的值，因此，需要提防这两个运算符在复合表达式中的使用</p><p>例如，以下程序使用  <code>for</code>  循环将输入的第一个单词改成大写形式，其中，解引用 it 和递增 it 两项任务是分开进行的</p><pre><code class="language-cpp">for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)    *it = toupper(*it); // capitalize the current character</code></pre><p>如果将解引用 it 和递增 it 结合到一块，即，如下所示，将产生未定义的行为。这是因为：赋值运算符左右两端的运算对象都用到了 beg ，然而，右侧的运算对象改变了 beg 的值</p><pre><code class="language-cpp">while (beg != s.end() &amp;&amp; !isspace(*beg))    *beg = toupper(*beg++);   // 错误：该赋值语句未定义</code></pre><h1 id="成员访问运算符"><a class="anchor" href="#成员访问运算符">#</a> 成员访问运算符</h1><p>点运算符（  <code>.</code>  ）和箭头运算符（  <code>&gt;</code>  ）可共同用于访问成员，其中，点运算符获取类对象的一个成员，箭头运算符与点运算符有关</p><p>表达式  <code>ptr-&gt;mem</code>  等价于  <code>(*ptr).mem</code></p><pre><code class="language-cpp">string s1 = &quot;a string&quot;, *p = &amp;s1;auto n = s1.size(); // run the size member of the string s1n = (*p).size();    // run size on the object to which p pointsn = p-&gt;size();      // equivalent to (*p).size()</code></pre><p>其中，因为 <strong>解引用运算符的优先级低于点运算符</strong> ，执行解引用运算的子表达式两端必须加上括号</p><p>如果不加括号，即：</p><pre><code class="language-cpp">// run the size member of p, then dereference the result!*p.size();    // error: p is a pointer and has no member named size</code></pre><p>表达式试图访问对象 p 的 size 成员，然而，p 本身是一个指针且不包含任何成员，所以，上述语句无法通过编译</p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值</p><p>点运算符：</p><ul><li>如果成员所属的对象是左值，那么结果是左值</li><li>如果成员所属的对象是右值，那么结果是右值</li></ul><h1 id="条件运算符"><a class="anchor" href="#条件运算符">#</a> 条件运算符</h1><p>条件运算符（  <code>? : </code>  ）可以把简单的 if-else 逻辑嵌入到单个表达式当中</p><p>条件运算符按照如下形式使用：</p><pre><code>cond  ? expr1  : expr2;</code></pre><p>其中，cond 是判断条件的表达式，而 expr1 和 expr2 是两个类型相同（或者，可以转换为某个公共类型）的表达式</p><p>条件运算符的执行过程是：首先求 cond 的值，如果条件为真，则对 expr1 求值并返回该值，否则，对 expr2 求值并返回该值</p><p>例如，可以使用条件运算符来判断成绩是否合格:</p><pre><code class="language-cpp">string finalgrade = (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;</code></pre><p>当条件运算符的两个表达式都是左值（或者，能转换成同一种左值类型）时，运算的结果是左值；否则，运算的结果是右值</p><h2 id="嵌套条件运算符"><a class="anchor" href="#嵌套条件运算符">#</a> 嵌套条件运算符</h2><p>允许在条件运算符的内部嵌套另外一个条件运算符</p><p>即，条件表达式可以作为另外一个条件运算符的 cond 或 expr</p><p>例如，可以使用嵌套的条件运算符将成绩分成三档：优秀（high pass）、合格（pass）和不合格（fail）：</p><pre><code class="language-cpp">finalgrade = (grade &gt; 90) ? &quot;high pass&quot;                          : (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;</code></pre><p>上述语句首先检查成绩是否在 90 分以上，如果是，执行符号  <code>?</code>  后面的表达式，得到 &quot;high pass&quot; ；如果否，执行符号  <code>:</code>  后面的分支，即，继续检查成绩是否在 60 分以下，如果是，得到 &quot;fail&quot; ；否则，得到 &quot;pass&quot;</p><p><strong>条件运算符满足右结合律，即，运算对象（一般）按照从右向左的顺序组合</strong></p><p>因此，在上面的代码中，靠右边的条件运算（比较成绩是否小于 60）构成了靠左边的条件运算的  <code>:</code>  分支</p><blockquote><p>随着条件运算嵌套层数的增加，代码的可读性急剧下降，因此，条件运算的嵌套最好别超过两到三层</p></blockquote><h2 id="在输出表达式中使用条件运算符"><a class="anchor" href="#在输出表达式中使用条件运算符">#</a> 在输出表达式中使用条件运算符</h2><p>条件运算符的优先级非常低，因此，<strong>当一条长表达式中嵌套了条件运算表达式时，通常需要在它两端加上括号</strong></p><p>例如：有时需要根据条件值输出两个对象中的一个，如果写这条语句时没把括号写全就有可能产生意想不到的结果：</p><pre><code class="language-cpp">cout &lt;&lt; ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;); // 输出 pass 或者 failcout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;   // 输出 1 或者 0cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //  错误：试图比较 cout 和 60</code></pre><p>在第二个条件运算表达式中，grade 和 60 的比较结果是  <code>&lt;&lt;</code>  运算符的运算对象，因此，如果 grade &lt; 60 为真，输出 1，否则，输出 0。 <code>&lt;&lt;</code>  运算符的返回值是  <code>cout</code>  ，接下来，  <code>cout</code>  将作为条件运算符的条件。也就是说，第二条表达式等价于</p><pre><code class="language-cpp">cout &lt;&lt; (grade &lt; 60);    // 输出 1 或者 0cout ?  &quot;fail&quot; : &quot;pass&quot;; // 根据 cout 的值（true 或者 false）产生对应的字面值</code></pre><p>在第三个条件运算语句中，<strong>小于运算符的优先级低于移位运算符</strong> ，所以会先输出 grade，然后比较 cout 和 60 ，即，等价于：</p><pre><code class="language-cpp">cout &lt;&lt; grade;cout &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;;</code></pre><p>因此，第三个条件运算语句是错误的</p><h1 id="位运算符"><a class="anchor" href="#位运算符">#</a> 位运算符</h1><p>位运算符作用于整数类型的运算对象，并将运算对象视为二进制位的集合</p><blockquote><p>一种名为 bitset 的标准库类型也可以表示任意大小的二进制位集合，所以位运算符同样能用于 bitset 类型</p></blockquote><p>位运算符提供检查和设置二进制位的功能</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">功能</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">~</td><td style="text-align:center">位求反</td><td style="text-align:center">~ expr</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td><td style="text-align:center">expr1 &lt;&lt; expr2</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右移</td><td style="text-align:center">expr1 &gt;&gt; expr2</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td><td style="text-align:center">expr1 &amp; expr2</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">位异或</td><td style="text-align:center">expr1 ^ expr2</td></tr><tr><td style="text-align:center">|</td><td style="text-align:center">位或</td><td style="text-align:center">expr1 | expr2</td></tr></tbody></table><p>一般来说，如果运算对象是 “小整型”，则它的值会被自动提升成较大的整数类型</p><p>运算对象可以是带符号的，也可以是无符号的</p><blockquote><p>在执行位运算时，如果运算对象是带符号的且它的值为负，如何处理运算对象的 “符号位” 将依赖于机器。并且，此时的左移操作可能会改变符号位的值，因此是一种未定义的行为</p></blockquote><p>建议 <strong>仅将位运算符用于处理无符号类型</strong></p><h2 id="位求反运算符"><a class="anchor" href="#位求反运算符">#</a> 位求反运算符</h2><p>位求反运算符（~）将运算对象逐位求反（即，将 1 置为 0 、将 0 置为 1 ）后生成一个新值</p><p>特别地，针对 char 类型对象执行位求反运算时，首先会将 char 类型的运算对象提升成 int 类型（提升时，运算对象原来的位保持不变，往高位添加 0 即可），随后将提升后的值逐位求反</p><p>例如：<br /><img data-src="/posts/2d2eedc7/Example1.png" class=""></p><h2 id="移位运算符"><a class="anchor" href="#移位运算符">#</a> 移位运算符</h2><p>移位运算符包括左移和右移</p><p>移位运算符的内置含义：对运算对象执行基于二进制位的移动操作</p><ul><li>针对左侧运算对象的内容，移动右侧运算对象所要求的位数</li><li>将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果</li></ul><p>其中，右侧的运算对象一定不能为负，并且，其值必须严格小于结果的位数（否则，会产生未定义的结果）</p><p>左移运算符（&lt;&lt;）在右侧插入值为 0 的二进制位</p><p>右移运算符（&gt;&gt;）的行为依赖于其左侧运算对象的类型：</p><ul><li>如果左侧运算对象是无符号类型，在左侧插入值为 0 的二进制位</li><li>如果左侧运算对象是带符号类型，在左侧插入符号位的副本或值为 0 的二进制位（由具体环境确定）</li></ul><p>无论是左移还是右移，移出边界的位都会被舍弃掉</p><p><img data-src="/posts/2d2eedc7/Example2.png" class=""></p><h3 id="移位运算符满足左结合律"><a class="anchor" href="#移位运算符满足左结合律">#</a> 移位运算符满足左结合律</h3><p>重载运算符的优先级和结合律都与它的内置版本一样</p><p>即，IO 运算符的优先级和结合律与移位运算符一样</p><p>由于移位运算符满足左结合律， <code>cout &lt;&lt; &quot;hi&quot; &lt;&lt; &quot; there&quot; &lt;&lt; endl;</code>  等价于  <code>( (cout &lt;&lt; &quot;hi&quot;) &lt;&lt; &quot; there&quot; ) &lt;&lt; endl;</code></p><p>移位运算符的优先级比算术运算符低，但比关系运算符、赋值运算符和条件运算符高。因此，在一次使用多个运算符时，有必要在适当的地方加上括号使其满足我们的要求</p><p>例如：</p><pre><code class="language-cpp">cout &lt;&lt; 42 + 10;   // 正确：+ 的优先级更高，输出 52cout &lt;&lt; (10 &lt; 42); // 正确：括号的优先级高，输出 1cout &lt;&lt; 10 &lt; 42;   // 错误：试图比较 cout 和 42 （等价于 (cout &lt;&lt; 10) &lt; 42;）</code></pre><h2 id="位与-位或-位异或运算符"><a class="anchor" href="#位与-位或-位异或运算符">#</a> 位与、位或、位异或运算符</h2><p>位与运算：如果两个运算对象的对应位置都是 1，则该位的运算结果为 1，否则为 0</p><p>位或运算：如果两个运算对象的对应位置至少有一个为 1，则该位的运算结果为 1，否则为 0</p><p>位异或运算：位或运算：如果两个运算对象的对应位置有且只有一个为 1，则该位的运算结果为 1，否则为 0</p><blockquote><p>一种常见的错误是混淆位运算符和逻辑运算符：位与（&amp;）和逻辑与（&amp;&amp;）、位或（|）和逻辑或（||）、位求反（~）和逻辑非（!）</p></blockquote><h1 id="sizeof-运算符"><a class="anchor" href="#sizeof-运算符">#</a> sizeof 运算符</h1><p>sizeof 运算符返回一条表达式或一个类型名字所占的字节数</p><p>sizeof 运算符满足右结合律，其所得的值是一个  <code>size_t</code>  类型的常量表达式</p><p>sizeof 运算符的运算对象有两种形式：</p><pre><code class="language-cpp">sizeof (type)sizeof expr</code></pre><p>在第二种形式中，sizeof 返回的是表达式结果类型的大小</p><p>需注意的是，sizeof 并不实际计算其运算对象的值</p><pre><code class="language-cpp">Sales_data data, *p;sizeof(Sales_data);  // Sales_data 类型对象所占的空间大小sizeof data;         // data 的类型的大小，即 sizeof(Sales_data)sizeof p;            // 指针所占的空间大小sizeof *p;           // p 所指类型的大小，即 sizeof(Sales_data)sizeof data.revenue; // Sales_data 的 revenue 成员所对应的类型的大小sizeof Sales_data::revenue; // 另一种获取 revenue 大小的方式</code></pre><p>对于  <code>sizeof *p</code>  ：</p><ul><li><code>sizeof</code>  满足右结合律，并且  <code>sizeof</code>  的优先级与  <code>*</code>  运算符一样，所以，表达式按照从右向左的顺序组合，即，等价于  <code>sizeof(*p)</code></li><li><code>sizeof</code>  不会实际求运算对象的值，即便  <code>p</code>  是一个无效（即未初始化）指针也不会有什么影响</li></ul><blockquote><p>可以在 sizeof 的运算对象中解引用一个无效指针，因为指针实际上并没有被真正使用。sizeof 不需要真的解引用指针也能知道它所指对象的类型</p></blockquote><blockquote><p>C++ 11 允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但执行 sizeof 运算时无须提供一个具体的对象，因为 sizeof 不需要真正获取该成员</p></blockquote><p>sizeof 运算符的结果 部分地 依赖于其作用的类型：</p><ul><li>对 char 或者类型为 char 的表达式执行 sizeof 运算，结果为 1</li><li>对引用类型执行 sizeof 运算，结果为被引用对象所占空间的大小</li><li>对指针执行 sizeof 运算，结果为指针本身所占空间的大小</li><li>对解引用指针执行 sizeof 运算，结果为指针指向的对象所占空间的大小，指针不需有效</li><li>对数组执行 sizeof 运算，结果为整个数组所占空间的大小，等价于 对数组中所有的元素各执行一次 sizeof 运算并将所得结果求和（注意， sizeof 运算不会把数组转换成指针来处理）</li><li>对 string 对象或 vector 对象执行 sizeof 运算，结果为该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li></ul><p>因为执行 sizeof 运算能得到整个数组的大小，可以用整个数组的大小除以单个元素的大小，得到数组中的元素个数</p><pre><code class="language-cpp">// sizeof(ia) / sizeof(*ia) 返回 ia 数组中的元素个数constexpr size_t sz = sizeof(ia)/sizeof(*ia);int arr2[sz]; // sizeof 返回一个常量表达式</code></pre><p>因为 sizeof 的返回值是一个常量表达式，所以我们可以用 sizeof 的结果声明数组的维度</p><h1 id="逗号运算符"><a class="anchor" href="#逗号运算符">#</a> 逗号运算符</h1><p>逗号运算符（comma operator）含有两个运算对象，按照从左向右的顺序依次求值</p><p>逗号运算符规定了运算对象求值的顺序：</p><ul><li>首先对左侧的表达式求值，然后将求值结果丢弃掉</li><li>逗号运算符真正的结果是右侧表达式的值</li></ul><p>如果右侧运算对象是左值，那么最终的求值结果也是左值</p><p>逗号运算符经常被用在 for 循环中，例如：</p><pre><code class="language-cpp">vector&lt;int&gt;::size_type cnt = ivec.size();for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)    ivec[ix] = cnt;</code></pre><p>这个循环在 for 语句的表达式中递增 ix、递减 cnt，每次循环迭代时 ix 和 cnt 都会相应改变</p><h1 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h1><p>如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代</p><pre><code class="language-cpp">int ival = 3.541 + 3; // 初始化 ival 为 6</code></pre><p>在上面的例子中，3 转换成 double 类型，然后执行浮点数加法，所得结果的类型是 double，由于被初始化的对象 ival 为 int 型，需要将加法运算得到的 double 类型的结果转换成 int 类型的值</p><p>隐式转换（implicit conversion）：自动执行的类型转换，无须程序员的介入</p><p>在下面这些情况下，编译器会自动地转换运算对象的类型：</p><ul><li>在大多数表达式中，比 int 类型小的整型值首先提升为较大的整数类型</li><li>在条件中，非布尔值转换成布尔类型</li><li>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型</li><li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型</li><li>函数调用时也会发生类型转换</li></ul><h2 id="算术转换"><a class="anchor" href="#算术转换">#</a> 算术转换</h2><p>算术转换（arithmetic conversion）：把一种算术类型转换成另外一种算术类型</p><p>算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型，例如：</p><ul><li>如果一个运算对象的类型是 long double，那么不论另外一个运算对象的类型是什么都会转换成 long double</li><li>还有一种更普遍的情况：当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型</li></ul><h3 id="整型提升"><a class="anchor" href="#整型提升">#</a> 整型提升</h3><p>整型提升（integral promotion）负责把小整数类型转换成较大的整数类型</p><p>对于 bool、char、signed char、unsigned char、short 和 unsigned short 等类型，只要它们所有可能的值都能存进 int ，它们就会提升成 int 类型；否则，提升成 unsigned int 类型</p><p>较大的 char 类型（wchar_t、char16_t、char32_t）提升成 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中能容纳原类型所有可能值的、最小的一种类型</p><h3 id="无符号类型的运算对象"><a class="anchor" href="#无符号类型的运算对象">#</a> 无符号类型的运算对象</h3><p>如果某个运算对象的类型是无符号类型，转换的结果将依赖于机器中各个整数类型的相对大小。具体而言，首先执行整型提升，然后进一步根据运算对象的类型做进一步转换</p><ul><li>如果结果的类型匹配，无须进行进一步的转换</li><li>如果两个（提升后的）运算对象都是带符号类型或者都是无符号类型，则小类型的运算对象转换成较大的类型</li><li>如果一个运算对象是无符号类型、另外一个运算对象是带符号类型<ul><li>如果无符号类型不小于带符号类型：将带符号的运算对象转换成无符号的</li><li>如果带符号类型大于无符号类型，此时转换的结果依赖于机器<ul><li>如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型</li><li>如果不能，那么带符号类型的运算对象转换成无符号类型</li></ul></li></ul></li></ul><p>要想理解算术转换，办法之一就是研究大量的例子：</p><pre><code class="language-cpp">bool      flag;         char           cval;short     sval;         unsigned short usval;int       ival;         unsigned int   uival;long      lval;         unsigned long  ulval;float     fval;         double         dval;3.14159L + 'a'; //  'a' 提升成 int，然后 int 值转换成 long doubledval + ival;    //  ival 转换成 doubledval + fval;    //  fval 转换成 doubleival = dval;    //  dval 转换成 intflag = dval;    //  如果 dval 为 0，则 flag 为 false，否则 flag 为 truecval + fval;    //  cval 提升成 int，然后 int 值转换成 floatsval + cval;    //  sval 和 cval 都提升成 intcval + lval;    //  cval 转换成 longival + ulval;   //  ival 转换成 unsigned longusval + ival;   //  根据 unsigned short 和 int 所占空间的大小进行提升uival + lval;   //  根据 unsigned int 和 long 所占空间的大小进行转换</code></pre><h2 id="其他隐式类型转换"><a class="anchor" href="#其他隐式类型转换">#</a> 其他隐式类型转换</h2><p>除了算术转换之外还有几种隐式类型转换，包括如下几种</p><h3 id="数组转换成指针"><a class="anchor" href="#数组转换成指针">#</a> 数组转换成指针</h3><p>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针</p><pre><code class="language-cpp">int ia[10];int* ip = ia;</code></pre><p>当数组被用作 decltype 关键字的参数，或者作为取地址符（&amp;）、sizeof 及 typeid 等运算符的运算对象时，上述转换不会发生</p><p>如果用一个引用来初始化数组，上述转换也不会发生</p><h3 id="指针的转换"><a class="anchor" href="#指针的转换">#</a> 指针的转换</h3><p>C++ 规定了几种其他的指针转换方式</p><ul><li>常量整数值 0 或者字面值 nullptr 能转换成任意指针类型</li><li>指向任意非常量的指针能转换成 void*</li><li>指向任意对象的指针能转换成 const void*</li></ul><p>此外，在有继承关系的类型间还有另外一种指针转换的方式</p><h3 id="转换成布尔类型"><a class="anchor" href="#转换成布尔类型">#</a> 转换成布尔类型</h3><p>存在一种从算术类型或指针类型向布尔类型自动转换的机制：如果指针或算术类型的值为 0 ，转换结果是 false ；否则转换结果是 true</p><h3 id="转换成常量"><a class="anchor" href="#转换成常量">#</a> 转换成常量</h3><p>允许将指向非常量类型的指针转换成指向相应的常量类型的指针</p><p>允许将绑定非常量类型的引用转换成绑定相应的常量类型的引用</p><p>也就是说，如果 T 是一种类型，我们就能将指向 T 的指针或引用分别转换成指向 const T 的指针或引用</p><pre><code class="language-cpp">int i;const int &amp;j = i;const int *p = &amp;i;</code></pre><p>相反的转换并不存在，因为它试图删除掉底层 const</p><pre><code class="language-cpp">int &amp;r = j, *q = p; // 错误：不允许 const 转换成非常量</code></pre><h3 id="类类型定义的转换"><a class="anchor" href="#类类型定义的转换">#</a> 类类型定义的转换</h3><p>类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换</p><p>我们之前已经使用过类类型转换：一处是在需要标准库 string 类型的地方使用 C 风格字符串；另一处是在条件部分读入 istream</p><pre><code class="language-cpp">string s, t = &quot;a value&quot;;  // 字符串字面值转换成 string 类型while (cin &gt;&gt; s)          // while 的条件部分把 cin 转换成 bool 值</code></pre><h2 id="显式转换"><a class="anchor" href="#显式转换">#</a> 显式转换</h2><p>有时我们希望显式地将对象强制转换成另外一种类型，即，<strong>强制类型转换</strong>（cast）</p><p>例如，如果想在下面的代码中执行浮点数除法，就需要使用某种方法将 i 和（或）j 显式地转换成 double</p><pre><code class="language-cpp">int i, j;double slope = i / j;</code></pre><blockquote><p>虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的</p></blockquote><h3 id="命名的强制类型转换"><a class="anchor" href="#命名的强制类型转换">#</a> 命名的强制类型转换</h3><p>一个命名的强制类型转换具有如下形式：</p><pre><code class="language-cpp">cast-name&lt;type&gt;(expression);</code></pre><p>其中，type 是转换的目标类型，expression 是要转换的值，cast-name 是 <strong>static_cast</strong>、<strong>dynamic_cast</strong>、<strong>const_cast</strong> 和 <strong>reinterpret_cast</strong> 中的一种</p><p>如果 type 是引用类型，则结果是左值</p><p>cast-name 指定了执行的是哪种转换（dynamic_cast 支持运行时类型识别）</p><h3 id="static_cast"><a class="anchor" href="#static_cast">#</a> static_cast</h3><p>任何具有明确定义的类型转换，只要不包含底层 const ，都可以使用 static_cast</p><p>例如，将一个运算对象强制转换成 double 类型以便执行浮点数除法：</p><pre><code class="language-cpp">// 进行强制类型转换以便执行浮点数除法double slope = static_cast&lt;double&gt;(j) / i;</code></pre><p>当需要把一个较大的算术类型赋值给较小的类型时，static_cast 非常有用</p><ul><li>一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息</li><li>但是当我们执行了显式的类型转换后，警告信息就会被关闭了</li></ul><p>static_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用 static_cast 找回存在于 void* 指针中的值</p><pre><code class="language-cpp">void* p = &amp;d;   // 任何非常量对象的地址都能存入 void*double *dp = static_cast&lt;double*&gt;(p); // 将 void* 转换回初始的指针类型</code></pre><p>当我们把指针存放在 void* 中，并且使用 static_cast 将其强制转换回原来的类型时，应该确保指针的值保持不变（即，强制转换的结果将与原始的地址值相等），因此，必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果</p><h3 id="const_cast"><a class="anchor" href="#const_cast">#</a> const_cast</h3><p>const_cast 只能改变运算对象的底层 const：</p><pre><code class="language-cpp">const char *pc;char *p = const_cast&lt;char*&gt;(pc); // 正确，但通过 p 写值是未定义的行为（因为 pc 所指对象本身是常量）</code></pre><p>对于将常量对象转换成非常量对象的行为，我们一般称其为 “去掉 const 性质（cast away the const）”</p><p>一旦我们去掉了某个对象的 const 性质，编译器就不回再阻止对该对象的写操作</p><ul><li>如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为</li><li>如果对象是一个常量，再使用 const_cast 执行写操作，会产生未定义的后果</li></ul><p>只有 const_cast 能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误</p><p>不能用 const_cast 改变表达式的类型：</p><pre><code class="language-cpp">const char *cp;char *q = static_cast&lt;char*&gt;(cp); // 错误: static_cast 不能去掉 const 性质static_cast&lt;string&gt;(cp); // 正确：字符串字面值转换成 string 类型const_cast&lt;string&gt;(cp);  // 错误：const_cast 只改变常量属性</code></pre><p>const_cast 常常用于有函数重载的上下文中</p><h3 id="reinterpret_cast"><a class="anchor" href="#reinterpret_cast">#</a> reinterpret_cast</h3><p>reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释</p><p>例如，假设有如下的转换</p><pre><code class="language-cpp">int *ip;char *pc = reinterpret_cast&lt;char*&gt;(ip); // 效果类似 C 风格的强制转换</code></pre><p>我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误</p><blockquote><p>reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解</p></blockquote><p>建议：尽量避免强制类型转换，尤其是 reinterpret_cast</p><h3 id="旧式的强制类型转换"><a class="anchor" href="#旧式的强制类型转换">#</a> 旧式的强制类型转换</h3><p>在早期版本的 C++ 语言中，显式地进行强制类型转换包含两种形式</p><pre><code class="language-cpp">type (expr); // 函数形式的强制类型转换(type) expr; // C 语言风格的强制类型转换</code></pre><p>当我们在某处执行旧式的强制类型转换时，如果换成 const_cast 和 static_cast 也合法，则其行为与对应的命名转换一致</p><p>如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能</p><pre><code class="language-cpp">int *ip;char *pc = (char*) ip; // ip 是指向 int 的指针</code></pre><h1 id="运算符优先级表"><a class="anchor" href="#运算符优先级表">#</a> 运算符优先级表</h1><p>从上到下，不同表格的优先级按从高到低排列，其中，同一个表格中的多个运算符具有相同的优先级</p><table><thead><tr><th style="text-align:center">结合律</th><th style="text-align:center">运算符</th><th style="text-align:center">功能</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">::</td><td style="text-align:center">全局作用域</td><td style="text-align:center">::name</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">::</td><td style="text-align:center">类作用域</td><td style="text-align:center">class::name</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">::</td><td style="text-align:center">命名空间作用域</td><td style="text-align:center">namespace::name</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">.</td><td style="text-align:center">成员选择</td><td style="text-align:center">object.member</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">-&gt;</td><td style="text-align:center">成员选择</td><td style="text-align:center">pointer-&gt;member</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">[]</td><td style="text-align:center">下标</td><td style="text-align:center">expr1[expr2]</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">()</td><td style="text-align:center">函数调用</td><td style="text-align:center">name(expr_list)</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">()</td><td style="text-align:center">类型构造</td><td style="text-align:center">type(expr_list)</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">++</td><td style="text-align:center">后置递增运算</td><td style="text-align:center">lvalue++</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">--</td><td style="text-align:center">后置递减运算</td><td style="text-align:center">lvalue--</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">typeid</td><td style="text-align:center">类型 ID</td><td style="text-align:center">typeid(type)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">typeid</td><td style="text-align:center">运行时类型 ID</td><td style="text-align:center">typeid(expr)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">explicit cast</td><td style="text-align:center">类型转换</td><td style="text-align:center">cast_name&lt;type&gt;(expr)</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">++</td><td style="text-align:center">前置递增运算</td><td style="text-align:center">++lvalue</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">--</td><td style="text-align:center">前置递减运算</td><td style="text-align:center">--lvalue</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">~</td><td style="text-align:center">位求反</td><td style="text-align:center">~expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">!</td><td style="text-align:center">逻辑非</td><td style="text-align:center">!expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">-</td><td style="text-align:center">一元负号</td><td style="text-align:center">-expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">+</td><td style="text-align:center">一元正号</td><td style="text-align:center">+expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">*</td><td style="text-align:center">解引用</td><td style="text-align:center">*expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">&amp;</td><td style="text-align:center">取地址</td><td style="text-align:center">&amp;expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">()</td><td style="text-align:center">类型转换</td><td style="text-align:center">(type) expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">sizeof</td><td style="text-align:center">对象的大小</td><td style="text-align:center">sizeof expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">sizeof</td><td style="text-align:center">类型的大小</td><td style="text-align:center">sizeof(type)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">sizeof...</td><td style="text-align:center">参数包的大小</td><td style="text-align:center">sizeof...(name)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">new</td><td style="text-align:center">创建对象</td><td style="text-align:center">new type</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">new[]</td><td style="text-align:center">创建数组</td><td style="text-align:center">new type[size]</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">delete</td><td style="text-align:center">释放对象</td><td style="text-align:center">delete expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">delete[]</td><td style="text-align:center">释放数组</td><td style="text-align:center">delete[] expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">noexcept</td><td style="text-align:center">能否抛出异常</td><td style="text-align:center">noexcept (expr)</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">-&gt;*</td><td style="text-align:center">指向成员选择的指针</td><td style="text-align:center">ptr-&gt;*ptr_to_member</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">.*</td><td style="text-align:center">指向成员选择的指针</td><td style="text-align:center">obj.*ptr_to_member</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">*</td><td style="text-align:center">乘法</td><td style="text-align:center">expr1 * epxr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">/</td><td style="text-align:center">除法</td><td style="text-align:center">expr1 / epxr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">%</td><td style="text-align:center">取模（取余）</td><td style="text-align:center">expr1 % epxr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">+</td><td style="text-align:center">加法</td><td style="text-align:center">expr1 + epxr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">-</td><td style="text-align:center">减法</td><td style="text-align:center">expr1 - expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">向左移位</td><td style="text-align:center">expr1 &lt;&lt; expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">向右移位</td><td style="text-align:center">expr1 &gt;&gt; expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td><td style="text-align:center">expr1 &lt; expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td><td style="text-align:center">expr1 &lt;= expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td><td style="text-align:center">expr1 &gt; expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td><td style="text-align:center">expr1 &gt;= expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">==</td><td style="text-align:center">相等</td><td style="text-align:center">expr1 == expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">!=</td><td style="text-align:center">不相等</td><td style="text-align:center">expr1 != expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td><td style="text-align:center">expr1 &amp; expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">^</td><td style="text-align:center">位异或</td><td style="text-align:center">expr1 ^ expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">|</td><td style="text-align:center">位或</td><td style="text-align:center">expr1 | expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑与</td><td style="text-align:center">expr1 &amp;&amp; expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">||</td><td style="text-align:center">逻辑或</td><td style="text-align:center">expr1 || expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">? :</td><td style="text-align:center">条件</td><td style="text-align:center">expr1 ? expr2 : epxr3</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">=</td><td style="text-align:center">赋值</td><td style="text-align:center">lvalue = expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">*=,/=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=</td><td style="text-align:center">复合赋值</td><td style="text-align:center">lvalue += expr 等</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">throw</td><td style="text-align:center">抛出异常</td><td style="text-align:center">throw expr</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">,</td><td style="text-align:center">逗号</td><td style="text-align:center">expr1, expr2</td></tr></tbody></table><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><strong>算术转换（arithmetic conversion）</strong>：从一种算术类型转换成另一种算术类型。在二元运算符的上下文中，为了保留精度，算术转换通常把较小的类型转换成较大的类型（例如整型转换成浮点型）</p><p><strong>结合律（associativity）</strong>：规定具有相同优先级的运算符如何组合在一起。结合律分为左结合律（运算符从左向右组合）和右结合律（运算符从右向左组合）</p><p><strong>二元运算符（binary operator）</strong>：有两个运算对象参与运算的运算符</p><p><strong>强制类型转换（cast）</strong>：一种显式的类型转换</p><p><strong>复合表达式（compound expression）</strong>：含有多于一个运算符的表达式</p><p><strong>const_cast</strong> ：一种涉及 const 的强制类型转换。将底层 const 对象转换成对应的非常量类型，或者执行相反的转换</p><p><strong>转换（conversion）</strong>：一种类型的值改变成另一种类型的值的过程</p><p><strong>dynamic_cast</strong> ：和继承及运行时类型识别一起使用</p><p><strong>表达式（expression）</strong>：C++ 程序中最低级别的计算。表达式将运算符作用于一个或多个运算对象，每个表达式都有对应的求值结果。表达式本身也可以作为运算对象，这时就得到了对多个运算符求值的复合表达式</p><p><strong>隐式转换（implicit conversion）</strong>：由编译器自动执行的类型转换。假如表达式需要某种特定的类型而运算对象是另外一种类型，此时只要规则允许，编译器就会自动地将运算对象转换成所需的类型</p><p><strong>整型提升（integral promotion）</strong>：把一种较小的整数类型转换成与之最接近的较大整数类型的过程。不论是否真的需要，小整数类型（即 short 、char 等）总是会得到提升</p><p><strong>左值（lvalue）</strong>：是指那些求值结果为对象或函数的表达式。一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象</p><p><strong>运算对象（operand）</strong>：表达式在某些值上执行运算，这些值就是运算对象。一个运算符有一个或多个相关的运算对象</p><p><strong>运算符（operator）</strong>：决定表达式所做操作的符号</p><ul><li>C++ 语言定义了一套运算符并说明了这些运算符作用于内置类型时的含义</li><li>C++ 还定义了运算符的优先级和结合律以及每种运算符处理的运算对象数量</li><li>可以重载运算符使其能处理类类型</li></ul><p><strong>求值顺序（order of evaluation）</strong>：是某个运算符的运算对象的求值顺序</p><ul><li>大多数情况下，编译器可以任意选择运算对象求值的顺序（运算对象一定要在运算符之前得到求值结果）</li><li>只有 &amp;&amp; 、|| 、条件和逗号四种运算符明确规定了求值顺序</li></ul><p><strong>重载运算符（overloaded operator）</strong>：针对某种运算符重新定义的适用于类类型的版本</p><p><strong>优先级（precedence）</strong>：规定了复合表达式中不同运算符的执行顺序。与低优先级的运算符相比，高优先级的运算符组合得更紧密</p><p><strong>reinterpret_cast</strong> ：把运算对象的内容解释成另外一种类型。这种强制类型转换本质上依赖于机器而且非常危险</p><p><strong>结果（result）</strong>：计算表达式得到的值或对象</p><p><strong>右值（rvalue）</strong>：是指一种表达式，其结果是值而非值所在的位置</p><p><strong>短路求值（short-circuit evaluation）</strong>：描述逻辑与运算符和逻辑或运算符的执行过程。如果根据运算符的第一个运算对象就能确定整个表达式的结果，求值终止，此时第二个运算对象将不会被求值</p><p><strong>sizeof</strong> ：是一个运算符，返回存储对象所需的字节数，该对象的类型可能是某个给定的类型名字，也可能由表达式的返回结果确定</p><p><strong>static_cast</strong> ：显式地执行某种定义明确的类型转换，常用于替代由编译器隐式执行的类型转换</p><p><strong>一元运算符（unary operators）</strong>：只有一个运算对象参与运算的运算符</p><p><strong>, 运算符（, operator）</strong>：逗号运算符，是一种从左向右求值的二元运算符。逗号运算符的结果是右侧运算对象的值，当且仅当右侧运算对象是左值时逗号运算符的结果是左值</p><p><strong>? : 运算符（? : operator）</strong>：条件运算符</p><ul><li>cond ? expr1 : expr2 提供 if-then-else 逻辑的表达式：如果条件 cond 为真，对 expr1 求值；否则对 expr2 求值</li><li>expr1 和 expr2 的类型应该相同或者能转换成同一种类型</li><li>expr1 和 expr2 中只有一个会被求值</li></ul><p><strong>&amp;&amp; 运算符（&amp;&amp;operator）</strong>：逻辑与运算符，如果两个运算对象都是真，结果才为真。只有当左侧运算对象为真时才会检查右侧运算对象</p><p><strong>&amp; 运算符（&amp;operator）</strong>：位与运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位都是 1 ，所得结果中该位为 1 ；否则所得结果中该位为 0</p><p><strong>^ 运算符（^ operator）</strong>：位异或运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位有且只有一个是 1 ，所得结果中该位为 1 ；否则所得结果中该位为 0</p><p><strong>|| 运算符（|| operator）</strong>：逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象</p><p><strong>| 运算符（| operator）</strong>：位或运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位至少有一个是 1 ，所得结果中该位为 1 ；否则所得结果中该位为 0</p><p><strong>++ 运算符（++ operator）</strong>：递增运算符。包括两种形式：前置版本和后置版本</p><ul><li>前置递增运算符得到一个左值，它给运算符加 1 并得到运算对象改变后的值</li><li>后置递增运算符得到一个右值，它给运算符加 1 并得到运算对象原始的、未改变的值的副本</li><li>注意：即使迭代器没有定义 + 运算符，也会有 ++ 运算符</li></ul><p><strong>-- 运算符（-- operator）</strong>：递减运算符。包括两种形式：前置版本和后置版本</p><ul><li>前置递减运算符得到一个左值，它从运算符减 1 并得到运算对象改变后的值</li><li>后置递减运算符得到一个右值，它从运算符减 1 并得到运算对象原始的、未改变的值的副本</li><li>注意：即使迭代器没有定义 - 运算符，也会有 -- 运算符</li></ul><p><strong>&lt;&lt; 运算符（ <code>&lt;&lt; operator</code> ）</strong>：左移运算符，将左侧运算对象的值的（可能是提升后的）副本向左移位，移动的位数由右侧运算对象确定。右侧运算对象必须大于等于 0 而且小于结果的位数。左侧运算对象应该是无符号类型，如果它是带符号类型，则一旦移动改变了符号位的值就会产生未定义的结果</p><p><strong>&gt;&gt; 运算符（&gt;&gt; operator）</strong>：右移运算符，除了移动方向相反，其他性质都和左移运算符类似。如果左侧运算对象是带符号类型，那么根据实现的不同新移入的内容也不同，新移入的位可能都是 0 ，也可能都是符号位的副本</p><p><strong>~ 运算符（~ operator）</strong>：位求反运算符，生成一个新的整型值。该值的每一位恰好与（可能是提升后的）运算对象的对应位相反</p><p><strong>! 运算符（! operator）</strong>：逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假</p><p>参考：C++ Primer 中文版（第 5 版）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 278. 第一个错误的版本</title>
      <link href="/posts/4cc2938/"/>
      <url>/posts/4cc2938/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmlyc3QtYmFkLXZlcnNpb24v">LeetCode 278</span></p><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有  <code>n</code>  个版本  <code>[1, 2, ..., n]</code> ，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用  <code>bool isBadVersion(version)</code>  接口来判断版本号  <code>version</code>  是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：n = 5, bad = 4输出：4解释：    调用 isBadVersion(3) -&gt; false     调用 isBadVersion(5) -&gt; true     调用 isBadVersion(4) -&gt; true    所以，4 是第一个错误的版本。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1, bad = 1输出：1</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>bad</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>  <code>n</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="method-二分查找"><a class="anchor" href="#method-二分查找">#</a> Method: 二分查找</h2><p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本</p><p>将左右边界分别初始化为  <code>1</code>  和  <code>n</code>  ，其中  <code>n</code>  是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界</p><p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧  <code>O(logn)</code>  次</p><pre><code class="language-cpp">int firstBadVersion(int n) &#123;    int left = 1, right = n;    while (left &lt; right) &#123;  // 循环直至区间左右端点相同        int mid = left + (right - left) / 2; // 防止计算时溢出        if (isBadVersion(mid)) &#123;            right = mid;    // 答案在区间 [left, mid] 中        &#125; else &#123;            left = mid + 1; // 答案在区间 [mid+1, right] 中        &#125;    &#125;    // 此时有 left == right，区间缩为一个点，即为答案    return left;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中  <code>n</code>  是给定版本的数量</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。我们只需要常数的空间保存若干变量</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 557. 反转字符串中的单词 III</title>
      <link href="/posts/e1635286/"/>
      <url>/posts/e1635286/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS13b3Jkcy1pbi1hLXN0cmluZy1paWkv">LeetCode 557</span></p><p>给定一个字符串  <code>s</code>  ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;Let's take LeetCode contest&quot;输出：&quot;s'teL ekat edoCteeL tsetnoc&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;God Ding&quot;输出：&quot;doG gniD&quot;</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code>  包含可打印的 ASCII 字符</li><li><code>s</code>  不包含任何开头或结尾空格</li><li><code>s</code>  里 至少 有一个词</li><li><code>s</code>  中的所有单词都用一个空格隔开</li><li></li></ul><h2 id="method-1-双指针原地解法"><a class="anchor" href="#method-1-双指针原地解法">#</a> Method 1: 双指针（原地解法）</h2><p>当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符…… 如此反复，就可以在原空间上翻转单词。</p><p>具体流程如下：</p><ol><li>指针  <code>left</code>  指向第一个字符或空字符前一个字符（双指针中的左端指针）</li><li>指针  <code>search</code>  向右搜索</li><li>当  <code>search</code>  搜索到空字符或尾后时，将  <code>search - 1</code>  赋给双指针中的右端指针  <code>right</code></li><li>将  <code>left</code>  和  <code>right</code>  之间的所有字符反转</li></ol><p>重复上述操作，直到所有字符均已被反转</p><pre><code class="language-cpp">string reverseWords(string s) &#123;    int search = 0;    auto n = s.size();    while (search &lt; n)    &#123;        int left = search;                       // left指向第一个字符或空字符后一个字符        while (s[search] != ' ' &amp;&amp; search &lt; n)   // 向右搜索，直到遇到空字符或者最后一个字符        &#123;            search++;        &#125;;        int right = search - 1;                  // right指向空字符前一个位置，即，单词最后一个字符所在位置        while (left &lt; right)                     // 反转单词        &#123;            swap(s[left], s[right]);            left++;            right--;        &#125;;        search++;                                // 继续搜索    &#125;;    return s;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，字符串中的每个字符要么在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间内被交换到相应的位置，要么因为是空格而保持不动</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，因为不需要开辟额外的数组</p><h2 id="method-2-双指针使用额外空间"><a class="anchor" href="#method-2-双指针使用额外空间">#</a> Method 2: 双指针（使用额外空间）</h2><p>开辟一个新字符串。从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词并得到单词的起止位置。随后，将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串。</p><pre><code class="language-cpp">string reverseWords(string s) &#123;    string ret;    int length = s.length();    int i = 0;    while (i &lt; length) &#123;        int start = i;        while (i &lt; length &amp;&amp; s[i] != ' ') &#123;            i++;        &#125;        for (int p = start; p &lt; i; p++) &#123;            ret.push_back(s[start + i - 1 - p]);        &#125;        while (i &lt; length &amp;&amp; s[i] == ' ') &#123;            i++;            ret.push_back(' ');        &#125;    &#125;    return ret;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为字符串的长度。原字符串中的每个字符都会在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间内放入新字符串中</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，开辟了与原字符串等大的空间</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 344. 反转字符串</title>
      <link href="/posts/d9baf118/"/>
      <url>/posts/d9baf118/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1zdHJpbmcv">LeetCode 344. Reverse String</span></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组  <code>s</code>  的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改</strong>输入数组、使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的额外空间解决这一问题。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>s.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s[i]</code>  都是 ASCII 码表中的可打印字符</li></ul><h2 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h2><p>解题步骤：</p><ol><li>定义  <code>left</code>  指向字符数组首元素， <code>right</code>  指向字符数组尾元素</li><li>当  <code>left &lt; right</code>  时，执行循环：交换  <code>s[left]</code>  和  <code>s[right]</code>  ， <code>left</code>  指针右移一位； <code>right</code>  指针左移一位</li></ol><p>代码如下：</p><pre><code class="language-cpp">void reverseString(vector&lt;char&gt;&amp; s) &#123;    int left = 0, right = s.size() - 1; // 双指针    while (left &lt; right)        swap(s[left++], s[right--]);    // 交换，并移动指针&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为字符数组的长度，一共执行了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 次的交换</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>如果库函数仅仅是解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数，例如这里使用的  <code>swap</code>  函数</p><p><code>swap</code>  函数具有两种实现方式，以交换  <code>s[left]</code>  和  <code>s[right]</code>  为例：</p><ol><li><p>直接交换数值</p><pre><code> int temp = s[left]; // 中间量 s[left] = s[right]; s[right] = temp;</code></pre></li><li><p>位运算（异或）</p><pre><code> s[left] ^= s[right]; // 中间量 s[right] ^= s[left]; // 将中间量与 s[right] 进行异或运算， = 号右边得到的是原始的 s[left] s[left] ^= s[right]; // 将中间量与 s[right] （即原始的 s[left] ） 进行异或运算， = 号右边得到的是原始的 s[right]</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
      <link href="/posts/81250b8a/"/>
      <url>/posts/81250b8a/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQv">LeetCode 167</span></p><p>给你一个下标从 1 开始的整数数组  <code>numbers</code>  ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数  <code>target</code>  的两个数。如果设这两个数分别是  <code>numbers[index1]</code>  和  <code>numbers[index2]</code>  ，则  <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>  。</p><p>以长度为 2 的整数数组  <code>[index1, index2]</code>  的形式返回这两个整数的下标  <code>index1</code>  和  <code>index2</code> 。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：numbers = [2,7,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numbers = [2,3,4], target = 6输出：[1,3]解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：numbers = [-1,0], target = -1输出：[1,2]解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</code></pre><h2 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h2><p>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较：</p><ol><li>如果两个元素之和等于目标值，则发现了唯一解。</li><li>如果两个元素之和小于目标值，则将左侧指针右移一位。</li><li>如果两个元素之和大于目标值，则将右侧指针左移一位。</li></ol><p>移动指针之后，重复上述操作，直到找到答案。</p><pre><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;    int i = 0, j = numbers.size() - 1;    while (i &lt; j)    &#123;        if (numbers[i] == target - numbers[j])            return &#123;i + 1, j + 1&#125;;        else if (numbers[i] &lt; target - numbers[j])            i++;        else            j--;    &#125;;    return &#123;-1, -1&#125;;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度。两个指针移动的总次数最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-二分查找"><a class="anchor" href="#method-2-二分查找">#</a> Method 2: 二分查找</h2><p>在数组中找到两个数，使得它们的和等于目标值，可以首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。</p><pre><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;    for (int i = 0; i &lt; numbers.size(); ++i) &#123;        int low = i + 1, high = numbers.size() - 1;        while (low &lt;= high) &#123;            int mid = (high - low) / 2 + low;            if (numbers[mid] == target - numbers[i]) &#123;                return &#123;i + 1, mid + 1&#125;;            &#125; else if (numbers[mid] &gt; target - numbers[i]) &#123;                high = mid - 1;            &#125; else &#123;                low = mid + 1;            &#125;        &#125;    &#125;    return &#123;-1, -1&#125;;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><ul><li>需要遍历数组一次确定第一个数，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>寻找第二个数使用二分查找，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQvc29sdXRpb24vbGlhbmctc2h1LXpoaS1oZS1paS1zaHUtcnUteW91LXh1LXNodS16dS1ieS1sZWV0LTIv">题解：推荐使用双指针方法</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 283. 移动零</title>
      <link href="/posts/35c387f3/"/>
      <url>/posts/35c387f3/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW92ZS16ZXJvZXMv">LeetCode 283. Move Zeroes</span></p><p>给定一个数组  <code>nums</code>  ，编写一个函数将所有  <code>0</code>  移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [0,1,0,3,12]输出：[1,3,12,0,0]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>&lt;</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">-2^{31} &lt;=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><p><strong>进阶</strong>：你能尽量减少完成的操作次数吗？</p><h1 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h1><p>算法思路：</p><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移</p><p>因此，每次交换都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变</p><p>代码实现：</p><pre><code class="language-cpp">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int left = 0;    for (int right = 0; right &lt; nums.size(); ++right) &#123;        if (nums[right]) &#123;            swap(nums[left], nums[right]);            ++left;        &#125;    &#125;&#125;</code></pre><p>或者：</p><pre><code class="language-cpp">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int left = 0;    for (int right = 0; right &lt; nums.size(); ++right) &#123;        if (nums[right]) &#123;            nums[left] = nums[right];            ++left;        &#125;    &#125;    for (; left &lt; nums.size(); ++left) &#123;        nums[left] = 0;    &#125;&#125;</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy9zb2x1dGlvbi95aS1kb25nLWxpbmctYnktbGVldGNvZGUtc29sdXRpb24v">leetcode-solution</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 189. 轮转数组</title>
      <link href="/posts/55ffda0f/"/>
      <url>/posts/55ffda0f/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWFycmF5Lw==">LeetCode 189. Rotate Array</span></p><p>给定一个整数数组  <code>nums</code> ，将数组中的元素向右轮转  <code>k</code>  个位置，其中  <code>k</code>  是非负数。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,4,5,6,7], k = 3输出：[5,6,7,1,2,3,4]解释：    向右轮转 1 步: [7,1,2,3,4,5,6]    向右轮转 2 步: [6,7,1,2,3,4,5]    向右轮转 3 步: [5,6,7,1,2,3,4]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [-1,-100,3,99], k = 2输出：[3,99,-1,-100]解释：    向右轮转 1 步: [99,-1,-100,3]    向右轮转 2 步: [3,99,-1,-100]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>k</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶：</strong></p><ul><li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><h2 id="method-1-使用额外的数组"><a class="anchor" href="#method-1-使用额外的数组">#</a> Method 1: 使用额外的数组</h2><blockquote><p>当我们将数组的元素向右移动 <code>k</code>  次后，尾部 <code>k mod n</code>  个元素会移动至数组头部，其余元素向后移动 <code>k mod n</code>  个位置。</p></blockquote><p>使用额外的数组来将每个元素放至正确的位置。用 <code>n</code>  表示数组的长度，我们遍历原数组，将原数组下标为 <code>i</code>  的元素放至新数组下标为 <code>(i + k) mod n</code>  的位置，最后将新数组拷贝至原数组即可</p><pre><code class="language-cpp">void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;    int n = nums.size();    vector&lt;int&gt; temp(n);    for (int i = 0; i &lt;= n - 1; i++)        temp[(i + k) % n] = nums[i];    nums.assign(temp.begin(), temp.end());&#125;</code></pre><h2 id="method-2-数组翻转"><a class="anchor" href="#method-2-数组翻转">#</a> Method 2: 数组翻转</h2><p>先将所有元素翻转，这样尾部的  <code>k mod n</code>  个元素就被移至数组头部，然后我们再翻转  <code>[0, k mod n − 1]</code>  区间的元素和  <code>[k mod n, n − 1]</code>  区间的元素即能得到最后的答案</p><p><img data-src="/posts/55ffda0f/1.png" class="" title="数组翻转"></p><pre><code class="language-cpp">// 水平翻转 nums 中 left 到 right 之间的元素void reverse(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    while (left &lt; right)    &#123;        swap(nums[left], nums[right]);        left++;        right--;    &#125;;&#125;void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;    int n = nums.size() - 1;    reverse(nums, 0, n);                      // 翻转第0至nums.size()-1个元素    reverse(nums, 0, (k % nums.size()) - 1);  // 翻转第0至k%nums.size()-1个元素    reverse(nums, (k % nums.size()), n);      // 翻转第k%nums.size()至nums.size()-1个元素&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 977. 有序数组的平方</title>
      <link href="/posts/6864a963/"/>
      <url>/posts/6864a963/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3F1YXJlcy1vZi1hLXNvcnRlZC1hcnJheS8=">LeetCode 977. Squares of a Sorted Array</span></p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组  <code>nums</code>  ，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100] 。排序后，数组变为 [0,1,9,16,100]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121]</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums.length</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>nums[i]</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>nums</code>  已按 非递减顺序 排序</li></ul><h2 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h2><p>解题思路：</p><ol><li><p>找出非递减数组  <code>nums</code>  中正负整数的分界线  <code>pos</code>  ，假定  <code>nums[pos] &lt;= 0</code>  。当我们将数组  <code>nums</code>  中的数平方后，第  <code>0</code>  位到第  <code>pos</code>  位将单调递减，第  <code>pos + 1</code>  位到第  <code>n − 1</code>  位将单调递增</p></li><li><p>创建  <code>ans</code>  数组，令 指针  <code>i</code>  和  <code>j</code>  分别指向 <code>pos</code>  和  <code>pos + 1</code> ，分以下情况进行操作（类似于 <strong>归并</strong> 操作）：</p><ul><li>如果  <code>i &lt; 0</code>  ，或者， <code>j &lt; nums.size()</code>  且  <code>nums[i] * nums[i] &gt;= nums[j] * nums[j]</code>  ，则填充  <code>nums[j] * nums[j]</code>  ，并执行  <code>j++</code></li><li>否则，填充  <code>nums[i] * nums[i]</code>  ，并执行  <code>i--</code></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;    // 找到最大的负数或者零所在的位置，即，正负数分界线    int mid = -1;    for (int i = 0; i &lt; nums.size(); i++) &#123;        if (nums[i] &lt; 0)            mid = i;        else            break;    &#125;    // 将结果填充到 ans 数组中（类似于归并操作）    vector&lt;int&gt; ans;    int i = mid, j = mid + 1;    while (j - i &lt;= nums.size()) &#123;        // 如果 i 超出边界，或者，j 未超出边界且 nums[i] 的平方大于 nums[j] ，则填充 nums[j] * nums[j]        if ((i &lt; 0) || (j &lt; nums.size() &amp;&amp; nums[i] * nums[i] &gt;= nums[j] * nums[j])) &#123;            ans.push_back(nums[j] * nums[j]);            j++;        &#125;        // 否则，填充 nums[i] * nums[i]        else &#123;            ans.push_back(nums[i] * nums[i]);            i--;        &#125;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，使用了额外的数组</p><h2 id="method-2-双指针"><a class="anchor" href="#method-2-双指针">#</a> Method 2: 双指针</h2><p>使用两个指针分别指向位置  <code>0</code>  和  <code>n − 1</code> ，每次比较两个指针对应的数，选择较大的并按照逆序放入答案数组，然后移动指针</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; ans(n, 0);     // 注意这里要初始化    for (int i = 0, j = n - 1, k = n - 1; i &lt;= j;) &#123;        if (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;            ans[k] = nums[i] * nums[i];            i++;        &#125;        else &#123;            ans[k] = nums[j] * nums[j];            j--;        &#125;        k--;    &#125;    return ans;&#125;</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，使用了额外的数组</p><p>另，由于数组按递增顺序排列，可以直接比较  <code> - nums[i]</code>  和  <code>nums[j]</code>  即可，而无须比较  <code>nums[i] * nums[i]</code>  和  <code>nums[j] * nums[j]</code></p><ul><li>若  <code>- nums[i] &gt; nums[j]</code>  ，即， <code>nums[i]</code>  的绝对值大于  <code>nums[j]</code>  ，则  <code>nums[i] * nums[i] &gt; nums[j] * nums[j]</code>  必然成立</li><li>若  <code>- nums[i] &lt;= nums[j]</code>  ，则  <code>nums[i] * nums[i] &lt;= nums[j] * nums[j]</code>  必然成立</li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 69. x 的平方根</title>
      <link href="/posts/379f5d4c/"/>
      <url>/posts/379f5d4c/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3FydHgv">LeetCode 69. Sqrt(x)</span></p><p>给你一个非负整数  <code>x</code>  ，计算并返回  <code>x</code>  的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去</strong> 。</p><p><strong>注意</strong>：不允许使用任何内置指数函数和算符，例如  <code>pow(x, 0.5)</code>  或者  <code>x ** 0.5</code>  。</p><p><strong>示例 1：</strong></p><pre><code>输入：x = 4输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：x = 8输出：2解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span>  <code>x</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="method-二分查找"><a class="anchor" href="#method-二分查找">#</a> Method: 二分查找</h2><p>找到满足  <code>k*k &lt;= x</code>  的最大整数  <code>k</code></p><pre><code class="language-cpp">int mySqrt(int x) &#123;    int left = 0, right = x;    while (left &lt;= right)    &#123;        int mid = left + (right - left) / 2;        if ((long long) mid * mid &lt;= x)            left = mid + 1;        else            right = mid - 1;    &#125;;    return right;&#125;</code></pre><p>其中， <code>(long long)</code>  强制转换类型，避免 <code>mid * mid</code>  溢出</p><p>或，考虑  <code>mid &lt;= x / mid</code> （此时需另外分析  <code>mid == 0</code>  的情形）</p><pre><code class="language-cpp">int mySqrt(int x) &#123;    int left = 0, right = x;    while (left &lt;= right)    &#123;        int mid = left + (right - left) / 2;        if (mid == 0)            break;        else if (mid &lt;= (x / mid))            left = mid + 1;        else            right = mid - 1;    &#125;;    return right;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Records</title>
      <link href="/posts/1b7ed9b4/"/>
      <url>/posts/1b7ed9b4/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a class="anchor" href="#基本数据类型">#</a> 基本数据类型</h1><p><a href="https://jiankychen.github.io/posts/933a3849">1523. 在区间范围内统计奇数数目</a></p><p><a href="https://jiankychen.github.io/posts/b3858f6e">1491. 去掉最低工资和最高工资后的平均工资</a></p><h1 id="数组"><a class="anchor" href="#数组">#</a> 数组</h1><p><a href="https://jiankychen.github.io/posts/2b0a159a">217. 存在重复元素</a></p><p><a href="https://jiankychen.github.io/posts/4a298fcf">704. 二分查找</a></p><p><a href="https://jiankychen.github.io/posts/6864a963">977. 有序数组的平方</a></p><p><a href="https://jiankychen.github.io/posts/c425967e">27. 移除元素</a></p><p><a href="https://jiankychen.github.io/posts/cfd138c6">209. 长度最小的子数组</a></p><p><a href="https://jiankychen.github.io/posts/b5e5ca5b">剑指 Offer 03. 数组中重复的数字</a></p><p><a href="https://jiankychen.github.io/posts/b6e7cff2">31. 下一个排列</a></p><p><a href="https://jiankychen.github.io/posts/7b7c8ac4">169. 多数元素</a></p><p><a href="https://jiankychen.github.io/posts/5f7bf763">238. 除自身以外数组的乘积</a></p><p><a href="https://jiankychen.github.io/posts/cf6f6c2f">240. 搜索二维矩阵 II</a></p><p><a href="https://jiankychen.github.io/posts/4b49476">287. 寻找重复数</a></p><p><a href="https://jiankychen.github.io/posts/8ae12f56">448. 找到所有数组中消失的数字</a></p><p><a href="https://jiankychen.github.io/posts/5c7b75ba">560. 和为 K 的子数组</a></p><p><a href="https://jiankychen.github.io/posts/ba321226">581. 最短无序连续子数组</a></p><h1 id="链表"><a class="anchor" href="#链表">#</a> 链表</h1><p><a href="https://jiankychen.github.io/posts/431c26c9">2. 两数相加</a></p><p><a href="https://jiankychen.github.io/posts/c5f901bc">203. 移除链表元素</a></p><p><a href="https://jiankychen.github.io/posts/f8927f54">707. 设计链表</a></p><p><a href="https://jiankychen.github.io/posts/ccf16d67">876. 链表的中间结点</a></p><p><a href="https://jiankychen.github.io/posts/7c5d77fa">206. 反转链表</a></p><p><a href="https://jiankychen.github.io/posts/f84c47a9">24. 两两交换链表中的节点</a></p><p><a href="https://jiankychen.github.io/posts/bcf47f8f">19. 删除链表的倒数第 N 个结点</a></p><p><a href="https://jiankychen.github.io/posts/fd7c45a8">160. 相交链表</a></p><p><a href="https://jiankychen.github.io/posts/">141. 环形链表</a></p><p><a href="https://jiankychen.github.io/posts/fe4aea2">142. 环形链表 II</a></p><p><a href="https://jiankychen.github.io/posts/13dd79c8">21. 合并两个有序链表</a></p><p><a href="https://jiankychen.github.io/posts/d2ca0889">23. 合并 K 个升序链表</a></p><p><a href="https://jiankychen.github.io/posts/3e7ca0d2">剑指 Offer 06. 从尾到头打印链表</a></p><p><a href="https://jiankychen.github.io/posts/d10d41c5">146. LRU 缓存</a></p><p><a href="https://jiankychen.github.io/posts/73ef6296">148. 排序链表</a></p><p><a href="https://jiankychen.github.io/posts/8ec137cf">234. 回文链表</a></p><h1 id="哈希表"><a class="anchor" href="#哈希表">#</a> 哈希表</h1><p><a href="https://jiankychen.github.io/posts/30250b0">242. 有效的字母异位词</a></p><p><a href="https://jiankychen.github.io/posts/c10e195a">349. 两个数组的交集</a></p><p><a href="https://jiankychen.github.io/posts/76ed881c">202. 快乐数</a></p><p><a href="https://jiankychen.github.io/posts/3da9e18f">1. 两数之和</a></p><p><a href="https://jiankychen.github.io/posts/40552b28">454. 四数相加 II</a></p><p><a href="https://jiankychen.github.io/posts/579713f1">383. 赎金信</a></p><p><a href="https://jiankychen.github.io/posts/1b6e2437">15. 三数之和</a></p><p><a href="https://jiankychen.github.io/posts/bb4f52a2">18. 四数之和</a></p><p><a href="https://jiankychen.github.io/posts/c5b1c655">49. 字母异位词分组</a></p><p><a href="https://jiankychen.github.io/posts/eb9b92a9">128. 最长连续序列</a></p><p><a href="https://jiankychen.github.io/posts/b97e9d80">438. 找到字符串中所有字母异位词</a></p><p><a href="https://jiankychen.github.io/posts/f9f1bc1c">554. 砖墙</a></p><p><a href="https://jiankychen.github.io/posts/a1960852">1296. 划分数组为连续数字的集合</a></p><h1 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h1><p><a href="https://jiankychen.github.io/posts/d9baf118">344. 反转字符串</a></p><p><a href="https://jiankychen.github.io/posts/bd781faa">541. 反转字符串 II</a></p><p><a href="https://jiankychen.github.io/posts/e1635286">557. 反转字符串中的单词 III</a></p><p><a href="https://jiankychen.github.io/posts/2b58e836">151. 颠倒字符串中的单词</a></p><p><a href="https://jiankychen.github.io/posts/8f083358">28. 实现 strStr ()</a></p><p><a href="https://jiankychen.github.io/posts/e28abd31">459. 重复的子字符串</a></p><p><a href="https://jiankychen.github.io/posts/fff72920">剑指 Offer 05. 替换空格</a></p><p><a href="https://jiankychen.github.io/posts/5c5f7907">剑指 Offer 58-II. 左旋转字符串</a></p><p><a href="https://jiankychen.github.io/posts/e9240da8">208. 实现 Trie (前缀树)</a></p><h1 id="双指针法"><a class="anchor" href="#双指针法">#</a> 双指针法</h1><p><a href="https://jiankychen.github.io/posts/55ffda0f">189. 轮转数组</a></p><p><a href="https://jiankychen.github.io/posts/35c387f3">283. 移动零</a></p><p><a href="https://jiankychen.github.io/posts/81250b8a">167. 两数之和 II - 输入有序数组</a></p><p><a href="https://jiankychen.github.io/posts/3deb1e70">3. 无重复字符的最长子串</a></p><p><a href="https://jiankychen.github.io/posts/9f11d9b">567. 字符串的排列</a></p><p><a href="https://jiankychen.github.io/posts/af31d3c7">11. 盛最多水的容器</a></p><p><a href="https://jiankychen.github.io/posts/748f18ba">75. 颜色分类</a></p><p><a href="https://jiankychen.github.io/posts/e9d7ca54">76. 最小覆盖子串</a></p><h1 id="栈与队列"><a class="anchor" href="#栈与队列">#</a> 栈与队列</h1><p><a href="https://jiankychen.github.io/posts/81d08953">232. 用栈实现队列</a></p><p><a href="https://jiankychen.github.io/posts/5a1b1370">225. 用队列实现栈</a></p><p><a href="https://jiankychen.github.io/posts/2998838f">20. 有效的括号</a></p><p><a href="https://jiankychen.github.io/posts/7fd44fa1">1047. 删除字符串中的所有相邻重复项</a></p><p><a href="https://jiankychen.github.io/posts/7936534f">150. 逆波兰表达式求值</a></p><p><a href="https://jiankychen.github.io/posts/3ba13828">239. 滑动窗口最大值</a></p><p><a href="https://jiankychen.github.io/posts/f382432a">347. 前 K 个高频元素</a></p><p><a href="https://jiankychen.github.io/posts/c5a6a467">85. 最大矩形</a></p><p><a href="https://jiankychen.github.io/posts/a4f04f78">155. 最小栈</a></p><p><a href="https://jiankychen.github.io/posts/767d00ca">394. 字符串解码</a></p><p><a href="https://jiankychen.github.io/posts/cf6d2393">227. 基本计算器 II</a></p><h1 id="二叉树"><a class="anchor" href="#二叉树">#</a> 二叉树</h1><p><a href="https://jiankychen.github.io/posts/1e967892">144. 二叉树的前序遍历</a></p><p><a href="https://jiankychen.github.io/posts/803071b8">94. 二叉树的中序遍历</a></p><p><a href="https://jiankychen.github.io/posts/4e96229e">145. 二叉树的后序遍历</a></p><p><a href="https://jiankychen.github.io/posts/c7ba20f5">102. 二叉树的层序遍历</a></p><p><a href="https://jiankychen.github.io/posts/78cba97a">107. 二叉树的层序遍历 II</a></p><p><a href="https://jiankychen.github.io/posts/3e207964">199. 二叉树的右视图</a></p><p><a href="https://jiankychen.github.io/posts/3c63380e">637. 二叉树的层平均值</a></p><p><a href="https://jiankychen.github.io/posts/f9949bc5">589. N 叉树的前序遍历 / 590. N 叉树的后序遍历</a></p><p><a href="https://jiankychen.github.io/posts/703dcf9d">429. N 叉树的层序遍历</a></p><p><a href="https://jiankychen.github.io/posts/a04bbb24">515. 在每个树行中找最大值</a></p><p><a href="https://jiankychen.github.io/posts/33b5a27e">116. 填充每个节点的下一个右侧节点指针</a></p><p><a href="https://jiankychen.github.io/posts/9147e73d">117. 填充每个节点的下一个右侧节点指针 II</a></p><p><a href="https://jiankychen.github.io/posts/356d8218">104. 二叉树的最大深度 / 559. N 叉树的最大深度</a></p><p><a href="https://jiankychen.github.io/posts/3fb6472b">111. 二叉树的最小深度</a></p><p><a href="https://jiankychen.github.io/posts/94c5ffae">226. 翻转二叉树</a></p><p><a href="https://jiankychen.github.io/posts/3c1e41f">101. 对称二叉树</a></p><p><a href="https://jiankychen.github.io/posts/b45c53f3">100. 相同二叉树</a></p><p><a href="https://jiankychen.github.io/posts/1994ddf3">572. 另一棵树的子树</a></p><p><a href="https://jiankychen.github.io/posts/63982204">222. 完全二叉树的节点个数</a></p><p><a href="https://jiankychen.github.io/posts/cd137cbe">110. 平衡二叉树</a></p><p><a href="https://jiankychen.github.io/posts/30d556a7">257. 二叉树的所有路径</a></p><p><a href="https://jiankychen.github.io/posts/d5288e2a">404. 左叶子之和</a></p><p><a href="https://jiankychen.github.io/posts/9392a5dc">513. 找树左下角的值</a></p><p><a href="https://jiankychen.github.io/posts/ee978a9e">112. 路径总和</a></p><p><a href="https://jiankychen.github.io/posts/5e6fc759">113. 路径总和 II</a></p><p><a href="https://jiankychen.github.io/posts/65174f2a">106. 从中序与后序遍历序列构造二叉树</a></p><p><a href="https://jiankychen.github.io/posts/4cb77bf3">105. 从前序与中序遍历序列构造二叉树</a></p><p><a href="https://jiankychen.github.io/posts/ce78200f">654. 最大二叉树</a></p><p><a href="https://jiankychen.github.io/posts/113bbac">617. 合并二叉树</a></p><p><a href="https://jiankychen.github.io/posts/40131ff6">700. 二叉搜索树中的搜索</a></p><p><a href="https://jiankychen.github.io/posts/282d26b5">98. 验证二叉搜索树</a></p><p><a href="https://jiankychen.github.io/posts/38849bf2">530. 二叉搜索树的最小绝对差</a></p><p><a href="https://jiankychen.github.io/posts/a4aa1b78">501. 二叉搜索树中的众数</a></p><p><a href="https://jiankychen.github.io/posts/8d6a58cf">236. 二叉树的最近公共祖先</a></p><p><a href="https://jiankychen.github.io/posts/adb53b8e">235. 二叉搜索树的最近公共祖先</a></p><p><a href="https://jiankychen.github.io/posts/f9bf03da">701. 二叉搜索树中的插入操作</a></p><p><a href="https://jiankychen.github.io/posts/7cd023d4">450. 删除二叉搜索树中的节点</a></p><p><a href="https://jiankychen.github.io/posts/40d04a5">669. 修剪二叉搜索树</a></p><p><a href="https://jiankychen.github.io/posts/c3291a68">108. 将有序数组转换为二叉搜索树</a></p><p><a href="https://jiankychen.github.io/posts/9b180ff8">538. 把二叉搜索树转换为累加树</a></p><p><a href="https://jiankychen.github.io/posts/67d53c79">114. 二叉树展开为链表</a></p><p><a href="https://jiankychen.github.io/posts/f9871213">297. 二叉树的序列化与反序列化</a></p><p><a href="https://jiankychen.github.io/posts/616e6c65">437. 路径总和 III</a></p><p><a href="https://jiankychen.github.io/posts/6b7b0cda">543. 二叉树的直径</a></p><h1 id="排序"><a class="anchor" href="#排序">#</a> 排序</h1><p><a href="https://jiankychen.github.io/posts/2afe4d97">215. 数组中的第 K 个最大元素</a></p><h1 id="模拟"><a class="anchor" href="#模拟">#</a> 模拟</h1><p><a href="https://jiankychen.github.io/posts/a46bcf58">48. 旋转图像</a></p><p><a href="https://jiankychen.github.io/posts/6b429da4">59. 螺旋矩阵 II</a></p><p><a href="https://jiankychen.github.io/posts/1a3c8370">621. 任务调度器</a></p><p><a href="https://jiankychen.github.io/posts/a8ab548b">463. 岛屿的周长</a></p><h1 id="二分查找"><a class="anchor" href="#二分查找">#</a> 二分查找</h1><p><a href="https://jiankychen.github.io/posts/4cc2938">278. 第一个错误的版本</a></p><p><a href="https://jiankychen.github.io/posts/d91b6109">35. 搜索插入位置</a></p><p><a href="https://jiankychen.github.io/posts/379f5d4c">69. x 的平方根</a></p><p><a href="https://jiankychen.github.io/posts/a56851c5">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p><a href="https://jiankychen.github.io/posts/7e8f6f39">744. 寻找比目标字母大的最小字母</a></p><p><a href="https://jiankychen.github.io/posts/392c26dc">4. 寻找两个正序数组的中位数</a></p><p><a href="https://jiankychen.github.io/posts/e1a07bef">33. 搜索旋转排序数组</a></p><h1 id="广度优先搜索-深度优先搜索"><a class="anchor" href="#广度优先搜索-深度优先搜索">#</a> 广度优先搜索 / 深度优先搜索</h1><p><a href="https://jiankychen.github.io/posts/67cb564f">733. 图像渲染</a></p><p><a href="https://jiankychen.github.io/posts/edd44cd5">695. 岛屿的最大面积</a></p><p><a href="https://jiankychen.github.io/posts/9ee04cc9">200. 岛屿数量</a></p><p><a href="https://jiankychen.github.io/posts/a888c0b0">207. 课程表</a></p><p><a href="https://jiankychen.github.io/posts/c8de8ad">399. 除法求值</a></p><h1 id="回溯"><a class="anchor" href="#回溯">#</a> 回溯</h1><p><a href="https://jiankychen.github.io/posts/d1540be5">77. 组合</a></p><p><a href="https://jiankychen.github.io/posts/382688bd">216. 组合总和 III</a></p><p><a href="https://jiankychen.github.io/posts/39fb19">17. 电话号码的字母组合</a></p><p><a href="https://jiankychen.github.io/posts/c2253dcd">39. 组合总和</a></p><p><a href="https://jiankychen.github.io/posts/e3119804">40. 组合总和 II</a></p><p><a href="https://jiankychen.github.io/posts/eeb65480">131. 分割回文串</a></p><p><a href="https://jiankychen.github.io/posts/a920fddd">93. 复原 IP 地址</a></p><p><a href="https://jiankychen.github.io/posts/7ea8ca7d">78. 子集</a></p><p><a href="https://jiankychen.github.io/posts/a06c07a7">90. 子集 II</a></p><p><a href="https://jiankychen.github.io/posts/8beb3ed8">491. 递增子序列</a></p><p><a href="https://jiankychen.github.io/posts/1ba17777">46. 全排列</a></p><p><a href="https://jiankychen.github.io/posts/cd8e32d2">47. 排列 II</a></p><p><a href="https://jiankychen.github.io/posts/714a7a8a">22. 括号生成</a></p><p><a href="https://jiankychen.github.io/posts/4c8f57fd">79. 单词搜索</a></p><p><a href="https://jiankychen.github.io/posts/7c57862a">301. 删除无效的括号</a></p><h1 id="贪心算法"><a class="anchor" href="#贪心算法">#</a> 贪心算法</h1><p><a href="https://jiankychen.github.io/posts/6d4c99f1">455. 分发饼干</a></p><p><a href="https://jiankychen.github.io/posts/f6882869">376. 摆动序列</a></p><p><a href="https://jiankychen.github.io/posts/37be6a99">53. 最大子数组和</a></p><p><a href="https://jiankychen.github.io/posts/1cc8aec1">122. 买卖股票的最佳时机 II</a></p><p><a href="https://jiankychen.github.io/posts/8e9df849">55. 跳跃游戏</a></p><p><a href="https://jiankychen.github.io/posts/13c5205f">45. 跳跃游戏 II</a></p><p><a href="https://jiankychen.github.io/posts/e072609b">1005. K 次取反后最大化的数组和</a></p><p><a href="https://jiankychen.github.io/posts/72c6f482">134. 加油站</a></p><p><a href="https://jiankychen.github.io/posts/d4035162">135. 分发糖果</a></p><p><a href="https://jiankychen.github.io/posts/bf1fd3eb">860. 柠檬水找零</a></p><p><a href="https://jiankychen.github.io/posts/75b6f5e4">406. 根据身高重建队列</a></p><p><a href="https://jiankychen.github.io/posts/74cc4150">452. 用最少数量的箭引爆气球</a></p><p><a href="https://jiankychen.github.io/posts/6f5fa844">435. 无重叠区间</a></p><p><a href="https://jiankychen.github.io/posts/c4b10462">763. 划分字母区间</a></p><p><a href="https://jiankychen.github.io/posts/2f540b31">56. 合并区间</a></p><p><a href="https://jiankychen.github.io/posts/6f2fbbf2">738. 单调递增的数字</a></p><p><a href="https://jiankychen.github.io/posts/7ede3731">714. 买卖股票的最佳时机含手续费</a></p><h1 id="动态规划"><a class="anchor" href="#动态规划">#</a> 动态规划</h1><p><a href="https://jiankychen.github.io/posts/a80d0031">剑指 Offer 10- II. 青蛙跳台阶问题</a></p><p><a href="https://jiankychen.github.io/posts/b2ace7fe">509. 斐波那契数</a></p><p><a href="https://jiankychen.github.io/posts/bb39abea">70. 爬楼梯</a></p><p><a href="https://jiankychen.github.io/posts/86b082df">746. 使用最小花费爬楼梯</a></p><p><a href="https://jiankychen.github.io/posts/4134dbbf">62. 不同路径</a></p><p><a href="https://jiankychen.github.io/posts/8b9f7566">63. 不同路径 II</a></p><p><a href="https://jiankychen.github.io/posts/22de13ba">64. 最小路径和</a></p><p><a href="https://jiankychen.github.io/posts/f552429c">343. 整数拆分</a></p><p><a href="https://jiankychen.github.io/posts/1eae8d8">96. 不同的二叉搜索树</a></p><p><a href="https://jiankychen.github.io/posts/31559997">416. 分割等和子集</a></p><p><a href="https://jiankychen.github.io/posts/51a8dea1">1049. 最后一块石头的重量 II</a></p><p><a href="https://jiankychen.github.io/posts/68eb68e8">494. 目标和</a></p><p><a href="https://jiankychen.github.io/posts/d75bfa3f">474. 一和零</a></p><p><a href="https://jiankychen.github.io/posts/b992262f">518. 零钱兑换 II</a></p><p><a href="https://jiankychen.github.io/posts/bed222b7">377. 组合总和 IV</a></p><p><a href="https://jiankychen.github.io/posts/ff7c5482">322. 零钱兑换</a></p><p><a href="https://jiankychen.github.io/posts/42243142">279. 完全平方数</a></p><p><a href="https://jiankychen.github.io/posts/6dd7981d">139. 单词拆分</a></p><p><a href="https://jiankychen.github.io/posts/be158ab">198. 打家劫舍</a></p><p><a href="https://jiankychen.github.io/posts/46ac943d">213. 打家劫舍 II</a></p><p><a href="https://jiankychen.github.io/posts/8ba06b1">337. 打家劫舍 III</a></p><p><a href="https://jiankychen.github.io/posts/7ef7bbd4">121. 买卖股票的最佳时机</a> ：只能买卖一次</p><p><a href="https://jiankychen.github.io/posts/1cc8aec1">122. 买卖股票的最佳时机 II</a> ：可以买卖多次</p><p><a href="https://jiankychen.github.io/posts/15ff7d07">123. 买卖股票的最佳时机 III</a> ：最多买卖两次</p><p><a href="https://jiankychen.github.io/posts/26a72e96">188. 买卖股票的最佳时机 IV</a> ：最多买卖 k 次</p><p><a href="https://jiankychen.github.io/posts/55c28bef">309. 最佳买卖股票时机含冷冻期</a> ：可以买卖多次，卖出有一天冷冻期</p><p><a href="https://jiankychen.github.io/posts/7ede3731">714. 买卖股票的最佳时机含手续费</a> ：可以买卖多次，每次都有手续费</p><p><a href="https://jiankychen.github.io/posts/a598c519">300. 最长递增子序列</a></p><p><a href="https://jiankychen.github.io/posts/c64b2400">674. 最长连续递增序列</a></p><p><a href="https://jiankychen.github.io/posts/340004fc">718. 最长重复子数组</a></p><p><a href="https://jiankychen.github.io/posts/c261e90a">1143. 最长公共子序列</a></p><p><a href="https://jiankychen.github.io/posts/2b9044b2">1035. 不相交的线</a></p><p><a href="https://jiankychen.github.io/posts/3df0135c">392. 判断子序列</a></p><p><a href="https://jiankychen.github.io/posts/b8a7b240">115. 不同的子序列</a></p><p><a href="https://jiankychen.github.io/posts/5ad6a6fd">583. 两个字符串的删除操作</a></p><p><a href="https://jiankychen.github.io/posts/8134aa5e">72. 编辑距离</a></p><p><a href="https://jiankychen.github.io/posts/570b359b">647. 回文子串</a></p><p><a href="https://jiankychen.github.io/posts/42c47a1c">5. 最长回文子串</a></p><p><a href="https://jiankychen.github.io/posts/4da38d24">516. 最长回文子序列</a></p><p><a href="https://jiankychen.github.io/posts/f95e67ed">10. 正则表达式匹配</a></p><p><a href="https://jiankychen.github.io/posts/d86ca4e7">32. 最长有效括号</a></p><p><a href="https://jiankychen.github.io/posts/4491e4cd">152. 乘积最大子数组</a></p><p><a href="https://jiankychen.github.io/posts/d81fafae">312. 戳气球</a></p><h1 id="单调栈"><a class="anchor" href="#单调栈">#</a> 单调栈</h1><p><a href="https://jiankychen.github.io/posts/f97737f4">739. 每日温度</a></p><p><a href="https://jiankychen.github.io/posts/6ce9cc69">42. 接雨水</a></p><p><a href="https://jiankychen.github.io/posts/e6beed44">84. 柱状图中最大的矩形</a></p><h1 id="位运算"><a class="anchor" href="#位运算">#</a> 位运算</h1><p><a href="https://jiankychen.github.io/posts/59ae1e23">136. 只出现一次的数字</a></p><p><a href="https://jiankychen.github.io/posts/38d980c0">338. 比特位计数</a></p><p><a href="https://jiankychen.github.io/posts/bbdfe11c">461. 汉明距离</a></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/e8eb0481/"/>
      <url>/posts/e8eb0481/</url>
      
        <content type="html"><![CDATA[<p><strong>二分查找</strong> （binary search），也称折半搜索（half-interval search）、对数搜索（logarithmic search），是用来在一个有序数组中查找某一元素的算法</p><p>以在一个升序数组中查找一个数为例：它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么查找右侧；如果中间元素大于所查找的值，查找左侧</p><p>时间复杂度：</p><ul><li>最优时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>最坏和平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：</p><ul><li>迭代版本的二分查找算法，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>递归版本的二分查找算法，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>基本上所有可以比较的数据类型都可以进行二分查找</p><p>一些 <strong>边界情况</strong> ：</p><ol><li>如何处理答案不存在的情况</li><li>区间内没有数字或只有一个 / 两个数字时，代码是否正常工作</li><li>数组中有很多个重复元素时，代码是否正常工作</li><li>会不会出现死循环</li><li>循环结束时，  <code>left</code>  与  <code>right</code>  是什么样的关系</li></ol><p>为避免 <strong>off-by-one</strong> 问题造成的死循环（即， <code>left</code>  始终比  <code>right</code>  小  <code>1</code> ），建议记住以下规律：</p><ul><li>如果代码用到  <code>left = mid</code>  ，把  <code>left</code>  不断向右 push ，那么  <code>mid</code>  向上取整，即  <code>mid = left + right + 1 &gt;&gt; 1</code></li><li>如果代码用到  <code>right = mid</code>  ，把  <code>right</code>  不断往左 push，那么  <code>mid</code>  向下取整，即  <code>mid = left + right &gt;&gt; 1</code></li></ul><p>参考：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDQuJUU0JUJBJThDJUU1JTg4JTg2JUU2JTlGJUE1JUU2JTg5JUJFLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：二分查找</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMUV4SWF2OXVLNGJ2Vm5uZjR0MEgyUQ==">穿几个马甲，就认不出你是二分法？</span></p></li></ul><h2 id="示例"><a class="anchor" href="#示例">#</a> 示例</h2><h3 id="binary-search"><a class="anchor" href="#binary-search">#</a> Binary Search</h3><p><a href="https://jiankychen.github.io/2022/03/16/leetcode704-er-fen-cha-zhao/">LeetCode 704. 二分查找</a></p><h3 id="search-insert-position"><a class="anchor" href="#search-insert-position">#</a> Search Insert position</h3><p><a href="https://jiankychen.github.io/2022/03/12/leetcode35-sou-suo-cha-ru-wei-zhi/">LeetCode 35. 搜索插入位置</a></p><h3 id="find-first-and-last-position-of-element-in-sorted-array"><a class="anchor" href="#find-first-and-last-position-of-element-in-sorted-array">#</a> Find First and Last Position of Element in Sorted Array</h3><p><a href="https://jiankychen.github.io/2022/04/19/leetcode34-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi/">LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h3 id="find-smallest-letter-greater-than-target"><a class="anchor" href="#find-smallest-letter-greater-than-target">#</a> Find Smallest Letter Greater Than Target</h3><p><a href="https://jiankychen.github.io/2022/04/19/leetcode744-xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-zi-mu/">LeetCode 744. 寻找比目标字母大的最小字母</a></p><h3 id="求方程的解"><a class="anchor" href="#求方程的解">#</a> 求方程的解</h3><p>输出方程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>16</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^3 + 16 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的解，已知这个解在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-10^9,10^9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 之间，并且函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">f(x) = x^3 + 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 在定义域上单调递增</p><p>输出的答案保留 5 位小数</p><pre><code class="language-cpp">double f( double x ) &#123;    return x * x * x + 16; // 函数f(x)&#125;double solve() &#123;    double L = -1e9, R = 1e9; // 方程解在 [L,R] 之间，且函数在 [L,R] 上单调增    while( R - L &gt;= 1e-6 ) &#123;  // 精确到 6 位小数，然后四舍五入        double M = L + (R - L) / 2.0;        if (f(M) == 0) return M;        else if (f(M) &lt; 0) L = M + 1e-6;        else if (f(M) &gt; 0) R = M - 1e-6;    &#125;    return L;&#125;int main() &#123;    printf( &quot;%.5lf\n&quot;, solve() );    return 0;&#125;</code></pre><p>若要求精确到 10 位小数：由于  <code>double</code>  本身存在不小的精度误差，如果通过  <code>R - L &gt;= 1e-10</code>  这种方式来控制二分的终止条件，会带来非常大的精度问题</p><p>这种时候，可以采用  <code>固定次数二分</code>  的方法</p><pre><code class="language-cpp">double L = -1e9, R = 1e9;for( int times = 0; times &lt; 100; ++times ) &#123; // 二分 100 次    double mid = (L + R) / 2.0;    // 此处省略二分内容&#125;</code></pre><blockquote><p>在  <code>double</code>  上二分时，尽量使用  <code>固定次数二分</code>  的方法</p></blockquote><h2 id="lower_bound-和-upper_bound"><a class="anchor" href="#lower_bound-和-upper_bound">#</a> lower_bound 和 upper_bound</h2><p>C++ 标准库中有两个使用二分查找的函数： <code>lower_bound</code>  和  <code>upper_bound</code> ，二者均定义于头文件  <code>&lt;algorithm&gt;</code>  中</p><ul><li><p><code>lower_bound</code>  ：在指定的升序排序的数组中，找到第一个大于等于  <code>x</code>  的数字</p></li><li><p><code>upper_bound</code>  ：在指定的升序排序的数组中，找到第一个大于  <code>x</code>  的数字</p></li></ul><p>这两个函数会返回对应数字的指针（或者是迭代器）</p><pre><code>#include &lt;algorithm&gt;int *p = lower_bound(first, last, value);   // Returns an iterator pointing to the first element in the range [first, last) that is not less than value, or last if no such element is found.int *q = lower_bound(first, last, value, comp);     // given comparison function comp</code></pre><p>巧妙地运用这两个函数，可以完成所有常见的二分查找操作：</p><ul><li>找到第一个大于等于 x 的数字</li><li>找到第一个大于 x 的数字</li><li>找到最后一个等于 x 的数字</li><li>查找数组中是否有数字 x</li><li>查询数组中有几个数字 x</li><li>找到最后一个小于 x 的数字</li><li>……</li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS9sb3dlcl9ib3VuZA==">cppreference</span></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 35. 搜索插入位置</title>
      <link href="/posts/d91b6109/"/>
      <url>/posts/d91b6109/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VhcmNoLWluc2VydC1wb3NpdGlvbi8=">LeetCode 35. Search Insert Position</span></p><p>给定一个排序数组 nums 和一个目标值 target，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的算法。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,3,5,6], target = 5输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,3,5,6], target = 2输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,3,5,6], target = 7输出：4</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span> nums.length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span> nums[i] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>nums 为 无重复元素 的 升序 排列数组</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span> target <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-二分查找"><a class="anchor" href="#method-二分查找">#</a> Method: 二分查找</h2><p>在一个有序数组中找到第一个大于等于  <code>target</code>  的下标</p><pre><code class="language-cpp">int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size() - 1;    while (left &lt;= right)    &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)            left = mid + 1;        else            right = mid - 1;    &#125;;    return left;&#125;</code></pre><p>二分查找需要注意边界条件，比如：循环结束条件中  <code>left</code>  和  <code>right</code>  的关系，更新  <code>left</code>  和  <code>right</code>  位置时要不要加 1 减 1。</p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VhcmNoLWluc2VydC1wb3NpdGlvbi9zb2x1dGlvbi90ZS1iaWUtaGFvLXlvbmctZGUtZXItZmVuLWNoYS1mYS1mYS1tby1iYW4tcHl0aG9uLS8=">写对二分查找不是套模板并往里面填空，需要仔细分析题意</span></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 字符串、向量和数组</title>
      <link href="/posts/cddca394/"/>
      <url>/posts/cddca394/</url>
      
        <content type="html"><![CDATA[<h1 id="命名空间的-using-声明"><a class="anchor" href="#命名空间的-using-声明">#</a> 命名空间的 using 声明</h1><p><code>std::cin</code>  的意思就是要使用命名空间 <code>std</code>  中的名字 <code>cin</code></p><p><code>using</code>  声明具有如下的形式：</p><pre><code class="language-cpp">using namespace::name;</code></pre><p>一旦声明了上述语句，就可以直接访问命名空间中的名字</p><p>例如：</p><pre><code class="language-cpp">#include &lt;iostream&gt;// using declaration; when we use the name cin, we get the one from the namespace stdusing std::cin;int main() &#123;    int i;    cin &gt;&gt; i;       // ok: cin is a synonym for std::cin    cout &lt;&lt; i;      // error: no using declaration; we must use the full name    std::cout &lt;&lt; i; // ok: explicitly use cout from namepsace std    return 0;&#125;</code></pre><p>按照规定，每个  <code>using</code>  声明引入命名空间中的一个成员</p><p>因此，<strong>每个名字都必须有自己独立的声明语句</strong>，而且 <strong>每句话都得以分号结束</strong></p><p>例如：</p><pre><code class="language-cpp">#include &lt;iostream&gt;// using declarations for names from the standard libraryusing std::cin;using std::cout;using std::endl;int main() &#123;    cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; endl;    int v1, v2;    cin &gt;&gt; v1 &gt;&gt; v2;    cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2        &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; endl;    return 0;&#125;</code></pre><p>一般来说，<strong>头文件不应该使用  <code>using</code>  声明</strong></p><p>因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个  <code>using</code>  声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，可能产生始料未及的名字冲突</p><h1 id="标准库类型-string"><a class="anchor" href="#标准库类型-string">#</a> 标准库类型 string</h1><p>标准库类型  <code>string</code>  表示可变长的字符序列</p><ul><li>使用  <code>string</code>  类型必须首先包含  <code>string</code>  头文件</li><li>作为标准库的一部分， <code>string</code>  定义在命名空间  <code>std</code>  中</li></ul><pre><code class="language-cpp">#include &lt;string&gt;using std::string;</code></pre><h2 id="定义和初始化string对象"><a class="anchor" href="#定义和初始化string对象">#</a> 定义和初始化 string 对象</h2><p><code>string</code>  有两类初始化方式</p><ul><li><p>拷贝初始化（copy initialization）: 使用等号来初始化一个变量，编译器把等号右侧的初始值拷贝到新创建的对象中去</p></li><li><p>直接初始化（direct initialization）: 不使用等号</p></li></ul><p><img data-src="/posts/cddca394/1.png" class=""></p><p>需注意：</p><ol><li><p><code>string</code>  接受无参数的初始化方式：<strong>不论  <code>string</code>  对象定义在函数内还是函数外，默认初始化都是得到空串</strong></p></li><li><p>如果提供了一个 <strong>字符串字面值</strong> ，该字面值中 <strong>除了最后那个空字符外</strong> 的所有字符 都被拷贝到新创建的  <code>string</code>  对象中</p></li></ol><h2 id="string对象上的操作"><a class="anchor" href="#string对象上的操作">#</a> string 对象上的操作</h2><p><code>string</code>  对象的大多数操作：<br /><img data-src="/posts/cddca394/2.png" class=""></p><p>其中， <code>is &gt;&gt; s</code>  读取时不包括空格符； <code>getline(is, s)</code>  读取整行，包含空格符</p><h3 id="读写string对象"><a class="anchor" href="#读写string对象">#</a> 读写 string 对象</h3><p>可以使用 IO 操作符读写 <code>string</code>  对象：</p><pre><code class="language-cpp">// Note: #include and using declarations must be added to compile this codeint main()&#123;    string s;          // empty string    cin &gt;&gt; s;          // read a whitespace-separated string into s    cout &lt;&lt; s &lt;&lt; endl; // write s to the output    return 0;&#125;</code></pre><blockquote><p><strong>在执行读取操作时， <code>string</code>  对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止</strong></p></blockquote><p>如上所述，如果程序的输入是 “　　Hello World！　　”（注意开头和结尾处的空格），则输出将是 “Hello”，没有任何空格</p><p>和内置类型的输入输出操作一样， <code>string</code>  对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写在一起：</p><pre><code class="language-cpp">string s1, s2;cin &gt;&gt; s1 &gt;&gt; s2; // read first input into s1, second into s2cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; // write both strings</code></pre><p>假设给上面这段程序输入与之前一样的内容 “Hello World!”，输出将是 “HelloWorld!”</p><h3 id="读取未知数量的string对象"><a class="anchor" href="#读取未知数量的string对象">#</a> 读取未知数量的 string 对象</h3><pre><code class="language-cpp">int main()&#123;    string word;    while (cin &gt;&gt; word)       // read until end-of-file        cout &lt;&lt; word &lt;&lt; endl; // write each word followed by a new line    return 0;&#125;</code></pre><p>一旦遇到文件结束标记或非法输入，循环也就结束了</p><h3 id="使用getline读取一整行"><a class="anchor" href="#使用getline读取一整行">#</a> 使用 getline 读取一整行</h3><p><strong> <code>getline</code>  能在最终得到的字符串中保留输入时的空白符</strong></p><p><code>getline</code>  函数的参数是一个输入流和一个 <code>string</code>  对象，函数从给定的输入流中读入内容，直到遇到换行符为止（换行符也被读进来了），然后把所读的内容存入到那个 <code>string</code>  对象中去（不存换行符）</p><p><strong> <code>getline</code>  只要一遇到换行符就结束读取操作并返回结果</strong>，哪怕输入的一开始就是换行符也是如此。如果输入一开始就是换行符，那么所得的结果就是一个空 <code>string</code></p><p>和输入运算符一样， <code>getline</code>  也会返回它的流参数。因此，也能使用 <code>getline</code>  的结果作为判断的条件：</p><pre><code class="language-cpp">int main() &#123;    string line;    // read input a line at a time until end-of-file (EOF)    while (getline(cin, line))        cout &lt;&lt; line &lt;&lt; endl;    return 0;&#125;</code></pre><p><strong>触发  <code>getline</code>  函数返回的那个换行符实际上被丢弃掉了，得到的  <code>string</code>  对象中并不包含该换行符</strong></p><h3 id="stringsize_type类型"><a class="anchor" href="#stringsize_type类型">#</a> string::size_type 类型</h3><p><code>size</code>  函数返回 <code>string</code>  对象的长度（即 <code>string</code>  对象中字符的个数），返回的是一个 <code>string::size_type</code>  类型的值</p><blockquote><p><code>string</code>  类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型 <code>size_type</code>  即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字 <code>size_type</code>  是在类 <code>string</code>  中定义的</p></blockquote><p><code>string::size_type</code>  类型的对象，是一个<strong>无符号类型</strong>的值，而且能足够存放下任何  <code>string</code>  对象的大小</p><p><strong>所有用于存放 <code>string</code>  类的 <code>size</code>  函数返回值的变量，都应该是 <code>string::size_type</code>  类型的</strong></p><p>在 C++ 11 新标准中，允许编译器通过 <code>auto</code>  或者 <code>decltype</code>  来推断变量的类型：</p><pre><code class="language-cpp">auto len = line.size(); // len has type string::size_type</code></pre><p>由于 <code>size</code>  函数返回的是一个无符号整型数，如果在表达式中混用了带符号数和无符号数，将可能产生意想不到的结果。例如，假设 <code>n</code>  是一个具有负值的  <code>int</code> ，则表达式 <code>s.size() &lt; n</code>  的判断结果几乎肯定是 <code>true</code>  ，因为负值 <code>n</code>  会自动地转换成一个比较大的无符号值</p><blockquote><p>如果一条表达式中已经有了 <code>size()</code>  函数，就不要再使用 <code>int</code> ，以避免混用 <code>int</code>  和 <code>unsigned</code>  可能带来的问题</p></blockquote><h3 id="比较string对象"><a class="anchor" href="#比较string对象">#</a> 比较 string 对象</h3><p><code>string</code>  类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较 <code>string</code>  对象中的字符，并且对大小写敏感。</p><p>相等性运算符（ <code>==</code>  和 <code>！=</code> ）、关系运算符（ <code>&lt;</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&gt;=</code> ）都依照（大小写敏感的）字典顺序：</p><ol><li>如果两个 <code>string</code>  对象的长度不同，而且较短 <code>string</code>  对象的每个字符都与较长 <code>string</code>  对象对应位置上的字符相同，就说较短 <code>string</code>  对象小于较长 string 对象。</li><li>如果两个 <code>string</code>  对象在某些对应的位置上不一致，则 <code>string</code>  对象比较的结果其实是 <code>string</code>  对象中第一对相异字符比较的结果。</li></ol><h3 id="为string对象赋值"><a class="anchor" href="#为string对象赋值">#</a> 为 string 对象赋值</h3><p>对于 <code>string</code>  类而言，允许把一个对象的值赋给另外一个对象：</p><pre><code class="language-cpp">string st1(10, 'c'), st2; // st1 is cccccccccc; st2 is an empty stringst1 = st2; // assignment: replace contents of st1 with a copy of st2        // both st1 and st2 are now the empty string</code></pre><h3 id="两个string对象相加"><a class="anchor" href="#两个string对象相加">#</a> 两个 string 对象相加</h3><p>两个 <code>string</code>  对象相加得到一个新的 <code>string</code>  对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。</p><pre><code class="language-cpp">string s1  = &quot;hello, &quot;, s2 = &quot;world\n&quot;;string s3 = s1 + s2;   // s3 is hello, world\ns1 += s2;   // equivalent to s1 = s1 + s2</code></pre><h3 id="字面值和string对象相加"><a class="anchor" href="#字面值和string对象相加">#</a> 字面值和 string 对象相加</h3><p>标准库允许把字符字面值和字符串字面值转换成 <code>string</code>  对象，所以在需要 <code>string</code>  对象的地方就可以使用这两种字面值来替代。</p><pre><code class="language-cpp">string s1 = &quot;hello&quot;, s2 = &quot;world&quot;; // no punctuation in s1 or s2string s3 = s1 + &quot;, &quot; + s2 + '\n';</code></pre><p>当把 <code>string</code>  对象和字符字面值及字符串字面值混在一条语句中使用时，<strong>必须确保每个加法运算符（ <code>+</code> ）的两侧的运算对象至少有一个是 <code>string</code> </strong>：</p><pre><code class="language-cpp">string s4 = s1 + &quot;, &quot;;           // ok: adding a string and a literalstring s5 = &quot;hello&quot; + &quot;, &quot;;      // error: no string operandstring s6 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has a string operand, equivalent to string s6 = (s1 + &quot;, &quot;) + &quot;world&quot;;string s7 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can't add string literals, equivalent to string s7 = (&quot;hello&quot; + &quot;, &quot;) + s2;</code></pre><blockquote><p>因为某些历史原因，也为了与 C 兼容，C++ 语言中的字符串字面值并不是标准库类型 <code>string</code>  的对象。切记，字符串字面值与 <code>string</code>  是不同的类型。</p></blockquote><h2 id="处理string对象中的字符"><a class="anchor" href="#处理string对象中的字符">#</a> 处理 string 对象中的字符</h2><p>我们经常需要单独处理 <code>string</code>  对象中的字符，比如检查一个 <code>string</code>  对象是否包含空白，或者把 <code>string</code>  对象中的字母改成小写，再或者查看某个特定的字符是否出现等</p><p>这类处理的一个关键问题是如何获取字符本身。另一个关键问题是要知道能改变某个字符的特性</p><p>在  <code>cctype</code>  头文件中定义了一组标准库函数处理这部分工作:<br /><img data-src="/posts/cddca394/3.png" class=""></p><h3 id="使用基于范围的for语句处理每个字符"><a class="anchor" href="#使用基于范围的for语句处理每个字符">#</a> 使用基于范围的 for 语句处理每个字符</h3><p>C++ 11 新标准提供的一种语句： <code>范围 for（range for）</code> 语句。这种语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，其语法形式是：</p><pre><code class="language-cpp">for (declaration : expression)    statement</code></pre><p>其中， <code>expression</code>  部分是一个对象，用于表示一个序列。 <code>declaration</code>  部分负责定义一个变量，该变量用于访问序列中的基础元素。每次迭代， <code>declaration</code>  部分的变量会被初始化为 <code>expression</code>  部分的下一个元素值</p><p>一个 <code>string</code>  对象表示一个字符的序列，因此 <code>string</code>  对象可以作为 <code>范围 for</code>  语句中的 <code>expression</code>  部分</p><pre><code class="language-cpp">string str(&quot;some string&quot;);// print the characters in str one character to a linefor (auto c : str)      // for every char in str    cout &lt;&lt; c &lt;&lt; endl;  // print the current character followed by a newline</code></pre><p><code>for</code>  循环把变量 <code>c</code>  和 <code>str</code>  联系了起来。此例中，通过使用 <code>auto</code>  关键字让编译器来决定变量 <code>c</code>  的类型，这里 <code>c</code>  的类型是 <code>char</code> 。每次迭代， <code>str</code>  的下一个字符被拷贝给 <code>c</code> ，因此该循环可以读作 “对于字符串 <code>str</code>  中的每个字符 <code>c</code> ，执行某某操作”</p><p>举个稍微复杂一点的例子，使用 <code>范围for</code>  语句和 <code>ispunct</code>  函数来统计 <code>string</code>  对象中标点符号的个数：</p><pre><code class="language-cpp">string s(&quot;Hello World!!!&quot;);// punct_cnt has the same type that s.size returnsdecltype(s.size()) punct_cnt = 0;// count the number of punctuation characters in sfor (auto c : s)        // for every char in s    if (ispunct(c))     // if the character is punctuation        ++punct_cnt;    // increment the punctuation countercout &lt;&lt; punct_cnt    &lt;&lt; &quot; punctuation characters in &quot; &lt;&lt; s &lt;&lt; endl;</code></pre><p>程序的输出结果将是： <code>3 punctuation characters in Hello World!!!</code> <br /> 这里我们使用 <code>decltype</code>  关键字声明计数变量 <code>punct_cnt</code> ，它的类型是 <code>s.size</code>  函数返回值的类型，也就是 <code>string：：size_type</code></p><h3 id="使用范围for语句改变字符串中的字符"><a class="anchor" href="#使用范围for语句改变字符串中的字符">#</a> 使用范围 for 语句改变字符串中的字符</h3><p>如果想要改变 <code>string</code>  对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符</p><p>假设我们想要把字符串改写为大写字母的形式，为此，可以使用标准库函数 <code>toupper</code> ，该函数接收一个字符，然后输出其对应的大写形式，程序为：</p><pre><code class="language-cpp">string s(&quot;Hello World!!!&quot;);// convert s to uppercasefor (auto &amp;c : s)   // for every char in s (note: c is a reference)    c = toupper(c); // c is a reference, so the assignment changes the char in scout &lt;&lt; s &lt;&lt; endl;</code></pre><p>上述代码的输出结果将是： <code>HELLO WORLD!!!</code> <br /> 每次迭代时，变量 <code>c</code>  引用 <code>string</code>  对象 <code>s</code>  的下一个字符，赋值给 <code>c</code>  也就是在改变 <code>s</code>  中对应字符的值</p><h3 id="只处理一部分字符"><a class="anchor" href="#只处理一部分字符">#</a> 只处理一部分字符</h3><p>要想访问 <code>string</code>  对象中的单个字符有两种方式：</p><ol><li>使用下标</li><li>使用迭代器</li></ol><p>下标运算符（ <code>[ ]</code> ）接收的输入参数是 <code>string::size_type</code>  类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用</p><p><strong> <code>string</code>  对象的下标从 0 计起</strong></p><p><code>string</code>  对象的下标必须大于等于 0 而小于 <code>s.size()</code> 。因为  <code>string</code>  对象的下标从 0 计起，最后一个字符的下标应该是 <code>s.size() - 1</code></p><p>下标的值称作 “下标” 或 “索引”</p><p>对于任何一个表达式，只要它的值是一个整型值，它就能作为索引</p><p>如果某个索引是带符号类型的值，将自动转换成由   <code>string::size_type</code>  表达的无符号类型</p><pre><code class="language-cpp">if (!s.empty())            // make sure there's a character to print    cout &lt;&lt; s[0] &lt;&lt; endl;  // print the first character in s</code></pre><p>只要字符串未被 <code>const</code>  限定符限制为常量，就能利用下标运算符为字符串中指定位置的字符赋新值</p><p>例如：</p><pre><code class="language-cpp">string s(&quot;some string&quot;);if (!s.empty())             // make sure there's a character in s[0]    s[0] = toupper(s[0]);   // assign a new value to the first character in s</code></pre><p>程序的输出结果将是： <code>Some string</code></p><p>再例如：</p><pre><code class="language-cpp">// process characters in s until we run out of characters or we hit a whitespacefor (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !isspace(s[index]); ++index)    s[index] = toupper(s[index]); // capitalize the current character</code></pre><p>程序的输出结果将是： <code>SOME string</code></p><p>在上述程序中， <code>for</code>  循环使用变量 <code>index</code>  作为 <code>s</code>  的下标， <code>index</code>  的类型是由 <code>decltype</code>  关键字决定的</p><p>上例使用了逻辑与运算符（ <code>&amp;&amp;</code> ）：如果参与运算的两个运算对象都为真，则逻辑与结果为真；否则结果为假</p><blockquote><p>对逻辑与运算符（ <code>&amp;&amp;</code> ）而言，C++ 语言规定：只有当左侧运算对象为真时，才会检查右侧运算对象的情况</p></blockquote><p>再次强调，注意检查下标的合法性。一种简便易行的方法是，<strong>总是设下标的类型为 <code>string::size_type</code> </strong>，因为此类型是无符号数，可以确保下标不会小于 0 ，此时，代码只需保证下标小于 <code>size()</code>  的值就可以了</p><h3 id="使用下标执行任意访问"><a class="anchor" href="#使用下标执行任意访问">#</a> 使用下标执行任意访问</h3><p>直接获取对应位置的字符，而不是从前往后依次访问</p><p>编写一个程序把 0 到 15 之间的十进制数转换成对应的十六进制形式：</p><pre><code class="language-cpp">const string hexdigits = &quot;0123456789ABCDEF&quot;; // possible hex digits (Note that it is a const string.)cout &lt;&lt; &quot;Enter a series of numbers between 0 and 15&quot;        &lt;&lt; &quot; separated by spaces. Hit ENTER when finished: &quot;        &lt;&lt; endl;string result;        // will hold the resulting hexify'd stringstring::size_type n;  // hold numbers from the inputwhile (cin &gt;&gt; n)    if (n &lt; hexdigits.size())    // ignore invalid input        result += hexdigits[n];  // fetch the indicated hex digitcout &lt;&lt; &quot;Your hex number is: &quot; &lt;&lt; result &lt;&lt; endl;</code></pre><p>假设输入的内容如下： <code>12 0 5 15 8 15</code> <br /> 程序的输出结果将是： <code>Your hex number is: C05F8F</code></p><h2 id="成员函数"><a class="anchor" href="#成员函数">#</a> 成员函数</h2><p><img data-src="/posts/cddca394/string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B01.png" class=""></p><p><img data-src="/posts/cddca394/string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B02.png" class=""></p><p><img data-src="/posts/cddca394/string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B03.png" class=""></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYm95dWFpLmNvbS9sZWFybi9jb3Vyc2VzLzE0OC9sZXNzb25zLzI0ODEvc3RlcHMvMD9mcm9tPXF6">https://www.boyuai.com/learn/courses/148/lessons/2481/steps/0?from=qz</span></p><h1 id="标准库类型-vector"><a class="anchor" href="#标准库类型-vector">#</a> 标准库类型 vector</h1><p>标准库<strong>类型</strong> <code>vector</code>  表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为 <code>vector</code>  “容纳着” 其他对象，所以它也常被称作 <code>容器（container）</code></p><p>要想使用  <code>vector</code>  ，必须包含适当的头文件:</p><pre><code class="language-cpp">#include &lt;vector&gt;using std::vector;</code></pre><p>C++ 语言既有类模板（class template），也有函数模板，其中 <code>vector</code>  是一个类模板</p><p>由 <code>vector</code>  生成的类型必须包含 <code>vector</code>  中元素的类型，例如 <code>vector&lt;int&gt;</code> ,  <code>vector&lt;vector&lt;int&gt;&gt;</code></p><p>组成 <code>vector</code>  的元素也可以是 <code>vector</code></p><pre><code class="language-cpp">vector&lt;int&gt; ivec;             // ivec holds objects of type intvector&lt;Sales_item&gt; Sales_vec; // holds Sales_itemsvector&lt;vector&lt;string&gt;&gt; file;  // vector whose elements are vectors</code></pre><p>引用不是对象，所以不存在包含引用的 <code>vector</code></p><h2 id="定义和初始化vector对象"><a class="anchor" href="#定义和初始化vector对象">#</a> 定义和初始化 vector 对象</h2><p><img data-src="/posts/cddca394/4.png" class=""></p><p>可以默认初始化 <code>vector</code>  对象，从而创建一个指定类型的空 <code>vector</code></p><p>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：</p><pre><code class="language-cpp">vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;  // list initializationvector&lt;string&gt; v2(&quot;a&quot;, &quot;an&quot;, &quot;the&quot;);  // errorvector&lt;int&gt; v3(10, 1); // v3 has ten elements with value 1vector&lt;int&gt; v4&#123;10, 1&#125;; // v4 has two elements with values 10 and 1</code></pre><h2 id="向vector对象中添加元素"><a class="anchor" href="#向vector对象中添加元素">#</a> 向 vector 对象中添加元素</h2><p><code>vector</code>  对象直接初始化的方式适用于三种情况：</p><ul><li>初始值已知且数量较少</li><li>初始值是另一个 <code>vector</code>  对象的副本</li><li>所有元素的初始值都一样</li></ul><p>一般情况下，可以先创建一个空 <code>vector</code> ，然后在运行时再利用 <code>vector</code>  的成员函数 <code>push_back</code>  向其中添加元素</p><p><code>push_back</code>  函数：把一个值当成 <code>vector</code>  对象的尾元素，“压到（push）” <code>vector</code>  对象的 “尾端（back）”</p><pre><code class="language-cpp">vector&lt;int&gt; v2;        // empty vectorfor (int i = 0; i != 100; ++i)    v2.push_back(i);    // append sequential integers to v2// at end of loop v2 has 100 elements, values 0 . . . 99// read words from the standard input and store them as elements in a vectorstring word;vector&lt;string&gt; text;       // empty vectorwhile (cin &gt;&gt; word) &#123;    text.push_back(word);  // append word to text&#125;</code></pre><p>需要注意：如果循环体内部包含有向 <code>vector</code>  对象添加元素的语句，则不能使用 <code>范围 for</code>  循环</p><blockquote><p><code>范围 for</code>  语句体内不应改变其所遍历序列的大小</p></blockquote><h2 id="其他vector操作"><a class="anchor" href="#其他vector操作">#</a> 其他 vector 操作</h2><p>除了 <code>push_back</code>  之外， <code>vector</code>  还提供了几种其他操作，大多数都和 <code>string</code>  的相关操作类似:<br /><img data-src="/posts/cddca394/5.png" class=""></p><p>例如：</p><pre><code class="language-cpp">vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8,9&#125;;for (auto &amp;i : v)     // for each element in v (note: i is a reference)    i *= i;           // square the element valuefor (auto i : v)      // for each element in v    cout &lt;&lt; i &lt;&lt; &quot; &quot;; // print the elementcout &lt;&lt; endl;</code></pre><p><code>vector</code>  的 <code>size</code>  函数返回 <code>vector</code>  对象中元素的个数，返回值的类型是由 <code>vector</code>  定义的 <code>size_type</code>  类型</p><p>要使用 <code>size_type</code> ，需首先指定它是由哪种类型定义的，对于  <code>vector</code>  而言， <code>vector</code>  对象的类型总是包含着元素的类型:</p><pre><code class="language-cpp">vector&lt;int&gt;::size_type // okvector::size_type      // error</code></pre><h3 id="计算-vector-内对象的索引"><a class="anchor" href="#计算-vector-内对象的索引">#</a> 计算 vector 内对象的索引</h3><p>对于  <code>vector</code>  ，可以使用下标运算符获取指定的元素</p><p><code>vector</code>  对象的下标也是从 0 开始计起，下标的类型是相应的 <code>size_type</code>  类型</p><p>此外，也能通过计算得到 <code>vector</code>  内对象的索引，然后直接获取索引位置上的元素：例如，假设有一组成绩的集合，其中成绩的取值是从 0 到 100。以 10 分为一个分数段，要求统计各个分数段各有多少个成绩，其代码实现如下：</p><pre><code class="language-cpp">// count the number of grades by clusters of ten: 0--9, 10--19, . .. 90--99, 100vector&lt;unsigned&gt; scores(11, 0); // 11 buckets, all initially 0unsigned grade;while (cin &gt;&gt; grade) &#123;      // read the grades    if (grade &lt;= 100)       // handle only valid grades        ++scores[grade / 10]; // increment the counter for the current clustercout &lt;&lt; scores &lt;&lt; endl;&#125;</code></pre><p>如果输入的成绩如下： <code>42 65 95 100 39 67 95 76 88 76 83 92 76 93</code>  ，则输出的结果应该是： <code>0 0 0 1 1 0 2 3 2 4 1</code></p><h3 id="不能用下标形式添加元素"><a class="anchor" href="#不能用下标形式添加元素">#</a> 不能用下标形式添加元素</h3><p>不能通过  <code>vector</code>  对象的下标形式来添加元素</p><pre><code class="language-cpp">vector&lt;int&gt; ivec;   // empty vectorfor (decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec[ix] = ix;  // disaster: ivec has no elements</code></pre><p>如前所述，正确的方法是使用 <code>push_back</code> ：</p><pre><code class="language-cpp">for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec.push_back(ix);  // ok: adds a new element with value ix</code></pre><p>注意，这里不能使用范围  <code>for</code>  语句，只能使用传统的  <code>for</code>  循环，因为 <code>vector</code>  序列长度发生变化了</p><p><strong> <code>vector</code>  对象（以及 <code>string</code>  对象）的下标运算符可用于访问已存在的元素，但不能用于添加元素</strong></p><blockquote><p>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出（buffer overflow）指的就是这类错误，这也是导致 PC 及其他设备上应用程序出现安全问题的一个重要原因</p></blockquote><p><strong>如果需要对  <code>vector</code>  对象或  <code>string</code>  对象使用 for 语句，则尽量使用范围 for，以免溢出</strong></p><h1 id="迭代器"><a class="anchor" href="#迭代器">#</a> 迭代器</h1><p>除了使用下标运算符来访问  <code>string</code>  对象的字符或  <code>vector</code>  对象的元素以外，也可以使用  <code>迭代器（iterator）</code>  访问</p><p>除了  <code>vector</code>  之外，标准库还定义了其他几种容器。<strong>所有标准库容器都可以使用迭代器</strong>，但是其中只有少数几种才同时支持下标运算符</p><p>严格来说， <code>string</code>  对象不属于容器类型，但是  <code>string</code>  支持很多与容器类型类似的操作，例如，下标运算符、迭代器</p><blockquote><p><code>string</code>  可以理解成 <code>vector&lt;char&gt;</code></p></blockquote><p>类似于指针类型，迭代器提供了对对象的间接访问：使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素</p><h2 id="使用迭代器"><a class="anchor" href="#使用迭代器">#</a> 使用迭代器</h2><p>有迭代器的类型同时拥有名为  <code>begin</code>  和  <code>end</code>  的成员</p><ul><li><code>begin</code> ：返回指向第一个元素（或第一个字符）的迭代器</li><li><code>end</code> ：返回指向尾元素的下一位置的迭代器（一个本不存在的元素）， <code>end</code>  返回的迭代器常被称作<strong>尾后迭代器</strong>或者简称为尾迭代器</li></ul><pre><code class="language-cpp">// the compiler determines the type of b and e// b denotes the first element and e denotes one past the last element in vauto b = v.begin(), e = v.end(); // b and e have the same type</code></pre><p>如果容器为空，则  <code>begin</code>  和  <code>end</code>  返回的是同一个迭代器，都是尾后迭代器</p><p>只要我们知道其支持  <code>begin</code>  和  <code>end</code>  ，就可以使用  <code>auto</code>  关键字来定义返回值的类型</p><blockquote><p>注意：试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为</p></blockquote><h3 id="迭代器运算符"><a class="anchor" href="#迭代器运算符">#</a> 迭代器运算符</h3><p><img data-src="/posts/cddca394/6.png" class=""></p><p>注意，<strong> <code>*iter</code>  返回的是迭代器  <code>iter</code>  所指元素的引用</strong>。因此，可以通过  <code>*iter</code>  来修改  <code>iter</code>  所指元素的值</p><pre><code class="language-cpp">string s(&quot;some string&quot;);if (s.begin() != s.end()) &#123; // make sure s is not empty    auto it = s.begin();    // it denotes the first character in s    *it = toupper(*it);     // make that character uppercase&#125;</code></pre><p>输出结果将是： <code>Some string</code></p><p>迭代器使用递增（ <code>++</code> ）运算符来从一个元素移动到下一个元素</p><p><strong>因为  <code>end</code>  返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作</strong></p><p>例如，把  <code>string</code>  对象中第一个单词改写为大写形式：</p><pre><code class="language-cpp">// process characters in s until we run out of characters or we hit a whitespacefor (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)    *it = toupper(*it); // capitalize the current character</code></pre><p>输出结果将是： <code>SOME string</code></p><p>使用  <code>==</code>  和  <code>!=</code>  来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同，或者都是同一个容器的尾后迭代器，则它们相等；否则，这两个迭代器不相等</p><blockquote><p>关键概念：泛型编程</p><p>只有  <code>string</code>  和  <code>vector</code>  等一些标准库类型有下标运算符，并不是所有标准库容器都能使用下标运算符访问，但是，所有标准库容器都可以使用迭代器</p><p>大多数的标准库容器都没有定义 <code>&lt;</code>  运算符，但是，所有标准库容器的迭代器都定义了  <code>==</code>  和  <code>!=</code></p><p>因此，只要我们养成使用迭代器和  <code>!=</code>  的习惯，就不用太在意用的到底是哪种容器类型</p></blockquote><h3 id="迭代器类型"><a class="anchor" href="#迭代器类型">#</a> 迭代器类型</h3><p>拥有迭代器的标准库类型使用  <code>iterator</code>  和  <code>const_iterator</code>  来表示迭代器的类型：</p><pre><code class="language-cpp">vector&lt;int&gt;::iterator it; // it can read and write vector&lt;int&gt; elementsstring::iterator it2;     // it2 can read and write characters in a stringvector&lt;int&gt;::const_iterator it3; // it3 can read but not write elementsstring::const_iterator it4;      // it4 can read but not write characters</code></pre><p><code>const_iterator</code>  类似于指向常量的指针，只能读取，不能修改它所指元素的值</p><p><code>iterator</code>  的对象可读可写</p><p>如果  <code>vector</code>  对象或  <code>string</code>  对象是一个常量，只能使用 <code>const_iterator</code></p><p>如果  <code>vector</code>  对象或  <code>string</code>  对象不是常量，那么，既能使用  <code>iterator</code>  也能使用  <code>const_iterator</code></p><h3 id="begin-和-end-运算符"><a class="anchor" href="#begin-和-end-运算符">#</a> begin 和 end 运算符</h3><p><code>begin</code>  和  <code>end</code>  返回的具体类型由其所指对象决定:</p><ul><li>如果对象是常量， <code>begin</code>  和  <code>end</code>  返回  <code>const_iterator</code></li><li>如果对象不是常量，返回  <code>iterator</code></li></ul><pre><code class="language-cpp">vector&lt;int&gt; v;const vector&lt;int&gt; cv;auto it1 = v.begin();  // it1 has type vector&lt;int&gt;::iteratorauto it2 = cv.begin(); // it2 has type vector&lt;int&gt;::const_iterator</code></pre><p>为了专门得到  <code>const_iterator</code>  类型的返回值，C++ 11 新标准引入了两个新函数，分别是  <code>cbegin</code>  和  <code>cend</code>  ：</p><pre><code class="language-cpp">auto it3 = v.cbegin(); // it3 has type vector&lt;int&gt;::const_iterator</code></pre><p>函数  <code>cbegin</code>  和  <code>cend</code>  分别返回指向容器第一个元素的迭代器、指向最后元素下一位置的迭代器，返回值都是  <code>const_iterator</code>  类型</p><h3 id="结合解引用和成员访问操作"><a class="anchor" href="#结合解引用和成员访问操作">#</a> 结合解引用和成员访问操作</h3><p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能进一步访问它的成员</p><p>例如，对于一个由字符串组成的  <code>vector</code>  对象来说，要想检查其元素是否为空，令  <code>it</code>  是该  <code>vector</code>  对象的迭代器，只需检查  <code>it</code>  所指字符串是否为空就可以了，其代码如下所示：</p><pre><code class="language-cpp">vector&lt;string&gt; v;auto it = v.begin();(*it).empty(); // dereferences it and calls the member empty on the resulting object</code></pre><p>注意， <code>(*it).empty()</code>  中的圆括号必不可少，该表达式的含义是先对  <code>it</code>  解引用，然后再执行点运算符。如果不加圆括号，点运算符将由  <code>it</code>  来执行，而非  <code>*it</code>  :</p><pre><code class="language-cpp">*it.empty();   // error: attempts to fetch the member named empty from it, but it is an iterator and has no member named empty</code></pre><p>为了简化形如  <code>(*it).empty()</code>  的表达式，C++ 定义了箭头运算符（ <code>-&gt;</code> ）</p><p>箭头运算符把解引用和成员访问两个操作结合在一起，即， <code>it-&gt;mem</code>  和  <code>(*it).mem</code>  表达的意思相同</p><pre><code class="language-cpp">it-&gt;empty;     // it-&gt;mem is a synonym for (* it).mem.</code></pre><p>例如，下列程序将输出三行  <code>hello the world!!</code></p><pre><code class="language-cpp">// print each line in text up to the first blank linevector&lt;string&gt; text(3, &quot;hello the world!!&quot;);for (auto it = text.cbegin(); it != text.cend() &amp;&amp; !it-&gt;empty(); ++it)    cout &lt;&lt; *it &lt;&lt; endl;</code></pre><h3 id="某些对-vector-对象的操作会使迭代器失效"><a class="anchor" href="#某些对-vector-对象的操作会使迭代器失效">#</a> 某些对 vector 对象的操作会使迭代器失效</h3><p>虽然  <code>vector</code>  对象可以动态地增长，但是也会有一些副作用：</p><ul><li>不能在  <code>范围 for</code>  循环中向  <code>vector</code>  对象添加元素</li><li>任何一种可能改变  <code>vector</code>  对象容量（capacity，而不是 size）的操作，比如  <code>push_back</code>  ，都会使该  <code>vector</code>  对象的迭代器失效</li></ul><p>谨记，<strong>如果循环体内使用了迭代器，就不要向相应的容器中添加元素</strong></p><h2 id="迭代器运算"><a class="anchor" href="#迭代器运算">#</a> 迭代器运算</h2><p>所有标准库容器的迭代器都支持递增运算（令迭代器每次移动一个元素）</p><p>可以用  <code>==</code>  和  <code>!=</code>  对任意标准库类型的两个有效迭代器进行比较</p><p>这些运算被称作迭代器运算（iterator arithmetic）</p><p><code>string</code>  和  <code>vector</code>  的迭代器支持更多的运算：</p><ul><li>迭代器的每次移动可以跨过多个元素</li><li>迭代器支持关系运算</li></ul><p><img data-src="/posts/cddca394/7.png" class=""></p><p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离</p><p>两个迭代器的距离，指的是左侧迭代器向右移动多少位置才能追上右侧迭代器，其类型是名为  <code>difference_type</code>  的带符号整型数，因为这个距离可正可负，所以  <code>difference_type</code>  是带符号类型的</p><p><code>string</code>  和  <code>vector</code>  都定义了  <code>difference_type</code></p><p>使用迭代器运算的一个经典算法是二分查找，例如，在升序数组  <code>text</code>  中寻找  <code>sought</code>  ：</p><pre><code class="language-cpp">// text must be sorted// beg and end will denote the range we're searchingauto beg = text.begin(), end = text.end();auto mid = text.begin() + (end - beg) / 2; // original midpoint// while there are still elements to look at and we haven't yet found soughtwhile (mid != end &amp;&amp; *mid != sought) &#123;    if (sought &lt; *mid)     // is the element we want in the first half?        end = mid;         // if so, adjust the range to ignore the second half    else                   // the element we want is in the second half        beg = mid + 1;     // start looking with the element just after mid    mid = beg + (end - beg) / 2;  // new midpoint&#125;</code></pre><p>程序定义了三个迭代器： <code>beg</code>  指向搜索范围内的第一个元素、 <code>end</code>  指向尾元素的下一位置、 <code>mid</code>  指向中间的那个元素</p><h1 id="数组"><a class="anchor" href="#数组">#</a> 数组</h1><p>数组是一种类似于标准库类型  <code>vector</code>  的<strong>数据结构</strong>（数组不是类类型）</p><ul><li>与  <code>vector</code>  相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问</li><li>与  <code>vector</code>  不同的地方是，<strong>数组的大小确定不变，不能随意向数组中增加元素</strong></li></ul><blockquote><p>数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后把原数组的所有元素复制到新数组中去</p><p>我们也无法像 <code>vector</code>  那样使用  <code>size</code>  函数直接获取数组的维度：如果是字符数组，可以调用  <code>strlen</code>  函数得到字符串的长度；如果是其他数组，只能使用  <code>sizeof(array) / sizeof(array[0])</code>  的方式计算数组的维度</p></blockquote><p>数组在内存空间的地址是连续的</p><p>数组的元素是不能删的，只能覆盖</p><blockquote><p>严格来讲， <code>vector</code>  是容器，不是数组</p></blockquote><h2 id="定义和初始化内置数组"><a class="anchor" href="#定义和初始化内置数组">#</a> 定义和初始化内置数组</h2><p>数组是一种复合类型，数组的声明形如  <code>int a[d]</code>  ，其中  <code>a</code>  是数组的名字， <code>d</code>  是数组的维度， <code>int</code>  是数组所存放对象的类型</p><p>维度，即数组中元素的个数，因此 <strong>必须大于 0 ，必须是一个常量表达式</strong></p><pre><code class="language-cpp">unsigned cnt = 42;          // not a constant expressionconstexpr unsigned sz = 42; // constant expression, due to constexprint arr[10];                // array of ten intsint *parr[sz];              // array of 42 pointers to intstring bad[cnt];            // error: cnt is not a constant expressionstring strs[get_size()];    // ok if get_size is constexpr, error otherwise</code></pre><p>默认情况下，数组的元素被默认初始化</p><blockquote><p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值</p></blockquote><p><strong>定义数组时必须指定数组的类型，不允许使用  <code>auto</code>  关键字推断类型</strong></p><p><strong>数组的元素应为对象，因此，不存在引用数组</strong></p><h3 id="显式初始化数组元素"><a class="anchor" href="#显式初始化数组元素">#</a> 显式初始化数组元素</h3><p>可以对数组的元素进行列表初始化，此时，允许忽略数组的维度</p><ul><li>如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来</li><li>如果指明了维度，那么初始值的总数量不应该超出指定的维度<ul><li>如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值</li></ul></li></ul><pre><code class="language-cpp">const unsigned sz = 3;        // constant expressionint ia1[sz] = &#123;0,1,2&#125;;        // array of three ints with values 0, 1, 2int a2[] = &#123;0, 1, 2&#125;;         // an array of dimension 3int a3[5] = &#123;0, 1, 2&#125;;        // equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;; // same as a4[] =  &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;int a5[2] = &#123;0,1,2&#125;;          // error: too many initializers</code></pre><h3 id="字符数组的特殊性"><a class="anchor" href="#字符数组的特殊性">#</a> 字符数组的特殊性</h3><p>可以用字符串字面值对字符数组数组初始化，但一定要注意，<strong>字符串字面值</strong> 的结尾处还有一个 <strong>空字符</strong> ，这个空字符也会被拷贝到字符数组中去</p><blockquote><p>单引号内的是字符字面值，双引号内的是字符串字面值</p></blockquote><pre><code class="language-cpp">char a1[] = &#123;'C', '+', '+'&#125;;       // 列表初始化，没有空字符（字符字面值）char a2[] = &#123;'C', '+', '+', '\0'&#125;; // 列表初始化，含有显式的空字符（字符字面值）char a3[] = &quot;C++&quot;;                 // 含有空字符（字符串字面值）const char a4[6] = &quot;Daniel&quot;;       // 错误：没有空间存放空字符（字符串字面值）</code></pre><h3 id="不允许拷贝和赋值"><a class="anchor" href="#不允许拷贝和赋值">#</a> 不允许拷贝和赋值</h3><p>无法直接通过某一个数组的数组名来初始化其他数组或给其他数组赋值</p><pre><code class="language-cpp">int a[] = &#123;0, 1, 2&#125;; // array of three intsint a2[] = a;        // error: cannot initialize one array with anothera2 = a;              // error: cannot assign one array to another</code></pre><p>若需实现数组的拷贝和赋值，需要逐个元素依次拷贝赋值</p><h3 id="理解复杂的数组声明"><a class="anchor" href="#理解复杂的数组声明">#</a> 理解复杂的数组声明</h3><p>可以定义一个存放指针的数组</p><p>因为数组本身就是对象，允许定义数组的指针及数组的引用</p><blockquote><p>不存在引用的数组（即，数组的元素不能是引用），但存在数组的引用（可以定义一个引用来绑定数组）</p></blockquote><pre><code class="language-cpp">int *ptrs[10];            //  ptrs是含有10个元素（整型指针）的数组（注：[]优先级高于*）int &amp;refs[10];            //  错误: 引用不是对象，不存在引用的数组（注：[]优先级高于&amp;，首先判断refs是一个维度为10的数组，数组的元素的类型是int &amp;，即，引用。由于引用不是对象，故语法错误）int (*Parray)[10] = &amp;arr; //  Parray指向一个含有10个整数的数组（注：()优先级高于[]，首先分析(*Parray)可知Parray是一个指针，然后考虑右边的[10]，可知Parray指向一个维度为10的数组，最后观察左边，知道数组中的元素为int）int (&amp;arrRef)[10] = arr;  //  arrRef引用一个含有10个整数的数组（注：()优先级高于[]，arrRef是一个引用，所绑定的对象是一个维度为10的数组，数组中的元素为int）</code></pre><p>默认情况下，类型修饰符从右向左依次绑定</p><p>对于  <code>ptrs</code>  来说，从右向左理解其含义比较简单：</p><ul><li>首先，定义的是一个大小为 10 的数组，数组的名字是  <code>ptrs</code></li><li>然后可以知道，数组中存放的是指向  <code>int</code>  的指针</li></ul><p>但对于  <code>Parray</code>  而言，由于其定义中包含  <code>()</code>  括号，需要按照由内向外的阅读顺序来理解  <code>Parray</code>  的含义：</p><ul><li>首先是圆括号括起来的部分， <code>*Parray</code>  意味着  <code>Parray</code>  是个指针</li><li>接下来观察右边可以知道， <code>Parray</code>  指向一个维度为 10 的数组</li><li>最后观察左边，数组中的元素是  <code>int</code></li><li>因此， <code>Parray</code>  是一个指针，指向一个  <code>int</code>  数组，其中，数组包含 10 个元素</li></ul><p>同理，对于  <code>int (&amp;arrRef)[10]</code>  ，我们按照由内向外的顺序阅读： <code>(&amp;arrRef)</code>  表示  <code>arrRef</code>  是一个引用，它引用的对象是一个维度为 10 的数组，数组中元素的类型是  <code>int</code></p><p>更复杂的：</p><pre><code class="language-cpp">int *(&amp;arry)[10] = ptrs; // array是数组的引用，该数组包含10个指向int的指针</code></pre><p>首先， <code>()</code>  优先级高于  <code>[]</code>  ，知道  <code>arry</code>  是一个引用；其次， <code>[]</code>  优先级高于  <code>*</code>  ，结合右边可知， <code>arry</code>  引用的对象是一个维度为 10 的数组；最后观察左边知道，数组元素的类型是指向  <code>int</code>  的指针</p><blockquote><p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读</p></blockquote><h2 id="访问数组元素"><a class="anchor" href="#访问数组元素">#</a> 访问数组元素</h2><p><strong>数组的元素也能使用范围  <code>for</code>  或下标运算符来访问</strong></p><p>注意：<strong>数组的索引从 0 开始</strong></p><p>在使用数组下标的时候，通常将其定义为  <code>size_t</code>  类型： <code>size_t</code>  是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小</p><p><strong> <code>size_t</code>  类型定义在  <code>cstddef</code>  头文件中</strong>，这个文件是 C 标准库头文件  <code>stddef.h</code>  的 C++ 版本</p><p>数组除了大小固定这一特点外，其他用法与  <code>vector</code>  基本类似</p><pre><code class="language-cpp">// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100unsigned scores[11] = &#123;&#125;; // 11 buckets, all value initialized to 0unsigned grade;while (cin &gt;&gt; grade) &#123;    if (grade &lt;= 100)        ++scores[grade / 10]; // increment the counter for the current cluster&#125;</code></pre><p>当需要遍历数组的所有元素时，最好的办法也是使用范围  <code>for</code></p><pre><code class="language-cpp">for (auto i : scores)      // for each counter in scores    cout &lt;&lt; i &lt;&lt; &quot; &quot;;      // print the value of that countercout &lt;&lt; endl;</code></pre><p>数组的下标应该大于等于 0 并且小于数组的大小</p><blockquote><p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误</p></blockquote><h2 id="指针和数组"><a class="anchor" href="#指针和数组">#</a> 指针和数组</h2><p><strong>使用数组名字时</strong>，编译器一般都会自动将其替换为 <strong>一个指向数组首元素的指针</strong></p><pre><code class="language-cpp">string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;  // array of stringsstring *p = &amp;nums[0];   // p points to the first element in numsstring *p2 = nums;      // equivalent to p2 = &amp;nums[0]int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsauto ia2(ia); // ia2 is an int* that points to the first element in iaia2 = 42;     // error: ia2 is a pointer, and we can't assign an int to a pointer</code></pre><p>尽管  <code>ia</code>  是由 10 个整数构成的数组，但是，当使用  <code>ia</code>  作为初始值时，编译器实际执行的初始化过程类似于下面的形式：</p><pre><code class="language-cpp">auto ia2(&amp;ia[0]);  // now it's clear that ia2 has type int*</code></pre><p><strong>当使用  <code>decltype</code>  关键字时，上述转换不会发生</strong>，即， <code>decltype(ia)</code>  返回的类型是 由 10 个整数构成的数组</p><pre><code class="language-cpp">// ia3 is an array of ten intsdecltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;   // ia is an array of ints, so is ia3int *p = ia;ia3 = p;    // error: can't assign an int* to an arrayia3[4] = i; // ok: assigns the value of i to an element in ia3</code></pre><h3 id="指向数组元素的指针也是迭代器"><a class="anchor" href="#指向数组元素的指针也是迭代器">#</a> 指向数组元素的指针也是迭代器</h3><p><code>vector</code>  和  <code>string</code>  的迭代器支持的运算，数组的指针全都支持</p><pre><code class="language-cpp">int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p = arr; // p points to the first element in arr++p;          // p points to arr[1]</code></pre><p>因此，使用数组的指针也能遍历数组中的元素。前提是要先获取到指向数组第一个元素的指针，以及 指向数组尾元素下一位置的指针</p><ul><li><p>通过数组名字或者数组中首元素的地址，能得到指向首元素的指针</p></li><li><p>可以设法获取数组尾元素之后的那个并不存在的元素的地址，从而得到指向数组尾元素的下一位置的指针</p><pre><code class="language-cpp">int *e = &amp;arr[10]; // pointer just past the last element in arr</code></pre><blockquote><p>这里使用下标运算符索引了一个不存在的元素（ <code>arr</code>  有 10 个元素，尾元素所在位置的索引是 9），这个不存在的元素就是用来提供其地址以初始化  <code>e</code></p></blockquote></li></ul><p>可改写此前的循环，令其输出  <code>arr</code>  的全部元素：</p><pre><code class="language-cpp">for (int *b = arr; b != e; ++b)    cout &lt;&lt; *b &lt;&lt; endl; // print the elements in arr</code></pre><p>尾后指针不指向具体的元素，因此，<strong>不能对尾后指针执行解引用或递增的操作</strong></p><p><strong>尽管能计算得到尾后指针，但这种用法极易出错</strong></p><h3 id="标准库函数-begin-和-end"><a class="anchor" href="#标准库函数-begin-和-end">#</a> 标准库函数 begin 和 end</h3><p>C++ 11 新标准引入了两个名为  <code>begin</code>  和  <code>end</code>  的函数</p><p><strong> <code>begin</code>  和  <code>end</code>  两个函数定义在  <code>iterator</code>  头文件中</strong></p><pre><code class="language-cpp">#include&lt;iterator&gt;</code></pre><p>这两个函数与容器中的两个同名成员功能类似，但是，由于数组不是类类型，这两个函数并不是数组的成员函数</p><p>因此，调用  <code>begin</code>  和  <code>end</code>  函数时，需要将数组作为它们的参数，例如：</p><pre><code class="language-cpp">int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsint *beg = begin(ia); // pointer to the first element in iaint *last = end(ia);  // pointer one past the last element in ia</code></pre><pre><code class="language-cpp">// pbeg 指向 arr 第一个元素，end 指向尾后int *pbeg = begin(arr),  *pend = end(arr);// 寻找第一个负数while (pbeg != pend &amp;&amp; *pbeg &gt;= 0)    ++pbeg;</code></pre><h3 id="指针运算"><a class="anchor" href="#指针运算">#</a> 指针运算</h3><p>指向数组元素的指针可以执行 <strong>迭代器</strong> 中的所有迭代器运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针上和用在迭代器上意义完全一致</p><p>注意：给指针加上一个整数，需保证新指针仍指向同一数组的某元素，或者指向同一数组的尾元素的下一位置</p><pre><code class="language-cpp">constexpr size_t sz = 5; // #include&lt;cstddef&gt;int arr[sz] = &#123;1,2,3,4,5&#125;;int *ip = arr;      // equivalent to int *ip = &amp;arr[0]int *ip2 = ip + 4;  // ip2 points to arr[4], the last element in arr// ok: arr is converted to a pointer to its first element; p points one past the end of arrint *p = arr + sz;  // use caution -- do not dereference!int *p2 = arr + 10; // error: arr has only 5 elements; p2 has undefined value</code></pre><p>和迭代器一样，两个指针相减的结果是它们之间的距离，其中，这两个指针必须指向同一个数组当中的元素</p><p>两个指针相减的结果，其类型是一种名为  <code>ptrdiff_t</code>  的标准库类型。和  <code>size_t</code>  一样， <code>ptrdiff_t</code>  也是一种定义在 <code>cstddef</code>  头文件中的机器相关的类型。两个指针相减的差值可能为负值，所以， <code>ptrdiff_t</code>  是一种带符号类型</p><pre><code class="language-cpp">auto n = end(arr) - begin(arr); // n is 5, the number of elements in arr</code></pre><p>只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较</p><pre><code class="language-cpp">int *b = arr, *e = arr + sz;while (b &lt; e) &#123;    // use *b    ++b;&#125;</code></pre><p>如果两个指针分别指向不相关的对象，则不能比较它们</p><pre><code class="language-cpp">int i = 0, sz = 42;int *p = &amp;i, *e = &amp;sz;// undefined: p and e are unrelated; comparison is meaningless!while (p &lt; e)</code></pre><h3 id="解引用和指针运算的交互"><a class="anchor" href="#解引用和指针运算的交互">#</a> 解引用和指针运算的交互</h3><p>指针加上一个整数所得结果依然是一个指针，如果该指针指向了一个元素，则允许解引用该指针</p><pre><code class="language-cpp">int ia[] = &#123;0,2,4,6,8&#125;; // array with 5 elements of type intint last = *(ia + 4);   // ok: initializes last to 8, the value of ia[4]</code></pre><p>表达式  <code>*(ia + 4)</code>  计算  <code>ia</code>  前进 4 个元素后的新地址，解引用该结果指针的效果等价于表达式  <code>ia[4]</code></p><p>相比之下，下列代码少了一个括号，故而是先解引用  <code>ia</code>  ，再给解引用的结果加 4</p><pre><code class="language-cpp">last = *ia + 4;  // ok: last = 4, equivalent to ia[0] + 4</code></pre><h3 id="下标和指针"><a class="anchor" href="#下标和指针">#</a> 下标和指针</h3><p>对数组执行下标运算，其实是对指向数组元素的指针执行下标运算</p><pre><code class="language-cpp">int ia[] = &#123;0,2,4,6,8&#125;;  // array with 5 elements of type intint i = ia[2];  // ia is converted to a pointer to the first element in ia                // ia[2] fetches the element to which (ia + 2) pointsint *p = ia;    // p points to the first element in iai = *(p + 2);   // equivalent to i = ia[2]</code></pre><p>只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），就可以执行下标运算：</p><pre><code class="language-cpp">int *p = &amp;ia[2];  // p points to the element indexed by 2int j = p[1];     // p[1] is equivalent to *(p + 1),                  // p[1] is the same element as ia[3]int k = p[-2];    // p[-2] is the same element as ia[0]</code></pre><p>注意，这里的  <code>p</code>  是指向  <code>ia[2]</code>  的指针，对指针  <code>p</code>  执行下标运算时，相当于给指针加上（减去）某整数值，即，对指针进行移动。例如上例的  <code>p[-2]</code>  等价于  <code>*(p - 2)</code>  ，也就是  <code>ia[0]</code></p><p>虽然标准库类型  <code>string</code>  和  <code>vector</code>  也能执行下标运算，但是，<strong>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求</strong>。即，内置的下标运算符可以处理负值，当然，结果地址必须指向原指针所指数组中的元素（或是同一数组尾元素的下一位置）</p><h2 id="c-风格字符串"><a class="anchor" href="#c-风格字符串">#</a> C 风格字符串</h2><p>字符串字面值是一种通用结构的实例，这种结构是 C++ 由 C 继承而来的 C 风格字符串（C-stylecharacter string）</p><p><strong>尽管 C++ 支持 C 风格字符串，但在 C++ 程序中最好还是不要使用它们</strong></p><blockquote><p>这是因为 C 风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因</p></blockquote><p>C 风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法</p><h3 id="c-标准库-string-函数"><a class="anchor" href="#c-标准库-string-函数">#</a> C 标准库 string 函数</h3><p>C 风格字符串的处理函数定义在  <code>cstring</code>  头文件中（C 语言头文件  <code>string.h</code>  的 C++ 版本）</p><ul><li><code>strlen(p)</code>  （&quot;len&quot; 是指 &quot;length&quot;）</li><li><code>strcmp(p1, p2)</code>  （&quot;cmp&quot; 是指 &quot;compare&quot;）</li><li><code>strcat(p1, p2)</code>  （&quot;cat&quot; 是指 &quot;concatenate&quot;）</li><li><code>strcpy(p1, p2)</code>  （&quot;cpy&quot; 是指 &quot;copy&quot;）</li></ul><p><img data-src="/posts/cddca394/8.png" class=""></p><blockquote><p>所列函数不负责验证其字符串参数</p></blockquote><p><strong>传入此类函数的指针必须指向以空字符作为结束的数组</strong></p><pre><code class="language-cpp">char ca[] = &#123;'C', '+', '+'&#125;;  // not null terminatedcout &lt;&lt; strlen(ca) &lt;&lt; endl;   // disaster: ca isn't null terminated</code></pre><p>此例中， <code>ca</code>  虽然是一个字符数组，但它不是以空字符作为结束的，因此，上述程序将产生未定义的结果（  <code>strlen</code>  函数可能会沿着  <code>ca</code>  在内存中的位置不断向前寻找，直到遇到空字符才停下来）</p><h3 id="比较字符串"><a class="anchor" href="#比较字符串">#</a> 比较字符串</h3><p>比较两个 C 风格字符串的方法 与 比较标准库  <code>string</code>  对象的方法 大相径庭</p><ul><li><p>比较标准库  <code>string</code>  对象的时候，用的是普通的关系运算符和相等性运算符</p><pre><code class="language-cpp">string s1 = &quot;A string example&quot;;string s2 = &quot;A different string&quot;;if (s1 &lt; s2)  // false: s2 is less than s1</code></pre></li><li><p>如果把这些运算符用在两个 C 风格字符串上，比较的将是指针，而非字符串本身</p><pre><code class="language-cpp">const char ca1[] = &quot;A string example&quot;;const char ca2[] = &quot;A different string&quot;;if (ca1 &lt; ca2)  // undefined: compares two unrelated addresses</code></pre></li></ul><p>正如之前介绍过的，使用数组时，真正用的是指向数组首元素的指针</p><p>因此，上面的  <code>if (ca1 &lt; ca2)</code>  实际是在比较两个  <code>const char *</code>  的值，由于这两个指针指向的并非同一对象，所以将得到未定义的结果</p><p>要想比较两个 C 风格字符串，需要调用  <code>strcmp</code>  函数</p><ul><li>如果两个字符串相等， <code>strcmp</code>  返回 0</li><li>如果前面的字符串较大，返回正值</li><li>如果后面的字符串较大，返回负值</li></ul><pre><code class="language-cpp">if (strcmp(ca1, ca2) &lt; 0) // same effect as string comparison s1 &lt; s2</code></pre><h3 id="目标字符串的大小由调用者指定"><a class="anchor" href="#目标字符串的大小由调用者指定">#</a> 目标字符串的大小由调用者指定</h3><p>连接或拷贝 C 风格字符串也与标准库  <code>string</code>  对象的同类操作差别很大</p><ul><li><p>要想把刚刚定义的那两个  <code>string</code>  对象  <code>s1</code>  和  <code>s2</code>  连接起来，可以直接写成下面的形式：</p><pre><code class="language-cpp">// initialize largeStr as a concatenation of s1, a space, and s2string largeStr = s1 + &quot; &quot; + s2;</code></pre></li><li><p>如果针对  <code>ca1</code>  和  <code>ca2</code>  这两个数组进行同样的操作，就会产生错误。这是因为，表达式  <code>ca1 + ca2</code>  试图将两个指针相加，这样的操作没什么意义，也是非法的</p></li></ul><p>正确的方法是，使用  <code>strcat</code>  函数和  <code>strcpy</code>  函数</p><p>不过要想使用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符</p><p>下面的代码虽然很常见，但是充满了安全风险，极易引发严重错误：</p><pre><code class="language-cpp">// disastrous if we miscalculated the size of largeStrstrcpy(largeStr, ca1);     // copies ca1 into largeStrstrcat(largeStr, &quot; &quot;);     // adds a space at the end of largeStrstrcat(largeStr, ca2);     // concatenates ca2 onto largeStr</code></pre><p>一个潜在的问题是，在估算  <code>largeStr</code>  所需的空间时，不容易估准，而且，  <code>largeStr</code>  所存的内容一旦改变，就必须重新检查其空间是否足够</p><blockquote><p>对大多数应用来说，使用标准库类型  <code>string</code>  要比使用 C 风格字符串更安全、更高效</p></blockquote><h2 id="与旧代码的接口"><a class="anchor" href="#与旧代码的接口">#</a> 与旧代码的接口</h2><p>很多 C++ 程序在标准库出现之前就已经写成了，它们肯定没用到  <code>string</code>  和  <code>vector</code>  类型</p><p>而且，有一些 C++ 程序实际上是与 C 语言或其他语言的接口程序，当然也无法使用 C++ 标准库</p><p>因此，现代的 C++ 程序不得不与那些充满了数组和 / 或 C 风格字符串的代码衔接</p><h3 id="混用-string-对象和-c-风格字符串"><a class="anchor" href="#混用-string-对象和-c-风格字符串">#</a> 混用 string 对象和 C 风格字符串</h3><p>可以使用字符串字面值来初始化  <code>string</code>  对象</p><pre><code class="language-cpp">string s(&quot;Hello World&quot;);  // s holds Hello World</code></pre><p>更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代</p><ul><li>允许使用以空字符结束的字符数组来初始化  <code>string</code>  对象、为  <code>string</code>  对象赋值</li><li>在  <code>string</code>  对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）</li><li>在  <code>string</code>  对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧的运算对象</li></ul><p>上述性质反过来就不成立了：如果程序的某处需要一个 C 风格字符串，无法直接用  <code>string</code>  对象来代替它。例如，不能用  <code>string</code>  对象直接初始化指向字符的指针</p><p>为了完成该功能， <code>string</code>  专门提供了一个名为  <code>c_str</code>  的成员函数</p><pre><code class="language-cpp">char *str = s; // error: can't initialize a char* from a stringconst char *str = s.c_str(); // ok</code></pre><p><code>c_str</code>  函数的返回值是一个 C 风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个  <code>string</code>  对象的一样</p><p><code>c_str</code>  函数的结果指针的类型是  <code>const char *</code>  ，从而确保我们不会改变字符数组的内容</p><p>注意，我们无法保证  <code>c_str</code>  函数返回的数组一直有效，如果后续操作改变了  <code>s</code>  的值，可能会让之前返回的数组失去效用</p><blockquote><p>如果程序想一直都能使用  <code>c_str()</code>  函数返回的数组，最好将该数组重新拷贝一份</p></blockquote><h3 id="使用数组初始化-vector-对象"><a class="anchor" href="#使用数组初始化-vector-对象">#</a> 使用数组初始化 vector 对象</h3><p>此前介绍过，不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用  <code>vector</code>  对象来初始化数组</p><p>但是，允许使用数组来初始化  <code>vector</code>  对象，只需 <strong>指明要拷贝区域的首元素地址和尾后地址</strong> 即可</p><pre><code class="language-cpp">int int_arr[] = &#123;0, 1, 2, 3, 4, 5&#125;;// ivec has six elements; each is a copy of the corresponding element in int_arrvector&lt;int&gt; ivec(begin(int_arr), end(int_arr));// copies three elements: int_arr[1], int_arr[2], int_arr[3]vector&lt;int&gt; subVec(int_arr + 1, int_arr + 4);</code></pre><h2 id="尽量使用标准库类型而非数组"><a class="anchor" href="#尽量使用标准库类型而非数组">#</a> 尽量使用标准库类型而非数组</h2><p>使用指针和数组很容易出错</p><ul><li>一部分原因是概念上的问题：指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误</li><li>其他问题则源于语法错误，特别是声明指针时的语法错误</li></ul><p>现代的 C++ 程序应当尽量使用  <code>vector</code>  和迭代器，避免使用内置数组和指针。应该尽量使用  <code>string</code>  ，避免使用 C 风格的基于数组的字符串</p><h1 id="多维数组"><a class="anchor" href="#多维数组">#</a> 多维数组</h1><p>严格来说，C++ 语言中没有多维数组，通常所说的多维数组其实是 <strong>数组的数组</strong></p><p>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小</p><pre><code class="language-cpp">int ia[3][4]; // 大小为 3 的数组，每个元素是含有 4 个整数的数组// array of size 10; each element is a 20-element array whose elements are arrays of 30 intsint arr[10][20][30] = &#123;0&#125;; // initialize all elements to 0</code></pre><p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列</p><h2 id="多维数组的初始化"><a class="anchor" href="#多维数组的初始化">#</a> 多维数组的初始化</h2><p><strong>允许使用花括号括起来的一组值初始化多维数组</strong></p><pre><code class="language-cpp">int ia[3][4] = &#123;    // three elements; each element is an array of size 4    &#123;0, 1, 2, 3&#125;,   // initializers for the row indexed by 0    &#123;4, 5, 6, 7&#125;,   // initializers for the row indexed by 1    &#123;8, 9, 10, 11&#125;  // initializers for the row indexed by 2&#125;;</code></pre><p>其中，内层嵌套着的花括号并不是必需的</p><p>例如下面的初始化语句，形式上更为简洁，完成的功能和上述代码完全一样：</p><pre><code class="language-cpp">// equivalent initialization without the optional nested braces for each rowint ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</code></pre><p>如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：</p><pre><code class="language-cpp">// explicitly initialize only element 0 in each rowint ia[3][4] = &#123; &#123;0&#125;, &#123;4&#125;, &#123;8&#125; &#125;;</code></pre><p>其他 <strong>未列出的元素执行默认值初始化</strong></p><p>在这种情况下，如果再省略掉内层的花括号，结果就大不一样了:</p><pre><code class="language-cpp">// explicitly initialize row 0; the remaining elements are value initializedint ix[3][4] = &#123;0, 3, 6, 9&#125;;</code></pre><p>此时初始化的是第一行的 4 个元素，其他元素被初始化为 0</p><h2 id="多维数组的下标引用"><a class="anchor" href="#多维数组的下标引用">#</a> 多维数组的下标引用</h2><p><strong>可以使用下标运算符来访问多维数组的元素，数组的每个维度对应一个下标运算符</strong></p><p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素</p><p>如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组</p><pre><code class="language-cpp">// assigns the first element of arr to the last element in the last row of iaia[2][3] = arr[0][0][0];int (&amp;row)[4] = ia[1]; // binds row to the second four-element array in ia</code></pre><p>程序中经常会用到两层嵌套的  <code>for</code>  循环来处理多维数组的元素，例如：</p><pre><code class="language-cpp">constexpr size_t rowCnt = 3, colCnt = 4;int ia[rowCnt][colCnt];   // 12 uninitialized elements// for each rowfor (size_t i = 0; i != rowCnt; ++i) &#123;    // for each column within the row    for (size_t j = 0; j != colCnt; ++j) &#123;        // assign the element's positional index as its value        ia[i][j] = i * colCnt + j;    &#125;&#125;</code></pre><p>在上例中，外层的  <code>for</code>  循环遍历  <code>ia</code>  的所有元素，注意，这里的元素是一维数组；内层的  <code>for</code>  循环则遍历那些一维数组的整数元素</p><h2 id="使用范围-for-语句处理多维数组"><a class="anchor" href="#使用范围-for-语句处理多维数组">#</a> 使用范围 for 语句处理多维数组</h2><pre><code class="language-cpp">size_t cnt = 0;for (auto &amp;row : ia)        // for every element in the outer array    for (auto &amp;col : row) &#123; // for every element in the inner array        col = cnt;          // give this element the next value        ++cnt;              // increment cnt    &#125;</code></pre><p>要改变数组元素的值，所以得把控制变量  <code>row</code>  和  <code>col</code>  声明成引用类型。第一个  <code>for</code>  循环遍历  <code>ia</code>  的所有元素（大小为 4 的数组），因此  <code>row</code>  的类型就是整数数组的引用；第二个  <code>for</code>  循环遍历那些 4 元素数组中的某一个，因此，  <code>col</code>  的类型是整数的引用</p><p>在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做</p><p>举一个例子，考虑如下的循环：</p><pre><code class="language-cpp">for (const auto &amp;row : ia)  // for every element in the outer array    for (auto col : row)    // for every element in the inner array        cout &lt;&lt; col &lt;&lt; endl;</code></pre><p>这个循环中并没有任何写操作，但我们依然将外层循环的控制变量声明成了引用类型，这是 <strong>为了避免数组被自动转成指针</strong></p><p>假设不用引用类型，则循环如下述形式：</p><pre><code class="language-cpp">for (auto row : ia)    for (auto col : row)</code></pre><p>程序将无法通过编译</p><p>这是因为：第一个循环遍历  <code>ia</code>  的元素实际是大小为 4 的数组，由于  <code>row</code>  不是引用类型，编译器初始化  <code>row</code>  时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针，这样得到的  <code>row</code>  的类型就是  <code>int*</code>  ，显然内层的循环就不合法了</p><p><strong>使用范围 for 语句处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</strong></p><h2 id="指针和多维数组"><a class="anchor" href="#指针和多维数组">#</a> 指针和多维数组</h2><p>使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针</p><p>多维数组实际上是数组的数组，因此，由多维数组名转换得来的指针，实际上是指向第一个内层数组的指针</p><pre><code class="language-cpp">int ia[3][4];     // array of size 3; each element is an array of ints of size 4int (*p)[4] = ia; // p points to an array of four ints（p 指向 ia 的第一行）p = &amp;ia[2];       // p now points to the last element in ia（p 指向 ia 的第三行）</code></pre><p>以  <code>int (*p)[4] = ia</code>  为例：</p><ul><li>对于  <code>=</code>  左侧，首先可以根据  <code>(*p)</code>  知道  <code>p</code>  是一个指针，由  <code>int [4]</code>  可以知道  <code>p</code>  指向的是一个包含 4 个整数的数组</li><li>对于等号右侧， <code>ia</code>  返回的是  <code>&amp;ia[0]</code>  ，即  <code>ia[0]</code>  的地址</li><li>因此， <code>p</code>  指向的是  <code>ia[0]</code>  ，即  <code>ia</code>  的第一行</li></ul><p>注意，在上述声明中，圆括号必不可少</p><pre><code class="language-cpp">int *ip[4];    // array of pointers to int（[] 优先级高于 * ，故而 ip 是一个数组，其元素为整形指针）int (*ip)[4];  // pointer to an array of four ints</code></pre><p>随着 C++ 11 新标准的提出，可以使用  <code>auto</code>  或者 <code>decltype</code>  ，以尽可能避免在数组前面加上一个指针类型</p><pre><code class="language-cpp">// print the value of each element in ia, with each inner array on its own line// p points to an array of four intsfor (auto p = ia; p != ia + 3; ++p) &#123;    // q points to the first element of an array of four ints; that is, q points to an int    for (auto q = *p; q != *p + 4; ++q)        cout &lt;&lt; *q &lt;&lt; ' ';    cout &lt;&lt; endl;&#125;</code></pre><p>在上例中，外层的  <code>for</code>  循环首先声明一个指针  <code>p</code>  ，令其指向  <code>ia</code>  的第一个内层数组，然后依次迭代直到  <code>ia</code>  的全部 3 行都处理完为止，其中，递增运算  <code>++p</code>  负责将指针  <code>p</code>  移动到  <code>ia</code>  的下一行</p><p>内层的  <code>for</code>  循环负责输出内层数组所包含的值。它首先令指针  <code>q</code>  指向  <code>p</code>  当前所在行的第一个元素（  <code>p</code>  指向某一个内层数组，则  <code>*p</code>  是一个数组，在使用  <code>*p</code>  时，会被自动地转换成指向首元素的指针）</p><p>使用 <strong>标准库函数  <code>begin</code>  和  <code>end</code> </strong> 也能实现同样的功能，而且看起来更简洁一些</p><pre><code class="language-cpp">// p points to the first array in iafor (auto p = begin(ia); p != end(ia); ++p) &#123;    // q points to the first element in an inner array    for (auto q = begin(*p); q != end(*p); ++q)        cout &lt;&lt; *q &lt;&lt; ' ';   // prints the int value to which q points    cout &lt;&lt; endl;&#125;</code></pre><h2 id="类型别名简化多维数组的指针"><a class="anchor" href="#类型别名简化多维数组的指针">#</a> 类型别名简化多维数组的指针</h2><p>使用类型别名（<strong>处理类型 - 类型别名</strong>）能让 读、写和理解一个指向多维数组的指针 变得简单一些</p><p>例如：</p><pre><code class="language-cpp">using int_array = int[4]; // new style type alias declaration; equivalent typedef declaration: typedef int int_array[4];// print the value of each element in ia, with each inner array on its own linefor (int_array *p = ia; p != ia + 3; ++p) &#123;    for (int *q = *p; q != *p + 4; ++q)        cout &lt;&lt; *q &lt;&lt; ' ';    cout &lt;&lt; endl;&#125;</code></pre><p>程序将类型 “4 个整数组成的数组” 命名为  <code>int_array</code>  ，用类型名  <code>int_array</code>  定义外层循环的控制变量（由  <code>*p</code>  知道  <code>p</code>  是一个指针，指向一个包含 4 个整数的数组， <code>q</code>  是一个指向整数的指针）</p><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><code>begin</code>  ：是 <code>string</code>  和 <code>vector</code>  的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针</p><p><code>缓冲区溢出（buffer overflow）</code>  ：一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括 <code>string</code> 、 <code>vector</code>  和 <code>数组</code> 等</p><p><code>C风格字符串（C-style string）</code>  ：以空字符结束的字符数组。字符串字面值是 C 风格字符串，C 风格字符串容易出错</p><p><code>类模板（class template）</code>  ：用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个 <code>vector</code>  对象需要指定元素的类型，例如： <code>vector&lt;int&gt;</code>  包含 <code>int</code>  类型的元素</p><p><code>编译器扩展（compiler extension）</code>  ：某个特定的编译器为 C++ 语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上</p><p><code>容器（container）</code>  ：是一种类型，其对象容纳了一组给定类型的对象。 <code>vector</code>  是一种容器类型</p><p><code>拷贝初始化（copy initialization）</code>  ：使用赋值号（ <code>=</code> ）的初始化形式。新创建的对象是初始值的一个副本</p><p><code>difference_type</code>  ：由 <code>string</code>  和 <code>vector</code>  定义的一种带符号整数类型，表示两个迭代器之间的距离</p><p><code>直接初始化（direct initialization）</code>  ：不使用赋值号（ <code>=</code> ）的初始化形式</p><p><code>empty</code>  ：是 <code>string</code>  和 <code>vector</code>  的成员，返回一个布尔值。当对象的大小为 0 时返回真，否则返回假</p><p><code>end</code>  ：是 <code>string</code>  和 <code>vector</code>  的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针</p><p><code>getline</code>  ：在 <code>string</code>  头文件中定义的一个函数，以一个 <code>istream</code>  对象和一个 <code>string</code>  对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入 <code>string</code>  对象，最后返回 <code>istream</code>  对象。其中换行符读入但是不保留</p><p><code>索引（index）</code>  ：是下标运算符使用的值。表示要在 <code>string</code>  对象、 <code>vector</code>  对象或者数组中访问的一个位置</p><p><code>实例化（instantiation）</code>  ：编译器生成一个指定的模板类或函数的过程</p><p><code>迭代器（iterator）</code>  ：是一种类型，用于访问容器中的元素或者在元素之间移动</p><p><code>迭代器运算（iterator arithmetic）</code>  ：是 <code>string</code>  或 <code>vector</code>  的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置</p><p><code>以空字符结束的字符串（null-terminatedstring）</code>  ：是一个字符串，它的最后一个字符后面还跟着一个空字符（ <code>'\0'</code> ）</p><p><code>尾后迭代器（off-the-end iterator）</code>  ： <code>end</code>  函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一位置</p><p><code>指针运算（pointer arithmetic）</code>  ：是指针类型支持的算术运算。指向数组的指针所支持的运算种类与迭代器运算一样</p><p><code>prtdiff_t</code>  ：是 <code>cstddef</code>  头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离</p><p><code>push_back</code>  ：是 <code>vector</code>  的成员，向 <code>vector</code>  对象的末尾添加元素</p><p><code>范围for语句（range for）</code>  ：一种控制语句，可以在值的一个特定集合内迭代</p><p><code>size</code>  ：是 <code>string</code>  和 <code>vector</code>  的成员，分别返回字符的数量或元素的数量。返回值的类型是 <code>size_type</code></p><p><code>size_t</code>  ：是 <code>cstddef</code>  头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小</p><p><code>size_type</code>  ：是 <code>string</code>  和 <code>vector</code>  定义的类型的名字，能存放下任意 <code>string</code>  对象或 <code>vector</code>  对象的大小。在标准库中， <code>size_type</code>  被定义为无符号类型</p><p><code>string</code>  ：是一种标准库类型，表示字符的序列</p><p><code>using声明（using declaration）</code>  ：令命名空间中的某个名字可被程序直接使用。 <code>using 命名空间::名字</code> ；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分 <code>命名空间::</code></p><p><code>值初始化（value initialization）</code>  ：是一种初始化过程。内置类型初始化为 0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值</p><p><code>vector</code>  ：是一种标准库类型，容纳某指定类型的一组元素</p><p><code>++运算符（++ operator）</code>  ：是迭代器和指针定义的递增运算符。执行 “加 1” 操作使得迭代器指向下一个元素</p><p><code>[ ]运算符（[ ] operator）</code>  ：下标运算符。 <code>obj[j]</code>  得到容器对象 <code>obj</code>  中位置 <code>j</code>  的那个元素。索引从 0 开始，第一个元素的索引是 0，尾元素的索引是 <code>obj.size() - 1</code> 。下标运算符的返回值是一个对象。如果 <code>p</code>  是指针、 <code>n</code>  是整数，则  <code>p[n]</code>  与  <code>*(p + n)</code>  等价</p><p><code>-&gt;运算符（-&gt;operator）</code>  ：箭头运算符，该运算符综合了解引用操作和点操作。 <code>a-&gt;b</code>  等价于 <code>(*a).b</code></p><p><code>&lt;&lt;运算符（&lt;&lt;operator）</code>  ：标准库类型 <code>string</code>  定义的输出运算符，负责输出 <code>string</code>  对象中的字符</p><p><code>&gt;&gt;运算符（&gt;&gt;operator）</code>  ：标准库类型 <code>string</code>  定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个 <code>string</code>  对象</p><p><code>!运算符（! operator）</code>  ：逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假</p><p><code>&amp;&amp;运算符（&amp;&amp;operator）</code>  ：逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象</p><p><code>||运算符（|| operator）</code>  ：逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象</p><p>参考：C++ Primer 中文版（第 5 版）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 变量和基本类型</title>
      <link href="/posts/38333d94/"/>
      <url>/posts/38333d94/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内置类型"><a class="anchor" href="#基本内置类型">#</a> 基本内置类型</h1><p>C++ 定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中，算术类型包含了字符、整数型、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p><h2 id="算术类型"><a class="anchor" href="#算术类型">#</a> 算术类型</h2><p>算术类型分为两类：整型（integral，包括字符和布尔类型在内）和浮点型。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th><th style="text-align:center">最小尺寸</th></tr></thead><tbody><tr><td style="text-align:center"><code>bool</code></td><td style="text-align:center">布尔类型</td><td style="text-align:center">未定义</td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center">字符</td><td style="text-align:center">8 位</td></tr><tr><td style="text-align:center"><code>wchar_t</code></td><td style="text-align:center">宽字符</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>char16_t</code></td><td style="text-align:center">Unicode 字符</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>char32_t</code></td><td style="text-align:center">Unicode 字符</td><td style="text-align:center">32 位</td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center">短整型</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center">整型</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">32 位</td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">64 位</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">单精度浮点数</td><td style="text-align:center">6 位有效数字</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center">双精度浮点数</td><td style="text-align:center">10 位有效数字</td></tr><tr><td style="text-align:center"><code>long double</code></td><td style="text-align:center">拓展精度浮点数</td><td style="text-align:center">10 位有效数字</td></tr></tbody></table><blockquote><p>上述表格列出了 C++ 标准规定的算术类型的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸</p></blockquote><h3 id="整型与浮点型"><a class="anchor" href="#整型与浮点型">#</a> 整型与浮点型</h3><p>布尔类型（bool）的取值是真（True）或者假（False）。</p><p>基本的字符类型是 <code>char</code> ，一个 <code>char</code>  的空间应确保可以存放机器基本字符集（如 ASCII 表）中任意字符对应的数字值，即，一个 <code>char</code>  的大小和一个机器字节一样。</p><p><code>wchar_t</code>  类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 <code>char16_t</code>  和 <code>char32_t</code>  则为 Unicode 字符集服务（Unicode 是用于表示所有自然语言中字符的标准）。</p><blockquote><p>Unicode 为每种语言中的每个字符设定了统一并且唯一的二进制编码，现在用的是 UCS-2，即，2 个字节编码。UTF-8，UTF-16，UTF-32 均为字符编码方案。</p></blockquote><p>大多数机器的字节（byte）由 8 比特（bit）构成，字（word）则由 32 或 64 比特构成，也就是 4 或 8 字节。</p><ul><li>计算机以比特序列存储数据</li><li>字节是可寻址的最小内存块</li><li>字是内存的基本单元</li></ul><p>浮点型可表示单精度、双精度和扩展精度值。通常， <code>float</code>  以 1 个字（32 比特）来表示， <code>double</code>  以 2 个字（64 比特）来表示， <code>long double</code>  以 3 或 4 个字（96 或 128 比特）来表示。一般来说，类型 <code>float</code>  和 <code>double</code>  分别有 7 和 16 个有效位。</p><blockquote><p>浮点数在机器内用指数形式表示，分解为：数符，尾数，指数符，指数。</p></blockquote><h3 id="带符号类型和无符号类型"><a class="anchor" href="#带符号类型和无符号类型">#</a> 带符号类型和无符号类型</h3><p>除布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。</p><ul><li>带符号类型可以表示正数、负数或 0</li><li>无符号类型仅能表示大于等于 0 的值。</li></ul><p>带符号类型： <code>int</code> 、 <code>short</code> 、 <code>long</code> 、 <code>long long</code></p><p>在这些类型名前添加 <code>unsigned</code>  就可以得到对应的无符号类型</p><p>即，无符号类型： <code>unsigned int</code> 、 <code>unsigned short</code> 、 <code>unsigned long</code> 、 <code>unsigned long long</code> 。</p><p>类型 <code>unsigned int</code>  可以缩写为 <code>unsigned</code> 。</p><p>字符型分为三种： <code>char</code> 、 <code>signed char</code> 、 <code>unsigned char</code> 。其中， <code>signed char</code>  类型和 <code>unsigned char</code>  类型分别为带符号类型和无符号类型， <code>char</code>  类型实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p><p>无符号类型中所有比特都用来存储值。</p><p>C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。</p><blockquote><p><code>8</code>  比特的 <code>signed char</code>  理论上应该可以表示 <code>-127</code>  至 <code>127</code>  区间内的值，大多数现代计算机将 <code>8</code>  比特的 <code>signed char</code>  实际的表示范围定为  <code>-128~127</code> 。</p></blockquote><h3 id="如何选择类型"><a class="anchor" href="#如何选择类型">#</a> 如何选择类型</h3><p>当明确知晓数值不可能为负时，选用无符号类型。</p><p>使用 <code>int</code>  执行整数运算。若数值超出 <code>int</code>  的表示范围，选用 <code>long long</code> 。</p><p>在算术表达式中不要使用 <code>char</code>  或 <code>bool</code> ，只有在存放字符或布尔值时才使用它们。</p><blockquote><p>因为类型 <code>char</code>  在一些机器上是有符号的，而在另一些机器上又是无符号的，所以使用 <code>char</code>  进行运算特别容易出问题。如果需要使用一个不大的整数，则应该明确指定类型是 <code>signed char</code>  或者 <code>unsigned char</code> 。</p></blockquote><p>执行浮点数运算选用 <code>double</code> 。</p><blockquote><p>这是因为 <code>float</code>  通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。 <code>long double</code>  提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。</p></blockquote><h2 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h2><p>类型转换是指，将对象从一种给定的类型转换（convert）为另一种相关类型。</p><h3 id="转换规则简介"><a class="anchor" href="#转换规则简介">#</a> 转换规则（简介）</h3><p>类型所能表示的值的范围决定了转换的过程：</p><ol><li><p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为 <code>0</code>  则结果为 <code>false</code> ，否则结果为 <code>true</code> 。</p></li><li><p>当我们把一个布尔值赋给非布尔类型时，初始值为 <code>false</code>  则结果为 <code>0</code> ，初始值为 <code>true</code>  则结果为 <code>1</code> 。</p></li><li><p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p></li><li><p>当我们把一个整数值赋给浮点类型时，小数部分记为 <code>0</code> 。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p></li><li><p>当我们给无符号类型赋一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如， <code>8</code>  比特大小的 <code>unsigned char</code>  可以表示 <code>0</code>  至 <code>255</code>  区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对 <code>256</code>  取模后所得的余数。因此，把 <code>-1</code>  赋给 <code>8</code>  比特大小的 <code>unsigned char</code>  所得的结果是 <code>255</code> 。</p></li><li><p>当我们给带符号类型赋一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p></li></ol><h3 id="含有无符号类型的表达式"><a class="anchor" href="#含有无符号类型的表达式">#</a> 含有无符号类型的表达式</h3><p>当一个算术表达式中既有无符号数又有 int 值时，那个 int 值就会转换成无符号数。</p><p><strong>如果表达式里既有带符号类型又有无符号类型</strong>，当带符号类型取值为负时会出现异常结果，这是因为<strong>带符号数会自动地转换成无符号数</strong></p><p>例如，在一个形如 <code>a * b</code>  的式子中，如果 <code>a = -1</code> ， <code>b = 1</code> ，而且 <code>a</code>  和 <code>b</code>  都是 <code>int</code> ，则表达式的值显然为 <code>-1</code> 。然而，如果 <code>a</code>  是 <code>int</code> ，而 <code>b</code>  是 <code>unsigned</code> ，则结果须视在当前机器上 <code>int</code>  所占位数而定。在我们的环境里，结果是 <code>4294967295</code> 。</p><blockquote><p><strong>切勿混用带符号类型和无符号类型</strong></p></blockquote><p>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值。</p><p>无符号数不会小于 0 这一事实同样关系到循环的写法。</p><pre><code class="language-cpp">// 以降序的形式逐个输出数字10到0for (int i = 10; i &gt;= 0; --i)    std::cout &lt;&lt; i &lt;&lt;std::endl;// 错误：变量u永远也不会小于0，循环条件一直成立for (unsigned u = 10, u &gt;= 0; --u)    std::cout &lt;&lt; u &lt;&lt;std::endl;</code></pre><p>上例中，当 <code>u</code>  等于 <code>0</code>  时这次迭代输出 <code>0</code> ，然后继续执行 <code>for</code>  语句里的表达式。表达式 <code>--u</code>  从 <code>u</code>  当中减去 <code>1</code> ，得到的结果 <code>-1</code>  并不满足无符号数的要求，此时 <code>-1</code>  被自动地转换成一个合法的无符号数。假设 <code>int</code>  类型占 <code>32</code>  位，则当 <code>u</code>  等于 <code>0</code>  时， <code>--u</code>  的结果将会是 <code>4294967295</code> 。</p><h2 id="字面值常量"><a class="anchor" href="#字面值常量">#</a> 字面值常量</h2><p>字面值常量（literal）：形如 42 的值，一望而知。</p><p>每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p><h3 id="整型和浮点型字面值"><a class="anchor" href="#整型和浮点型字面值">#</a> 整型和浮点型字面值</h3><p>可以将整型字面值写作十进制数、八进制数或十六进制数的形式</p><ul><li><p>以 0 开头的整数代表八进制数</p></li><li><p>以 0x 或 0X 开头的代表十六进制数</p><pre><code> 20 //十进制 024 //八进制 0x14 //十六进制</code></pre></li></ul><p>整型字面值具体的数据类型由它的值和符号决定。<strong>默认情况下，十进制字面值是带符号类型，八进制和十六进制字面值既可能是带符号的也可能是无符号的。</strong></p><ul><li>十进制字面值的类型是 <code>int</code> 、 <code>long</code>  和 <code>long long</code>  中尺寸最小的那个（例如，三者当中最小是 int），当然前提是这种类型要能容纳下当前的值</li><li>八进制和十六进制字面值的类型是能容纳其数值的 <code>int</code> 、 <code>unsigned int</code> 、 <code>long</code> 、 <code>unsigned long</code> 、 <code>long long</code>  和 <code>unsigned long long</code> （即，带符号的和无符号的 <code>int</code> 、 <code>long</code> 、 <code>long long</code> ）中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误</li></ul><p>类型 <code>short</code>  没有对应的字面值</p><blockquote><p>尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如 - 42 的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</p></blockquote><p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 或 e 标识:</p><pre><code>3.141593.14159E00.0e0.001</code></pre><p>默认的，浮点型字面值是一个 <code>double</code> 。</p><h3 id="字符和字符串字面值"><a class="anchor" href="#字符和字符串字面值">#</a> 字符和字符串字面值</h3><p>由单引号括起来的一个字符称为字符型字面值</p><p>双引号括起来的零个或多个字符则构成字符串型字面值</p><pre><code class="language-cpp">'a' // 字符字面值&quot;Hello World!&quot; // 字符串字面值</code></pre><p>字符串字面值的类型实际上是由常量字符构成的数组（array）</p><p><strong>编译器在每个字符串字面值的结尾处添加一个空字符 (  <code>'\0'</code>  )</strong> 。因此，字符串字面值的实际长度要比它的内容多 1。</p><p>例如，字面值 'A' 表示的就是单独的字符 A，而字符串 &quot;A&quot; 则代表了一个字符的数组，该数组包含两个字符：一个是字母 A、另一个是空字符。</p><p>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。</p><pre><code class="language-cpp">// 当书写的字符串字面值比较长，写在一行里不太合适时，分多行书写字符串字面值std::cout &lt;&lt; &quot;a really, really long string literal &quot;          &lt;&lt; &quot;that spans two lines&quot; &lt;&lt; std::endl;</code></pre><h3 id="转义序列"><a class="anchor" href="#转义序列">#</a> 转义序列</h3><p>有两类字符程序员不能直接使用：</p><ul><li>一类是不可打印（nonprintable）的字符，如退格或其他控制字符，因为它们没有可视的图符</li><li>另一类是在 C++ 语言中有特殊含义的字符（单引号、双引号、问号、反斜线）</li></ul><p>这些情况需要用到转义序列（escape sequence）</p><p>C++ 语言规定的转义序列包括：</p><blockquote><p>换行符  <code>\n</code> <br /> 纵向制表符  <code>\v</code> <br /> 反斜线  <code>\\</code> <br /> 回车符  <code>\r</code> <br /> 横向制表符  <code>\t</code> <br /> 退格符  <code>\b</code> <br /> 问号  <code>\?</code> <br /> 进纸符  <code>\f</code> <br /> 报警（响铃）符  <code>\a</code> <br /> 双引号  <code>\&quot;</code> <br /> 单引号  <code>\'</code></p></blockquote><p>在程序中，上述转义序列被当作一个字符使用。</p><pre><code class="language-cpp">std::cout &lt;&lt; '\n';          // 转到新一行std::cout &lt;&lt; &quot;\tHi!\n&quot;;     // 输出一个制表符，输出&quot;Hi!&quot;，转到新一行</code></pre><p>我们也可以使用泛化的转义序列，其形式是：</p><ul><li><strong> <code>\x</code>  后紧跟 1 个或多个十六进制数字</strong></li><li><strong> <code>\</code>  后紧跟 1 个、2 个或 3 个八进制数字</strong></li></ul><p>其中，数字部分表示的是字符对应的数值</p><blockquote><p>假设使用的是 Latin-1 字符集，以下是一些示例：（对应 ASCII 表）<br /> <code>\7</code>  响铃<br /> <code>\12</code>  换行符<br /> <code>\40</code>  空格<br /> <code>\0</code>  空字符<br /> <code>\115</code>  字符 M<br /> <code>\x4d</code>  字符 M</p></blockquote><p>例如：</p><pre><code class="language-cpp">std::cout &lt;&lt; &quot;Hi! \x4dO\115!\n&quot;;    // 输出&quot;Hi MOM!&quot;，转到新一行std::cout &lt;&lt; '\115' &lt;&lt; '\n';        // 输出&quot;M&quot;，转到新一行</code></pre><p>注意：</p><ul><li><p>如果反斜线 <code>\</code>  后面跟着的八进制数字超过 3 个，只有前 3 个数字与 <code>\</code>  构成转义序列。例如， <code>&quot;\1234&quot;</code>  表示 2 个字符，即八进制数 123 对应的字符以及字符 4</p></li><li><p>而  <code>\x</code>  要用到后面跟着的所有数字，例如， <code>&quot;\x1234&quot;</code>  表示一个 16 位的字符，该字符由这 4 个十六进制数所对应的比特唯一确定。因为大多数机器的 <code>char</code>  型数据占 8 位，所以上面这个例子可能会报错。一般来说，超过 8 位的十六进制字符，都是与 下一节所示表格的某个前缀作为开头的扩展字符集 一起使用</p></li></ul><h3 id="指定字面值的类型"><a class="anchor" href="#指定字面值的类型">#</a> 指定字面值的类型</h3><p>通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p><p>字符和字符串字面值：</p><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">含义</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">Unicode 16 字符</td><td style="text-align:center">char16_t</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">Unicode 32 字符</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">宽字符</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center">u8</td><td style="text-align:center">UTF-8 （仅用于字符串字面值常量）</td><td style="text-align:center">char</td></tr></tbody></table><p>整型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">u 或 U</td><td style="text-align:center">unsigned</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">ll 或 LL</td><td style="text-align:center">long long</td></tr></tbody></table><p>浮点型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">f 或 F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long double</td></tr></tbody></table><p>当使用一个长整型字面值时，请使用大写字母 L 来标记，因为小写字母 l 和数字 1 容易混淆</p><pre><code class="language-cpp">L'a'        // 宽字符型字面值，类型是 wchar_tu8&quot;hi!&quot;     // UTF-8 字符串字面值，类型是 char42ULL       // 无符号整型字面值，类型是 unsigned long long1E-3F       // 单精度浮点型字面值，类型是 float3.14159L    // 扩展精度浮点型字面值，类型是 long double</code></pre><p>对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。</p><ul><li>如果后缀中有 <code>U</code> ，则该字面值属于无符号类型，也就是说，以 <code>U</code>  为后缀的十进制数、八进制数或十六进制数都将从 <code>unsigned int</code> 、 <code>unsigned long</code>  和 <code>unsigned long long</code>  中选择能匹配的空间最小的一个作为其数据类型</li><li>如果后缀中有 <code>L</code> ，则字面值的类型至少是 <code>long</code></li><li>如果后缀中有 <code>LL</code> ，则字面值的类型将是 <code>long long</code>  和 <code>unsigned long long</code>  中的一种</li><li>可以将 <code>U</code>  与 <code>L</code>  或 <code>LL</code>  合在一起使用。例如，以 <code>UL</code>  为后缀的字面值的数据类型将根据具体数值情况或者取 <code>unsigned long</code> ，或者取 <code>unsigned long long</code></li></ul><h3 id="布尔字面值和指针字面值"><a class="anchor" href="#布尔字面值和指针字面值">#</a> 布尔字面值和指针字面值</h3><p><code>true</code>  和 <code>false</code>  是布尔类型的字面值</p><p><code>nullptr</code>  是指针字面值</p><h1 id="变量"><a class="anchor" href="#变量">#</a> 变量</h1><p>C++ 中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算</p><p>对 C++ 程序员来说，“变量（variable）” 和 “对象（object）” 一般可以互换使用。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间</p><h2 id="变量定义"><a class="anchor" href="#变量定义">#</a> 变量定义</h2><p>变量定义的基本形式是：首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束</p><p>列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值，例如：</p><pre><code class="language-cpp">int sum = 0, value, // sum, value, and units_sold have type int    units_sold = 0; // sum and units_sold have initial value 0Sales_item item;    // item has type Sales_item (see § 1.5.1 (p. 20))// string is a library type, representing a variable-length sequence of charactersstd::string book(&quot;0-201-78345-X&quot;); // book initialized from string literal</code></pre><h3 id="初始化"><a class="anchor" href="#初始化">#</a> 初始化</h3><p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialized）了</p><p>在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量，例如：</p><pre><code class="language-cpp">// ok: price is defined and initialized before it is used to initialize discountdouble price = 109.99, discount = price * 0.16;// ok: call applyDiscount and use the return value to initialize salePricedouble salePrice = applyDiscount(price, discount);</code></pre><p><strong>初始化不是赋值</strong></p><ul><li>初始化的含义是创建变量时赋予其一个初始值</li><li>赋值的含义是把对象的当前值擦除，而以一个新值来替代</li></ul><h4 id="列表初始化"><a class="anchor" href="#列表初始化">#</a> 列表初始化</h4><p>列表初始化（List Initialization）: 用花括号来初始化变量，例如：</p><pre><code class="language-cpp">int units_sold = &#123;0&#125;;int units_sold&#123;0&#125;;</code></pre><p>当我们使用列表初始化以初始化内置类型的变量时，如果初始值存在丢失信息的风险，编译器将报错</p><p>例如，使用一个  <code>long double</code>  型的值来初始化一个  <code>int</code>  型的变量，此时可能丢失数据（至少  <code>ld</code>  的小数部分会丢失掉，而且  <code>int</code>  可能也存不下  <code>ld</code>  的整数部分），所以编译器拒绝  <code>a</code>  和  <code>b</code>  的初始化请求：</p><pre><code class="language-cpp">long double ld = 3.1415926536;int a&#123;ld&#125;, b = &#123;ld&#125;; // error: narrowing conversion requiredint c(ld), d = ld;   // ok: but value will be truncated</code></pre><h4 id="默认初始化"><a class="anchor" href="#默认初始化">#</a> 默认初始化</h4><p>默认初始化（default initialized）：如果定义变量时没有指定初值，则变量会被赋予 “默认值”</p><ol><li><p>如果是 <strong>内置类型的变量</strong> 未被显式初始化，它的值由定义的位置决定</p><ul><li><strong>定义于任何函数体之外的变量被初始化为 0</strong></li><li><strong>定义在函数体内部的内置类型变量将不被初始化（uninitialized）</strong></li></ul></li><li><p>每个类各自决定其初始化对象的方式，而且，是否可以不经初始化就定义对象也由类自己决定</p><ul><li>绝大多数类都支持无须显式初始化而定义对象，即，为对象提供了一个合适的默认值。例如， <code>string</code>  类规定：如果没有指定初值，则生成一个空串</li><li>一些类要求每个对象都显式初始化。此时，如果创建了一个该类的对象却并未对其做明确的初始化操作，将引发错误</li></ul></li></ol><blockquote><p>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义<br />类的对象如果没有显式地初始化，则其值由类确定</p></blockquote><p><strong>未初始化的变量含有一个不确定的值，使用未初始化的变量将带来无法预计的后果。</strong></p><blockquote><p>建议初始化每一个内置类型的变量</p></blockquote><h2 id="变量声明"><a class="anchor" href="#变量声明">#</a> 变量声明</h2><p>C++ 语言支持分离式编译（separatecompilation）机制，即，允许将程序分割为若干个文件，每个文件可被独立编译</p><p>特别地，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</p><blockquote><ul><li>C++ 是一种静态类型（statically typed）语言，即，在编译阶段检查变量的类型。其中，检查类型的过程称为类型检查（type checking）</li><li>我们已经知道，对象的类型决定了对象所能参与的运算。在 C++ 语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件</li><li>程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型</li></ul></blockquote><p>变量声明（declaration）：规定了变量的类型和名字</p><p>变量定义：不仅规定了变量的类型和名字，还申请存储空间，也可能会为变量赋一个初始值</p><p><strong>如果想声明一个变量，就在变量名前添加  <code>extern</code>  关键字</strong> ，注意，<strong>不要显式地初始化变量</strong> ，例如：</p><pre><code class="language-cpp">extern int i;   // declares but does not define iint j;          // declares and defines j</code></pre><p><strong>任何包含显式初始化的声明即成为定义</strong> ，即，如果  <code>extern</code>  语句包含初始值，那么它就不再是声明，而是定义，例如：</p><pre><code class="language-cpp">extern double pi = 3.1416; // definition</code></pre><p>在函数体内部，如果试图初始化一个由  <code>extern</code>  关键字标记的变量，将引发错误。即，包含有  <code>extern</code>  标记的定义，例如， <code>extern double pi=3.14;</code>  ，不能放在函数体内部</p><p><strong>变量能且只能被定义一次，但是可以被多次声明</strong></p><blockquote><p>如果要在多个文件中使用同一个变量，必须将声明和定义分离：</p><ul><li>变量的定义必须出现在且只能出现在一个文件中</li><li>其他用到该变量的文件必须对其进行声明，但不能重复定义</li></ul></blockquote><h2 id="标识符"><a class="anchor" href="#标识符">#</a> 标识符</h2><p>C++ 的标识符（identifier）由 <strong>字母</strong> 、<strong>数字</strong> 和 <strong>下划线</strong> 组成，并且，<strong>必须以字母或下划线开头</strong></p><p>标识符的长度没有限制，但是，<strong>对大小写字母敏感</strong> ，例如：</p><pre><code class="language-cpp">// defines four different int variablesint somename, someName, SomeName, SOMENAME;</code></pre><p><strong>C++ 关键字 和 操作符替代名 不能被用作标识符</strong></p><p><img data-src="/posts/38333d94/1.png" class="" title="关键字与操作符替代名"></p><p>此外，也还需要注意：</p><ul><li>标识符不能连续出现两个下划线</li><li>不能以下划线紧连大写字母开头</li><li>定义在函数体外的标识符不能以下划线开头</li></ul><p>变量命名规范变量命名有许多约定俗成的规范，以有效提高程序的可读性：</p><ul><li>标识符要能体现实际含义</li><li>变量名一般用小写字母，如  <code>index</code>  ，而不使用  <code>Index</code>  或  <code>INDEX</code></li><li>用户自定义的类名一般以大写字母开头，如  <code>Sales_item</code></li><li>如果标识符由多个单词组成，则单词间应有明显区分，如下划线命名法  <code>student_loan</code>  或驼峰命名法  <code>studentLoan</code>  ，而不要使用  <code>studentloan</code></li></ul><h2 id="名字的作用域"><a class="anchor" href="#名字的作用域">#</a> 名字的作用域</h2><p>不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体</p><p>作用域（scope），可简单理解为 名字的有效区域</p><ul><li><p>C++ 语言中大多数作用域都以花括号分隔</p></li><li><p>同一个名字在不同的作用域中可能指向不同的实体</p></li><li><p>名字的有效区域始于名字的声明语句，止于声明语句所在的作用域末端</p></li></ul><blockquote><p>A scope is a part of the program in which a name has a particular meaning.</p></blockquote><p>例如：</p><pre><code class="language-cpp">#include &lt;iostream&gt;int main() &#123;    int sum = 0;    // sum values from 1 through 10 inclusive    for (int val = 1; val &lt;= 10; ++val)        sum += val;  // equivalent to sum = sum + val    std::cout &lt;&lt; &quot;Sum of 1 to 10 inclusive is &quot;              &lt;&lt; sum &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>上例中， <code>main</code>  定义于所有花括号之外，具有 <strong>全局作用域</strong>（global scope），在整个程序的范围内都可使用； <code>sum</code>  定义于  <code>main</code>  函数所限定的作用域内，在  <code>main</code>  函数作用域内任意位置都可以访问，但无法在  <code>main</code>  函数之外访问，即，具有 <strong>块作用域</strong>（block scope）</p><blockquote><p>一般来说，在对象第一次被使用的地方附近定义它是一种好的选择</p></blockquote><p>作用域可以彼此包含，被包含（或者说被嵌套）的作用域称为 <strong>内层作用域</strong>（inner scope），如上例中  <code>val</code>  的作用域；包含着别的作用域的作用域称为 <strong>外层作用域</strong>（outer scope），如上例中  <code>sum</code>  的作用域</p><p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。但与此同时，允许在内层作用域中重新定义外层作用域已有的名字：</p><pre><code class="language-cpp">#include &lt;iostream&gt;// Program for illustration purposes only: It is bad style for a function// to use a global variable and also define a local variable with the same nameint reused = 42;  // reused has global scopeint main()&#123;    int unique = 0; // unique has block scope    // output #1: uses global reused; prints 42 0    std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;    int reused = 0; // new, local object named reused hides global reused    // output #2: uses local reused; prints 0 0    std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;    // output #3: explicitly requests the global reused; prints 42 0    std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;    return 0;&#125;</code></pre><p><strong>如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量</strong></p><h1 id="复合类型"><a class="anchor" href="#复合类型">#</a> 复合类型</h1><p>复合类型（compound type）是指基于基本数据类型定义的类型</p><p>这里将介绍两种复合类型：<strong>引用</strong> 和 <strong>指针</strong></p><h2 id="引用"><a class="anchor" href="#引用">#</a> 引用</h2><blockquote><p>这里的 “引用（reference）” ，指的其实是 “左值引用（lvalue reference）”</p></blockquote><p>引用（reference）为对象起了另外一个名字，即，别名</p><p>通过将声明符写成  <code>&amp;d</code>  的形式来定义引用类型，其中  <code>d</code>  是声明的变量名</p><p>如下所示， <code>refVal</code>  是  <code>ival</code>  的一个引用</p><pre><code class="language-cpp">int ival = 1024;int &amp;refVal = ival; // refVal 指向 ival（是 ival 的另一个名字）int &amp;refVal2;       // 报错：引用必须被初始化</code></pre><p>定义引用时，程序把 引用 和 它的初始值 绑定（bind）在一起，而不是将初始值拷贝给引用</p><ul><li>一旦初始化完成，<strong>引用 将和 它的初始值对象 一直绑定在一起</strong></li><li>注意，无法将引用重新绑定到另外一个对象，因此，<strong>引用必须初始化</strong></li></ul><h3 id="引用即别名"><a class="anchor" href="#引用即别名">#</a> 引用即别名</h3><p>引用并不是对象，它只是为一个已经存在的对象额外起一个名字</p><p>对 引用 进行的所有操作都是在与之绑定的对象上进行的：</p><ul><li>为 引用 赋值，实际上是把值赋给了 引用所绑定的对象</li><li>获取 引用 的值，实际上是获取 引用所绑定的对象 的值</li><li>以 引用 作为初始值，实际上是以 引用所绑定的对象 作为初始值</li></ul><p>例如：</p><pre><code class="language-cpp">refVal = 2;               // 把2赋给refVal指向的对象，即，赋给ivalint ii = refVal;          // 与ii = ival执行结果一样int &amp;refVal3 = refVal;    // 正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上int i = refVal;           // 正确：i被初始化为ival的值</code></pre><p><strong>引用本身不是一个对象，所以不能定义引用的引用</strong></p><h3 id="引用的定义"><a class="anchor" href="#引用的定义">#</a> 引用的定义</h3><p>允许在一条语句中定义多个引用，其中，每个引用标识符都必须以符号  <code>&amp;</code>  开头，例如：</p><pre><code class="language-cpp">int i =1024, i2 = 2048; // i 和 i2 都是 intint &amp;r = i, r2 = i2;    // r 是 i 的引用，r2 是 int 型对象int i3 = 1024, &amp;ri = i3;// i3 是 int 型对象，ri 是 i3 的引用int &amp;r3 = i3, &amp;r4 = i2; // r3 和 r4 都是引用</code></pre><p>除了两种例外情况，其他所有 引用的类型 都要严格匹配于 与之绑定的对象</p><p>并且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</p><pre><code class="language-cpp">int &amp;refVal4 = 10;      // 错误：引用类型的初始值必须是一个对象，而不能是字面值double dval = 3.14;int &amp;refVal5 = dval;    // 错误：此处引用类型的初始值必须是 int 型对象</code></pre><h2 id="指针"><a class="anchor" href="#指针">#</a> 指针</h2><p>指针（pointer）是 “指向（point to）” 另外一种类型的复合类型</p><p>与引用类似，指针也可实现对其他对象的间接访问</p><p>与引用不同的是：</p><ol><li>指针本身是一个对象，允许对指针赋值和拷贝</li><li>指针可以先后指向不同的对象</li><li>指针无须在定义时赋初值</li></ol><blockquote><p>如果在块作用域内定义一个指针，但没有初始化指针，指针将拥有一个不确定的值</p></blockquote><p>通过将声明符写成  <code>*d</code>  的形式来定义指针，其中  <code>d</code>  是变量名</p><p>如果在一条语句中定义多个指针变量，每个变量前面都必须有符号  <code>*</code>  ，例如：</p><pre><code class="language-cpp">int *ip1, *ip2;  // ip1 和 ip2 都是指向 int 型对象的指针double dp, *dp2; // dp2 是指向 double 型对象的指针，dp 是 double 型对象</code></pre><h3 id="获取对象的地址"><a class="anchor" href="#获取对象的地址">#</a> 获取对象的地址</h3><p>指针存放的是某个对象的地址</p><p>要获取某对象的地址，需使用 <strong>取地址符（  <code>&amp;</code>  操作符）</strong></p><pre><code class="language-cpp">int ival = 42;int *p = &amp;ival; // p 存放变量 ival 的地址，或者说，p 是指向变量 ival 的指针                // 把 p 定义为一个指向 int 的指针，随后初始化 p 令其指向名为 ival 的 int 对象</code></pre><p>引用不是对象，没有实际地址，因此，<strong>不能定义指向引用的指针</strong></p><p>除两种特殊情况外，其他所有 指针的类型 都要和 它所指向的对象 严格匹配，例如：</p><pre><code class="language-cpp">double dval;double *pd = &amp;dval;     // 正确：初始值是 double 型对象的地址double *pd2 = pd;       // 正确：初始值是 double 对象的指针int *pi = pd;           // 错误：指针 pi 的类型和 pd 的类型不匹配pi = &amp;dval;             // 错误：试图把 double 型对象的地址赋给 int 型指针</code></pre><p>实际上，<strong>在声明语句中，指针的类型 用于确定 指针所指对象的类型</strong> 。因此，二者必须匹配</p><h3 id="指针值"><a class="anchor" href="#指针值">#</a> 指针值</h3><p>指针的值（即地址），应属下列 4 种状态之一：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，即，指针没有指向任何对象</li><li>无效指针，即，上述情况之外的其他值</li></ol><p>拷贝 / 访问无效指针的值将会引发错误</p><h3 id="利用指针访问对象"><a class="anchor" href="#利用指针访问对象">#</a> 利用指针访问对象</h3><p>如果指针指向了一个对象，则允许使用 <strong>解引用符（  <code>*</code>  操作符）</strong>，来访问该对象</p><pre><code class="language-cpp">int ival = 42;int *p = &amp;ival; // p 是指向变量 ival 的指针cout &lt;&lt; *p;     // 解引用，访问指针所指对象，输出 42</code></pre><p>对指针解引用可以得到指针所指的对象</p><p>因此，给解引用所得结果赋值，也就是给指针所指对象赋值</p><pre><code class="language-cpp">*p = 0;     // 经由指针 p 为 p 所指对象（即，ival）赋值cout &lt;&lt; *p; // 输出 0</code></pre><p><strong>解引用操作仅适用于那些确实指向了某个对象的有效指针</strong></p><h3 id="空指针"><a class="anchor" href="#空指针">#</a> 空指针</h3><p>空指针（null pointer）不指向任何对象</p><p>生成空指针的方法：</p><pre><code>int *p1 = nullptr;int *p2 = 0;int *p3 = NULL;     // 需要首先 #include cstdlib</code></pre><p>获得空指针最直接的办法：用字面值  <code>nullptr</code>  来初始化指针</p><ul><li><code>nullptr</code>  是一种特殊类型的字面值，它可以被转换成任意其他的指针类型</li><li>C++ 程序中，<strong>建议使用  <code>nullptr</code>  ，而尽量避免使用  <code>NULL</code> </strong></li></ul><p><strong>把  <code>int</code>  变量直接赋给指针是错误的操作，即使  <code>int</code>  变量的值恰好等于 0 也不行</strong></p><pre><code class="language-cpp">int zero = 0;pi = zero;      // 错误：不能把 int 变量直接赋给指针</code></pre><p>尽管 C++ 语法上规定 “指针无须在定义时初始化”，但是，使用未经初始化的指针很可能会在运行时引发错误</p><p>因此，建议初始化所有的指针，并且，尽量在定义对象之后才定义指向它的指针。如果确实不清楚指针应该指向何处，可以把它初始化为  <code>nullptr</code>  或者  <code>0</code></p><h3 id="赋值和指针"><a class="anchor" href="#赋值和指针">#</a> 赋值和指针</h3><p>指针和引用都能实现对其他对象的间接访问</p><ul><li>引用本身不是一个对象。一旦定义了引用，就无法再将其绑定到另外的对象，以后每次使用这个引用都是访问它最初绑定的那个对象</li><li>指针可以指向新的对象：给指针赋值就是令它存放一个新的地址，从而指向一个新的对象</li></ul><pre><code class="language-cpp">pi = &amp;ival; // pi 的值被改变，现在 pi 指向了 ival*pi = 0;    // ival 的值被改变，指针 pi 并没有改变</code></pre><h3 id="其他指针操作"><a class="anchor" href="#其他指针操作">#</a> 其他指针操作</h3><p>判断  <code>true</code>  和  <code>false</code> ：</p><ul><li>如果指针的值是  <code>0</code>  ，即，空指针，对应的条件值取  <code>false</code></li><li>如果指针非空，对应的条件值是  <code>true</code></li></ul><p>对于两个类型相同的合法指针，可以用相等操作符（  <code>==</code>  ）和不相等操作符（  <code>!=</code>  ）来比较它们，其结果为布尔类型的值</p><ul><li>如果两个指针所存放的地址值相同，则它们相等</li><li>反之，它们不相等</li></ul><p>两个指针相等，对应有三种可能：</p><ul><li>两个指针都为空</li><li>两个指针指向同一个对象</li><li>两个指针都指向了同一个对象的下一地址</li></ul><blockquote><p>需要注意的是，一个指针指向某对象，同时，另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等</p></blockquote><h3 id="void-指针"><a class="anchor" href="#void-指针">#</a> void * 指针</h3><p><code>void *</code>  是一种特殊的指针类型，可用于存放任意对象的地址</p><p>但是，我们无法直接确定该地址中到底是个什么类型的对象</p><pre><code class="language-cpp">double obj = 3.14, *pd = &amp;obj;void *pv = &amp;obj;    // 正确：void * 能存放任意类型对象的地址pv = pd;            // 正确</code></pre><p><code>void *</code>  指针的作用：</p><ul><li>与别的指针比较</li><li>作为函数的输入或输出</li><li>赋给另外一个  <code>void *</code>  指针</li></ul><p>注意，我们并不知道这个对象到底是什么类型，所以，不能直接操作  <code>void *</code>  指针所指的对象（因为无法确定能在这个对象上做哪些操作）</p><blockquote><p>给定指针  <code>p</code>  ，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，说明原因</p><ul><li>如果在定义  <code>p</code>  时曾用  <code>nullptr</code>  或者  <code>0</code>  初始化  <code>p</code>  ，判断  <code>p</code>  是否指向合法的对象，只需把  <code>p</code>  作为  <code>if</code>  语句的条件即可，如果  <code>p</code>  的值是  <code>nullptr</code>  ，则条件为假；反之，条件为真</li><li>如果没有注意  <code>p</code>  的初始化，可把  <code>if(p)</code>  置于  <code>try</code>  结构中，当程序块顺利执行时，表示  <code>p</code>  指向了合法的对象；当程序块出错跳转到  <code>catch</code>  语句时，表示  <code>p</code>  没有指向合法的对象</li></ul></blockquote><h2 id="复合类型的声明"><a class="anchor" href="#复合类型的声明">#</a> 复合类型的声明</h2><p>变量的定义包括：一个 <strong>基本数据类型</strong>（base type）、一组 <strong>声明符</strong>（declarator）</p><p>在同一条定义语句中，基本数据类型只能有一个，但声明符的形式却可以有好几种，即，一条定义语句可能定义出不同类型的变量，例如：</p><pre><code class="language-cpp">int i = 1024, *p = &amp;i, &amp;r = i;  // i 是一个 int 型对象                                // p 是一个指向 int 型对象的指针                                // r 是一个 int 对象的引用</code></pre><p>上例中， <code>int</code>  是基本数据类型， <code>*</code>  和  <code>&amp;</code>  是类型修饰符</p><p>类型修饰符与变量名共同组成声明符</p><h3 id="定义多个变量"><a class="anchor" href="#定义多个变量">#</a> 定义多个变量</h3><p>在定义语句中，<strong>类型修饰符（  <code>*</code>  和  <code>&amp;</code>  ）仅作用于紧随其后的单个变量</strong>，而不是作用于本次定义的全部变量</p><p>涉及指针或引用的声明，一般有两种写法:</p><ol><li><p>把类型修饰符和变量标识符写在一起，这种形式强调了变量所具有的复合类型</p><pre><code class="language-cpp">int *p1, *p2;   //p1和p2都是指向int型对象的指针</code></pre></li><li><p>把修饰符和类型名写在一起，并且每条语句只定义一个变量，这种形式强调本次声明定义了一种复合类型</p><pre><code class="language-cpp">int* p1;    //p1是指向int型对象的指针int* p2;    //p2是指向int型对象的指针</code></pre></li></ol><p>推荐采用第一种写法，即，<strong>将  <code>*</code> （或是  <code>&amp;</code>  ）与变量名连在一起</strong></p><h3 id="指向指针的指针"><a class="anchor" href="#指向指针的指针">#</a> 指向指针的指针</h3><p>指针是内存中的对象，有自己的地址，因此，允许把指针的地址再存放到另一个指针当中</p><p>通过  <code>*</code>  的个数可以区分指针的级别</p><ul><li><code>**</code>  表示指向指针的指针</li><li><code>***</code>  表示指向指针的指针的指针</li><li>以此类推</li></ul><p>例如：</p><pre><code class="language-cpp">int ival = 1024;int *pi = &amp;ival;    // pi 指向一个 int 型的数int **ppi = &amp;pi;    // ppi 指向一个 int 型的指针</code></pre><p>下图描述了它们之间的关系:</p><p><img data-src="/posts/38333d94/2.png" class=""></p><p>解引用  <code>int</code>  型指针会得到一个  <code>int</code>  型的数，类似地，解引用指向指针的指针会得到一个指针</p><p>对于指针的指针而言，如果想要访问最原始的那个对象，需要对指针的指针做两次解引用，例如：</p><pre><code class="language-cpp">cout &lt;&lt; ival;   // direct valuecout &lt;&lt; *pi;    // indirect valuecout &lt;&lt; **ppi;  // doubly indirect value</code></pre><h3 id="指向指针的引用"><a class="anchor" href="#指向指针的引用">#</a> 指向指针的引用</h3><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用</p><pre><code class="language-cpp">int i = 42;int *p;         // p 是一个指向 int 型对象的指针int *&amp;r = p;    // r 是一个对指针 p 的引用，即，r 是 p 的别名r = &amp;i;         // 给 r 赋值一个地址，相当于给 p 赋值一个地址，即，令 p 指向 i*r = 0;         // 给 r 的解引用（也就是 p 指向的对象）赋值，即，给 i 赋值 0</code></pre><p>想要理解变量  <code>r</code>  的类型，最简单的办法是从右向左阅读</p><ul><li>离变量名最近的符号对变量的类型有最直接的影响， <code>int *&amp;r = p;</code>  中的符号  <code>&amp;</code>  说明  <code>r</code>  是一个引用</li><li>声明符的其余部分用以确定  <code>r</code>  引用的类型，此例中的符号  <code>*</code>  说明  <code>r</code>  引用的是一个指针</li><li>最后，基本数据类型  <code>int</code>  指出，指针指向一个  <code>int</code>  型对象，即， <code>r</code>  引用的是一个  <code>int</code>  指针</li></ul><p><strong>对于一条比较复杂的指针或引用的声明语句，从右向左阅读有助于弄清楚它的真实含义</strong></p><h1 id="const-限定符"><a class="anchor" href="#const-限定符">#</a> const 限定符</h1><h2 id="const"><a class="anchor" href="#const">#</a> const</h2><p>关键字  <code>const</code>  可以限定变量的类型，使得变量成为常量</p><pre><code class="language-cpp">const int bufSize = 512;bufSize = 1024; // error: attempt to write to const object</code></pre><p><strong> <code>const</code>  对象一旦创建后，其值就不能再改变，因此， <code>const</code>  对象必须初始化</strong></p><p><code>const</code>  对象的初始值可以是任意复杂的表达式</p><pre><code class="language-cpp">const int i = get_size();  // ok: initialized at run timeconst int j = 42;          // ok: initialized at compile timeconst int k;               // error: k is uninitialized const</code></pre><h3 id="初始化-和-const"><a class="anchor" href="#初始化-和-const">#</a> 初始化 和 const</h3><p>只能对  <code>const</code>  对象执行不改变其内容的操作</p><p>例如， <code>const int</code>  和普通的  <code>int</code>  一样，都能参与算术运算，也都能转换成一个布尔值，等等</p><p>再例如，可以利用  <code>const</code>  对象去初始化另一个对象</p><pre><code class="language-cpp">int i = 42;const int ci = i;    // ok: the value in i is copied into ciint j = ci;          // ok: the value in ci is copied into j</code></pre><p><strong>默认情况下， <code>const</code>  对象仅在文件内有效</strong>，当多个文件中出现了同名的  <code>const</code>  变量时，相当于在不同文件中分别定义了独立的变量</p><p>如果想要只在一个文件中定义  <code>const</code>  ，而在其他多个文件中声明并使用它，解决方案为：对于  <code>const</code>  变量，不管是声明还是定义，都添加  <code>extern</code>  关键字</p><pre><code class="language-cpp">// file_1.cc defines and initializes a const that is accessible to other filesextern const int bufSize = fcn(); // definition// file_1.hextern const int bufSize; // declaration, same bufSize as defined in file_1.cc</code></pre><p>如上述程序所示， <code>file_1.cc</code>  定义并初始化了  <code>bufSize</code>  。因为这条语句包含了初始值，所以它是一次定义，然而，因为  <code>bufSize</code>  是一个常量，必须用  <code>extern</code>  加以限定使其被其他文件使用</p><p><code>file_1.h</code>  头文件中的声明也由  <code>extern</code>  做了限定，其作用是指明  <code>bufSize</code>  并非本文件所独有，它的定义将在别处出现</p><blockquote><p>任何包含了显式初始化的声明，就成为了定义</p></blockquote><p><strong>如果想在多个文件之间共享  <code>const</code>  对象，必须在变量的定义之前添加  <code>extern</code>  关键字</strong></p><h2 id="const-的引用"><a class="anchor" href="#const-的引用">#</a> const 的引用</h2><p>对常量的引用（reference to const）: 把引用绑定到  <code>const</code>  对象上</p><p>对常量的引用不能被用于修改它所绑定的对象，即，不能够通过该引用修改对象的值</p><p>但实际上，可以通过其他途径修改该对象的值</p><pre><code class="language-cpp">const int ci = 1024;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量                    // 不存在通过引用 r1 修改 ci 的风险，故而语法正确r1 = 42;int &amp;r2 = ci;       // 错误：试图让一个非常量引用指向一个常量对象                    // 存在通过 r2 修改 ci 的风险，故而语法错误</code></pre><p>术语：常量引用是对  <code>const</code>  的引用</p><ul><li>C++ 程序员们经常把词组 “对 const 的引用” 简称为 “常量引用”</li><li>严格来说，并不存在常量引用，因为引用不是一个对象</li></ul><p><strong>复合类型</strong> 中指出，引用的类型必须与其所引用对象的类型一致，但是有两个例外</p><ul><li><p>第一种例外情况：在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许将一个常量引用绑定到非常量的对象、字面值，甚至是一个一般表达式</p><pre><code class="language-cpp">int i = 42;const int &amp;r1 = i;      // 允许将 const int &amp; 绑定到一个普通 int 对象上。仅仅是说，不能通过 r1 修改 i 的值const int &amp;r2 = 42;     // 正确：r2 是一个对 const 的引用。不存在通过 r2 修改 42 的风险const int &amp;r3 = r1 * 2; // 正确：r3 是一个对 const 的引用。不存在通过 r3 修改 r1 * 2 的风险int &amp;r4 = r1 * 2;       // 错误：r4 是一个普通的非常量引用。存在通过 r4 修改 r1 * 2 的风险</code></pre></li></ul><p>可以这样理解这一例外情形：将一个  <code>const</code>  引用与一个非常量对象绑定，仅仅是限制了 “不能通过该 const 引用修改对象的值” ，因此，不存在通过 const 引用修改对象值的风险，语法正确</p><p>对 const 的引用可能引用一个并非 const 的对象</p><p>必须认识到，<strong>常量引用仅限定了引用可参与的操作，并未限定引用所指对象本身是否为常量</strong></p><p>常量引用的对象也可能是个非常量，所以允许通过其他途径改变它的值</p><pre><code class="language-cpp">int i = 42;int &amp;r1 = i;        // 引用r1绑定对象iconst int &amp;r2 = i;  // 常量引用 r2 绑定对象 i ，不允许通过 r2 修改 i 的值r1 = 0;             // r1 并非常量引用，可以通过 r1 修改 i 的值r2 = 0;             // 错误：r2 是常量引用，不允许通过 r2 修改 i 的值i = 36;             // i 不是常量，可以直接为 i 赋值</code></pre><p>上例中， <code>r2</code>  是  <code>i</code>  的常量引用，但  <code>r1</code>  不是  <code>i</code>  的常量引用，因此，可以通过  <code>r1</code>  修改  <code>i</code>  的值，并且， <code>i</code>  本身不是常量，可以直接为  <code>i</code>  赋新值</p><h2 id="指针-与-const"><a class="anchor" href="#指针-与-const">#</a> 指针 与 const</h2><h3 id="指向常量的指针"><a class="anchor" href="#指向常量的指针">#</a> 指向常量的指针</h3><p>与引用一样，也可以令指针指向常量或非常量</p><p>指向常量的指针（pointer to const）：不能用于改变其所指对象的值</p><p>如何定义一个指向常量的指针：</p><ul><li><code>*</code>  放在变量名之前</li><li>基本数据类型放在  <code>*</code>  之前</li><li><code>const</code>  放在基本数据类型之前</li></ul><p>例如：</p><pre><code class="language-cpp">const double *cptr = &amp;pi;</code></pre><p><strong>要想存放常量对象的地址，只能使用指向常量的指针</strong></p><p>即，限定了 “不能通过该指针修改常量对象的值”</p><pre><code class="language-cpp">const double pi = 3.14;     // pi 是一个常量double *ptr = &amp;pi;          // 错误：ptr 是一个普通指针。存在通过解引用 *ptr 修改 pi 的值的风险，故语法错误const double *cptr = &amp;pi;   // 正确: cptr 是一个指向常量的指针。不存在通过 *cptr 修改 pi 的值的风险，故语法正确*cptr = 42;                 // 错误：cptr 是指向常量的指针，不能给 *cptr 赋值</code></pre><p><strong>复合类型</strong> 中指出，指针的类型必须与其所指对象的类型一致，但是有两个例外：</p><ul><li><p>第一种例外情况：允许让一个指向常量的指针指向一个非常量的对象</p><pre><code class="language-cpp">double dval = 3.14;     // dval是一个双精度浮点数，它的值可以改变cptr = &amp;dval;           // 正确，但是不能通过 cptr 修改 dval 的值</code></pre></li></ul><p>可以这样理解这一例外情形：将一个常量指针指向一个非常量的对象，仅仅是限制了 “不能通过该指针修改对象的值” ，因此，不存在通过常量指针修改对象值的风险，语法正确</p><p>和常量引用一样，<strong>指向常量的指针也没有规定其所指的对象必须是一个常量。指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变</strong></p><blockquote><p>试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用 “自以为是” 罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值</p></blockquote><h3 id="const-指针常量指针"><a class="anchor" href="#const-指针常量指针">#</a> const 指针（常量指针）</h3><p>指针是对象，因此，允许把指针本身定为常量，即，常量指针（const 指针）</p><p>常量指针（const pointer）必须初始化，并且，一旦初始化完成，它的值（即，存放在指针中的那个地址）就不能再改变</p><p>换而言之，一旦常量指针初始化完成，就不能再令其指向新的对象</p><p>如何定义一个常量指针：</p><ul><li><code>const</code>  放在变量名之前</li><li><code>*</code>  放在  <code>const</code>  之前</li><li>基本数据类型放在  <code>*</code>  之前</li></ul><p>例如：</p><pre><code class="language-cpp">int *const curErr = &amp;errNum;</code></pre><p>其中，把  <code>*</code>  放在  <code>const</code>  关键字之前，用以说明指针是一个常量，这样的书写形式隐含着一层意味，即，不变的是指针本身的值，而非指向的那个值</p><pre><code class="language-cpp">int errNum = 0;int *const curErr = &amp;errNum;    // curErr 将一直指向 errNumconst double pi = 3.14;const double *const pip = &amp;pi;  // pi 是一个指向常量的常量指针</code></pre><blockquote><p>要想弄清楚这些声明的含义，最行之有效的办法是从右向左阅读</p></blockquote><p>对  <code>int *const curErr = &amp;errNum;</code>  这一语句而言</p><ul><li>离  <code>curErr</code>  最近的符号是  <code>const</code>  ，意味着  <code>curErr</code>  本身是一个常量对象，对象的类型由声明符的其余部分确定</li><li>声明符中的下一个符号是  <code>*</code>  ，意思是  <code>curErr</code>  是一个常量指针</li><li>最后，基本数据类型  <code>int</code>  说明该常量指针指向的是一个 <code>int</code>  对象</li></ul><p>类似地，我们也能推断出， <code>pip</code>  是一个常量指针，它指向的对象是一个  <code>double</code>  型常量</p><p><strong>常量指针，只是说指针本身是一个常量，并不是说不能通过指针修改其所指对象的值</strong>，能否这样做完全依赖于所指对象的类型</p><p>在上述示例中</p><ul><li><code>pip</code>  是一个指向常量的常量指针，因此，不论是  <code>pip</code>  所指的对象值、还是  <code>pip</code>  自己存储的那个地址，都不能改变</li><li><code>curErr</code>  指向的是一个非常量的整数，因此，可以用  <code>curErr</code>  去修改  <code>errNum</code>  的值</li></ul><h2 id="顶层-const-与-底层-const"><a class="anchor" href="#顶层-const-与-底层-const">#</a> 顶层 const 与 底层 const</h2><p>指针本身是不是常量，以及指针所指的对象是不是一个常量，是两个相互独立的问题</p><p><strong>顶层 const</strong>（top-levelconst）：指针本身是一个常量</p><p><strong>底层 const</strong>（low-level const）：指针所指的对象是一个常量</p><p>更一般的说法：</p><ul><li>顶层 const 可以表示任意的对象是常量，并且，对任何数据类型的对象都适用，如算术类型、类、指针等</li><li>底层 const 则与指针和引用等复合类型的基本类型部分有关</li></ul><p>比较特殊的是，指针类型既可以是顶层 const ，也可以是底层 const ，即，指向常量的常量指针</p><pre><code class="language-cpp">int i = 0;int *const pi = &amp;i;         // 顶层 constconst int ci = 42;          // 顶层 constconst int *p2 = &amp;ci;        // 底层 constconst int *const p3 = p2;   // 底层 const，顶层 constconst int &amp;r = ci;          // 底层 const</code></pre><p>当执行对象的拷贝操作时，顶层 const 不受影响（执行拷贝操作并不会改变顶层 const 对象的值，因此，拷入和拷出的对象是否是常量都没什么影响）</p><pre><code class="language-cpp">i = ci;     // 正确：拷贝对象 ci 的值，顶层 const 对此操作无影响p2 = p3;    // 正确：p2 和 p3 指向的对象类型相同，p3 顶层 const 的部分不影响</code></pre><p>当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者，两个对象的数据类型必须能够转换（一般来说，非常量可以转换成常量，反之则不行）</p><pre><code class="language-cpp">int *p = p3;        // 错误：p3 包含底层 const 的定义，而 p 没有。存在通过 p 修改 p3 所指对象的值的风险，故语法错误p2 = p3;            // 正确：p2 和 p3 都是底层 const 。不存在通过 p2 修改 p3 所指对象的值的风险，故语法正确p2 = &amp;i;            // 正确：int * 能转换成 const int * 。p2 是一个指向常量的指针int &amp;r = ci;        // 错误：普通的 int &amp; 不能绑定 int 常量。存在通过引用 r 修改常量 ci 值的风险，故语法错误const int &amp;r2 = i;  // 正确：const int &amp; 可以跟一个普通 int 对象绑定。r2 是一个指向常量的指针</code></pre><h2 id="constexpr-和-常量表达式"><a class="anchor" href="#constexpr-和-常量表达式">#</a> constexpr 和 常量表达式</h2><p>常量表达式（const expression）是指值不会改变，并且在编译阶段就能得到计算结果的表达式</p><ul><li>字面值属于常量表达式</li><li>用常量表达式初始化的  <code>const</code>  对象也是常量表达式（编译器将在编译过程中把用常量表达式初始化的  <code>const</code>  对象替换成对应的值）</li></ul><p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如:</p><pre><code class="language-cpp">const int max_files = 20;           // 是常量表达式const int limit = max_files + 1;    // 是常量表达式int staff_size = 27;                // 不是常量表达式（值会改变）const int sz = get_size();          // 不是常量表达式（无法在编译阶段得到计算结果）</code></pre><h3 id="constexpr-变量"><a class="anchor" href="#constexpr-变量">#</a> constexpr 变量</h3><p>C++ 11 标准规定，允许将变量声明为  <code>constexpr</code>  类型，以便由编译器来验证变量的值是否是一个常量表达式</p><p>因此，声明为  <code>constexpr</code>  的量一定是一个常量，并且，必须用常量表达式来初始化</p><pre><code class="language-cpp">constexpr int mf = 20;          // 20 是常量表达式constexpr int limit = mf + 1;   // mf + 1 是常量表达式constexpr int sz = size();      // 只有当 size 是一个 constexpr 函数时才正确</code></pre><p>虽然不能使用普通函数作为  <code>constexpr</code>  变量的初始值，但是，C++ 11 标准允许定义一种特殊的  <code>constexpr</code>  函数。其中，函数应该足够简单，以使得编译时就可以计算其结果。于是，就能用  <code>constexpr</code>  函数去初始化  <code>constexpr</code>  变量了（详见 <strong>constexpr 函数</strong> ）</p><blockquote><p>Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions.</p></blockquote><h3 id="字面值类型"><a class="anchor" href="#字面值类型">#</a> 字面值类型</h3><p>常量表达式的值需要在编译时就得到计算，因此，对声明  <code>constexpr</code>  时用到的类型必须有所限制。由于这些类型一般比较简单，值也显而易见、容易得到，就把它们称为字面值类型（literal type）</p><p>算术类型、引用和指针都属于字面值类型</p><p>自定义类  <code>Sales_item</code>  、 IO 库、 <code>string</code>  类型不属于字面值类型，不能被定义成  <code>constexpr</code></p><p>尽管指针和引用都能定义成  <code>constexpr</code>  ，但它们的初始值却受到严格限制</p><ul><li>一个  <code>constexpr</code>  指针的初始值必须是  <code>nullptr</code>  或者  <code>0</code>  ，或者是存储于某个固定地址中的对象</li></ul><blockquote><ul><li>一般来说，定义在函数体内的变量并非存放在固定地址中，因此， <code>constexpr</code>  指针不能指向这样的变量</li><li>对于定义在所有函数体之外的对象，其地址固定不变，故而能用来初始化  <code>constexpr</code>  指针</li><li>此外，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样，也有固定地址</li></ul></blockquote><h3 id="指针-和-constexpr"><a class="anchor" href="#指针-和-constexpr">#</a> 指针 和 constexpr</h3><p>如果在  <code>constexpr</code>  声明中定义了一个指针，限定符  <code>constexpr</code>  仅对指针有效，与指针所指的对象无关</p><p>相当于一个常量指针，表示指针本身是常量，无法指向别的对象</p><pre><code class="language-cpp">const int *p = nullptr;         // 指向常量的指针int const *q1 = nullptr;        // 常量指针constexpr int *q2 = nullptr;    // 常量指针</code></pre><p>关键在于， <code>constexpr</code>  把它所定义的对象置为了顶层 const</p><p>与其他常量指针类似， <code>constexpr</code>  指针既可以指向常量也可以指向一个非常量</p><h1 id="处理类型"><a class="anchor" href="#处理类型">#</a> 处理类型</h1><h2 id="类型别名"><a class="anchor" href="#类型别名">#</a> 类型别名</h2><p>类型别名（type alias）：某种类型的同义词</p><p>有两种方法可用于定义类型别名:</p><ol><li><p>使用关键字 <code>typedef</code> ：</p><pre><code class="language-cpp">typedef double wages;   // wages是double的同义词typedef wages base, *p; // base是double的同义词, p是double*的同义词</code></pre><p>其中，关键字 <code>typedef</code>  作为声明语句中的基本数据类型的一部分出现</p><p>含有 <code>typedef</code>  的声明语句，其定义的不再是变量，而是类型别名</p><p>这里的声明符可以包含类型修饰符，因此，可以由基本数据类型构造出复合类型</p></li><li><p>使用别名声明（aliasdeclaration）：</p><pre><code class="language-cpp">using SI = Sales_item;  // SI是Sales_item的同义词</code></pre><p>用关键字 <code>using</code>  作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定为等号右侧类型的别名</p></li></ol><p>类型别名和类型的名字等价，只要是能使用类型名字的地方，就能使用类型别名</p><pre><code class="language-cpp">wages hourly, weekly;    // 等效于double hourly, weekly;SI item;                 // 等效于Sales_item item</code></pre><h3 id="指针-常量和类型别名"><a class="anchor" href="#指针-常量和类型别名">#</a> 指针、常量和类型别名</h3><p>如果某个类型别名指代的是复合类型或常量，对于使用类型别名来定义变量的声明语句而言，<strong>不能简单地用原复合类型来代替类型别名</strong></p><p>例如，以下声明语句用到了类型 <code>pstring</code> ，它实际上是类型 <code>char *</code>  的别名</p><pre><code class="language-cpp">typedef char *pstring;const pstring cstr = 0; // cstr是一个指向char对象的常量指针，相当于char *const cstr = 0const pstring *ps;      // ps是一个指针，它的对象是一个指向char的常量指针                        // 因为const pstring是一个指向char的常量指针类型</code></pre><p>上述两条声明语句的基本数据类型都是 <code>const pstring</code> ，其中</p><ul><li><code>const</code>  是对  <code>pstring</code>  类型的修饰，用以说明  <code>pstring</code>  类型的变量  <code>cstr</code>  是常量</li><li><code>pstring</code>  是类型 <code>char *</code>  的别名，即，指向 <code>char</code>  的指针</li></ul><p>因此， <code>const pstring</code>  是指向 <code>char</code>  的常量指针，而非指向常量字符的指针（若直接用  <code>char *</code>  替换掉  <code>pstring</code>  ，会把  <code>cstr</code>  误解成一个指向常量的指针）</p><pre><code class="language-cpp">const pstring cstr = 0;   // cstr是指向char的常量指针const char *cstr = 0;     // 对const pstring cstr的错误理解，将cstr错当成一个指向char常量的指针</code></pre><h2 id="auto-类型说明符"><a class="anchor" href="#auto-类型说明符">#</a> auto 类型说明符</h2><p>C++11 新标准引入了 <code>auto</code>  类型说明符</p><p><code>auto</code>  类型说明符：让编译器通过初始值来推算变量的类型</p><p><strong> <code>auto</code>  定义的变量必须有初始值</strong></p><pre><code class="language-cpp">//根据val1和val2相加的结果来推断item的类型auto item = val1 + val2;</code></pre><p>使用 <code>auto</code>  时，可以在一条语句中声明多个变量。但是需要注意，使用 <code>auto</code>  的声明语句只能有一个基本数据类型，即，该语句中所有变量初始值的基本数据类型必须一样</p><pre><code class="language-cpp">auto i = 0, *p = &amp;i;      // ok: i是一个int型变量，p是一个指向int型对象的指针auto sz = 0, pi = 3.14;   // error: sz和pi的类型不一致，根据sz会推导为int型，但pi会推断为float/double型</code></pre><h3 id="复合类型-常量-和-auto"><a class="anchor" href="#复合类型-常量-和-auto">#</a> 复合类型、常量 和 auto</h3><p>编译器推断出来的 <code>auto</code>  类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则</p><ol><li><p>当引用被用作初始值时，真正参与初始化的其实是引用对象的值，编译器以引用对象的类型作为 <code>auto</code>  的类型</p><pre><code class="language-cpp">int i = 0, &amp;r = i;auto a = r;  // a是int型（r是int型对象i的引用）</code></pre></li><li><p><code>auto</code>  一般会忽略掉顶层 <code>const</code> ，而底层 <code>const</code>  则会保留下来</p><pre><code class="language-cpp">const int ci = i, &amp;cr = ci;auto b = ci;  // b是一个int型（顶层const被忽略）auto c = cr;  // c是一个int型auto d = &amp;i;  // d是一个指向int的指针auto e = &amp;ci; // e是一个指向int常量的指针（底层const被保留）</code></pre></li><li><p>如果希望推断出的 <code>auto</code>  类型是一个顶层 <code>const</code> ，需要在  <code>auto</code>  前添加  <code>const</code>  限定符以明确指出</p><pre><code class="language-cpp">const auto f = ci; // ci的类型是int，f是一个int常量（顶层const）</code></pre></li><li><p>可以将引用的类型设为 <code>auto</code> ，此时，引用的初始化规则仍然适用</p><pre><code class="language-cpp">auto &amp;g = ci;       // g is a const int&amp;. 因为ci是int常量，不允许存在通过g修改ci的风险，故而g是常量引用auto &amp;h = 42;       // error: 不能为非常量引用绑定字面值。字面值常量42的类型为int，故auto推断为int型，此时存在通过h修改42的风险，故而语法错误const auto &amp;j = 42; // ok: 可以为常量引用绑定字面值</code></pre><p>设置一个类型为 <code>auto</code>  的引用时，初始值中的顶层  <code>const</code>  属性仍然保留。即，不能通过引用修改所指对象的值</p></li><li><p>在一条语句中定义多个变量时，切记，符号 <code>&amp;</code>  和 <code>*</code>  只从属于某个声明符，而非基本数据类型的一部分。因此，初始值必须是同一种类型</p><pre><code class="language-cpp">auto k = ci, &amp;l = i;    // k是int型对象，l是int型对象i的引用auto &amp;m = ci, *p = &amp;ci; // m是一个int型常量引用，p是指向int常量的指针auto &amp;n = i, *p2 = &amp;ci; //error: 根据i推断的类型是int; 根据&amp;ci推断的类型是const int。（存在通过p2修改ci的风险）</code></pre></li></ol><h2 id="decltype-类型指示符"><a class="anchor" href="#decltype-类型指示符">#</a> decltype 类型指示符</h2><p>C++11 新标准引入了类型说明符 <code>decltype</code> ，它的作用是选择并返回操作数的数据类型</p><p>编译器分析表达式并得到它的类型，却不实际计算表达式的值</p><pre><code class="language-cpp">decltype(f()) sum = x;</code></pre><p>编译器并不实际调用函数 <code>f</code> ，而是使用 当调用发生时 <code>f</code>  的返回值类型 作为 <code>sum</code>  的类型</p><p>如果 <code>decltype</code>  使用的表达式是一个变量，则 <code>decltype</code>  返回该变量的类型（包括顶层 const 和引用在内）</p><pre><code class="language-cpp">const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x的类型是const intdecltype(cj) y = x; // y的类型是const int &amp;decltype(cj) z;     // error: z是一个引用，必须初始化</code></pre><blockquote><p>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在 <code>decltype</code>  处是一个例外：在 <code>decltype</code>  中，引用和引用所指对象是不同的数据类型，如上例， <code>ci</code>  是 <code>const int</code>  型，而 <code>cj</code>  是 <code>const int&amp;</code>  型</p></blockquote><h3 id="decltype-和-引用"><a class="anchor" href="#decltype-和-引用">#</a> decltype 和 引用</h3><p>如果 <code>decltype</code>  使用的表达式不是一个变量，则 <code>decltype</code>  返回表达式结果对应的类型</p><pre><code class="language-cpp">//decltype的结果可以是引用类型int i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b;  // ok: 加法的结果是int型，故而b是一个（未初始化）的int对象decltype(*p) c;     // error: c是int&amp;型，必须初始化</code></pre><p>因为 <code>r</code>  是一个引用，因此 <code>decltype(r)</code>  的结果是引用类型。如果想让结果类型是 <code>r</code>  所指对象的类型，可以把 <code>r</code>  作为表达式的一部分（例如， <code>r + 0</code>  ）</p><p>如果表达式执行的是解引用操作， <code>decltype</code>  将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此， <code>decltype(*p)</code>  的结果类型就是 <code>int&amp;</code> ，而非 <code>int</code></p><p>如果 <code>decltype</code>  使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器会把它当成是一个表达式，这样的  <code>decltype</code>  会得到引用类型</p><pre><code class="language-cpp">// decltype of a parenthesized variable is always a referencedecltype((i)) d;    // error: d 是 int &amp;，必须初始化decltype(i) e;      // ok: e 是一个（未被初始化的）int</code></pre><p>换而言之</p><ul><li><p>对于  <code>decltype((variable))</code> （注意是双层括号），结果类型永远是引用类型</p></li><li><p>对于  <code>decltype(variable)</code>  ，只有当 <code>variable</code>  本身就是一个引用时，结果类型才是引用类型</p></li></ul><h2 id="auto-和-decltype"><a class="anchor" href="#auto-和-decltype">#</a> auto 和 decltype</h2><p><code>auto</code>  和 <code>decltype</code>  的区别：</p><ol><li><p><code>auto</code>  类型说明符用编译器计算变量的初始值来推断其类型，而 <code>decltype</code>  虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值</p></li><li><p>编译器推断出来的 <code>auto</code>  类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如， <code>auto</code>  一般会忽略掉顶层 <code>const</code> ，而把底层 <code>const</code>  保留下来。与之相反， <code>decltype</code>  会保留变量的顶层 <code>const</code></p></li><li><p>与 <code>auto</code>  不同， <code>decltype</code>  的结果类型与表达式形式密切相关：如果 <code>decltype</code>  使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型</p></li></ol><h1 id="自定义数据结构"><a class="anchor" href="#自定义数据结构">#</a> 自定义数据结构</h1><p>数据结构是 把一组相关的数据元素组织起来然后使用它们 的策略和方法</p><p>C++ 语言允许用户以类的形式自定义数据类型，而库类型 <code>string</code> 、 <code>istream</code> 、 <code>ostream</code>  等也都是以类的形式定义的</p><h2 id="定义-sales_data-类型"><a class="anchor" href="#定义-sales_data-类型">#</a> 定义 Sales_data 类型</h2><pre><code class="language-cpp">struct Sales_data&#123;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;&#125;;</code></pre><p>这里的类以 <strong>关键字 <code>struct</code> </strong> 开始，紧跟着类名和类体（其中类体部分可以为空）</p><ul><li>类体由花括号包围形成了一个新的作用域</li><li>类内部定义的名字必须唯一，但是可以与类外部定义的名字重复</li></ul><p><strong>类体右侧的表示结束的花括号后必须写一个分号</strong>，这是因为类体后面可以紧跟变量名以示对该类型对象的定义</p><pre><code class="language-cpp">struct Sales_data &#123; /* ... */ &#125; accum, trans, *salesptr; // equivalent, but better way to define these objectsstruct Sales_data &#123; /* ... */ &#125;;Sales_data accum, trans, *salesptr;</code></pre><p>一般来说，最好不要把对象的定义和类的定义放在一起</p><p>也可以使用 C++ 语言提供的另外一个 <strong>关键字  <code>class</code> </strong> 来定义数据结构</p><p>类的定义可以与 <code>main</code>  函数放在同一个文件内。但是，我们通常在头文件中定义类，并且类所在头文件的名字应与类的名字一样</p><p>例如，库类型  <code>string</code>  在名为  <code>string</code>  的头文件中定义。又如，我们应该把  <code>Sales_data</code>  类定义在名为  <code>Sales_data.h</code>  的头文件中</p><h2 id="类数据成员"><a class="anchor" href="#类数据成员">#</a> 类数据成员</h2><p>类体定义类的成员，我们在上述例子中定义的类只有数据成员（datamember）</p><p>类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他  <code>Sales_data</code>  的对象</p><p>定义数据成员的方法：</p><ul><li>首先说明一个基本类型</li><li>随后紧跟一个或多个声明符</li></ul><p>C++ 11 标准规定，可以为数据成员提供一个类内初始值（in-class initializer）</p><ul><li>创建对象时，类内初始值将用于初始化数据成员</li><li>没有初始值的成员将被默认初始化</li></ul><p>对类内初始值的限制：要么放在花括号里，要么放在等号右边，而不能使用圆括号</p><h2 id="使用-sales_data-类"><a class="anchor" href="#使用-sales_data-类">#</a> 使用 Sales_data 类</h2><p><span class="exturl" data-url="aHR0cHM6Ly93ZXJlYWQucXEuY29tL3dlYi9yZWFkZXIvZmY3MzJmZTA3MjAyMWEyNGZmN2JiMjRrMWZmMzI1ZjAyMTgxZmYxZGU3NzQyZmM=">详见：自己动手实现对于 Sales_data 类的操作</span></p><p>关键在于，使用点操作符（  <code>.</code>  ）读入对象的成员，如</p><pre><code class="language-cpp">Sales_data data1;                               // data1为Sales_data类型的对象std::cin &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold;   // 写入对象data1的bookNo成员和units_sold成员</code></pre><h2 id="编写自己的头文件"><a class="anchor" href="#编写自己的头文件">#</a> 编写自己的头文件</h2><p><strong>类通常被定义在头文件中，并且，类所在头文件的名字应与类的名字一样</strong></p><p><strong>头文件通常包含那些只能被定义一次的实体</strong>，如：类、 <code>const</code>  和  <code>constexpr</code>  变量等</p><p>头文件也经常用到其他头文件的功能。因此，有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地工作</p><blockquote><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明</p></blockquote><h3 id="预处理器概述"><a class="anchor" href="#预处理器概述">#</a> 预处理器概述</h3><p>确保头文件多次包含时仍能安全工作的常用技术是 <strong>预处理器</strong>（preprocessor）</p><p>预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能  <code>#include</code>  ，当预处理器看到  <code>#include</code>  标记时就会用指定的头文件的内容代替  <code>#include</code></p><p>C++ 程序还会用到的一项预处理功能是 <strong>头文件保护符</strong>（headerguard），头文件保护符依赖于预处理变量</p><ul><li>预处理变量有两种状态：已定义和未定义</li><li><code>#define</code>  指令把一个名字设定为预处理变量</li><li><code>#ifdef</code>  和  <code>#ifdef</code>  两个指令分别检查某个指定的预处理变量是否已经定义<ul><li><code>#ifdef</code>  指令：当且仅当变量已定义时为真</li><li><code>#ifndef</code>  指令：当且仅当变量未定义时为真</li></ul></li><li>一旦检查结果为真，则执行后续操作直至遇到  <code>#endif</code>  指令为止</li></ul><p>使用这些功能就能有效地防止重复包含的发生</p><p>例如：</p><pre><code class="language-cpp">#ifndef SALES_DATA_H    // SALES_DATA_H即为预处理变量，ifndef是if not defined的缩写。若未定义SALES_DATA_H，则执行后续操作，直到遇到#endif指令#define SALES_DATA_H#include &lt;string&gt;struct Sales_data &#123;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;&#125;;#endif</code></pre><p>第一次包含  <code>Sales_data.h</code>  时， <code>#ifndef</code>  的检查结果为真，预处理器将顺序执行后面的操作直至遇到  <code>#endif</code>  为止。此时，预处理变量  <code>SALES_DATA_H</code>  的值将变为已定义，而且  <code>Sales_data.h</code>  也会被拷贝到我们的程序中来。后面如果再一次包含  <code>Sales_data.h</code>  ，则  <code>#ifndef</code>  的检查结果将为假，编译器将忽略  <code>#ifndef</code>  到  <code>#endif</code>  之间的部分</p><blockquote><p>预处理变量无视 C++ 语言中关于作用域的规则</p></blockquote><p>整个程序中的预处理变量包括头文件保护符必须唯一，<strong>通常的做法是基于头文件中类的名字来构建保护符的名字</strong>，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，<strong>一般把预处理变量的名字全部大写</strong></p><blockquote><p>注意：头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要</p></blockquote><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><code>地址（address）</code>  ：是一个数字，根据它可以找到内存中的一个字节。</p><p><code>别名声明（alias declaration）</code>  ：为另外一种类型定义一个同义词：使用 “名字 = 类型” 的格式将名字作为该类型的同义词。</p><p><code>算术类型（arithmetic type）</code>  ：布尔值、字符、整数、浮点数等内置类型。</p><p><code>数组（array）</code>  ：是一种数据结构，存放着一组未命名的对象，可以通过索引来访问这些对象。</p><p><code>auto</code>  ：是一个类型说明符，通过变量的初始值来推断变量的类型。</p><p><code>基本类型（base type）</code>  ：是类型说明符，可用 <code>const</code>  修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符。</p><p><code>绑定（bind）</code>  ：令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。</p><p><code>字节（byte）</code>  ：内存中可寻址的最小单元，大多数机器的字节占 8 位。</p><p><code>类成员（class member）</code>  ：类的组成部分。</p><p><code>复合类型（compound type）</code>  ：是一种类型，它的定义以其他类型为基础。</p><p><code>const</code>  ：是一种类型修饰符，用于说明永不改变的对象。 <code>const</code>  对象一旦定义就无法再赋新值，所以必须初始化。</p><p><code>常量指针（const pointer）</code>  ：是一种指针，它的值永不改变。</p><p><code>常量引用（const reference）</code>  ：是一种习惯叫法，含义是指向常量的引用。</p><p><code>常量表达式（const expression）</code>  ：能在编译时计算并获取结果的表达式。</p><p><code>constexpr</code>  ：是一种函数，用于代表一条常量表达式。</p><p><code>转换（conversion）</code>  ：一种类型的值转变成另外一种类型值的过程。C++ 语言支持内置类型之间的转换。</p><p><code>数据成员（data member）</code>  ：组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。</p><p><code>声明（declaration）</code>  ：声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用。</p><p><code>声明符（declarator）</code>  ：是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。</p><p><code>decltype</code>  ：是一个类型说明符，从变量或表达式推断得到类型。</p><p><code>默认初始化（default initialization）</code>  ：当对象未被显式地赋予初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为 0；局部作用域的对象未被初始化即拥有未定义的值。</p><p><code>定义（definition）</code>  ：为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用。</p><p><code>转义序列（escape sequence）</code>  ：字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于 3 个八进制数字，或者字母 x 加上 1 个十六进制数。</p><p><code>全局作用域（global scope）</code>  ：位于其他所有作用域之外的作用域。</p><p><code>头文件保护符（header guard）</code>  ：使用预处理变量以防止头文件被某个文件重复包含。</p><p><code>标识符（identifier）</code>  ：组成名字的字符序列，标识符对大小写敏感。</p><p><code>类内初始值（in-class initializer）</code>  ：在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内。</p><p><code>在作用域内（in scope）</code>  ：名字在当前作用域内可见。</p><p><code>被初始化（initialized）</code>  ：变量在定义的同时被赋予初始值，变量一般都应该被初始化。</p><p><code>内层作用域（inner scope）</code>  ：嵌套在其他作用域之内的作用域。</p><p><code>整型（integral type）</code>  ：参见算术类型。</p><p><code>列表初始化（list initialization）</code>  ：利用花括号把一个或多个初始值放在一起的初始化形式。</p><p><code>字面值（literal）</code>  ：是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值。</p><p><code>局部作用域（local scope）</code>  ：是块作用域的习惯叫法。</p><p><code>底层const（low-level const）</code>  ：一个不属于顶层的 <code>const</code> ，类型如果由底层常量定义，则不能被忽略。</p><p><code>成员（member）</code>  ：类的组成部分。</p><p><code>不可打印字符（nonprintable character）</code>  ：不具有可见形式的字符，如控制符、退格、换行符等。</p><p><code>空指针（null pointer）</code>  ：值为 0 的指针，空指针合法但是不指向任何对象。</p><p><code>nullptr</code>  ：是表示空指针的字面值常量。</p><p><code>对象（object）</code>  ：是内存的一块区域，具有某种类型，变量是命名了的对象。</p><p><code>外层作用域（outer scope）</code>  ：嵌套着别的作用域的作用域。</p><p><code>指针（pointer）</code>  ：是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者 0。</p><p><code>指向常量的指针（pointer to const）</code>  ：是一个指针，存放着某个常量对象的地址。指向常量的指针不能用来改变它所指对象的值。</p><p><code>预处理器（preprocessor）</code>  ：在 C++ 编译过程中执行的一段程序。</p><p><code>预处理变量（preprocessor variable）</code>  ：由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。</p><p><code>引用（reference）</code>  ：是某个对象的别名。</p><p><code>对常量的引用（reference to const）</code>  ：是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。</p><p><code>作用域（scope）</code>  ：是程序的一部分，在其中某些名字有意义。</p><p>C++ 的作用域：全局、类、块</p><ul><li><p><code>全局（global）</code> —— 名字定义在所有其他作用域之外。</p></li><li><p><code>类（class）</code> —— 名字定义在类内部。命名空间（namespace）—— 名字定义在命名空间内部。</p></li><li><p><code>块（block）</code> —— 名字定义在块内部。名字从声明位置开始直至声明语句所在的作用域末端为止都是可用的。</p></li></ul><p><code>分离式编译（separate compilation）</code>  ：把程序分割为多个单独文件的能力。</p><p><code>带符号类型（signed）</code>  ：保存正数、负数或 0 的整型。</p><p><code>字符串（string）</code>  ：是一种库类型，表示可变长字符序列。</p><p><code>struct</code>  ：是一个关键字，用于定义类。</p><p><code>临时值（temporary）</code>  ：编译器在计算表达式结果时创建的无名对象。为某表达式创建了一个临时值，则此临时值将一直存在直到包含有该表达式的最大的表达式计算完成为止。</p><p><code>顶层const（top-level const）</code>  ：是一个 <code>const</code> ，规定某对象的值不能改变。</p><p><code>类型别名（type alias）</code>  ：是一个名字，是另外一个类型的同义词，通过关键字 typedef 或别名声明语句来定义。</p><p><code>类型检查（type checking）</code>  ：是一个过程，编译器检查程序使用某给定类型对象的方式与该类型的定义是否一致。</p><p><code>类型说明符（type specifier）</code>  ：类型的名字。</p><p><code>typedef</code>  ：为某类型定义一个别名。当关键字 <code>typedef</code>  作为声明的基本类型出现时，声明中定义的名字就是类型名。</p><p><code>未定义（undefined）</code>  ：即 C++ 语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题。</p><p><code>未初始化（uninitialized）</code>  ：变量已定义但未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为。</p><p><code>无符号类型（unsigned）</code>  ：保存大于等于 0 的整型。</p><p><code>变量（variable）</code>  ：命名的对象或引用。C++ 语言要求变量要先声明后使用。</p><p><code>void*</code>  ：可以指向任意非常量的指针类型，不能执行解引用操作。</p><p><code>void类型</code>  ：是一种有特殊用处的类型，既无操作也无值。不能定义一个 <code>void</code>  类型的变量。</p><p><code>字（word）</code>  ：在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32 位机器上的字通常占据 4 个字节。</p><p><code>&amp;运算符（&amp;operator）</code>  ：取地址运算符。</p><p><code>*运算符（* operator）</code>  ：解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。</p><p><code>#define</code>  ：是一条预处理指令，用于定义一个预处理变量。</p><p><code>#endif</code>  ：是一条预处理指令，用于结束一个 <code>#ifdef</code>  或 <code>#ifndef</code>  区域。</p><p><code>#ifdef</code>  ：是一条预处理指令，用于判断给定的变量是否已经定义。</p><p><code>#ifndef</code>  ：是一条预处理指令，用于判断给定的变量是否尚未定义。</p><p>参考：C++ Primer 中文版（第 5 版）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识 C++</title>
      <link href="/posts/b5c83bc3/"/>
      <url>/posts/b5c83bc3/</url>
      
        <content type="html"><![CDATA[<p>每个 C++ 程序都包含一个或多个函数（function），其中一个必须命名为  <code>main</code></p><p>操作系统通过调用  <code>main</code>  来运行 C++ 程序</p><p>在多数系统中， <code>main</code>  函数的返回值用于指示状态：返回值 0 表示成功，非 0 返回值通常用来指出错误类型</p><p>当  <code>return</code>  语句包括一个返回值时，<strong>该返回值的类型必须与函数返回类型相容</strong>，如  <code>main</code>  函数的返回值 0 是  <code>int</code>  类型的值</p><h1 id="编译-运行程序"><a class="anchor" href="#编译-运行程序">#</a> 编译、运行程序</h1><p>源文件：后缀为  <code>.c</code>  、 <code>.cxx</code>  、 <code>.cpp</code>  、 <code>.cp</code>  、 <code>.c</code>  的程序文件</p><p>可执行文件：</p><ul><li>Windows 系统： <code>.exe</code>  文件</li><li>UNIX 系统： <code>.out</code>  文件</li></ul><blockquote><p>windows 系统运行一个可执行文件时，需提供可执行文件的文件名，可以忽略其拓展名  <code>.exe</code>  ，而 UNIX 系统则需要使用完整的文件名（包含文件拓展名）</p></blockquote><p>运行 GUN 编译器的命令： <code>g++ -o prog1 prog1.cc</code></p><ul><li><code>-o prog1</code>  是编译器参数，指定可执行文件的文件名</li><li>此命令生成名为  <code>prog1</code>  (UNIX) 或  <code>prog1.exe</code>  (windows) 的可执行文件</li><li>若省略  <code>-o prog1</code>  ，则生成  <code>a.out</code>  (UNIX) 或  <code>a.exe</code>  (windows) 可执行文件</li></ul><h1 id="输入与输出"><a class="anchor" href="#输入与输出">#</a> 输入与输出</h1><p>C++ 语言并未定义任何输入输出（IO）语句，取而代之，包含了一个全面的标准库（standard library）来提供 IO 机制（以及很多其他设施）</p><p>标准库  <code>iostream</code></p><ul><li>输入流  <code>istream</code></li><li>输出流  <code>ostream</code></li></ul><p>标准输入输出对象</p><ul><li><code>cin</code>  标准输入</li><li><code>cout</code>  标准输出</li><li><code>cerr</code>  输出警告与错误信息</li><li><code>clog</code>  输出程序运行时的一般性信息</li></ul><p><code>&lt;&lt;</code>  : 输出运算符，将给定值写到给定的  <code>ostream</code>  对象中，如:  <code>std::cout &lt;&lt; &quot;Enter two number&quot;;</code></p><p><code>&gt;&gt;</code>  : 输入运算符，从给定的  <code>istream</code>  读入数据，并存入给定对象中，如:  <code>std::cin &gt;&gt; v1;</code></p><p><code>endl</code>  : 操纵符，写入  <code>endl</code>  的效果是结束当前行，并将与设备关联的缓冲区 (buffer) 中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流 (stream)</p><p>流 (stream) ：一个流就相当于一个字符序列，是从 IO 设备读出或写入 IO 设备的。术语 “流” 想要表达的是，随着时间的推移，字符是顺序生成或消耗的</p><pre><code class="language-cpp">#include &lt;iostream&gt;int main() &#123;std::cout &lt;&lt; &quot;Enter two number&quot; &lt;&lt; std::endl;int v1 = 0, v2 = 0;std::cin &gt;&gt; v1 &gt;&gt; v2;std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;return 0;&#125;</code></pre><h1 id="include"><a class="anchor" href="#include">#</a> include</h1><p>程序使用标准库时，必须包含相关的头文件，如:  <code>#include &lt;iostream&gt;</code>  告诉编译器使用  <code>iostream</code>  库</p><p>尖括号  <code>&lt;&gt;</code>  内的名字即指出了一个头文件，如  <code>iostream</code>  、 <code>array</code>  、 <code>cmath</code>  、 <code>algorithm</code>  等</p><p><code>#include</code>  指令和头文件的名字必须写在同一行中，<strong>不用以分号结束</strong></p><p>通常情况下， <code>#include</code>  指令必须出现在所有函数之外</p><p>一般将一个程序的所有  <code>#include</code>  指令都放在源文件的开始位置</p><h1 id="命名空间"><a class="anchor" href="#命名空间">#</a> 命名空间</h1><p>命名空间 (namespace) 可以避免 名字定义冲突 以及 使用库中相同名字导致的冲突</p><p>标准库定义的所有名字都在命名空间  <code>std</code>  中</p><p>通过命名空间使用标准库有一个副作用：<strong>当使用标准库中的一个名字时，必须显式说明使用的是命名空间 <code>std</code>  中的名字</strong></p><p><code>::</code>  : 作用域操作符，如： <code>std::cin</code>  、 <code>std::cout</code>  、 <code>std::endl</code>  分别指明  <code>cin</code>  、 <code>cout</code>  、 <code>endl</code>  是命名空间  <code>std</code>  中的</p><p><code>using</code>  声明：一开始对  <code>cin</code>  、 <code>cout</code>  、 <code>endl</code>  使用  <code>using</code>  声明，以后无需再添加  <code>std::</code>  形式的前缀</p><blockquote><p>每行的  <code>using</code>  声明都要以分号结束</p></blockquote><p>例如：</p><pre><code class="language-cpp">#include &lt;iostream&gt;using std::cout;using std::cin;using std::endl;void main()&#123;cout &lt;&lt; &quot;Enter two number&quot; &lt;&lt; endl;int v1 = 0, v2 = 0;cin &gt;&gt; v1 &gt;&gt; v2;cout &lt;&lt; &quot;The product of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 * v2 &lt;&lt; endl;&#125;</code></pre><h1 id="注释"><a class="anchor" href="#注释">#</a> 注释</h1><p>单行注释:</p><ul><li>以双斜线  <code>//</code>  开始，以换行符结束</li><li>这种注释可以包含任何文本，包括额外的双斜线</li></ul><p>界定符对注释：</p><ul><li>以界定符  <code>/*</code>  开始，以界定符  <code>*/</code>  结束</li><li>可以包含除  <code>*/</code>  外的任意内容，包括换行符</li><li>界定符对注释可以跨越程序中的多行</li></ul><p>注释界定符可以放置于任何允许放置制表符、空格符或换行符的地方</p><p>当注释界定符跨越多行时，最好能显式地指出其内部的程序行都属于多行注释的一部分</p><blockquote><p>C++ Primer 所采用的风格是：注释内的每行都以一个星号开头，从而指出整个范围都是多行注释的一部分</p></blockquote><p>例如：</p><pre><code class="language-cpp"># include &lt;iostream&gt;/** 简单主函数* 读取两个数，求它们的和*/int main()&#123;// 提示用户输入两个数std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;int v1 = 0, v2 = 0;     // 保存用于读取输入数据的变量std::cin &gt;&gt; v1 &gt;&gt; v2;   // 读取输入数据std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;return 0;&#125;</code></pre><p><strong>界定符对注释通常用于多行解释，而双斜线注释常用于半行和单行附注</strong></p><blockquote><p><strong>注释界定符不能嵌套</strong>，因为界定符对以  <code>/*</code>  开始，以  <code>*/</code>  结束</p></blockquote><p>调试时，通常需要注释掉一些代码，由于这些代码本身可能包含界定符对形式的注释，若继续采用界定符对进行注释则可能导致注释嵌套错误，因此，调试时注释的最好的方式是用单行注释方式注释掉代码段每一行</p><p>例如：</p><pre><code class="language-cpp">// /*// * 单行注释中的任何内容都会被忽略// * 包括内部的注释对也一样会被忽略// */</code></pre><h1 id="控制语句"><a class="anchor" href="#控制语句">#</a> 控制语句</h1><p>语句一般是顺序执行的：语句块的第一条语句首先执行，然后是第二条语句，依此类推</p><p>但程序设计语言也提供了多种不同的控制流语句，允许我们写出更为复杂的执行路径</p><h2 id="while"><a class="anchor" href="#while">#</a> while</h2><p><code>while</code>  语句反复执行一段代码，直至给定条件为假为止</p><p><code>while</code>  语句的形式：</p><pre><code class="language-cpp">while (condition)    statement</code></pre><p><code>while</code>  语句的执行过程：交替检测  <code>condition</code>  条件 和 执行  <code>statement</code>  语句，直至 <code>condition</code>  为假时停止</p><p>其中， <code>statement</code>  可以是一条语句，也可以是多条语句组成的语句块</p><h3 id="语句块"><a class="anchor" href="#语句块">#</a> 语句块</h3><p>语句块 (block) ，是指用花括号  <code>&#123;&#125;</code>  包围的零条或多条语句的序列</p><p>语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块，如：</p><pre><code class="language-cpp">int sum = 0, val = 1;while (val &lt;= 10) &#123;    sum = sum + val;        // 等价于 sum += val;    val = val + 1;          // 等价于 ++ val;&#125;</code></pre><h2 id="for"><a class="anchor" href="#for">#</a> for</h2><p><code>for</code>  语句包含 <strong>循环头</strong> 和 <strong>循环体</strong></p><p>循环头控制循环体的执行次数</p><p>循环头由三部分组成：</p><ul><li><strong>初始化语句</strong> (init-statement)</li><li><strong>循环条件</strong> (condition)</li><li><strong>表达式</strong> (expression)</li></ul><p>即， <code>for (init-statement; condition; expression)</code></p><p><strong>初始化语句只在  <code>for</code>  循环入口处执行一次</strong></p><p><strong>在初始化语句中定义的变量，在循环结束之后是不能使用的</strong></p><p>每次执行循环体前都会先检查循环条件</p><p>表达式在  <code>for</code>  循环体之后执行</p><blockquote><p>若循环体不被执行，表达式亦不会被执行</p></blockquote><p>执行完表达式后， <code>for</code>  语句重新检测循环条件，循环持续至循环条件为假</p><pre><code class="language-cpp">int sum = 0;for (int val = 1; val &lt;= 10; ++ val) &#123;    sum += val;&#125;</code></pre><p>上例中，初始化语句中定义的变量  <code>val</code>  在  <code>for</code>  语句结束后即失效</p><h2 id="for-与-while"><a class="anchor" href="#for-与-while">#</a> for 与 while</h2><p><code>for</code>  循环：</p><ul><li>一般用于循环次数已知的情况</li><li><code>for</code>  循环可以节省内存，在初始化语句中定义一个局部变量，循环结束后，局部变量即被释放</li></ul><p><code>while</code>  循环：</p><ul><li>一般用于循环次数不确定的情况，并且通常需要在循环之前定义变量</li></ul><h2 id="读取数量不定的输入数据"><a class="anchor" href="#读取数量不定的输入数据">#</a> 读取数量不定的输入数据</h2><p>当循环次数不确定时，采用  <code>while</code>  循环</p><p>以读取数量不定的输入数据为例，其代码实现如下：</p><pre><code class="language-cpp">#include &lt;iostream&gt;int main()&#123;    int sum = 0, value = 0;    // 读取数据直至遇到文件尾，计算所有读入的值的和    while (std::cin &gt;&gt; value)        sum += value;    std::cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>例中，数据读取操作是在  <code>while</code>  的循环条件中完成的</p><p><code>while</code>  循环条件的求值就是执行表达式  <code>std::cin &gt;&gt; value</code>  ，表达式 <code>std::cin &gt;&gt; value</code>  返回输入运算符  <code>&gt;&gt;</code>  左侧运算对象，即  <code>std::cin</code>  ，因此，该循环条件实际上是检测  <code>std::cin</code></p><blockquote><p>当我们使用一个  <code>istream</code>  对象，如  <code>cin</code>  ，作为条件时，其效果是检测流的状态：当遇到文件结束符 (end-of-file) 或遇到一个无效输入时（例如读入的值不是一个整数）， <code>istream</code>  对象的状态会变为无效。进一步地，无效状态的  <code>istream</code>  对象会使条件变为假</p></blockquote><p>键盘输入文件结束符：</p><ul><li>windows 系统： <code>Ctrl + Z</code>  ，然后按  <code>Enter</code>  或  <code>Return</code>  键</li><li>UNIX 系统、Mac OS X 系统： <code>Ctrl + D</code></li></ul><h2 id="if"><a class="anchor" href="#if">#</a> if</h2><p><code>if</code>  是条件语句，其语句形式为：</p><pre><code class="language-cpp">if (condition) &#123;    statement;&#125;</code></pre><p>条件  <code>condition</code>  为真，执行条件之后的语句块  <code>statement</code>  ，否则不予执行</p><p>或者：</p><pre><code class="language-cpp">if (condition) &#123;    statement1;&#125; else &#123;    statement2;&#125;</code></pre><p>条件  <code>condition</code>  为真时，执行  <code>statement1</code>  ，否则，执行  <code>statement2</code></p><h3 id="用-if-语句统计输入序列中每个值连续出现了多少次"><a class="anchor" href="#用-if-语句统计输入序列中每个值连续出现了多少次">#</a> 用 if 语句统计输入序列中每个值连续出现了多少次</h3><p>代码实现：</p><pre><code class="language-cpp">#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main() &#123;    int currentNum, num;            // currentNum 为当前统计的数字，num 为新读取的数字    if (cin &gt;&gt; currentNum) &#123;        // 初始化当前统计数字        int count = 1;              // 初始化当前统计数字的出现次数        while (cin &gt;&gt; num) &#123;        // 读取下一个数字            if (num == currentNum)  // 如果新输入数字与当前统计的数字相同，出现次数加一                ++ count;            else &#123;                  // 如果不同，输出当前统计数字的出现次数，并更新所统计的数字，重置计数器                cout &lt;&lt; currentNum &lt;&lt; &quot; occurs &quot; &lt;&lt; count &lt;&lt; &quot; times &quot; &lt;&lt; endl;                currentNum = num;                count = 1;            &#125;        &#125;        cout &lt;&lt; currentNum &lt;&lt; &quot; occurs &quot; &lt;&lt; count &lt;&lt; &quot; times &quot; &lt;&lt; endl;     // 输出文件最后一个数字的出现次数    &#125;    return 0;&#125;</code></pre><h1 id="类"><a class="anchor" href="#类">#</a> 类</h1><p>类 (class) ：一个类定义了一个类型 (class type) 以及与其关联的一组操作，其中，类型名就是类名</p><p>如： <code>sales_item</code>  类定义了一个名为  <code>sales_item</code>  的类型</p><p>与内置类型（例如  <code>int</code>  ）一样，我们可以定义 类 类型的变量</p><p>如： <code>sales_item item</code>  表示  <code>item</code>  是一个  <code>sales_item</code>  类型的对象，通常简单表述为 “一个  <code>sale-item</code>  对象” ，或者，“一个  <code>sales_item</code>  ”</p><h1 id="头文件"><a class="anchor" href="#头文件">#</a> 头文件</h1><p>C++ 通过使用头文件来使用标准库设施，或者是访问某个特定的类</p><p>头文件：通常根据其中定义的类的名字来命名，通常使用  <code>.h</code>  作为头文件的后缀，但也有些习惯用  <code>.H</code>  、 <code>.hpp</code>  或  <code>.hxx</code></p><p>C++ 标准库头文件通常不带后缀</p><p>通过  <code>#include</code>  指令使用头文件</p><ul><li>若是标准库的头文件，则用尖括号  <code>&lt;&gt;</code>  包围头文件名，如  <code>#include &lt;iostream&gt;</code></li><li>若是不属于标准库的头文件，则用双引号  <code>&quot;&quot;</code>  包围，如  <code>#include &quot;sales_item&quot;</code></li></ul><h2 id="标准库头文件"><a class="anchor" href="#标准库头文件">#</a> 标准库头文件</h2><p>C++ 标准库中除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库</p><blockquote><p>建议使用 C++ 版本的 C 标准库头文件</p></blockquote><p>C 语言的头文件形如  <code>name.h</code>  ，C++ 则将这些文件命名为  <code>cname</code>  。也就是去掉了  <code>.h</code>  后缀，而在文件名  <code>name</code>  之前添加了字母  <code>c</code>  ，这里的  <code>c</code>  表示这是一个属于 C 语言标准库的头文件</p><p>一般来说，C++ 程序应该使用名为  <code>cname</code>  的头文件而不使用  <code>name.h</code>  的形式</p><p>定义在  <code>cname</code>  头文件中的名字从属于命名空间  <code>std</code>  ，而定义在  <code>.h</code>  头文件中的名字不输于命名空间  <code>std</code></p><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><code>参数（实参，argument）</code>  ：向函数传递的值</p><p><code>赋值（assignment）</code>  ：抹去一个对象的当前值，用一个新值取代</p><p><code>程序块（block）</code>  ：零条或多条语句的序列，用花括号包围</p><p><code>缓冲区（buffer）</code>  ：一个存储区域，用于保存数据</p><ul><li>IO 设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的</li><li>我们可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备</li><li>默认情况下，读  <code>cin</code>  会刷新  <code>cout</code>  ；程序非正常终止时也会刷新  <code>cout</code></li></ul><p><code>内置类型（built-in type）</code>  ：由语言定义的类型，如  <code>int</code></p><p><code>Cerr</code>  ：一个  <code>ostream</code>  对象，关联到标准错误，通常写入到与标准输出相同的设备</p><ul><li>默认情况下，写到  <code>cerr</code>  的数据是不缓冲的</li><li><code>cerr</code>  通常用于输出错误信息或其他不属于程序正常逻辑的输出内容</li></ul><p><code>字符串字面值常量（character string literal）</code>  ：术语 string literal 的另一种叫法</p><p><code>cin</code>  ：一个  <code>istream</code>  对象，用来从标准输入读取数据</p><p><code>类（class）</code>  ：一种用于定义自己的数据结构及其相关操作的机制。<strong>类是 C++ 中最基本的特性之一</strong>。在标准库中， <code>istream</code>  和  <code>ostream</code>  都是类</p><p><code>类类型（class type）</code>  ：类定义的类型。类名即为类型名</p><p><code>clog</code>  ：一个  <code>ostream</code>  对象，关联到标准错误</p><ul><li>默认情况下，写到  <code>clog</code>  的数据是被缓冲的</li><li><code>clog</code>  通常用于报告程序的执行信息，存入一个日志文件中</li></ul><p><code>注释（comment）</code>  ：被编译器忽略的程序文本</p><ul><li>C++ 有两种类型的注释：单行注释 和 界定符对注释</li><li>单行注释：以  <code>//</code>  开始，从  <code>//</code>  到行尾的所有内容都是注释</li><li>界定符对注释：以  <code>/*</code>  开始，其后的所有内容都是注释，直至遇到  <code>*/</code>  为止</li></ul><p><code>条件（condition）</code>  ：求值结果为真或假的表达式。通常，值 0 表示假，非零值表示真</p><p><code>cout</code>  ：一个  <code>ostream</code>  对象，用于将数据写入标准输出。通常用于程序的正常输出内容</p><p><code>花括号（curly brace）</code>  ：花括号用于划定程序块边界。左花括号  <code>&#123;</code>  为程序块开始，右花括号  <code>&#125;</code>  为结束</p><p><code>数据结构（data structure）</code>  ：数据及其上所允许的操作的一种逻辑组合</p><p><code>编辑-编译-调试（edit-compile-debug）</code>  ：使程序能正确执行的开发过程</p><p><code>文件结束符（end-of-file）</code>  ：系统特定的标识，指出文件中无更多数据了</p><p><code>表达式（expression）</code>  ：最小的计算单元。一个表达式包含一个或多个运算对象，通常还包含一个或多个运算符。表达式求值会产生一个结果。例如，假设  <code>i</code>  和  <code>j</code>  是  <code>int</code>  对象，则  <code>i + j</code>  是一个表达式，它产生两个  <code>int</code>  值的和</p><p><code>for语句（for statement）</code>  ：迭代语句，提供重复执行能力。通常用来将一个计算反复执行指定次数</p><p><code>函数（function）</code>  ：具名的计算单元</p><p><code>函数体（function body）</code>  ：语句块，定义了函数所执行的动作</p><p><code>函数名（function name）</code>  ：函数为人所知的名字，也用来进行函数调用</p><p><code>头文件（header）</code>  ：使类或其他名字的定义可被多个程序使用的一种机制。程序通过  <code>#include</code>  指令使用头文件</p><p><code>if语句（if statement）</code>  ：根据一个特定条件的值进行条件执行的语句。如果条件为真，执行  <code>if</code>  语句体。否则，执行  <code>else</code>  语句体（如果存在的话）</p><p><code>初始化（initialize）</code>  ：在一个对象创建的时候赋予它一个值</p><p><code>iostream</code>  ：头文件，提供了面向流的输入输出的标准库类型</p><p><code>istream</code>  ：提供了面向流的输入的库类型</p><p><code>库类型（library type）</code>  ：标准库定义的类型，如  <code>istream</code></p><p><code>main</code>  ：操作系统执行一个 C++ 程序时所调用的函数。每个程序必须有且只有一个命名为  <code>main</code>  的函数</p><p><code>操纵符（manipulator）对象</code> ，如  <code>std::endl</code>  ，在读写流的时候用来 “操纵” 流本身</p><p><code>成员函数（member function）</code>  ：类定义的操作。通常通过调用成员函数来操作特定对象</p><p><code>方法（method）</code>  ：成员函数的同义术语</p><p><code>命名空间（namespace）</code>  ：将库定义的名字放在一个单一位置的机制。命名空间可以帮助避免不经意的名字冲突。C++ 标准库定义的名字在命名空间  <code>std</code>  中</p><p><code>ostream</code>  ：标准库类型，提供面向流的输出</p><p><code>形参列表（parameter list）</code>  ：函数定义的一部分，指出调用函数时可以使用什么样的实参，可能为空列表</p><p><code>返回类型（return type）</code>  ：函数返回值的类型</p><p><code>源文件（source file）</code>  ：包含 C++ 程序的文件</p><p><code>标准错误（standard error）</code>  ：输出流，用于报告错误。标准输出和标准错误通常关联到程序执行所在的窗口</p><p><code>标准输入（standard input）</code>  ：输入流，通常与程序执行所在窗口相关联</p><p><code>标准库（standard library）</code>  ：一个类型和函数的集合，每个 C++ 编译器都必须支持</p><ul><li>标准库提供了支持 IO 操作的类型</li><li>C++ 程序员倾向于用 “库” 指代整个标准库，还倾向于用库类型表示标准库的特定部分，例如，用 “ <code>iostream</code>  库” 表示标准库中定义 IO 类的部分</li></ul><p><code>标准输出（standard output）</code>  ：输出流，通常与程序执行所在窗口相关联</p><p><code>语句（statement）</code>  ：程序的一部分，指定了当程序执行时进行什么动作。一个表达式接一个分号就是一条语句；其他类型的语句包括语句块、 <code>if</code>  语句、 <code>for</code>  语句和  <code>while</code>  语句，所有这些语句内都包含其他语句</p><p><code>std</code>  ：标准库所使用的命名空间。 <code>std::cout</code>  表示我们要使用定义在命名空间  <code>std</code>  中的名字  <code>cout</code></p><p><code>字符串常量（string literal）</code>  ：零或多个字符组成的序列，用双引号包围，例如， <code>&quot;a string literal&quot;</code></p><p><code>未初始化的变量（uninitialized variable）</code>  ：未赋予初值的变量</p><ul><li>类类型的变量如果未指定初值，则按类定义指定的方式进行初始化</li><li>定义在函数内部的内置类型变量默认是不初始化的，除非有显式的初始化语句</li><li>试图使用一个未初始化变量的值是错误的</li><li><strong>未初始化变量是 bug 的常见成因</strong></li></ul><p><code>变量（variable）</code>  ：具名对象</p><p><code>while语句（while statement）</code>  ：迭代语句，提供重复执行直至一个特定条件为假的机制。循环体会执行零次或多次，依赖于循环条件求值结果</p><p><code>() 运算符（() operator）</code>  ：调用运算符。跟随在函数名之后的一对括号 “  <code>()</code>  ”，起到调用函数的效果。传递给函数的实参放置在括号内</p><p><code>++ 运算符（++ operator）</code>  ：递增运算符。将运算对象的值加 1， <code>++i</code>  等价于  <code>i = i + 1</code></p><p><code>+= 运算符（+= operator）</code>  ：复合赋值运算符，将右侧运算对象加到左侧运算对象上； <code> a += b</code>  等价于  <code>a = a + b</code></p><p><code>. 运算符（.operator）</code>  ：点运算符。左侧运算对象必须是一个类类型对象，右侧运算对象必须是此对象的一个成员的名字。运算结果即为该对象的这个成员</p><p><code>:: 运算符（:: operator）</code>  ：作用域运算符。其用处之一是访问命名空间中的名字。例如， <code>std::cout</code>  表示命名空间  <code>std</code>  中的名字  <code>cout</code></p><p><code>= 运算符（= operator）</code>  ：将右侧运算对象的值赋予左侧运算对象所表示的对象</p><p><code>-- 运算符（-- operator）</code>  ：递减运算符。将运算对象的值减 1， <code>--i</code>  等价于  <code>i = i - 1</code></p><p><code>&lt;&lt; 运算符（&lt;&lt; operator）</code>  ：输出运算符</p><ul><li>将右侧运算对象的值写到左侧运算对象表示的输出流，例如， <code>cout &lt;&lt; &quot;hi&quot;</code>  表示将 hi 写到标准输出</li><li>输出运算符可以连接，例如， <code>cout &lt;&lt; &quot;hi&quot; &lt;&lt; &quot;bye&quot;</code>  表示将输出 hibye</li></ul><p><code>&gt;&gt; 运算符（&gt;&gt; operator）</code>  ：输入运算符</p><ul><li>从左侧运算对象所指定的输入流读取数据，存入右侧运算对象中。例如， <code>cin &gt;&gt; i</code>  表示从标准输入读取下一个值，存入  <code>i</code>  中</li><li>输入运算符可以连接。例如， <code>cin &gt;&gt; i &gt;&gt; j</code>  表示先读取一个值存入  <code>i</code>  ，再读取一个值存入  <code>j</code></li></ul><p><code>\#include</code>  ：头文件包含指令，使头文件中代码可被程序使用</p><p><code>== 运算符（== operator）</code>  ：相等运算符。检测左侧运算对象是否 等于 右侧运算对象</p><p><code>!= 运算符（!= operator）</code>  ：不等运算符。检测左侧运算对象是否 不等于 右侧运算对象</p><p><code>&lt;= 运算符（&lt;= operator）</code>  ：小于等于运算符。检测左侧运算对象是否 小于等于 右侧运算对象</p><p><code>&lt; 运算符（&lt; operator）</code>  ：小于运算符。检测左侧运算对象是否 小于 右侧运算对象</p><p><code>&gt;= 运算符（&gt;= operator）</code>  ：大于等于运算符。检测左侧运算对象是否 大于等于 右侧运算对象</p><p><code>&gt; 运算符（&gt; operator）</code>  ：大于运算符。检测左侧运算对象是否 大于 右侧运算对象</p><p>参考：C++ Primer 中文版（第 5 版）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode 使用</title>
      <link href="/posts/b84c37ec/"/>
      <url>/posts/b84c37ec/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode-快捷键"><a class="anchor" href="#vscode-快捷键">#</a> vscode 快捷键</h1><h2 id="主命令框"><a class="anchor" href="#主命令框">#</a> 主命令框</h2><p>Ctrl + Shift + P: 打开命令面板</p><h2 id="编辑器与窗口"><a class="anchor" href="#编辑器与窗口">#</a> 编辑器与窗口</h2><p>Ctrl + K, V: 打开预览面板</p><p>Ctrl + `: 打开 / 关闭终端</p><p>Ctrl + Tab: 文件之间切换</p><p>Ctrl + W: 关闭当前窗口</p><h2 id="代码编辑"><a class="anchor" href="#代码编辑">#</a> 代码编辑</h2><p>Ctrl + F: 查找</p><p>Ctrl + H: 查找替换</p><p>Ctrl + Shift + T: 重新打开刚关闭的编辑页面</p><p>Ctrl + Backspace: 删除上一个单词</p><p>Ctrl + N: 新建文件</p><p>Ctrl + S: 保存</p><h2 id="光标"><a class="anchor" href="#光标">#</a> 光标</h2><p>Home: 光标移动至行首</p><p>End: 光标移动至行末</p><p>Ctrl + Home: 光标移至文件开头</p><p>Ctrl + End: 光标移至文件末尾</p><p>Shift + Home: 选择从光标到行首的内容</p><p>Shift + End: 选择从光标到行尾的内容</p><p>Alt + Up: 向上移动一行</p><p>Alt + Down: 向下移动一行</p><h2 id="调试-运行"><a class="anchor" href="#调试-运行">#</a> 调试、运行</h2><p>Ctrl + Shift + B: 重启调试</p><p>Ctrl + F5: 运行但不调试</p><p>F5: 启动调试</p><h1 id="终端-terminal"><a class="anchor" href="#终端-terminal">#</a> 终端 Terminal</h1><h2 id="配置-cmd"><a class="anchor" href="#配置-cmd">#</a> 配置 cmd</h2><p>以管理员身份运行 <code>powershell</code></p><ul><li><p>输入 <code>set-ExecutionPolicy RemoteSigned</code>  然后回车</p></li><li><p>根据提示，输入 <code>Y</code>  回车即可</p></li></ul><h2 id="hexo-指令"><a class="anchor" href="#hexo-指令">#</a> hexo 指令</h2><p><code>hexo n &quot; &quot;</code> : 新建 md 文件</p><p><code>hexo c</code> : 清理</p><p><code>hexo g</code> : 生成</p><p><code>hexo d</code> : 部署到 github</p><h2 id="g-指令"><a class="anchor" href="#g-指令">#</a> g++ 指令</h2><p><code>g++ hello.cpp -o hello.exe</code> : 输出编译后的结果到指定的文件 file 中 (输出指定的可执行文件 hello.exe)，-o 不仅可以指定输出的可执行文件，还可以指定中间文件的输出</p><p><code>g++ -o hello.exe hello.cpp</code> : 同上</p><p><code>g++ hello.cpp</code> : 输出的是 a.exe</p><p><code>g++ -E -o hello.i hello.cpp</code> : 对源文件进行预处理，预处理后生成.i (或者是 .ii) 文件，对 hello.cpp 进行预处理生成 hello.i 文件</p><p><code>g++ -S -o hello.s hello.cpp</code> : 只进行预处理和编译，生成汇编文件 hello.s</p><p><code>g++ -c -o hello.o hello.cpp</code> : 只进行预处理，编译，汇编操作，生成.o (.obj) 文件，不进行链接</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo 博客搭建与配置</title>
      <link href="/posts/ace9da28/"/>
      <url>/posts/ace9da28/</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备"><a class="anchor" href="#前期准备">#</a> 前期准备</h1><h2 id="安装git"><a class="anchor" href="#安装git">#</a> 安装 git</h2><ol><li>下载：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZA==">https://git-scm.com/download</span></li><li>安装：除了选择安装路径外，一直点 next 就行</li></ol><p>可参考教程<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhaGFtZWllci9hcnRpY2xlL2RldGFpbHMvODYzMTI1MzA="> https://blog.csdn.net/hahameier/article/details/86312530</span></p><h2 id="安装nodejs"><a class="anchor" href="#安装nodejs">#</a> 安装 node.js</h2><ol><li>下载：<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">https://nodejs.org/en/</span></li><li>安装：除了选择路径以外，一直点 next 就行</li></ol><h1 id="hexo环境搭建"><a class="anchor" href="#hexo环境搭建">#</a> hexo 环境搭建</h1><h2 id="进入命令行"><a class="anchor" href="#进入命令行">#</a> 进入命令行</h2><p>打开命令行窗口：按  <code>win+r</code>  键，输入  <code>cmd</code>  ，回车，后续操作均在命令行进行</p><h2 id="安装cnpm"><a class="anchor" href="#安装cnpm">#</a> 安装 cnpm</h2><p>安装 cnpm 镜像源：输入  <code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>  ，回车，等待...</p><h2 id="安装hexo"><a class="anchor" href="#安装hexo">#</a> 安装 hexo</h2><p>安装 hexo 框架：输入  <code>cnpm install -g hexo-cli</code>  ，回车</p><h2 id="新建blog文件"><a class="anchor" href="#新建blog文件">#</a> 新建 blog 文件</h2><ol><li>以管理员权限打开  <code>cmd</code></li><li>输入  <code>mkdir e:\blog</code>  并回车，实现在  <code>e:\</code>  路径下创建  <code>blog</code>  文件夹</li><li>配置路径：先输入  <code>e:</code>  回车，切换默认目录至  <code>e</code>  盘；然后输入  <code>cd e:\blog</code>  回车，切换至  <code>e:\blog</code>  目录</li></ol><blockquote><p><code>cmd</code>  切换目录：</p><ul><li>“盘符 <code>:</code> ” 命令：进入指定硬盘区域，例： <code>D:</code>  命令，切换到 D 盘</li><li>“ <code>cd</code>  + 空格 + 文件位置” 命令：切换到该磁盘下的指定目录</li><li><code>dir</code>  命令，显示当前目录下的所有文件</li><li><code>cd ..</code>  命令：返回上一级目录</li></ul></blockquote><h2 id="初始化"><a class="anchor" href="#初始化">#</a> 初始化</h2><ol><li>初始化博客：输入  <code>hexo init</code>  ，回车，等待... 直到出现  <code>INFO Starting blogging with Hexo</code></li><li>启动本地博客服务：输入  <code>hexo s</code>  ，回车，得到本地访问地址  <code>http://localhost:4000</code></li><li>访问本地博客：浏览器打开 <span class="exturl" data-url="aHR0cHM6Ly9sb2NhbGhvc3Q6NDAwMC8=">https://localhost:4000/</span></li></ol><h2 id="安装git插件"><a class="anchor" href="#安装git插件">#</a> 安装 git 插件</h2><ol><li>配置到 <code>blog</code>  目录：在 <code>cmd</code>  命令行输入 <code>e:</code>  回车，然后输入 <code>cd e:\blog</code>  回车</li><li>安装部署插件：输入 <code>cnpm install --save hexo-deployer-git</code>  并回车，等待安装完成，如若出现 warning 可直接忽略</li></ol><h2 id="配置git"><a class="anchor" href="#配置git">#</a> 配置 git</h2><ol><li>打开 <strong>git bash</strong></li><li>输入  <code>git config --global user.email YourEmail</code>  ，其中 <code>YourEmail</code>  是 github 邮箱</li><li>输入  <code>git config --global user.name YourName</code>  ， <code>YourName</code>  是 github 用户名</li></ol><h2 id="创建github仓库"><a class="anchor" href="#创建github仓库">#</a> 创建 github 仓库</h2><p>登录 github 网页，右上角  <code>New repository</code>  新建仓库， <code>Repository name</code>  命名为  <code>YourName.github.io</code> （以避免二级域名）</p><h2 id="配置_configyml"><a class="anchor" href="#配置_configyml">#</a> 配置_config.yml</h2><p>打开  <code>e:\blog</code>  路径下的  <code>_config.yml</code>  文件，找到  <code>Deployment</code>  板块，配置如下</p><pre><code class="language-yml"># Deploymentdeploy:   type: git  repo: https://github.com/YourGithubName/YourGithubName.github.io.git  branch: master</code></pre><p>其中， <code>repo</code>  后面的链接为个人 github 仓库的链接， <code>branch</code>  填写仓库默认分支</p><blockquote><p>注：冒号后面需要有英文环境下的空格</p></blockquote><h2 id="部署到github仓库"><a class="anchor" href="#部署到github仓库">#</a> 部署到 github 仓库</h2><ol><li><code>cmd</code>  命令行配置到路径  <code>e:\blog</code></li><li>部署：输入  <code>hexo d</code>  并回车，部署到 github 仓库里</li><li>等待弹窗，输入 github 账户密码，即配置完成</li></ol><h2 id="hexo相关命令"><a class="anchor" href="#hexo相关命令">#</a> hexo 相关命令</h2><ul><li><code>hexo c</code> ：清理</li><li><code>hexo n</code> ：新建</li><li><code>hexo g</code> ：生成博客</li><li><code>hexo s</code> ：启动本地博客服务</li><li><code>hexo d</code> ：部署到远端 github 博客</li></ul><h1 id="其他配置"><a class="anchor" href="#其他配置">#</a> 其他配置</h1><h2 id="主题"><a class="anchor" href="#主题">#</a> 主题</h2><p>本博客采用的是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span> 主题</p><p>其相关配置可参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUvY29tcHV0ZXItc2NpZW5jZS9ub3RlL3RoZW1lLXNob2thLWRvYy8=">Shoka 主题使用说明</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmV2ZXJzZXNhY2xlLmNvbS9TdXBwbGVtZW50LWZvci1zaG9rYS10aGVtZS8=">Shoka 主题功能介绍补充点</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9jYXRlZ29yaWVzL1NIT0tBLw==">Shoka 主题进阶玩法</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYS9pc3N1ZXMvNjU=">添加 Jsdelivr CDN 的链接无法访问</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oaWtraS5zaXRlLzZmMDEwNDMzLmh0bWw=">Jsdelivr 刷新缓存</span></li></ul><p>可访问 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">hexo 主题列表</span> 查看更多主题</p><h2 id="插件"><a class="anchor" href="#插件">#</a> 插件</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JvemJvL2hleG8tYWJicmxpbms=">静态链接转换：hexo-abbrlink</span> / <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Zpa28xNi9oZXhvLXBlcm1hbGluay1waW55aW4=">hexo-permalink-pinyin</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lpeXVuZ2VudC9oZXhvLWFzc2V0LWltZw==">显示本地图片：hexo-asset-img</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjYXRjaGUvaGV4by1nZW5lcmF0b3ItcmVhZG1lLWZpbGU=">为 github 生成 readme.md 文件：hexo-generator-readme-file</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3BsdWdpbnMv">hexo 插件列表</span></p><h2 id="评论系统"><a class="anchor" href="#评论系统">#</a> 评论系统</h2><p>本博客搭建的是 <span class="exturl" data-url="aHR0cHM6Ly92YWxpbmUuanMub3JnL3F1aWNrc3RhcnQuaHRtbA==">Valine</span> 评论系统</p><p>在  <code>_config.yml</code>  主题配置文件中，添加如下配置（具体参数可参考 <span class="exturl" data-url="aHR0cHM6Ly92YWxpbmUuanMub3JnL2NvbmZpZ3VyYXRpb24uaHRtbA==">Valine 配置项</span>）：</p><pre><code class="language-yml"># valinevaline:  appId: # Leancloud 的 AppID  appKey: # Leancloud 的 AppKey  placeholder: 欢迎评论~ # Comment box placeholder  avatar: mp # Gravatar style : mp, identicon, monsterid, wavatar, robohash, retro  pageSize: 10 # Pagination size  lang: zh-CN  visitor: true # 文章访问量统计  NoRecordIP: false # 不记录 IP  serverURLs: # Leanclound 的 REST API 服务器地址</code></pre><p>需自行填写  <code>appId</code>  和  <code>appKey</code>  ，其值分别为 Leancloud 的  <code>AppID</code>  和  <code>AppKey</code></p><blockquote><p>若 Leancloud 为国际版，需在  <code>_config.yml</code>  文件中设置  <code>serverURLs</code>  ，其值为 Leancloud 中的  <code>REST API 服务器地址</code></p></blockquote><p>注：Valine 没有评论管理、邮件通知等功能</p><p>邮件通知、评论管理功能可参考以下教程：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9kZXNlcnRzLmlvL3ZhbGluZS1hZG1pbi1kb2N1bWVudC8=">Valine Admin</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yZWlubmVzcy5jb20vYmxvZy92dWVwcmVzcy8j">Valine Admin 升级版（含 QQ、微信提醒功能）</span></p></li></ul><h1 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVliNDExYTd0eT9wPTEmYW1wO3NoYXJlX21lZGl1bT1hbmRyb2lkJmFtcDtzaGFyZV9wbGF0PWFuZHJvaWQmYW1wO3NoYXJlX3NvdXJjZT1XRUlYSU4mYW1wO3NoYXJlX3RhZz1zX2kmYW1wO3RpbWVzdGFtcD0xNjM1MDcxMjM3JmFtcDt1bmlxdWVfaz1rWWRXUzE=">Hexo 博客搭建的视频教程</span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGhpbG9iaW5nL3AvMTU2NzA0NzAuaHRtbA==">解决 Github 连接不上的问题：HOSTS 文件配置</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU2OTg0Ni9hcnRpY2xlL2RldGFpbHMvMTA1ODA4Njgz">使用 SSH 地址</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o5NTI5NTc0MDcvYXJ0aWNsZS9kZXRhaWxzLzExMTY0MjU0OD9zcG09MTAwMS4yMTAxLjMwMDEuNjY2MS4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMiU3RWRlZmF1bHQlN0VDVFJMSVNUJTdFUmF0ZS0xLnBjX3JlbGV2YW50X2RlZmF1bHQmYW1wO2RlcHRoXzEtdXRtX3NvdXJjZT1kaXN0cmlidXRlLnBjX3JlbGV2YW50X3QwLm5vbmUtdGFzay1ibG9nLTIlN0VkZWZhdWx0JTdFQ1RSTElTVCU3RVJhdGUtMS5wY19yZWxldmFudF9kZWZhdWx0JmFtcDt1dG1fcmVsZXZhbnRfaW5kZXg9MQ==">hexo + github 本地和线上图片不显示问题</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmp1c3Rsb3Zlc21pbGUudG9wL3Bvc3RzL2M4OTcyYjYzLmh0bWw/dGltZT0xNjUzNTMwNzcxNzY3">Hexo 博客搭建超级指南</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzODU4Nzg1L2FydGljbGUvZGV0YWlscy8xMjMxMDQ4MjM=">Hexo 博客同时部署到 Github 和 Gitee</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oaWtraS5zaXRlL2VkYWE5NGZiLmh0bWw=">为博客添加免费的 CDN 加速</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saXpoZW5pbmcuZ2l0aHViLmlvL3Bvc3RzL2I0NjczMjdjLw==">将 Hexo 博客提交 Google 并配置 Google Analysis</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTgwMDg4NC9hcnRpY2xlL2RldGFpbHMvMTAzNzUwNjgz">百度，必应，谷歌收录</span></p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/posts/96be88e3/"/>
      <url>/posts/96be88e3/</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a class="anchor" href="#标题">#</a> 标题</h1><p>语句： <code># 标题名</code></p><p>n 级标题就有 n 个 <code>#</code></p><h1 id="斜体"><a class="anchor" href="#斜体">#</a> 斜体</h1><p>语句： <code>* 文本内容 *</code></p><h1 id="粗体"><a class="anchor" href="#粗体">#</a> 粗体</h1><p>语句： <code>** 文本内容 **</code></p><p>加粗的斜体则用三个  <code>*</code>  进行包围</p><h1 id="公式"><a class="anchor" href="#公式">#</a> 公式</h1><p>我们这里的 Hexo 博客使用的是 <code>KaTex</code>  插件，语法与 <code>LaTex</code>  基本一致</p><p><code>$$</code>  实现内嵌式公式， <code>$$$$</code>  实现公式居中展示</p><p><span class="exturl" data-url="aHR0cHM6Ly9rYXRleC5vcmcvZG9jcy9zdXBwb3J0ZWQuaHRtbA==">KaTex 说明文档</span></p><h1 id="行内代码"><a class="anchor" href="#行内代码">#</a> 行内代码</h1><p>语句：一对反引号（`）</p><h1 id="块代码"><a class="anchor" href="#块代码">#</a> 块代码</h1><p>语句：</p><ul><li>通过在代码块首尾分别添加 三个反引号 (```) 实现</li><li>通过对整个代码块施加 <code>一个缩进符(Tab键)</code>  实现（此方法需要前面空一行）</li></ul><p>测试代码：</p><pre><code>    // 通过缩进符实现代码块    int main() &#123;        int a = 0;        a++;        return a;    &#125;</code></pre><p>或</p><pre><code>```// 通过三个反引号实现代码块int main() &#123;    int b = 10;    b--;    return b;&#125;```</code></pre><p>测试结果：</p><pre><code>// 通过缩进展示代码块int main() &#123;    int a = 0;    a++;    return a;&#125;</code></pre><pre><code>// 通过三个反引号实现代码块int main() &#123;    int b = 10;    b--;    return b;&#125;</code></pre><h1 id="代码高亮"><a class="anchor" href="#代码高亮">#</a> 代码高亮</h1><p>实现方法：</p><ul><li>在三个反引号后面加上 key 值</li><li>常用的几个 key 值为 cpp、java、python、matlab、markdown</li></ul><p>测试代码：</p><pre><code>```cppstring s;vector&lt;int&gt; nums;```</code></pre><p>测试结果：</p><pre><code class="language-cpp">string s = '';vector&lt;int&gt; nums;</code></pre><p>另，用缩进符实现的代码块似乎无法实现高亮</p><table><thead><tr><th style="text-align:center">language</th><th style="text-align:center">key</th></tr></thead><tbody><tr><td style="text-align:center">ActionScript</td><td style="text-align:center">actionscript</td></tr><tr><td style="text-align:center">Apache</td><td style="text-align:center">apache</td></tr><tr><td style="text-align:center">AppleScript</td><td style="text-align:center">applescript</td></tr><tr><td style="text-align:center">AsciiDoc</td><td style="text-align:center">asciidoc</td></tr><tr><td style="text-align:center">AspectJ</td><td style="text-align:center">asciidoc</td></tr><tr><td style="text-align:center">AutoHotkey</td><td style="text-align:center">autohotkey</td></tr><tr><td style="text-align:center">AVR Assembler</td><td style="text-align:center">avrasm</td></tr><tr><td style="text-align:center">Axapta</td><td style="text-align:center">axapta</td></tr><tr><td style="text-align:center">Bash</td><td style="text-align:center">bash</td></tr><tr><td style="text-align:center">BrainFuck</td><td style="text-align:center">brainfuck</td></tr><tr><td style="text-align:center">Cap’n Proto</td><td style="text-align:center">capnproto</td></tr><tr><td style="text-align:center">Clojure REPL</td><td style="text-align:center">clojure</td></tr><tr><td style="text-align:center">Clojure</td><td style="text-align:center">clojure</td></tr><tr><td style="text-align:center">CMake</td><td style="text-align:center">cmake</td></tr><tr><td style="text-align:center">CoffeeScript</td><td style="text-align:center">coffeescript</td></tr><tr><td style="text-align:center">C++</td><td style="text-align:center">cpp</td></tr><tr><td style="text-align:center">C#</td><td style="text-align:center">cs</td></tr><tr><td style="text-align:center">CSS</td><td style="text-align:center">css</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">d</td></tr><tr><td style="text-align:center">Dart</td><td style="text-align:center">d</td></tr><tr><td style="text-align:center">Delphi</td><td style="text-align:center">delphi</td></tr><tr><td style="text-align:center">Diff</td><td style="text-align:center">diff</td></tr><tr><td style="text-align:center">Django</td><td style="text-align:center">django</td></tr><tr><td style="text-align:center">DOS.bat</td><td style="text-align:center">dos</td></tr><tr><td style="text-align:center">Dust</td><td style="text-align:center">dust</td></tr><tr><td style="text-align:center">Elixir</td><td style="text-align:center">elixir</td></tr><tr><td style="text-align:center">ERB(Embedded Ruby)</td><td style="text-align:center">erb</td></tr><tr><td style="text-align:center">Erlang REPL</td><td style="text-align:center">erlang-repl</td></tr><tr><td style="text-align:center">Erlang</td><td style="text-align:center">erlang</td></tr><tr><td style="text-align:center">FIX</td><td style="text-align:center">fix</td></tr><tr><td style="text-align:center">F#</td><td style="text-align:center">fsharp</td></tr><tr><td style="text-align:center">G-code(ISO 6983)</td><td style="text-align:center">gcode</td></tr><tr><td style="text-align:center">Gherkin</td><td style="text-align:center">gherkin</td></tr><tr><td style="text-align:center">GLSL</td><td style="text-align:center">glsl</td></tr><tr><td style="text-align:center">Go</td><td style="text-align:center">go</td></tr><tr><td style="text-align:center">Gradle</td><td style="text-align:center">gradle</td></tr><tr><td style="text-align:center">Groovy</td><td style="text-align:center">groovy</td></tr><tr><td style="text-align:center">Haml</td><td style="text-align:center">haml</td></tr><tr><td style="text-align:center">Handlebars</td><td style="text-align:center">handlebars</td></tr><tr><td style="text-align:center">Haskell</td><td style="text-align:center">haskell</td></tr><tr><td style="text-align:center">Haxe</td><td style="text-align:center">haxe</td></tr><tr><td style="text-align:center">HTML</td><td style="text-align:center">html</td></tr><tr><td style="text-align:center">HTTP</td><td style="text-align:center">http</td></tr><tr><td style="text-align:center">Ini file</td><td style="text-align:center">ini</td></tr><tr><td style="text-align:center">Java</td><td style="text-align:center">java</td></tr><tr><td style="text-align:center">JavaScript</td><td style="text-align:center">javascript</td></tr><tr><td style="text-align:center">JSON</td><td style="text-align:center">json</td></tr><tr><td style="text-align:center">Lasso</td><td style="text-align:center">lasso</td></tr><tr><td style="text-align:center">Less</td><td style="text-align:center">less</td></tr><tr><td style="text-align:center">Lisp</td><td style="text-align:center">lisp</td></tr><tr><td style="text-align:center">LiveCode</td><td style="text-align:center">livecodeserver</td></tr><tr><td style="text-align:center">LiveScript</td><td style="text-align:center">livescript</td></tr><tr><td style="text-align:center">Lua</td><td style="text-align:center">lua</td></tr><tr><td style="text-align:center">Makefile</td><td style="text-align:center">makefile</td></tr><tr><td style="text-align:center">Markdown</td><td style="text-align:center">markdown</td></tr><tr><td style="text-align:center">Mathematica</td><td style="text-align:center">mathematica</td></tr><tr><td style="text-align:center">Matlab</td><td style="text-align:center">matlab</td></tr><tr><td style="text-align:center">MEL (Maya Embedded Language)</td><td style="text-align:center">mel</td></tr><tr><td style="text-align:center">Mercury</td><td style="text-align:center">mercury</td></tr><tr><td style="text-align:center">Mizar</td><td style="text-align:center">mizar</td></tr><tr><td style="text-align:center">Monkey</td><td style="text-align:center">monkey</td></tr><tr><td style="text-align:center">Nginx</td><td style="text-align:center">nginx</td></tr><tr><td style="text-align:center">Nimrod</td><td style="text-align:center">nimrod</td></tr><tr><td style="text-align:center">Nix</td><td style="text-align:center">nix</td></tr><tr><td style="text-align:center">NSIS</td><td style="text-align:center">nsis</td></tr><tr><td style="text-align:center">Objective C</td><td style="text-align:center">objectivec</td></tr><tr><td style="text-align:center">OCaml</td><td style="text-align:center">ocaml</td></tr><tr><td style="text-align:center">Oxygene</td><td style="text-align:center">oxygene</td></tr><tr><td style="text-align:center">Parser 3</td><td style="text-align:center">parser3</td></tr><tr><td style="text-align:center">Perl</td><td style="text-align:center">perl</td></tr><tr><td style="text-align:center">PHP</td><td style="text-align:center">php</td></tr><tr><td style="text-align:center">PowerShell</td><td style="text-align:center">powershell</td></tr><tr><td style="text-align:center">Processing</td><td style="text-align:center">processing</td></tr><tr><td style="text-align:center">Python’s profiler output</td><td style="text-align:center">profile</td></tr><tr><td style="text-align:center">Protocol Buffers</td><td style="text-align:center">protobuf</td></tr><tr><td style="text-align:center">Puppet</td><td style="text-align:center">puppet</td></tr><tr><td style="text-align:center">Python</td><td style="text-align:center">python</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">q</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">r</td></tr><tr><td style="text-align:center">RenderMan RIB</td><td style="text-align:center">rib</td></tr><tr><td style="text-align:center">Roboconf</td><td style="text-align:center">roboconf</td></tr><tr><td style="text-align:center">RenderMan RSL</td><td style="text-align:center">rsl</td></tr><tr><td style="text-align:center">Ruby</td><td style="text-align:center">ruby</td></tr><tr><td style="text-align:center">Oracle Rules Language</td><td style="text-align:center">ruleslanguage</td></tr><tr><td style="text-align:center">Rust</td><td style="text-align:center">rust</td></tr><tr><td style="text-align:center">Scala</td><td style="text-align:center">scala</td></tr><tr><td style="text-align:center">Scheme</td><td style="text-align:center">scheme</td></tr><tr><td style="text-align:center">Scilab</td><td style="text-align:center">scilab</td></tr><tr><td style="text-align:center">SCSS</td><td style="text-align:center">scss</td></tr><tr><td style="text-align:center">Smali</td><td style="text-align:center">smali</td></tr><tr><td style="text-align:center">SmallTalk</td><td style="text-align:center">smalltalk</td></tr><tr><td style="text-align:center">SML</td><td style="text-align:center">sml</td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center">sql</td></tr><tr><td style="text-align:center">Stata</td><td style="text-align:center">stata</td></tr><tr><td style="text-align:center">STEP Part21(ISO 10303-21)</td><td style="text-align:center">step21</td></tr><tr><td style="text-align:center">Stylus</td><td style="text-align:center">stylus</td></tr><tr><td style="text-align:center">Swift</td><td style="text-align:center">swift</td></tr><tr><td style="text-align:center">Tcl</td><td style="text-align:center">tcl</td></tr><tr><td style="text-align:center">Tex</td><td style="text-align:center">tex</td></tr><tr><td style="text-align:center">text</td><td style="text-align:center">text/plain</td></tr><tr><td style="text-align:center">Thrift</td><td style="text-align:center">thrift</td></tr><tr><td style="text-align:center">Twig</td><td style="text-align:center">twig</td></tr><tr><td style="text-align:center">TypeScript</td><td style="text-align:center">typescript</td></tr><tr><td style="text-align:center">Vala</td><td style="text-align:center">vala</td></tr><tr><td style="text-align:center"><span class="exturl" data-url="aHR0cDovL1ZCLk5FVA==">VB.NET</span></td><td style="text-align:center">vbnet</td></tr><tr><td style="text-align:center">VBScript in HTML</td><td style="text-align:center">vbscript-html</td></tr><tr><td style="text-align:center">VBScript</td><td style="text-align:center">vbscript</td></tr><tr><td style="text-align:center">Verilog</td><td style="text-align:center">verilog</td></tr><tr><td style="text-align:center">VHDL</td><td style="text-align:center">vhdl</td></tr><tr><td style="text-align:center">Vim Script</td><td style="text-align:center">vim</td></tr><tr><td style="text-align:center">Intel x86 Assembly</td><td style="text-align:center">x86asm</td></tr><tr><td style="text-align:center">XL</td><td style="text-align:center">xl</td></tr><tr><td style="text-align:center">XML</td><td style="text-align:center">xml</td></tr><tr><td style="text-align:center">YAML</td><td style="text-align:center">yml</td></tr></tbody></table><h1 id="链接"><a class="anchor" href="#链接">#</a> 链接</h1><p>语句</p><ul><li><code>[]()</code></li></ul><p>测试代码:<br /> <code>[Jianky's blog](https://jiankychen.github.io/)</code></p><p>测试结果:<br /><a href="https://jiankychen.github.io/">Jianky's blog</a></p><h1 id="插入图片"><a class="anchor" href="#插入图片">#</a> 插入图片</h1><p>语句</p><ul><li><code>![]()</code></li></ul><p>测试代码:<br /> <code>![Jianky](_data/iamges/avatar.jpg)</code></p><p>测试结果:<br /><img data-src="/source/_data/images/avatar.jpg" alt="Jianky" height="100px" /></p><h1 id="注释"><a class="anchor" href="#注释">#</a> 注释</h1><p>语句</p><ul><li><code>[//]: </code></li><li><code>[comment]: </code></li><li><code>[^_^]: </code></li></ul><p>测试代码</p><pre><code>a[//]: b[comment]: cd[//]: &lt;&gt; (This is also a comment.)[//]: # (This may be the most platform independent comment)e[comment]: &lt;&gt; (This is a comment, it will not be included)[^_^]: 注意这里要另起一行，整体缩进    commentted-out contents    should be shift to right by four spaces (`&gt;&gt;`).g</code></pre><p>测试结果</p><p>a</p><p>d</p><p>e</p><p>g</p><h1 id="转义字符"><a class="anchor" href="#转义字符">#</a> 转义字符</h1><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">命名实体</th><th style="text-align:center">十进制编码</th></tr></thead><tbody><tr><td style="text-align:center">空格</td><td style="text-align:center"><code>&amp;nbsp;</code></td><td style="text-align:center"><code>&amp;#160;</code></td></tr><tr><td style="text-align:center">全角空格</td><td style="text-align:center"><code>&amp;emsp;</code></td><td style="text-align:center"><code>&amp;#12288;</code></td></tr><tr><td style="text-align:center">'</td><td style="text-align:center"><code>&amp;apos;</code></td><td style="text-align:center"><code>&amp;#39;</code></td></tr><tr><td style="text-align:center">&quot;</td><td style="text-align:center"><code>&amp;quot;</code></td><td style="text-align:center"><code>&amp;#34;</code></td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">—</td><td style="text-align:center"><code>&amp;#40;</code></td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">—</td><td style="text-align:center"><code>&amp;#41;</code></td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center"><code>&amp;lt;</code></td><td style="text-align:center"><code>&amp;#60;</code></td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center"><code>&amp;gt;</code></td><td style="text-align:center"><code>&amp;#62;</code></td></tr><tr><td style="text-align:center">[</td><td style="text-align:center">—</td><td style="text-align:center"><code>&amp;#91;</code></td></tr><tr><td style="text-align:center">]</td><td style="text-align:center">—</td><td style="text-align:center"><code>&amp;#93;</code></td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">—</td><td style="text-align:center"><code>&amp;#123;</code></td></tr><tr><td style="text-align:center">}</td><td style="text-align:center">—</td><td style="text-align:center"><code>&amp;#125;</code></td></tr><tr><td style="text-align:center">´</td><td style="text-align:center"><code>&amp;acute;</code></td><td style="text-align:center"><code>&amp;#180;</code></td></tr><tr><td style="text-align:center">°</td><td style="text-align:center"><code>&amp;deg;</code></td><td style="text-align:center"><code>&amp;#176;</code></td></tr><tr><td style="text-align:center">®</td><td style="text-align:center"><code>&amp;reg;</code></td><td style="text-align:center"><code>&amp;#174;</code></td></tr><tr><td style="text-align:center">©</td><td style="text-align:center"><code>&amp;copy;</code></td><td style="text-align:center"><code>&amp;#169;</code></td></tr></tbody></table><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTU2Njk0L2FydGljbGUvZGV0YWlscy85NjE1MzI0Nw==">markdown 转移字符</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3drZF8wMDcvYXJ0aWNsZS9kZXRhaWxzLzEyNzk5ODMyNQ==">HTML 转义字符</span></li></ul><h1 id="绘制流程图"><a class="anchor" href="#绘制流程图">#</a> 绘制流程图</h1><p>VScode 可借助插件 Markdown Preview Mermaid Support 实现流程图</p><p>流程图方向：</p><ul><li><code>TB</code>  ：top bottom - 从上到下</li><li><code>BT</code>  ：bottom top - 从下到上</li><li><code>RL</code>  ：right left - 从右到左</li><li><code>LR</code>  ：left right - 从左到右</li><li><code>TD</code>  ：等同于 TB</li></ul><p>流程块形状：</p><ul><li><code>[]</code>  ：方形</li><li><code>()</code>  ：圆角</li><li><code>(())</code>  ：圆形</li><li><code>&#123;&#125;</code>  ：菱形</li><li><code>&#123;&#123;&#125;&#125;</code>  ：六角形</li><li><code>[\\]</code>  ：平行四边形</li><li><code>[//]</code>  ：平行四边形</li></ul><p>连接线样式：</p><ul><li><code>--&gt;</code>  ：有向箭头</li><li><code>---</code>  ：无向连接线</li><li><code>-.-</code>  ：虚线</li><li><code>===</code>  ：加粗线条</li></ul><p>测试代码 1</p><pre><code>```mermaidgraph LR;    A --&gt; B;    B --&gt; X;    X --&gt; C;```</code></pre><p>测试结果 1</p><pre class="mermaid graph"><svg id="mermaid-1697907390931" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="55" style="max-width: 283.640625px;" viewBox="0 0 283.640625 55"><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-A LE-B" id="L-A-B" style="opacity: 1;"><path class="path" d="M38,27.5L63,27.5L88,27.5" marker-end="url(#arrowhead17)" style="fill:none"></path><defs><marker id="arrowhead17" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-B LE-X" id="L-B-X" style="opacity: 1;"><path class="path" d="M117.0625,27.5L142.0625,27.5L167.0625,27.5" marker-end="url(#arrowhead18)" style="fill:none"></path><defs><marker id="arrowhead18" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-X LE-C" id="L-X-C" style="opacity: 1;"><path class="path" d="M196.0625,27.5L221.0625,27.5L246.0625,27.5" marker-end="url(#arrowhead19)" style="fill:none"></path><defs><marker id="arrowhead19" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g></g><g class="nodes"><g class="node default" id="flowchart-A-6" transform="translate(23,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-15" y="-19.5" width="30" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-5,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">A</tspan></text></g></g></g><g class="node default" id="flowchart-B-7" transform="translate(102.53125,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-14.53125" y="-19.5" width="29.0625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-4.53125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">B</tspan></text></g></g></g><g class="node default" id="flowchart-X-9" transform="translate(181.5625,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-14.5" y="-19.5" width="29" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-4.5,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">X</tspan></text></g></g></g><g class="node default" id="flowchart-C-11" transform="translate(260.8515625,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-14.7890625" y="-19.5" width="29.578125" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-4.7890625,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">C</tspan></text></g></g></g></g></g></g></svg></pre><p>测试代码 2</p><pre><code>```mermaidgraph LR    1[A] --&gt; 2(B) --- 3((C)) -.- 4[/D/]```</code></pre><p>测试结果 2</p><pre class="mermaid graph"><svg id="mermaid-1697907392978" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="55" style="max-width: 320.0625px;" viewBox="0 0 320.0625 55"><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-1 LE-2" id="L-1-2" style="opacity: 1;"><path class="path" d="M38,27.5L63,27.5L88,27.5" marker-end="url(#arrowhead17)" style="fill:none"></path><defs><marker id="arrowhead17" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-2 LE-3" id="L-2-3" style="opacity: 1;"><path class="path" d="M117.0625,27.5L142.0625,27.5L167.0625,27.5" marker-end="url(#arrowhead18)" style="fill:none"></path><defs><marker id="arrowhead18" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 0 0 L 0 0 z" style="fill: #333"></path></marker></defs></g><g class="edgePath LS-3 LE-4" id="L-3-4" style="opacity: 1;"><path class="path" d="M206.0625,27.5L231.0625,27.5L266.3125,28" marker-end="url(#arrowhead19)" style="fill:none;stroke-width:2px;stroke-dasharray:3;"></path><defs><marker id="arrowhead19" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 0 0 L 0 0 z" style="fill: #333"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><text><tspan xml:space="preserve" dy="1em" x="1"></tspan></text></g></g></g><g class="nodes"><g class="node default" id="flowchart-1-4" transform="translate(23,27.5)" style="opacity: 1;"><rect rx="0" ry="0" x="-15" y="-19.5" width="30" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-5,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">A</tspan></text></g></g></g><g class="node default" id="flowchart-2-5" transform="translate(102.53125,27.5)" style="opacity: 1;"><rect rx="5" ry="5" x="-14.53125" y="-19.5" width="29.0625" height="39" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-4.53125,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">B</tspan></text></g></g></g><g class="node default" id="flowchart-3-6" transform="translate(186.5625,27.5)" style="opacity: 1;"><circle x="-14.7890625" y="-19.5" r="19.5" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.7890625,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">C</tspan></text></g></g></g><g class="node default" id="flowchart-4-7" transform="translate(284.0625,27.5)" style="opacity: 1;"><polygon points="-13,0 23.5,0 43,-39 6.5,-39" transform="translate(-15,19.5)" class="label-container"></polygon><g class="label" transform="translate(0,0)"><g transform="translate(-5,-9.5)"><text style=""><tspan xml:space="preserve" dy="1em" x="1">D</tspan></text></g></g></g></g></g></g></svg></pre><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dobGZsbHovYXJ0aWNsZS9kZXRhaWxzLzEyMTM2MDA0MA==">利用 Markdown Preview Mermaid Support 插件画流程图</span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ODY0YzFjZjU2NjA=">绘制流程图的语法</span></p><p>除  <code>Mermaid</code>  流程图外，也可以通过 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlbmdsaWx1b2h1YS9hcnRpY2xlL2RldGFpbHMvMTIxMjI5OTAz">Flowchart</span> 的方式绘制流程图</p><p>注意，hexo 默认不支持  <code>Flowchart</code>  和  <code>merimaid</code>  流程图，需要安装插件，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6aDA3MDl6bWwvYXJ0aWNsZS9kZXRhaWxzLzEwMzMxMDQwNT9zcG09MTAwMS4yMTAxLjMwMDEuNjY2MS4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMiU3RWRlZmF1bHQlN0VDVFJMSVNUJTdFUmF0ZS0xLnBjX3JlbGV2YW50X3BheWNvbHVtbl92MyZhbXA7ZGVwdGhfMS11dG1fc291cmNlPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMiU3RWRlZmF1bHQlN0VDVFJMSVNUJTdFUmF0ZS0xLnBjX3JlbGV2YW50X3BheWNvbHVtbl92MyZhbXA7dXRtX3JlbGV2YW50X2luZGV4PTE=">Hexo 引入 Mermaid</span></p><blockquote><p>shoka 主题对于流程图 mermaid 的支持暂时因 puppeteer 插件而无法正常显示，具体可见 <span class="exturl" data-url="aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUvY29tcHV0ZXItc2NpZW5jZS9ub3RlL3RoZW1lLXNob2thLWRvYy9kZXBlbmRlbnRzLw==">multi-markdown-it 安装与配置</span></p></blockquote><h1 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZG93bi1pdC5naXRodWIuaW8v">markdown demo</span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMDg3OTExNDA=">编辑器测评</span></p><p>编辑器推荐：<strong>vscode</strong>，Joplin，Typora，sublime，Moeditor</p><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPW1hcnAtdGVhbS5tYXJwLXZzY29kZQ==">Create slide deck written in Marp Markdown on VS Code.</span></p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
