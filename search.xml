<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组</title>
      <link href="/2022/03/05/19-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/05/19-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组是一种类似于标准库类型<code>vector</code>的数据结构。与<code>vector</code>相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与<code>vector</code>不同的地方是，<strong>数组的大小确定不变，不能随意向数组中增加元素</strong>。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</p><blockquote><p>如果不清楚元素的确切个数，请使用<code>vector</code>。</p></blockquote><blockquote><p>数组与<code>vector</code>的相似之处是都能存放类型相同的对象，且这些对象本身没有名字，需要通过其所在位置访问。</p><p>数组与<code>vector</code>的最大不同是，数组的大小固定不变，不能随意向数组中增加额外的元素，虽然在某些情境下运行时性能较好，但是与<code>vector</code>相比损失了灵活性。</p><p>具体来说，数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后把原数组的所有元素复制到新数组中去。我们也无法像<code>vector</code>那样使用<code>size</code>函数直接获取数组的维度。如果是字符数组，可以调用<code>strlen</code>函数得到字符串的长度；如果是其他数组，只能使用<code>sizeof(array)/sizeof(array[0])</code>的方式计算数组的维度。</p></blockquote><h1>定义和初始化内置数组</h1><p>数组是一种复合类型。数组的声明形如<code>a[d]</code>，其中<code>a</code>是数组的名字，<code>d</code>是数组的维度。维度说明了数组中元素的个数，因此<strong>必须大于<code>0</code>，必须是一个常量表达式</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned cnt = 42;          // not a constant expression</span><br><span class="line">constexpr unsigned sz = 42; // constant expression</span><br><span class="line">                            // constexpr</span><br><span class="line">int arr[10];                // array of ten ints</span><br><span class="line">int *parr[sz];              // array of 42 pointers to int</span><br><span class="line">string bad[cnt];            // error: cnt is not a constant expression</span><br><span class="line">string strs[get_size()];    // ok if get_size is constexpr, error otherwise</span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。</p><blockquote><p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p></blockquote><p><strong>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。</strong></p><p>和vector一样，<strong>数组的元素应为对象，因此不存在引用数组。</strong></p><h2 id="显式初始化数组元素">显式初始化数组元素</h2><p>可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const unsigned sz = 3;        // constant expression</span><br><span class="line">int ia1[sz] = &#123;0,1,2&#125;;        // array of three ints with values 0, 1, 2</span><br><span class="line">int a2[] = &#123;0, 1, 2&#125;;         // an array of dimension 3</span><br><span class="line">int a3[5] = &#123;0, 1, 2&#125;;        // equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;</span><br><span class="line">string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;; // same as a4[] =  &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;</span><br><span class="line">int a5[2] = &#123;0,1,2&#125;;          // error: too many initializers</span><br></pre></td></tr></table></figure><h2 id="字符数组的特殊性">字符数组的特殊性</h2><p>可以用字符串字面值对字符数组数组初始化，但一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。</p><blockquote><p>单引号内的是字符字面值，双引号内的是字符串字面值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;;       // list initialization, no null（字符字面值）</span><br><span class="line">char a2[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;, &#x27;\0&#x27;&#125;; // list initialization, explicit null（字符字面值）</span><br><span class="line">char a3[] = &quot;C++&quot;;                 // null terminator added automatically（字符串字面值）</span><br><span class="line">const char a4[6] = &quot;Daniel&quot;;       // error: no space for the null!（字符串字面值）</span><br></pre></td></tr></table></figure><p><code>a4</code>的定义是错误的：尽管字符串字面值<code>&quot;Daniel&quot;</code>看起来只有6个字符，但是数组的大小必须至少是7，其中6个位置存放字面值的内容，另外1个存放结尾处的空字符。</p><h2 id="不允许拷贝和赋值">不允许拷贝和赋值</h2><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[] = &#123;0, 1, 2&#125;; // array of three ints</span><br><span class="line">int a2[] = a;        // error: cannot initialize one array with another</span><br><span class="line">a2 = a;              // error: cannot assign one array to another</span><br></pre></td></tr></table></figure><blockquote><p>若需实现数组的拷贝和赋值，需要逐个元素依次拷贝赋值。</p></blockquote><h2 id="理解复杂的数组声明">理解复杂的数组声明</h2><p>和<code>vector</code>一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。</p><blockquote><p>不存在引用的数组（即，数组的元素不能是引用），但存在数组的引用（可以定义一个引用来绑定数组）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *ptrs[10];            //  ptrs是含有10个元素（整型指针）的数组（注：[]优先级高于*）</span><br><span class="line">int &amp;refs[10];            //  数组里边装引用？错误: 引用不是对象，不存在引用的数组（注：[]优先级高于&amp;，首先判断refs是一个维度为10的数组，数组的元素的类型是int &amp;，即，引用。由于引用不是对象，故语法错误）</span><br><span class="line">int (*Parray)[10] = &amp;arr; //  Parray指向一个含有10个整数的数组（注：()优先级高于[]。首先分析(*Parray)，可知Parray是一个指针；然后考虑右边的[10]，可知Parray指向一个维度为10的数组；最后观察左边，知道数组中的元素为int）</span><br><span class="line">int (&amp;arrRef)[10] = arr;  //  arrRef引用一个含有10个整数的数组（()优先级高于[]。arrRef是一个引用，所绑定的对象是一个维度为10的数组，数组中的元素为int）</span><br></pre></td></tr></table></figure><p>默认情况下，类型修饰符从右向左依次绑定。对于<code>ptrs</code>来说，从右向左理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字是<code>ptrs</code>，然后知道数组中存放的是指向<code>int</code>的指针。</p><p>但是对于<code>Parray</code>来说，从右向左理解就不太合理了。就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解<code>Parray</code>的含义：首先是圆括号括起来的部分，<code>*Parray</code>意味着<code>Parray</code>是个指针，接下来观察右边，可知道<code>Parray</code>是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是<code>int</code>。这样最终的含义就明白无误了，<code>Parray</code>是一个指针，它指向一个<code>int</code>数组，数组中包含10个元素。</p><p>同理，<code>(&amp;arrRef)</code>表示<code>arrRef</code>是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是<code>int</code>。</p><p>更复杂的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *(&amp;arry)[10] = ptrs; // array是数组的引用，该数组包含10个指向int的指针</span><br></pre></td></tr></table></figure><p>首先，<code>()</code>优先级高于<code>[]</code>，知道<code>arry</code>是一个引用；其次，<code>[]</code>优先级高于<code>*</code>，结合右边可知，<code>arry</code>引用的对象是一个大小为10的数组；最后观察左边知道，数组的元素的类型是指向int的指针。</p><blockquote><p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p></blockquote><h1>访问数组元素</h1><p><strong>数组的元素也能使用<code>范围for</code>语句或<code>下标运算符</code>来访问。</strong></p><p><strong>数组的索引从0开始。</strong></p><p>在使用数组下标的时候，通常将其定义为<code>size_t</code>类型。<code>size_t</code>是一种机器相关的<code>无符号类型</code>，它被设计得足够大以便能表示内存中任意对象的大小。在<code>cstddef</code>头文件中定义了<code>size_t</code>类型，这个文件是C标准库<code>stddef.h</code>头文件的C++语言版本。</p><p>数组除了大小固定这一特点外，其他用法与vector基本类似:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100</span><br><span class="line">unsigned scores[11] = &#123;&#125;; // 11 buckets, all value initialized to 0</span><br><span class="line">unsigned grade;</span><br><span class="line">while (cin &gt;&gt; grade) &#123;</span><br><span class="line">    if (grade &lt;= 100)</span><br><span class="line">        ++scores[grade/10]; // increment the counter for the current cluster</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例所用的下标运算符是由C++语言直接定义的，这个运算符能用在数组类型的运算对象上。<code>vector</code>类型所用的下标运算符是库模板<code>vector</code>定义的，只能用于<code>vector</code>类型的运算对象。</p><p>与<code>vector</code>和<code>string</code>一样，当需要遍历数组的所有元素时，最好的办法也是使用<code>范围for</code>语句:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto i : scores)      // for each counter in scores</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; &quot; &quot;;      // print the value of that counter</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>检查下标的值：数组的下标应该大于等于0而且小于数组的大小。</p><blockquote><p>要想防止数组下标越界，除了小心谨慎注意细节以及对代码进行彻底的测试之外，没有其他好办法。对于一个程序来说，即使顺利通过编译并执行，也不能肯定它不包含此类致命的错误。</p></blockquote><blockquote><p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p></blockquote><h1>指针和数组</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>可以使用下标运算符来访问<code>string</code>对象的字符或<code>vector</code>对象的元素，还有另外一种更通用的机制也可以实现同样的目的，即，<code>迭代器（iterator）</code>。</p><p>除了<code>vector</code>之外，标准库还定义了其他几种容器。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</p><blockquote><p>严格来说，string对象不属于容器类型，但是string支持很多与容器类型类似的操作。vector支持下标运算符，这点和string一样；string支持迭代器，这也和vector是一样的。</p><p><code>string</code>可以理解成<code>vector&lt;char&gt;</code></p></blockquote><p>类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者<code>string</code>对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。</p><h1>使用迭代器</h1><p>获取迭代器不是使用取地址符，有迭代器的类型同时拥有名为<code>begin</code>和<code>end</code>的成员。</p><ol><li><code>begin</code>成员负责返回指向第一个元素（或第一个字符）的迭代器</li><li><code>end</code>成员则负责返回指向容器（或<code>string</code>对象）“尾元素的下一位置”的迭代器。（一个本不存在的元素）。<code>end</code>成员返回的迭代器常被称作<strong>尾后迭代器</strong>或者简称为尾迭代器。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。</li></ol><blockquote><p>试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// the compiler determines the type of b and e</span><br><span class="line">// b denotes the first element and e denotes one past the last element in v</span><br><span class="line">auto b = v.begin(), e = v.end(); // b and e have the same type</span><br></pre></td></tr></table></figure><blockquote><p>如果容器为空，则<code>begin</code>和<code>end</code>返回的是同一个迭代器，都是尾后迭代器。</p></blockquote><p>只要我们知道其支持<code>begin</code>和<code>end</code>，就可以使用<code>auto</code>关键字来定义返回值的类型。因为一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么，利用<code>auto</code>关键字使编译器自行推断即可。</p><h2 id="迭代器运算符">迭代器运算符</h2><img src="/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/1.png" class=""><p>注意，<code>*iter</code>返回的是迭代器<code>iter</code>所指元素的引用。因此可以通过<code>*iter</code>修改<code>iter</code>所指元素的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s(&quot;some string&quot;);</span><br><span class="line">if (s.begin() != s.end()) &#123; // make sure s is not empty</span><br><span class="line">    auto it = s.begin();    // it denotes the first character in s</span><br><span class="line">    *it = toupper(*it);     // make that character uppercase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果将是：<code>Some string</code></p><p>迭代器使用递增（<code>++</code>）运算符来从一个元素移动到下一个元素。</p><p><strong>因为<code>end</code>返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</strong></p><p>例如，利用迭代器及其递增运算符可以把string对象中第一个单词改写为大写形式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// process characters in s until we run out of characters or we hit a whitespace</span><br><span class="line">for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)</span><br><span class="line">    *it = toupper(*it); // capitalize the current character</span><br></pre></td></tr></table></figure><p>输出结果将是：<code>SOME string</code></p><blockquote><p>关键概念：泛型编程</p><p>之前已经说过，只有<code>string</code>和<code>vector</code>等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了<code>==</code>和<code>!=</code>，但是它们中的大多数都没有定义<code>&lt;</code>运算符。因此，只要我们养成使用迭代器和<code>!=</code>的习惯，就不用太在意用的到底是哪种容器类型。</p></blockquote><p>使用<code>==</code>和<code>!=</code>来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否则就说这两个迭代器不相等。</p><h2 id="迭代器类型">迭代器类型</h2><p>拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it; // it can read and write vector&lt;int&gt; elements</span><br><span class="line">string::iterator it2;     // it2 can read and write characters in a string</span><br><span class="line">vector&lt;int&gt;::const_iterator it3; // it3 can read but not write elements</span><br><span class="line">string::const_iterator it4;      // it4 can read but not write characters</span><br></pre></td></tr></table></figure><p><code>const_iterator</code>和指向常量的指针差不多，能读取但不能修改它所指的元素值。相反，<code>iterator</code>的对象可读可写。</p><p>如果<code>vector</code>对象或<code>string</code>对象是一个常量，只能使用<code>const_iterator</code>；如果<code>vector</code>对象或<code>string</code>对象不是常量，那么既能使用<code>iterator</code>也能使用<code>const_iterator</code>。</p><blockquote><p>术语：迭代器和迭代器类型</p><p>迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义的迭代器类型，还可能是指某个迭代器对象。</p><p>重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。</p><p>每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套操作。</p></blockquote><h2 id="begin和end运算符">begin和end运算符</h2><p><code>begin</code>和<code>end</code>返回的具体类型由对象是否是常量决定，如果对象是常量，<code>begin</code>和<code>end</code>返回<code>const_iterator</code>；如果对象不是常量，返回<code>iterator</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v;</span><br><span class="line">const vector&lt;int&gt; cv;</span><br><span class="line">auto it1 = v.begin();  // it1 has type vector&lt;int&gt;::iterator</span><br><span class="line">auto it2 = cv.begin(); // it2 has type vector&lt;int&gt;::const_iterator</span><br></pre></td></tr></table></figure><p>有时候我们希望即使对象不是常量，我们也想使用<code>const_iterator</code>。为了便于专门得到<code>const_iterator</code>类型的返回值，C++11新标准引入了两个新函数，分别是<code>cbegin</code>和<code>cend</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto it3 = v.cbegin(); // it3 has type vector&lt;int&gt;::const_iterator</span><br></pre></td></tr></table></figure><p>类似于<code>begin</code>和<code>end</code>，上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论<code>vector</code>对象（或<code>string</code>对象）本身是否是常量，返回值都是<code>const_iterator</code>。</p><h2 id="结合解引用和成员访问操作">结合解引用和成员访问操作</h2><p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。</p><p>例如，对于一个由字符串组成的<code>vector</code>对象来说，要想检查其元素是否为空，令<code>it</code>是该<code>vector</code>对象的迭代器，只需检查<code>it</code>所指字符串是否为空就可以了，其代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">auto it = v.begin();</span><br><span class="line"></span><br><span class="line">(*it).empty(); // dereferences it and calls the member empty on the resulting object</span><br></pre></td></tr></table></figure><p>注意，<code>(*it).empty()</code>中的圆括号必不可少，该表达式的含义是先对<code>it</code>解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由<code>it</code>来执行，而非<code>it</code>解引用的结果:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*it.empty();   // error: attempts to fetch the member named empty from it, but it is an iterator and has no member named empty</span><br></pre></td></tr></table></figure><p>为了简化形如<code>(*it).empty()</code>的表达式，C++语言定义了箭头运算符（<code>-&gt;</code>）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it).mem</code>表达的意思相同。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">it-&gt;empty;     // it-&gt;mem is a synonym for (* it).mem.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// print each line in text up to the first blank line</span><br><span class="line">vector&lt;string&gt; text(3, &quot;hello the world!!&quot;);</span><br><span class="line">for (auto it = text.cbegin(); it != text.cend() &amp;&amp; !it-&gt;empty(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上述程序将输出三行<code>hello the world!!</code><br>值得注意的是，因为循环从头到尾只是读取<code>text</code>的元素而未向其中写值，所以使用了<code>cbegin</code>和<code>cend</code>来控制整个迭代过程。</p><h2 id="某些对vector对象的操作会使迭代器失效">某些对vector对象的操作会使迭代器失效</h2><p>虽然<code>vector</code>对象可以动态地增长，但是也会有一些副作用。</p><ol><li>一个限制是不能在<code>范围for</code>循环中向<code>vector</code>对象添加元素。</li><li>另外一个限制是任何一种可能改变<code>vector</code>对象容量的操作，比如<code>push_back</code>，都会使该<code>vector</code>对象的迭代器失效。</li></ol><blockquote><p>谨记，<strong>但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</strong></p></blockquote><h1>迭代器运算</h1><p>迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都有支持递增运算的迭代器。类似的，也能用<code>==</code>和<code>!=</code>对任意标准库类型的两个有效迭代器进行比较。</p><p><code>string</code>和<code>vector</code>的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算（iterator arithmetic），其细节由表3.7列出。</p><img src="/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/2.png" class=""><p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为<code>difference_type</code>的带符号整型数。<code>string</code>和<code>vector</code>都定义了<code>difference_type</code>，因为这个距离可正可负，所以<code>difference_type</code>是带符号类型的。</p><blockquote><p>使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜索完成；如果不是，假如该元素小于要找的元素，则在序列的后半部分继续搜素；假如该元素大于要找的元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中间元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜索。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// text must be sorted</span><br><span class="line">// beg and end will denote the range we&#x27;re searching</span><br><span class="line">auto beg = text.begin(), end = text.end();</span><br><span class="line">auto mid = text.begin() + (end - beg)/2; // original midpoint</span><br><span class="line">// while there are still elements to look at and we haven&#x27;t yet found sought</span><br><span class="line">while (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line">    if (sought &lt; *mid)     // is the element we want in the first half?</span><br><span class="line">        end = mid;         // if so, adjust the range to ignore the second half</span><br><span class="line">    else                   // the element we want is in the second half</span><br><span class="line">        beg = mid + 1;     // start looking with the element just after mid</span><br><span class="line">    mid = beg + (end - beg)/2;  // new midpoint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的一开始定义了三个迭代器：beg指向搜索范围内的第一个元素、end指向尾元素的下一位置、mid指向中间的那个元素。初始状态下，搜索范围是名为text的vector<string>的全部范围。</p><p>循环部分先检查搜索范围是否为空，如果mid和end的当前值相等，说明已经找遍了所有元素。此时条件不满足，循环终止。当搜索范围不为空时，可知mid指向了某个元素，检查该元素是否就是我们所要搜索的，如果是，也终止循环。</p><p>当进入到循环体内部后，程序通过某种规则移动beg或者end来缩小搜索的范围。如果mid所指的元素比要找的元素sought大，可推测若text含有sought，则必出现在mid所指元素的前面。此时，可以忽略mid后面的元素不再查找，并把mid赋给end即可。另一种情况，如果＊mid比sought小，则要找的元素必出现在mid所指元素的后面。此时，通过令beg指向mid的下一个位置即可改变搜索范围。因为已经验证过mid不是我们要找的对象，所以在接下来的搜索中不必考虑它。</p><p>循环过程终止时，mid或者等于end或者指向要找的元素。如果mid等于end，说明text中没有我们要找的元素。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iterator </tag>
            
            <tag> const_iterator </tag>
            
            <tag> begin </tag>
            
            <tag> end </tag>
            
            <tag> cbegin </tag>
            
            <tag> cend </tag>
            
            <tag> 箭头运算符 </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库类型vector</title>
      <link href="/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/"/>
      <url>/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/</url>
      
        <content type="html"><![CDATA[<p>标准库类型<code>vector</code>表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为<code>vector</code>“容纳着”其他对象，所以它也常被称作<code>容器（container）</code>。</p><p>要想使用vector，必须包含适当的头文件:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure><p>C++语言既有类模板（class template），也有函数模板，其中<code>vector</code>是一个类模板。</p><p><code>vector</code>是模板而非类型，由<code>vector</code>生成的类型必须包含<code>vector</code>中元素的类型，例如<code>vector&lt;int&gt;</code>, <code>vector&lt;vector&lt;int&gt;&gt;</code>。</p><blockquote><p>组成<code>vector</code>的元素也可以是<code>vector</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;             // ivec holds objects of type int</span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec; // holds Sales_items</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; file;  // vector whose elements are vectors</span><br></pre></td></tr></table></figure><p>引用不是对象，所以不存在包含引用的<code>vector</code>。</p><h1>定义和初始化vector对象</h1><img src="/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/1.png" class=""><p>可以默认初始化<code>vector</code>对象，从而创建一个指定类型的空<code>vector</code>。</p><p>之前已经讲过，C++语言提供了几种不同的初始化方式。在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。目前已经介绍过的两种例外情况是：其一，使用拷贝初始化时（即使用<code>=</code>时），只能提供一个初始值；其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;  // list initialization</span><br><span class="line">vector&lt;string&gt; v2(&quot;a&quot;, &quot;an&quot;, &quot;the&quot;);  // error</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v3(10, 1); // v3 has ten elements with value 1</span><br><span class="line">vector&lt;int&gt; v4&#123;10, 1&#125;; // v4 has two elements with values 10 and 1</span><br></pre></td></tr></table></figure><h1>向vector对象中添加元素</h1><p>根据上述初始化<code>vector</code>对象的方法可知，<code>vector</code>对象直接初始化的方式适用于三种情况：初始值已知且数量较少、初始值是另一个<code>vector</code>对象的副本、所有元素的初始值都一样。</p><p>对于一般情况，可以先创建一个空<code>vector</code>，然后在运行时再利用<code>vector</code>的成员函数<code>push_back</code>向其中添加元素。<code>push_back</code>负责把一个值当成<code>vector</code>对象的尾元素“压到（push）”<code>vector</code>对象的“尾端（back）”。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v2;        // empty vector</span><br><span class="line">for (int i = 0; i != 100; ++i)</span><br><span class="line">    v2.push_back(i);    // append sequential integers to v2</span><br><span class="line">// at end of loop v2 has 100 elements, values 0 . . . 99</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// read words from the standard input and store them as elements in a vector</span><br><span class="line">string word;</span><br><span class="line">vector&lt;string&gt; text;       // empty vector</span><br><span class="line">while (cin &gt;&gt; word) &#123;</span><br><span class="line">    text.push_back(word);  // append word to text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++标准要求<code>vector</code>应该能在运行时高效快速地添加元素。因此既然<code>vector</code>对象能高效地增长，那么在定义<code>vector</code>对象的时候设定其大小也就没什么必要了，事实上如果这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的<code>vector</code>对象，再在运行时向其中添加具体值。</p><p>特别需要注意一点：如果循环体内部包含有向<code>vector</code>对象添加元素的语句，则不能使用<code>范围for</code>循环。</p><blockquote><p><code>范围for</code>语句体内不应改变其所遍历序列的大小。</p></blockquote><h1>其他vector操作</h1><p>除了push_back之外，vector还提供了几种其他操作，大多数都和string的相关操作类似:</p><img src="/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/2.png" class=""><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">for (auto &amp;i : v)     // for each element in v (note: i is a reference)</span><br><span class="line">    i *= i;           // square the element value</span><br><span class="line">for (auto i : v)      // for each element in v</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; &quot; &quot;; // print the element</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><code>vector</code>的<code>empty</code>和<code>size</code>两个成员与<code>string</code>的同名成员功能完全一致：<code>empty</code>检查<code>vector</code>对象是否包含元素然后返回一个布尔值；<code>size</code>则返回<code>vector</code>对象中元素的个数，返回值的类型是由<code>vector</code>定义的<code>size_type</code>类型。</p><p>要使用<code>size_type</code>，需首先指定它是由哪种类型定义的。<code>vector</code>对象的类型总是包含着元素的类型:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt;::size_type // ok</span><br><span class="line">vector::size_type      // error</span><br></pre></td></tr></table></figure><p>各个相等性运算符和关系运算符也与<code>string</code>的相应运算符功能一致。</p><p>使用下标运算符能获取到指定的元素。<code>vector</code>对象的下标也是从0开始计起，下标的类型是相应的<code>size_type</code>类型。此外，也能通过计算得到<code>vector</code>内对象的索引，然后直接获取索引位置上的元素。</p><p>假设有一组成绩的集合，其中成绩的取值是从0到100。以10分为一个分数段，要求统计各个分数段各有多少个成绩:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// count the number of grades by clusters of ten: 0--9, 10--19, . .. 90--99, 100</span><br><span class="line">vector&lt;unsigned&gt; scores(11, 0); // 11 buckets, all initially 0</span><br><span class="line">unsigned grade;</span><br><span class="line">while (cin &gt;&gt; grade) &#123;      // read the grades</span><br><span class="line">    if (grade &lt;= 100)       // handle only valid grades</span><br><span class="line">        ++scores[grade/10]; // increment the counter for the current cluster</span><br><span class="line">cout &lt;&lt; scores &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的成绩如下：<code>42 65 95 100 39 67 95 76 88 76 83 92 76 93</code><br>则输出的结果应该是：<code>0 0 0 1 1 0 2 3 2 4 1</code></p><blockquote><p>使用下标的时候必须清楚地知道它是否在合理范围。</p></blockquote><p>不能通过<code>vector</code>对象的下标形式来添加元素:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;   // empty vector</span><br><span class="line">for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)</span><br><span class="line">    ivec[ix] = ix;  // disaster: ivec has no elements</span><br></pre></td></tr></table></figure><p>这段代码是错误的：<code>ivec</code>是一个空<code>vector</code>，根本不包含任何元素，当然也就不能通过下标去访问任何元素！如前所述，正确的方法是使用<code>push_back</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)</span><br><span class="line">    ivec.push_back(ix);  // ok: adds a new element with value ix</span><br></pre></td></tr></table></figure><p>注意，这里不能使用范围for语句，只能使用传统的for循环。因为<code>vector</code>序列长度改变</p><p><strong><code>vector</code>对象（以及<code>string</code>对象）的<code>下标运算符</code>可用于访问已存在的元素，而不能用于添加元素。</strong></p><p>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出（buffer overflow）指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。</p><p>因此，<strong>如需要对<code>vector</code>对象或<code>string</code>对象使用for语句，则尽量使用范围for，以免溢出。</strong></p><p><a href="https://weread.qq.com/web/reader/ff732fe072021a24ff7bb24k341323f021e34173cb3824c">原文：标准库类型vector</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 范围for </tag>
            
            <tag> 下标运算符 </tag>
            
            <tag> vector </tag>
            
            <tag> push_back </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库类型string</title>
      <link href="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/"/>
      <url>/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/</url>
      
        <content type="html"><![CDATA[<p>标准库类型<code>string</code>表示可变长的字符序列，<strong>使用<code>string</code>类型必须首先包含<code>string</code>头文件</strong>。作为标准库的一部分，<strong><code>string</code>定义在命名空间<code>std</code>中</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using std::string;</span><br></pre></td></tr></table></figure><h1>定义和初始化string对象</h1><img src="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/1.png" class=""><p>拷贝初始化（copy initialization）: 使用等号（<code>=</code>）初始化一个变量，编译器把等号右侧的初始值拷贝到新创建的对象中去。</p><p>直接初始化（direct initialization）: 不使用等号。</p><p><code>string</code>接受无参数的初始化方式，所以<strong>不论<code>string</code>对象定义在函数内还是函数外，默认初始化都是得到空串。</strong></p><p>如果提供了一个<strong>字符串字面值</strong>，则该字面值中<strong>除了最后那个空字符外</strong>的其他所有字符都被拷贝到新创建的<code>string</code>对象中去。</p><h1>string对象上的操作</h1><p><code>string</code>对象的大多数操作：</p><img src="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/2.png" class=""><blockquote><p><code>is&gt;&gt;s</code>读取时不包括空格符；<code>getline(is,s)</code>读取整行，包含空格符。</p></blockquote><h2 id="读写string对象">读写string对象</h2><p>可以使用IO操作符读写<code>string</code>对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Note: #include and using declarations must be added to compile this code</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;          // empty string</span><br><span class="line">    cin &gt;&gt; s;          // read a whitespace-separated string into s</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl; // write s to the output</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</strong></p></blockquote><p>如上所述，如果程序的输入是“　　Hello World！　　”（注意开头和结尾处的空格），则输出将是“Hello”，输出结果中没有任何空格。</p><p>和内置类型的输入输出操作一样，<code>string</code>对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写在一起：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2; // read first input into s1, second into s2</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; // write both strings</span><br></pre></td></tr></table></figure><p>假设给上面这段程序输入与之前一样的内容“ Hello World! ”，输出将是“HelloWorld!”。</p><h2 id="读取未知数量的string对象">读取未知数量的string对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    string word;</span><br><span class="line">    while (cin &gt;&gt; word)       // read until end-of-file</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl; // write each word followed by a new line</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦遇到文件结束标记或非法输入，循环也就结束了。</p><h2 id="使用getline读取一整行">使用getline读取一整行</h2><p><strong><code>getline</code>能在最终得到的字符串中保留输入时的空白符。</strong></p><p><code>getline</code>函数的参数是一个输入流和一个<code>string</code>对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个<code>string</code>对象中去（注意不存换行符）。</p><p><strong><code>getline</code>只要一遇到换行符就结束读取操作并返回结果</strong>，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空<code>string</code>。</p><p>和输入运算符一样，<code>getline</code>也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用<code>getline</code>的结果作为条件。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string line;</span><br><span class="line">    // read input a line at a time until end-of-file</span><br><span class="line">    while (getline(cin, line))</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>触发<code>getline</code>函数返回的那个换行符实际上被丢弃掉了，得到的<code>string</code>对象中并不包含该换行符。</strong></p></blockquote><h2 id="string-size-type类型">string::size_type类型</h2><p><code>size</code>函数返回<code>string</code>对象的长度（即<code>string</code>对象中字符的个数），返回的是一个<code>string::size_type</code>类型的值。</p><blockquote><p><code>string</code>类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型<code>size_type</code>即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字<code>size_type</code>是在类<code>string</code>中定义的。</p></blockquote><p><code>string::size_type</code>类型的对象，是一个无符号类型的值，而且能足够存放下任何<code>string</code>对象的大小。<strong>所有用于存放<code>string</code>类的<code>size</code>函数返回值的变量，都应该是<code>string::size_type</code>类型的。</strong></p><p>在C++11新标准中，允许编译器通过<code>auto</code>或者<code>decltype</code>来推断变量的类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto len = line.size(); // len has type string::size_type</span><br></pre></td></tr></table></figure><p>由于<code>size</code>函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int，则表达式<code>s.size()&lt;n</code>的判断结果几乎肯定是<code>true</code>。这是因为负值n会自动地转换成一个比较大的无符号值。</p><blockquote><p>如果一条表达式中已经有了<code>size()</code>函数就不要再使用<code>int</code>了，这样可以避免混用<code>int</code>和<code>unsigned</code>可能带来的问题。</p></blockquote><h2 id="比较string对象">比较string对象</h2><p><code>string</code>类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较<code>string</code>对象中的字符，并且对大小写敏感。</p><p>相等性运算符（<code>==</code>和<code>！=</code>）、关系运算符（<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>）都依照（大小写敏感的）字典顺序：</p><ol><li>如果两个<code>string</code>对象的长度不同，而且较短<code>string</code>对象的每个字符都与较长<code>string</code>对象对应位置上的字符相同，就说较短<code>string</code>对象小于较长string对象。</li><li>如果两个<code>string</code>对象在某些对应的位置上不一致，则<code>string</code>对象比较的结果其实是<code>string</code>对象中第一对相异字符比较的结果。</li></ol><h2 id="为string对象赋值">为string对象赋值</h2><p>对于string类而言，允许把一个对象的值赋给另外一个对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string st1(10, &#x27;c&#x27;), st2; // st1 is cccccccccc; st2 is an empty string</span><br><span class="line">st1 = st2; // assignment: replace contents of st1 with a copy of st2</span><br><span class="line">           // both st1 and st2 are now the empty string</span><br></pre></td></tr></table></figure><h2 id="两个string对象相加">两个string对象相加</h2><p>两个<code>string</code>对象相加得到一个新的<code>string</code>对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s1  = &quot;hello, &quot;, s2 = &quot;world\n&quot;;</span><br><span class="line">string s3 = s1 + s2;   // s3 is hello, world\n</span><br><span class="line">s1 += s2;   // equivalent to s1 = s1 + s2</span><br></pre></td></tr></table></figure><h2 id="字面值和string对象相加">字面值和string对象相加</h2><p>标准库允许把字符字面值和字符串字面值转换成<code>string</code>对象，所以在需要<code>string</code>对象的地方就可以使用这两种字面值来替代。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s1 = &quot;hello&quot;, s2 = &quot;world&quot;; // no punctuation in s1 or s2</span><br><span class="line">string s3 = s1 + &quot;, &quot; + s2 + &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure><p>当把<code>string</code>对象和字符字面值及字符串字面值混在一条语句中使用时，<strong>必须确保每个加法运算符（<code>+</code>）的两侧的运算对象至少有一个是<code>string</code></strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s4 = s1 + &quot;, &quot;;           // ok: adding a string and a literal</span><br><span class="line">string s5 = &quot;hello&quot; + &quot;, &quot;;      // error: no string operand</span><br><span class="line">string s6 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has a string operand, equivalent to string s6 = (s1 + &quot;, &quot;) + &quot;world&quot;;</span><br><span class="line">string s7 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can&#x27;t add string literals, equivalent to string s7 = (&quot;hello&quot; + &quot;, &quot;) + s2;</span><br></pre></td></tr></table></figure><blockquote><p>因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型<code>string</code>的对象。切记，字符串字面值与<code>string</code>是不同的类型。</p></blockquote><h1>处理string对象中的字符</h1><p>我们经常需要单独处理<code>string</code>对象中的字符，比如检查一个<code>string</code>对象是否包含空白，或者把<code>string</code>对象中的字母改成小写，再或者查看某个特定的字符是否出现等。</p><p>这类处理的一个关键问题是如何获取字符本身。另一个关键问题是要知道能改变某个字符的特性。</p><p>在cctype头文件中定义了一组标准库函数处理这部分工作:</p><img src="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/3.png" class=""><blockquote><p>建议：使用C++版本的C标准库头文件<br>C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如<code>name.h</code>，C++则将这些文件命名为<code>cname</code>。也就是去掉了<code>.h</code>后缀，而在文件名<code>name</code>之前添加了字母<code>c</code>，这里的<code>c</code>表示这是一个属于C语言标准库的头文件。<br>一般来说，C++程序应该使用名为<code>cname</code>的头文件而不使用<code>name.h</code>的形式。在名为<code>cname</code>的头文件中定义的名字从属于命名空间<code>std</code>，而定义在名为<code>.h</code>的头文件中的则不然。</p></blockquote><h2 id="使用基于范围的for语句处理每个字符">使用基于范围的for语句处理每个字符</h2><p>C++11新标准提供的一种语句：<code>范围for（rangefor）</code>语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>其中，<code>expression</code>部分是一个对象，用于表示一个序列。<code>declaration</code>部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，<code>declaration</code>部分的变量会被初始化为<code>expression</code>部分的下一个元素值。</p><p>一个<code>string</code>对象表示一个字符的序列，因此<code>string</code>对象可以作为<code>范围for</code>语句中的<code>expression</code>部分。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string str(&quot;some string&quot;);</span><br><span class="line">// print the characters in str one character to a line</span><br><span class="line">for (auto c : str)      // for every char in str</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  // print the current character followed by a newline</span><br></pre></td></tr></table></figure><p><code>for</code>循环把变量<code>c</code>和<code>str</code>联系了起来，其中我们定义循环控制变量的方式与定义任意一个普通变量是一样的。此例中，通过使用<code>auto</code>关键字让编译器来决定变量<code>c</code>的类型，这里<code>c</code>的类型是<code>char</code>。每次迭代，<code>str</code>的下一个字符被拷贝给<code>c</code>，因此该循环可以读作“对于字符串<code>str</code>中的每个字符<code>c</code>，”执行某某操作。此例中的“某某操作”即输出一个字符，然后换行。</p><p>举个稍微复杂一点的例子，使用<code>范围for</code>语句和<code>ispunct</code>函数来统计<code>string</code>对象中标点符号的个数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s(&quot;Hello World!!!&quot;);</span><br><span class="line">// punct_cnt has the same type that s.size returns; see § 2.5.3 (p. 70)</span><br><span class="line">decltype(s.size()) punct_cnt = 0;</span><br><span class="line">// count the number of punctuation characters in s</span><br><span class="line">for (auto c : s)        // for every char in s</span><br><span class="line">    if (ispunct(c))     // if the character is punctuation</span><br><span class="line">        ++punct_cnt;    // increment the punctuation counter</span><br><span class="line">cout &lt;&lt; punct_cnt</span><br><span class="line">     &lt;&lt; &quot; punctuation characters in &quot; &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>程序的输出结果将是：<code>3 punctuation characters in Hello World!!!</code><br>这里我们使用<code>decltype</code>关键字声明计数变量<code>punct_cnt</code>，它的类型是<code>s.size</code>函数返回值的类型，也就是<code>string：：size_type</code>。</p><h2 id="使用范围for语句改变字符串中的字符">使用范围for语句改变字符串中的字符</h2><p>如果想要改变<code>string</code>对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。</p><p>假设我们想要把字符串改写为大写字母的形式。为了做到这一点可以使用标准库函数<code>toupper</code>，该函数接收一个字符，然后输出其对应的大写形式。这样，为了把整个<code>string</code>对象转换成大写，只要对其中的每个字符调用<code>toupper</code>函数并将结果再赋给原字符就可以了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s(&quot;Hello World!!!&quot;);</span><br><span class="line">// convert s to uppercase</span><br><span class="line">for (auto &amp;c : s)   // for every char in s (note: c is a reference)</span><br><span class="line">    c = toupper(c); // c is a reference, so the assignment changes the char in s</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上述代码的输出结果将是：<code>HELLO WORLD!!!</code><br>每次迭代时，变量<code>c</code>引用<code>string</code>对象<code>s</code>的下一个字符，赋值给<code>c</code>也就是在改变<code>s</code>中对应字符的值。</p><h2 id="只处理一部分字符">只处理一部分字符</h2><p>如果要处理string对象中的每一个字符，使用<code>范围for</code>语句是个好主意。然而，有时我们需要访问的只是其中一个字符，或者访问多个字符但遇到某个条件就要停下来。</p><p>要想访问<code>string</code>对象中的单个字符有两种方式：</p><ol><li>使用下标</li><li>使用迭代器</li></ol><p>下标运算符（<code>[ ]</code>）接收的输入参数是<code>string::size_type</code>类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。</p><p><strong><code>string</code>对象的下标从0计起。</strong></p><blockquote><p><code>string</code>对象的下标必须大于等于0而小于<code>s.size()</code>。因为string对象的下标从0计起，最后一个字符的下标应该是<code>s.size() - 1</code>。使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问空<code>string</code>也会引发不可预知的结果。因此，只要对<code>string</code>对象使用了下标，都要确认在那个位置上确实有值。</p></blockquote><p>下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由<code>string::size_type</code>表达的无符号类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!s.empty())            // make sure there&#x27;s a character to print</span><br><span class="line">    cout &lt;&lt; s[0] &lt;&lt; endl;  // print the first character in s</span><br></pre></td></tr></table></figure><p>只要字符串未被<code>const</code>限定符限制为常量，就能利用下标运算符为字符串中指定位置的字符赋新值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s(&quot;some string&quot;);</span><br><span class="line">if (!s.empty())             // make sure there&#x27;s a character in s[0]</span><br><span class="line">    s[0] = toupper(s[0]);   // assign a new value to the first character in s</span><br></pre></td></tr></table></figure><p>程序的输出结果将是：<code>Some string</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// process characters in s until we run out of characters or we hit a whitespace</span><br><span class="line">for (decltype(s.size()) index = 0;</span><br><span class="line">     index != s.size() &amp;&amp; !isspace(s[index]); ++index)</span><br><span class="line">        s[index] = toupper(s[index]); // capitalize the current character</span><br></pre></td></tr></table></figure><p>程序的输出结果将是：<code>SOME string</code><br>在上述程序中，<code>for</code>循环使用变量<code>index</code>作为<code>s</code>的下标，<code>index</code>的类型是由<code>decltype</code>关键字决定的。首先把<code>index</code>初始化为<code>0</code>，这样第一次迭代就会从<code>s</code>的首字符开始；之后每次迭代将<code>index</code>加1以得到<code>s</code>的下一个字符。循环体负责将当前的字母改写为大写形式。</p><p>需要注意的是，上例使用了逻辑与运算符（<code>&amp;&amp;</code>）。如果参与运算的两个运算对象都为真，则逻辑与结果为真；否则结果为假。对这个运算符来说最重要的一点是，C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。如上例所示，这条规定确保了只有当下标取值在合理范围之内时才会真的用此下标去访问字符串。也就是说，只有在<code>index</code>达到<code>s.size()</code>之前才会执行<code>s[index]</code>。</p><p>再次强调，注意检查下标的合法性。一种简便易行的方法是，<strong>总是设下标的类型为<code>string::size_type</code></strong>，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于<code>size()</code>的值就可以了。</p><h2 id="使用下标执行随机访问">使用下标执行随机访问</h2><p>直接获取对应位置的字符，而不是从前往后依次访问。</p><p>编写一个程序把0到15之间的十进制数转换成对应的十六进制形式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const string hexdigits = &quot;0123456789ABCDEF&quot;; // possible hex digits (Note that it is a const string.)</span><br><span class="line">cout &lt;&lt; &quot;Enter a series of numbers between 0 and 15&quot;</span><br><span class="line">     &lt;&lt; &quot; separated by spaces. Hit ENTER when finished: &quot;</span><br><span class="line">     &lt;&lt; endl;</span><br><span class="line">string result;        // will hold the resulting hexify&#x27;d string</span><br><span class="line">string::size_type n;  // hold numbers from the input</span><br><span class="line">while (cin &gt;&gt; n)</span><br><span class="line">    if (n &lt; hexdigits.size())    // ignore invalid input</span><br><span class="line">        result += hexdigits[n];  // fetch the indicated hex digit</span><br><span class="line">cout &lt;&lt; &quot;Your hex number is: &quot; &lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>假设输入的内容如下：<code>12 0 5 15 8 15</code><br>程序的输出结果将是：<code>Your hex number is: C05F8F</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> 范围for </tag>
            
            <tag> 下标运算符 </tag>
            
            <tag> string::size_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命名空间的using声明</title>
      <link href="/2022/03/03/15-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E/"/>
      <url>/2022/03/03/15-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><code>std::cin</code>的意思就是要使用命名空间<code>std</code>中的名字<code>cin</code>。</p><p><code>using</code>声明具有如下的形式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace::name;</span><br></pre></td></tr></table></figure><p>一旦声明了上述语句，就可以直接访问命名空间中的名字。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// using declaration; when we use the name cin, we get the one from the namespace std</span><br><span class="line">using std::cin;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    cin &gt;&gt; i;       // ok: cin is a synonym for std::cin</span><br><span class="line">    cout &lt;&lt; i;      // error: no using declaration; we must use the full name</span><br><span class="line">    std::cout &lt;&lt; i; // ok: explicitly use cout from namepsace std</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>每个名字都需要独立的using声明</h1><p>按照规定，每个<code>using</code>声明引入命名空间中的一个成员。因此，用到的每个名字都必须有自己的声明语句，而且<strong>每句话都得以分号结束。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// using declarations for names from the standard library</span><br><span class="line">using std::cin;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; endl;</span><br><span class="line">    int v1, v2;</span><br><span class="line">    cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2</span><br><span class="line">         &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>头文件不应包含using声明</h1><p>位于头文件的代码一般来说不应该使用<code>using</code>声明。</p><blockquote><p>因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个<code>using</code>声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 头文件 </tag>
            
            <tag> using声明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>术语表-Chapter2</title>
      <link href="/2022/03/02/14-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter2/"/>
      <url>/2022/03/02/14-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter2/</url>
      
        <content type="html"><![CDATA[<p><code>地址（address）</code>：是一个数字，根据它可以找到内存中的一个字节。</p><p><code>别名声明（alias declaration）</code>：为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词。</p><p><code>算术类型（arithmetic type）</code>：布尔值、字符、整数、浮点数等内置类型。</p><p><code>数组（array）</code>：是一种数据结构，存放着一组未命名的对象，可以通过索引来访问这些对象。</p><p><code>auto</code>：是一个类型说明符，通过变量的初始值来推断变量的类型。</p><p><code>基本类型（base type）</code>：是类型说明符，可用<code>const</code>修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符。</p><p><code>绑定（bind）</code>：令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。</p><p><code>字节（byte）</code>：内存中可寻址的最小单元，大多数机器的字节占8位。</p><p><code>类成员（class member）</code>：类的组成部分。</p><p><code>复合类型（compound type）</code>：是一种类型，它的定义以其他类型为基础。</p><p><code>const</code>：是一种类型修饰符，用于说明永不改变的对象。<code>const</code>对象一旦定义就无法再赋新值，所以必须初始化。</p><p><code>常量指针（const pointer）</code>：是一种指针，它的值永不改变。</p><p><code>常量引用（const reference）</code>：是一种习惯叫法，含义是指向常量的引用。</p><p><code>常量表达式（const expression）</code>：能在编译时计算并获取结果的表达式。</p><p><code>constexpr</code>：是一种函数，用于代表一条常量表达式。</p><p><code>转换（conversion）</code>：一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换。</p><p><code>数据成员（data member）</code>：组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。</p><p><code>声明（declaration）</code>：声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用。</p><p><code>声明符（declarator）</code>：是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。</p><p><code>decltype</code>：是一个类型说明符，从变量或表达式推断得到类型。</p><p><code>默认初始化（default initialization）</code>：当对象未被显式地赋予初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值。</p><p><code>定义（definition）</code>：为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用。</p><p><code>转义序列（escape sequence）</code>：字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数。</p><p><code>全局作用域（global scope）</code>：位于其他所有作用域之外的作用域。</p><p><code>头文件保护符（header guard）</code>：使用预处理变量以防止头文件被某个文件重复包含。</p><p><code>标识符（identifier）</code>：组成名字的字符序列，标识符对大小写敏感。</p><p><code>类内初始值（in-class initializer）</code>：在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内。</p><p><code>在作用域内（in scope）</code>：名字在当前作用域内可见。</p><p><code>被初始化（initialized）</code>：变量在定义的同时被赋予初始值，变量一般都应该被初始化。</p><p><code>内层作用域（inner scope）</code>：嵌套在其他作用域之内的作用域。</p><p><code>整型（integral type）</code>：参见算术类型。</p><p><code>列表初始化（list initialization）</code>：利用花括号把一个或多个初始值放在一起的初始化形式。</p><p><code>字面值（literal）</code>：是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值。</p><p><code>局部作用域（local scope）</code>：是块作用域的习惯叫法。</p><p><code>底层const（low-level const）</code>：一个不属于顶层的<code>const</code>，类型如果由底层常量定义，则不能被忽略。</p><p><code>成员（member）</code>：类的组成部分。</p><p><code>不可打印字符（nonprintable character）</code>：不具有可见形式的字符，如控制符、退格、换行符等。</p><p><code>空指针（null pointer）</code>：值为0的指针，空指针合法但是不指向任何对象。</p><p><code>nullptr</code>：是表示空指针的字面值常量。</p><p><code>对象（object）</code>：是内存的一块区域，具有某种类型，变量是命名了的对象。</p><p><code>外层作用域（outer scope）</code>：嵌套着别的作用域的作用域。</p><p><code>指针（pointer）</code>：是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0。</p><p><code>指向常量的指针（pointer to const）</code>：是一个指针，存放着某个常量对象的地址。指向常量的指针不能用来改变它所指对象的值。</p><p><code>预处理器（preprocessor）</code>：在C++编译过程中执行的一段程序。</p><p><code>预处理变量（preprocessor variable）</code>：由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。</p><p><code>引用（reference）</code>：是某个对象的别名。</p><p><code>对常量的引用（reference to const）</code>：是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。</p><p><code>作用域（scope）</code>：是程序的一部分，在其中某些名字有意义。</p><p>C++有几级作用域：全局、类、块</p><p><code>全局（global）</code>——名字定义在所有其他作用域之外。</p><p><code>类（class）</code>——名字定义在类内部。命名空间（namespace）——名字定义在命名空间内部。</p><p><code>块（block）</code>——名字定义在块内部。名字从声明位置开始直至声明语句所在的作用域末端为止都是可用的。</p><p><code>分离式编译（separate compilation）</code>：把程序分割为多个单独文件的能力。</p><p><code>带符号类型（signed）</code>：保存正数、负数或0的整型。</p><p><code>字符串（string）</code>：是一种库类型，表示可变长字符序列。</p><p><code>struct</code>：是一个关键字，用于定义类。</p><p><code>临时值（temporary）</code>：编译器在计算表达式结果时创建的无名对象。为某表达式创建了一个临时值，则此临时值将一直存在直到包含有该表达式的最大的表达式计算完成为止。</p><p><code>顶层const（top-level const）</code>：是一个<code>const</code>，规定某对象的值不能改变。</p><p><code>类型别名（type alias）</code>：是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义。</p><p><code>类型检查（type checking）</code>：是一个过程，编译器检查程序使用某给定类型对象的方式与该类型的定义是否一致。</p><p><code>类型说明符（type specifier）</code>：类型的名字。</p><p><code>typedef</code>：为某类型定义一个别名。当关键字<code>typedef</code>作为声明的基本类型出现时，声明中定义的名字就是类型名。</p><p><code>未定义（undefined）</code>：即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题。</p><p><code>未初始化（uninitialized）</code>：变量已定义但未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为。</p><p><code>无符号类型（unsigned）</code>：保存大于等于0的整型。</p><p><code>变量（variable）</code>：命名的对象或引用。C++语言要求变量要先声明后使用。</p><p><code>void*</code>：可以指向任意非常量的指针类型，不能执行解引用操作。</p><p><code>void类型</code>：是一种有特殊用处的类型，既无操作也无值。不能定义一个<code>void</code>类型的变量。</p><p><code>字（word）</code>：在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节。</p><p><code>&amp;运算符（&amp;operator）</code>：取地址运算符。</p><p><code>*运算符（* operator）</code>：解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。</p><p><code>#define</code>：是一条预处理指令，用于定义一个预处理变量。</p><p><code>#endif</code>：是一条预处理指令，用于结束一个<code>#ifdef</code>或<code>#ifndef</code>区域。</p><p><code>#ifdef</code>：是一条预处理指令，用于判断给定的变量是否已经定义。</p><p><code>#ifndef</code>：是一条预处理指令，用于判断给定的变量是否尚未定义。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义数据结构</title>
      <link href="/2022/03/02/13-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/02/13-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p><p>C++语言允许用户以类的形式自定义数据类型，而库类型<code>string</code>、<code>istream</code>、<code>ostream</code>等也都是以类的形式定义的。</p><h1>定义Sales_data类型</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Sales_data</span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold = 0;</span><br><span class="line">    double revenue = 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的类以关键字<code>struct</code>开始，紧跟着类名和类体（其中类体部分可以为空）。类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。</p><p><strong>类体右侧的表示结束的花括号后必须写一个分号</strong>，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Sales_data &#123; /* ... */ &#125; accum, trans, *salesptr; // equivalent, but better way to define these objects</span><br><span class="line">struct Sales_data &#123; /* ... */ &#125;;</span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure><p>分号表示声明符（通常为空）的结束。</p><p>一般来说，最好不要把对象的定义和类的定义放在一起。</p><p>用户也可以使用C++语言提供的另外一个关键字<code>class</code>来定义自己的数据结构。</p><p>类的定义可以与<code>main</code>函数放在同一个文件内，但是，我们通常在头文件中定义类，并且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如，我们应该把Sales_data类定义在名为Sales_data.h的头文件中。</p><h1>类数据成员</h1><p>类体定义类的成员，我们上面定义的类只有数据成员（datamember）。</p><p>类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他<code>Sales_data</code>的对象。</p><p>定义数据成员的方法：首先说明一个基本类型，随后紧跟一个或多个声明符。</p><p>C++11新标准规定，可以为数据成员提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p><blockquote><p>对类内初始值的限制：要么放在花括号里，要么放在等号右边，而不能使用圆括号。</p></blockquote><h1>使用Sales_data类</h1><p><a href="https://weread.qq.com/web/reader/ff732fe072021a24ff7bb24k1ff325f02181ff1de7742fc">详见：自己动手实现对于Sales_data类的操作</a></p><p>关键在于，使用点操作符(<code>.</code>)读入对象的成员，如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sales_data data1;                               // data1为Sales_data类型的对象</span><br><span class="line">std::cin &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold;   // 写入对象data1的bookNo成员和units_sold成员</span><br></pre></td></tr></table></figure><h1>编写自己的头文件</h1><p>为了确保各个文件中类的定义一致，<strong>类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。</strong></p><p>头文件通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量等。</p><p>头文件也经常用到其他头文件的功能。因此，有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地工作。</p><blockquote><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p></blockquote><h2 id="预处理器概述">预处理器概述</h2><p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>（preprocessor），它由C++语言从C语言继承而来。</p><blockquote><p>预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能<code>#include</code>，当预处理器看到<code>#include</code>标记时就会用指定的头文件的内容代替<code>#include</code>。</p></blockquote><p>C++程序还会用到的一项预处理功能是<strong>头文件保护符</strong>（headerguard），头文件保护符依赖于预处理变量。</p><blockquote><p>预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</p></blockquote><p>使用这些功能就能有效地防止重复包含的发生：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef SALES_DATA_H    // SALES_DATA_H即为预处理变量，ifndef是if not defined的缩写。若未定义SALES_DATA_H，则执行后续操作，直到遇到#endif指令</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold = 0;</span><br><span class="line">    double revenue = 0.0;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直至遇到#endif为止。此时，预处理变量SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，则#ifndef的检查结果将为假，编译器将忽略#ifndef到#endif之间的部分。</p><blockquote><p>预处理变量无视C++语言中关于作用域的规则。</p></blockquote><p>整个程序中的预处理变量包括头文件保护符必须唯一，<strong>通常的做法是基于头文件中类的名字来构建保护符的名字</strong>，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，<strong>一般把预处理变量的名字全部大写</strong>。</p><blockquote><p>头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> struct </tag>
            
            <tag> 点运算符 </tag>
            
            <tag> 头文件 </tag>
            
            <tag> 预处理器 </tag>
            
            <tag> 头文件保护符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理类型</title>
      <link href="/2022/03/02/12-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/03/02/12-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>类型别名</h1><p>类型别名（type alias）是某种类型的同义词。</p><p>有两种方法可用于定义类型别名:</p><ol><li>传统的方法是使用关键字<code>typedef</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef double wages;   // wages是double的同义词</span><br><span class="line">typedef wages base, *p; // base是double的同义词, p是double*的同义词</span><br></pre></td></tr></table></figure><p>其中，关键字<code>typedef</code>作为声明语句中的基本数据类型的一部分出现。含有<code>typedef</code>的声明语句定义的不再是变量而是类型别名。这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。</p><ol start="2"><li>新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SI = Sales_item;  // SI是Sales_item的同义词</span><br></pre></td></tr></table></figure><p>这种方法用关键字<code>using</code>作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p><p>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wages hourly, weekly;    // 等效于double hourly, weekly;</span><br><span class="line">SI item;                 // 等效于Sales_item item</span><br></pre></td></tr></table></figure><h2 id="指针、常量和类型别名">指针、常量和类型别名</h2><p>如果某个类型别名指代的是复合类型或常量，当一条声明语句用到了类型别名时，<strong>不能简单地用原复合类型来代替类型别名。</strong></p><p>例如下面的声明语句用到了类型<code>pstring</code>，它实际上是类型<code>char *</code>的别名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef char *pstring;</span><br><span class="line">const pstring cstr = 0; // cstr是一个指向char对象的常量指针，相当于char *const cstr = 0;</span><br><span class="line">const pstring *ps;      // ps是一个指针，它的对象是一个指向char的常量指针。因为const pstring是一个指向char的常量指针类型</span><br></pre></td></tr></table></figure><p>上述两条声明语句的基本数据类型都是<code>const pstring</code>，和过去一样，<code>const</code>是对给定类型的修饰。<code>pstring</code>实际上是指向<code>char</code>的指针，因此，<code>const pstring</code>就是指向char的常量指针，而非指向常量字符的指针。</p><blockquote><p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const pstring cstr = 0;   //cstr是指向char的常量指针</span><br><span class="line">const char *cstr = 0;     //对const pstring cstr的错误理解，将cstr错当成一个指向char常量的指针</span><br></pre></td></tr></table></figure></blockquote><h1>auto类型说明符</h1><p>C++11新标准引入了<code>auto</code>类型说明符，<code>auto</code>让编译器通过初始值来推算变量的类型。</p><p><code>auto</code>定义的变量必须有初始值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据val1和val2相加的结果来推断item的类型</span><br><span class="line">auto item = val1 + val2;</span><br></pre></td></tr></table></figure><p>使用<code>auto</code>也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto i = 0, *p = &amp;i;      // ok: i是一个int型变量，p是一个指向int型对象的指针</span><br><span class="line">auto sz = 0, pi = 3.14;   // error: sz和pi的类型不一致，根据sz会推导为int型，但pi会推断为float/double型</span><br></pre></td></tr></table></figure><h2 id="复合类型、常量和auto">复合类型、常量和auto</h2><p>编译器推断出来的<code>auto</code>类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p><ol><li>当引用被用作初始值时，真正参与初始化的其实是引用对象的值，此时编译器以引用对象的类型作为<code>auto</code>的类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 0, &amp;r = i;</span><br><span class="line">auto a = r;  // a是int型（r是int型对象i的引用）</span><br></pre></td></tr></table></figure><ol start="2"><li>其次，<code>auto</code>一般会忽略掉顶层<code>const</code>，同时底层<code>const</code>则会保留下来</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int ci = i, &amp;cr = ci;</span><br><span class="line">auto b = ci;  // b是一个int型（顶层const被忽略）</span><br><span class="line">auto c = cr;  // c是一个int型</span><br><span class="line">auto d = &amp;i;  // d是一个指向int的指针</span><br><span class="line">auto e = &amp;ci; // e是一个指向int常量的指针（底层const被保留）</span><br></pre></td></tr></table></figure><ol start="3"><li>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要明确指出：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const auto f = ci; // ci的类型是int，f是一个int常量（顶层const）</span><br></pre></td></tr></table></figure><ol start="4"><li>可以将引用的类型设为<code>auto</code>，此时原来的初始化规则（引用的初始化规则）仍然适用：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto &amp;g = ci;       // g is a const int&amp;. 因为ci是int常量，不允许存在通过g修改ci的风险，故而g是常量引用</span><br><span class="line">auto &amp;h = 42;       // error: 不能为非常量引用绑定字面值。字面值常量42的类型为int，故auto推断为int型，此时存在通过h修改42的风险，故而语法错误</span><br><span class="line">const auto &amp;j = 42; // ok: 可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure><p>设置一个类型为<code>auto</code>的引用时，初始值中的顶层常量属性仍然保留。即，不能通过引用修改所指对象的值。</p><ol start="5"><li>要在一条语句中定义多个变量，切记，符号<code>&amp;</code>和<code>*</code>只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto k = ci, &amp;l = i;    // k是int型对象，l是int型对象i的引用</span><br><span class="line">auto &amp;m = ci, *p = &amp;ci; // m是一个int型常量引用，p是指向int常量的指针</span><br><span class="line">auto &amp;n = i, *p2 = &amp;ci; //error: 根据i推断的类型是int; 根据&amp;ci推断的类型是const int。（存在通过p2修改ci的风险）</span><br></pre></td></tr></table></figure><h1>decltype类型指示符</h1><p>C++11新标准引入了类型说明符d<code>ecltype</code>，它的作用是选择并返回操作数的数据类型。</p><p>编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decltype(f()) sum = x;</span><br></pre></td></tr></table></figure><p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。</p><p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int ci = 0, &amp;cj = ci;</span><br><span class="line">decltype(ci) x = 0; // x的类型是const int</span><br><span class="line">decltype(cj) y = x; // y的类型是const int&amp;</span><br><span class="line">decltype(cj) z;     // error: z是一个引用，必须初始化</span><br></pre></td></tr></table></figure><blockquote><p>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。在decltype中，引用和引用所指对象是不同的数据类型，如上例，ci是const int型，而cj是const int&amp;型。</p></blockquote><h2 id="decltype和引用">decltype和引用</h2><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//decltype的结果可以是引用类型</span><br><span class="line">int i = 42, *p = &amp;i, &amp;r = i;</span><br><span class="line">decltype(r + 0) b;  // ok: 加法的结果是int型，故而b是一个（未初始化）的int对象</span><br><span class="line">decltype(*p) c;     // error: c是int&amp;型，必须初始化</span><br></pre></td></tr></table></figure><p>因为<code>r</code>是一个引用，因此<code>decltype(r)</code>的结果是引用类型。如果想让结果类型是<code>r</code>所指的类型，可以把<code>r</code>作为表达式的一部分，如<code>r+0</code>，显然这个表达式的结果将是一个具体值而非一个引用。</p><p>如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，<code>decltype(*p)</code>的结果类型就是<code>int&amp;</code>，而非<code>int</code>。</p><p>如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式,所以这样的<code>decltype</code>就会得到引用类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// decltype of a parenthesized variable is always a reference</span><br><span class="line">decltype((i)) d;    // error: d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e;      // ok: e是一个（未被初始化的）int</span><br></pre></td></tr></table></figure><blockquote><p><code>decltype((variable))</code>（注意是双层括号）的结果永远是引用，而<code>decltype(variable)</code>结果只有当<code>variable</code>本身就是一个引用时才是引用。</p></blockquote><blockquote><p><code>auto</code>和<code>decltype</code>的区别主要有三个方面：</p><ol><li><code>auto</code>类型说明符用编译器计算变量的初始值来推断其类型，而<code>decltype</code>虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。</li><li>编译器推断出来的<code>auto</code>类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，<code>auto</code>一般会忽略掉顶层<code>const</code>，而把底层<code>const</code>保留下来。与之相反，<code>decltype</code>会保留变量的顶层<code>const</code>。</li><li>与<code>auto</code>不同，<code>decltype</code>的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类型别名 </tag>
            
            <tag> typedef </tag>
            
            <tag> using </tag>
            
            <tag> auto </tag>
            
            <tag> decltype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const限定符</title>
      <link href="/2022/03/01/11-const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
      <url>/2022/03/01/11-const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>用关键字<code>const</code>对变量的类型加以限定，使得变量成为常量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure><p><code>const</code>对象一旦创建后其值就不能再改变，所以，<code>const</code>对象必须初始化。初始值可以是任意复杂的表达式。</p><h2 id="初始化和const">初始化和const</h2><p>对于<code>const</code>类型的对象，只能执行不改变其内容的操作。</p><blockquote><p>可以利用<code>const</code>对象去初始化指针，因为const对象是常量，而不是变量。</p></blockquote><h2 id="默认状态下，const对象仅在文件内有效">默认状态下，const对象仅在文件内有效</h2><p>默认情况下，<code>const</code>对象被设定为仅在文件内有效。</p><p>某些时候，我们希望只在一个文件中定义<code>const</code>，而在其他多个文件中声明并使用它。解决的办法是，对于<code>const</code>变量不管是声明还是定义都添加<code>extern</code>关键字，这样只需定义一次就可以了。</p><blockquote><p>任何包含了显式初始化的声明，就成为了定义。</p></blockquote><p><strong>如果想在多个文件之间共享<code>const</code>对象，必须在变量的定义之前添加<code>extern</code>关键字。</strong></p><h1>const的引用</h1><p>对常量的引用（reference to const）: 把引用绑定到const对象上。</p><p>对常量的引用不能被用于修改它所绑定的对象。</p><blockquote><p>即，不能够通过该引用修改对象的值，但可以通过其他途径修改该对象的值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line">const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量。不存在通过引用r1修改ci的风险，故而语法正确</span><br><span class="line"></span><br><span class="line">r1 = 42;</span><br><span class="line">int &amp;r2 = ci;       //错误：试图让一个非常量引用指向一个常量对象。存在通过r2修改ci的风险，故而语法错误</span><br></pre></td></tr></table></figure><blockquote><p>术语：常量引用是对const的引用</p></blockquote><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">const int &amp;r1 = i;      //允许将const int &amp;绑定到一个普通int对象上。仅仅是说，不能通过r1修改i的值</span><br><span class="line">const int &amp;r2 = 42;     //正确：r2是一个对const的引用。不存在通过r2修改42的风险</span><br><span class="line">const int &amp;r3 = r1 * 2; //正确：r3是一个对const的引用。不存在通过r3修改r1 * 2的风险</span><br><span class="line">int &amp;r4 = r1 * 2;       //错误：r4是一个普通的非常量引用。存在通过r4修改r1 * 2的风险</span><br></pre></td></tr></table></figure><h2 id="对const的引用可能引用一个并非const的对象">对const的引用可能引用一个并非const的对象</h2><blockquote><p>常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int &amp;r1 = i;        //引用r1绑定对象i</span><br><span class="line">const int &amp;r2 = i;  //常量引用r2绑定对象i，不允许通过r2修改i的值</span><br><span class="line">r1 = 0;             //r1并非常量，i的值修改为0</span><br><span class="line">r2 = 0;             //错误：r2是常量引用，不允许通过r2修改i的值</span><br></pre></td></tr></table></figure><h1>指针和const</h1><h2 id="指向常量的指针">指向常量的指针</h2><p>指向常量的指针（pointer toconst）：不能用于改变其所指对象的值。</p><p>要想存放常量对象的地址，只能使用指向常量的指针：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const double pi = 3.14;     //pi是一个常量</span><br><span class="line">double *ptr = &amp;pi;          //错误：ptr是一个普通指针。存在通过解引用*ptr修改pi的值的风险，故语法错误</span><br><span class="line">const double *cptr = &amp;pi;   //正确: cptr是一个指向常量的指针。不存在通过*cptr修改pi的值的风险，故语法正确</span><br><span class="line">*cptr = 42;                 //错误：cptr是指向常量的指针，不能给*cptr赋值。</span><br></pre></td></tr></table></figure><p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double dval = 3.14;     //dval是一个双精度浮点数，它的值可以改变</span><br><span class="line">cptr = &amp;dval;           //正确，但是不能通过cptr修改dval的值</span><br></pre></td></tr></table></figure><p>和常量引用一样，<strong>指向常量的指针也没有规定其所指的对象必须是一个常量。指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</strong></p><blockquote><p>试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</p></blockquote><h2 id="const指针（常量指针）">const指针（常量指针）</h2><p>指针是对象，允许把指针本身定为常量。</p><p>常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。</p><p>把<code>*</code>放在<code>const</code>关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int errNum = 0;</span><br><span class="line">int *const curErr = &amp;errNum;    //curErr将一直指向errNum</span><br><span class="line">const double pi = 3.14;</span><br><span class="line">const double *const pip = &amp;pi;  //pi是一个指向常量的常量指针</span><br></pre></td></tr></table></figure><p>要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离<code>curErr</code>最近的符号是<code>const</code>，意味着<code>curErr</code>本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是<code>*</code>，意思是<code>curErr</code>是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个<code>int</code>对象。与之相似，我们也能推断出，<code>pip</code>是一个常量指针，它指向的对象是一个双精度浮点型常量。</p><p><strong>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。</strong></p><blockquote><p>例如，<code>pip</code>是一个指向常量的常量指针，则不论是<code>pip</code>所指的对象值还是<code>pip</code>自己存储的那个地址都不能改变。相反的，<code>curErr</code>指向的是一个一般的非常量整数，那么就完全可以用<code>curErr</code>去修改<code>errNum</code>的值</p></blockquote><h1>顶层const</h1><p>指针本身是不是常量，以及指针所指的对象是不是一个常量，是两个相互独立的问题。</p><p>顶层const（top-levelconst）表示指针本身是个常量。</p><blockquote><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。</p></blockquote><p>底层const（low-level const）表示指针所指的对象是一个常量。</p><p>比较特殊的是，指针类型既可以是顶层const也可以是底层const。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const pi = &amp;i;         //顶层const</span><br><span class="line">const int ci = 42;          //顶层const</span><br><span class="line">const int *p2 = &amp;ci;        //底层const</span><br><span class="line"></span><br><span class="line">const int *const p3 = p2;   //底层const，顶层const</span><br><span class="line">const int &amp;r = ci;          //底层const</span><br></pre></td></tr></table></figure><p>当执行对象的拷贝操作时，顶层const不受什么影响（执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = ci;     //正确：拷贝对象ci的值，顶层const对此操作无影响</span><br><span class="line">p2 = p3;    //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</span><br></pre></td></tr></table></figure><p>当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p = p3;        //错误：p3包含底层const的定义，而p没有。存在通过p修改p3所指对象的值的风险，故语法错误</span><br><span class="line">p2 = p3;            //正确：p2和p3都是底层const。不存在通过p2修改p3所指对象的值的风险，故语法正确</span><br><span class="line">p2 = &amp;i;            //正确：int *能转换成const int *。p2是一个指向常量的指针</span><br><span class="line">int &amp;r = ci;        //错误：普通的int &amp;不能绑定int常量。存在通过引用r修改常量ci值的风险，故语法错误</span><br><span class="line">const int &amp;r2 = i;  //正确：const int &amp;可以跟一个普通int对象绑定。r2是一个指向常量的指针</span><br></pre></td></tr></table></figure><h1>constexpr和常量表达式</h1><p>常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。</p><blockquote><p><strong>字面值</strong>属于常量表达式，<strong>用常量表达式初始化的<code>const</code>对象</strong>也是常量表达式。</p></blockquote><p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int max_files = 20;           //是常量表达式</span><br><span class="line">const int limit = max_files + 1;    //是常量表达式</span><br><span class="line">int staff_size = 27;                //不是常量表达式（值会改变）</span><br><span class="line"></span><br><span class="line">const int sz = get_size();          //不是常量表达式（无法在编译过程得到计算结果）</span><br></pre></td></tr></table></figure><h2 id="constexpr变量">constexpr变量</h2><p>C++11新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。声明为<code>constexpr</code>的变量一定是一个常量，而且必须用常量表达式初始化：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constexpr int mf = 20;          //20是常量表达式</span><br><span class="line">constexpr int limit = mf + 1;   //mf+1是常量表达式</span><br><span class="line">constexpr int sz = size();      //只有当size是一个constexpr函数时才是一条正确的声明语句</span><br></pre></td></tr></table></figure><p>尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。</p><blockquote><p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p></blockquote><h2 id="字面值类型">字面值类型</h2><p>字面值类型（literal type）</p><p>算术类型、引用和指针都属于字面值类型。</p><p>自定义类<code>Sales_item</code>、<code>IO</code>库、<code>string</code>类型则不属于字面值类型，也就不能被定义成<code>constexpr</code>。</p><p>尽管指针和引用都能定义成<code>constexpr</code>，但它们的初始值却受到严格限制。一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者<code>0</code>，或者是存储于某个固定地址中的对象。</p><blockquote><p>函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。此外，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。</p></blockquote><h2 id="指针和constexpr">指针和constexpr</h2><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</p><blockquote><p>相当于一个常量指针，表示指针本身是常量，无法指向别的对象。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int *p = nullptr;         //指向常量的指针</span><br><span class="line">int const *q1 = nullptr;        //常量指针</span><br><span class="line">constexpr int *q2 = nullptr;    //常量指针</span><br></pre></td></tr></table></figure><p>关键在于，<code>constexpr</code>把它所定义的对象置为了顶层const。</p><p>与其他常量指针类似，<code>constexpr</code>指针既可以指向常量也可以指向一个非常量。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> const </tag>
            
            <tag> constexpr </tag>
            
            <tag> 常量表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合类型</title>
      <link href="/2022/02/28/10-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/02/28/10-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>复合类型（compound type）是指基于其他类型定义的类型。例如：引用和指针。</p><p>一条声明语句由一个**基本数据类型（base type）<strong>和紧随其后的一个</strong>声明符（declarator）**列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p><h1>引用</h1><blockquote><p>“引用（reference）”指的其实是“左值引用（lvalue reference）”。</p></blockquote><p>引用（reference）为对象起了另外一个名字。</p><p>通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<code>d</code>是声明的变量名。如下所示，<code>refVal</code>是<code>ival</code>的一个引用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = 1024;</span><br><span class="line">int &amp;refVal = ival; //refVal指向ival（是ival的另一个名字）</span><br><span class="line">int &amp;refVal2;       //报错：引用必须被初始化</span><br></pre></td></tr></table></figure><p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，<strong>引用将和它的初始值对象一直绑定在一起</strong>。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p><h2 id="引用即别名">引用即别名</h2><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p></blockquote><p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：</p><blockquote><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">refVal = 2;               //把2赋给refVal指向的对象，即，赋给ival</span><br><span class="line">int ii = refVal;          //与ii = ival执行结果一样</span><br><span class="line">int &amp;refVal3 = refVal;    //正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上</span><br><span class="line">int i = refVal;           //正确：i被初始化为ival的值</span><br></pre></td></tr></table></figure></blockquote><p><strong>引用本身不是一个对象，所以不能定义引用的引用。</strong></p><h2 id="引用的定义">引用的定义</h2><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i =1024, i2 = 2048; //i和i2都是int</span><br><span class="line">int &amp;r = i, r2 = i2;    //r是i的引用，r2是int型对象</span><br><span class="line">int i3 = 1024, &amp;ri = i3;//i3是int型对象，ri是i3的引用</span><br><span class="line">int &amp;r3 = i3, &amp;r4 = i2; //r3和r4都是引用</span><br></pre></td></tr></table></figure><p>除了书本2.4.1节（第55页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int &amp;refVal4 = 10;      //错误：引用类型的初始值必须是一个对象，而不能是字面值</span><br><span class="line">double dval = 3.14;</span><br><span class="line">int &amp;refVal5 = dval;    //错误：此处引用类型的初始值必须是int型对象</span><br></pre></td></tr></table></figure><h1>指针</h1><p>指针（pointer）是“指向（point to）”另外一种类型的复合类型。</p><p>与引用类似，指针也实现了对其他对象的间接访问。</p><blockquote><p>指针与引用相比又有很多不同点:</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li><li>指针无须在定义时赋初值。</li></ol></blockquote><p>和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p><p>定义指针类型的方法将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号<code>*</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *ip1, *ip2; //ip1和ip2都是指向int型对象的指针</span><br><span class="line">double dp, *dp2;//dp2是指向double型对象的指针，dp是double型对象</span><br></pre></td></tr></table></figure><h2 id="获取对象的地址">获取对象的地址</h2><p>指针存放某个对象的地址。要获取某对象的地址，则使用<strong>取地址符（操作符<code>&amp;</code>）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = 42;</span><br><span class="line">int *p = &amp;ival; //p存放变量ival的地址，或者说，p是指向变量ival的指针。（把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。）</span><br></pre></td></tr></table></figure><blockquote><p>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p></blockquote><p>除了2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double dval;</span><br><span class="line">double *pd = &amp;dval;     //正确：初始值是double型对象的地址</span><br><span class="line">double *pd2 = pd;       //正确：初始值是double对象的指针</span><br><span class="line"></span><br><span class="line">int *pi = pd;           //错误：指针pi的类型和pd的类型不匹配</span><br><span class="line">pi = &amp;dval;             //错误：试图把double型对象的地址赋给int型指针</span><br></pre></td></tr></table></figure><p><strong>声明语句中指针的类型实际上用于确定指针所指向对象的类型</strong>，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</p><h2 id="指针值">指针值</h2><p>指针的值（即地址）应属下列4种状态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>试图拷贝或以其他方式访问无效指针的值都将引发错误。访问无效指针的后果无法预计。</p><p>尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p><h2 id="利用指针访问对象">利用指针访问对象</h2><p>如果指针指向了一个对象，则允许使用<strong>解引用符（操作符*）</strong>，来访问该对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = 42;</span><br><span class="line">int *p = &amp;ival; //p是指向变量ival的指针</span><br><span class="line">cout &lt;&lt; *p;     //解引用，访问指针所指对象，输出42</span><br></pre></td></tr></table></figure><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*p = 0;     //经由指针p为p所指对象（即，ival）赋值</span><br><span class="line">cout &lt;&lt; *p; //输出0</span><br></pre></td></tr></table></figure><p><strong>解引用操作仅适用于那些确实指向了某个对象的有效指针。</strong></p><h2 id="空指针">空指针</h2><p>空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p1 = nullptr;</span><br><span class="line">int *p2 = 0;</span><br><span class="line">int *p3 = NULL;     //需要首先#include cstdlib</span><br></pre></td></tr></table></figure><p>得到空指针最直接的办法就是用字面值<code>nullptr</code>来初始化指针，<code>nullptr</code>是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。现在的C++程序最好使用<code>nullptr</code>，同时尽量避免使用<code>NULL</code>。</p><p><strong>把<code>int</code>变量直接赋给指针是错误的操作，即使<code>int</code>变量的值恰好等于0也不行。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int zero = 0;</span><br><span class="line">pi = zero;      //错误：不能把int变量直接赋给指针</span><br></pre></td></tr></table></figure><blockquote><p>尽管C++语法上规定“指针无须在定义时初始化”，但使用未经初始化的指针是引发运行时错误的一大原因，且访问未经初始化的指针所引发的后果也是无法预计的。<br>因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。</p></blockquote><h2 id="赋值和指针">赋值和指针</h2><p>指针和引用都能提供对其他对象的间接访问。</p><blockquote><p>引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。<br>指针可以指向新的对象：给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。</p></blockquote><p>赋值永远改变的是等号左侧的对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pi = &amp;ival; //pi的值被改变，现在pi指向了ival</span><br><span class="line">*pi = 0;    //ival的值被改变，指针pi并没有改变</span><br></pre></td></tr></table></figure><h2 id="其他指针操作">其他指针操作</h2><p>如果指针的值是0，条件取<code>false</code>。任何非0指针对应的条件值都是<code>true</code>。</p><p>对于两个类型相同的合法指针，可以用相等操作符（<code>==</code>）或不相等操作符（<code>!=</code>）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。</p><blockquote><p>两个指针存放的地址值相同（两个指针相等）有三种可能：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</p></blockquote><h2 id="void-指针">void * 指针</h2><p><code>void *</code>是一种特殊的指针类型，可用于存放任意对象的地址。然而，我们对该地址中到底是个什么类型的对象并不了解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double obj = 3.14, *pd = &amp;obj;</span><br><span class="line">void *pv = &amp;obj;    //正确：void *能存放任意类型对象的地址</span><br><span class="line">pv = pd;            //正确</span><br></pre></td></tr></table></figure><p><code>void *</code>指针的功用：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个<code>void *</code>指针。</p><p>不能直接操作<code>void *</code>指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p><blockquote><p>练习2.23：给定指针<code>p</code>，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，说明原因。</p><p>【出题思路】本题旨在考查指针初始化，读者应该熟悉并掌握C++11的新语法特征<code>nullptr</code>。</p><p>【解答】在C++程序中，应该尽量初始化所有指针，并且尽可能等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为<code>nullptr</code>或者<code>0</code>，这样程序就能检测并知道它有没有指向一个具体的对象了。其中，<code>nullptr</code>是C++11新标准刚刚引入的一个特殊字面值，它可以转换成任意其他的指针类型。在此前提下，判断<code>p</code>是否指向合法的对象，只需把<code>p</code>作为<code>if</code>语句的条件即可，如果<code>p</code>的值是<code>nullptr</code>，则条件为假；反之，条件为真。如果不注意初始化所有指针而贸然判断指针的值，则有可能引发不可预知的结果。一种处理的办法是把<code>if(p)</code>置于<code>try</code>结构中，当程序块顺利执行时，表示<code>p</code>指向了合法的对象；当程序块出错跳转到<code>catch</code>语句时，表示<code>p</code>没有指向合法的对象。</p></blockquote><h1>理解复合类型的声明</h1><p>变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。即，一条定义语句可能定义出不同类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 1024, *p = &amp;i, &amp;r = i;  //i是一个int型对象，p是一个指向int型对象的指针，r是一个int对象的引用</span><br></pre></td></tr></table></figure><p>其中，<code>int</code>是基本数据类型，<code>*</code>和<code>&amp;</code>是类型修饰符，后者是声明符的一部分。</p><h2 id="定义多个变量">定义多个变量</h2><p>在定义语句种，类型修饰符（<code>*</code>和<code>&amp;</code>）仅作用于紧随其后的单个变量，而不是作用于本次定义的全部便了。</p><p>涉及指针或引用的声明，一般有两种写法:</p><ol><li>第一种把修饰符和变量标识符写在一起：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p1, *p2;   //p1和p2都是指向int型对象的指针</span><br></pre></td></tr></table></figure><p>这种形式着重强调变量具有的复合类型。</p><ol start="2"><li>第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* p1;    //p1是指向int型对象的指针</span><br><span class="line">int* p2;    //p2是指向int型对象的指针</span><br></pre></td></tr></table></figure><p>这种形式着重强调本次声明定义了一种复合类型。</p><p>上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其中的一种写法，不要总是变来变去。</p><p>推荐采用第一种写法，将＊（或是&amp;）与变量名连在一起。</p><h2 id="指向指针的指针">指向指针的指针</h2><p>指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。</p><p>通过<code>*</code>的个数可以区分指针的级别。也就是说，<code>**</code>表示指向指针的指针，<code>***</code>表示指向指针的指针的指针，以此类推：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = 1024;</span><br><span class="line">int *pi = &amp;ival;    //pi指向一个int型的数</span><br><span class="line">int **ppi = &amp;pi;    //ppi指向一个int型的指针</span><br></pre></td></tr></table></figure><p>下图描述了它们之间的关系:</p><img src="/2022/02/28/10-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/1.png" class=""><p>解引用<code>int</code>型指针会得到一个<code>int</code>型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; ival;   //direct value</span><br><span class="line">cout &lt;&lt; *pi;    //indirect value</span><br><span class="line">cout &lt;&lt; **ppi;  //doubly indirect value</span><br></pre></td></tr></table></figure><h2 id="指向指针的引用">指向指针的引用</h2><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p;         //p是一个指向int型对象的指针</span><br><span class="line">int *&amp;r = p;    //r是一个对指针p的引用，即，r是p的别名</span><br><span class="line"></span><br><span class="line">r = &amp;i;         //给r赋值一个地址，即，令p指向i</span><br><span class="line">*r = 0;         //解引用r得到int型对象i（也就是P指向的对象），给i赋值0</span><br></pre></td></tr></table></figure><p>要理解<code>r</code>的类型到底是什么，最简单的办法是从右向左阅读<code>r</code>的定义。离变量名最近的符号（此例中是<code>&amp;r</code>的符号<code>&amp;</code>）对变量的类型有最直接的影响，因此<code>r</code>是一个引用。声明符的其余部分用以确定<code>r</code>引用的类型是什么，此例中的符号<code>*</code>说明<code>r</code>引用的是一个指针。最后，声明的基本数据类型部分指出<code>r</code>引用的是一个<code>int</code>指针。</p><p><strong>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量</title>
      <link href="/2022/02/28/9-%E5%8F%98%E9%87%8F/"/>
      <url>/2022/02/28/9-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。</p><p>对C++程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</p><h1>变量定义</h1><p>变量定义的基本形式是：首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。</p><blockquote><p>列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。</p></blockquote><h2 id="初始值">初始值</h2><p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialized）了。</p><p>在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。</p><p><strong>初始化不是赋值</strong>，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p><h2 id="列表初始化">列表初始化</h2><p>用花括号来初始化变量: 用花括号来初始化变量</p><blockquote><p>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错</p></blockquote><h2 id="默认初始化">默认初始化</h2><p>如果定义变量时没有指定初值，则变量被默认初始化（default initialized）。</p><p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。</p><blockquote><p>定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p></blockquote><p>每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。</p><blockquote><p>绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。例如，<code>string</code>类规定如果没有指定初值则生成一个空串。一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。</p></blockquote><p><strong>未初始化的变量含有一个不确定的值，使用未初始化的变量将带来无法预计的后果。</strong></p><h1>变量声明和定义的关系</h1><p>C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。</p><blockquote><p>前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。</p></blockquote><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separatecompilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p><blockquote><p>如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。</p></blockquote><p>声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。</p><blockquote><p>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</p></blockquote><p>如果想声明一个变量而非定义它，就在变量名前添加关键字<code>extern</code>，而且不要显式地初始化变量。</p><p>任何包含了显式初始化的声明即成为定义: <code>extern</code>语句如果包含初始值就不再是声明，而变成定义了。</p><p>在函数体内部，如果试图初始化一个由<code>extern</code>关键字标记的变量，将引发错误。</p><blockquote><p>包含有<code>extern</code>标记的定义，例如，<code>extern double pi=3.14;</code>，不能放在函数体内部</p></blockquote><blockquote><p>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p></blockquote><p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong></p><h1>标识符</h1><p>C++的标识符（identifier）由字母、数字和下画线组成，其中<strong>必须以字母或下画线开头</strong>。标识符的长度没有限制，但是<strong>对大小写字母敏感</strong>。</p><p><strong>C++关键字和C++操作符替代名不能被用作标识符</strong>。</p><img src="/2022/02/28/9-%E5%8F%98%E9%87%8F/1.png" class="" title="关键字与操作符替代名"><p>用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p><blockquote><p>变量命名规范变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性：</p><ol><li>标识符要能体现实际含义。</li><li>变量名一般用小写字母，如<code>index</code>，不要使用<code>Index</code>或<code>INDEX</code>。</li><li>用户自定义的类名一般以大写字母开头，如<code>Sales_item</code>。</li><li>如果标识符由多个单词组成，则单词间应有明显区分，如下划线命名法<code>student_loan</code>或驼峰命名法<code>studentLoan</code>，不要使用<code>studentloan</code>。</li></ol></blockquote><h1>名字的作用域</h1><p>同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。</p><p>作用域（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。</p><blockquote><p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p></blockquote><p>全局作用域（global scope）、块作用域（block scope）。</p><p>内层作用域（innerscope）、外层作用域（outer scope）。</p><blockquote><p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。</p></blockquote><p>一般来说，在对象第一次被使用的地方附近定义它是一种好的选择。</p><p><strong>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量</strong>。(语法上允许，但实际编程使用时容易出错。)</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量定义 </tag>
            
            <tag> 变量声明 </tag>
            
            <tag> 标识符 </tag>
            
            <tag> 名字作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本内置类型</title>
      <link href="/2022/01/01/8-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/01/01/8-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中，算术类型包含了字符、整数型、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p><h1>算术类型</h1><p>算术类型分为两类：整型（integral，包括字符和布尔类型在内）和浮点型。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th><th style="text-align:center">最小尺寸</th></tr></thead><tbody><tr><td style="text-align:center"><code>bool</code></td><td style="text-align:center">布尔类型</td><td style="text-align:center">未定义</td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center">字符</td><td style="text-align:center">8位</td></tr><tr><td style="text-align:center"><code>wchar_t</code></td><td style="text-align:center">宽字符</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>char16_t</code></td><td style="text-align:center">Unicode字符</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>char32_t</code></td><td style="text-align:center">Unicode字符</td><td style="text-align:center">32位</td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center">短整型</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center">整型</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">32位</td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">64位</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">单精度浮点数</td><td style="text-align:center">6位有效数字</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center">双精度浮点数</td><td style="text-align:center">10位有效数字</td></tr><tr><td style="text-align:center"><code>long double</code></td><td style="text-align:center">拓展精度浮点数</td><td style="text-align:center">10位有效数字</td></tr></tbody></table><p>上述表格列出了C++标准规定的算术类型的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。</p><h2 id="整型与浮点型">整型与浮点型</h2><p>布尔类型（bool）的取值是真（True）或者假（False）。</p><p>基本的字符类型是<code>char</code>，一个<code>char</code>的空间应确保可以存放机器基本字符集（如ASCII表）中任意字符对应的数字值，即，一个<code>char</code>的大小和一个机器字节一样。</p><p><code>wchar_t</code>类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型<code>char16_t</code>和<code>char32_t</code>则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。</p><blockquote><p>Unicode为每种语言中的每个字符设定了统一并且唯一的二进制编码，现在用的是UCS-2，即，2个字节编码。UTF-8，UTF-16，UTF-32均为字符编码方案。</p></blockquote><p>大多数机器的字节（byte）由8比特（bit）构成，字（word）则由32或64比特构成，也就是4或8字节。</p><p>浮点型可表示单精度、双精度和扩展精度值。通常，<code>float</code>以1个字（32比特）来表示，<code>double</code>以2个字（64比特）来表示，<code>long double</code>以3或4个字（96或128比特）来表示。一般来说，类型<code>float</code>和<code>double</code>分别有7和16个有效位。</p><blockquote><p>浮点数在机器内用指数形式表示，分解为：数符，尾数，指数符，指数。</p></blockquote><h2 id="带符号类型和无符号类型">带符号类型和无符号类型</h2><p>除布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。</p><p>带符号类型可以表示正数、负数或0；无符号类型仅能表示大于等于0的值。</p><p>带符号类型：<code>int</code>、<code>short</code>、<code>long</code>、<code>long long</code>；在这些类型名前添加<code>unsigned</code>就可以得到对应的无符号类型，即，无符号类型：<code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code>、<code>unsigned long long</code>。</p><p>类型<code>unsigned int</code>可以缩写为<code>unsigned</code>。</p><p>字符型分为三种：<code>char</code>、<code>signed char</code>、<code>unsigned char</code>。其中，<code>signed char</code>类型和<code>unsigned char</code>类型分别为带符号类型和无符号类型，<code>char</code>类型实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p><p>无符号类型中所有比特都用来存储值。</p><p>C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。</p><blockquote><p>8比特的signed char理论上应该可以表示-127至127区间内的值，大多数现代计算机将8比特的signed char实际的表示范围定为 -128~127。</p></blockquote><h2 id="建议：如何选择类型">建议：如何选择类型</h2><p>当明确知晓数值不可能为负时，选用无符号类型。</p><p>使用<code>int</code>执行整数运算。若数值超出<code>int</code>的表示范围，选用<code>long long</code>。</p><p>在算术表达式中不要使用<code>char</code>或<code>bool</code>，只有在存放字符或布尔值时才使用它们。</p><blockquote><p>因为类型<code>char</code>在一些机器上是有符号的，而在另一些机器上又是无符号的，所以使用<code>char</code>进行运算特别容易出问题。如果需要使用一个不大的整数，则应该明确指定类型是<code>signed char</code>或者<code>unsigned char</code>。</p></blockquote><p>执行浮点数运算选用<code>double</code>。</p><blockquote><p>这是因为<code>float</code>通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。<code>long double</code>提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。</p></blockquote><h1>类型转换</h1><p>类型转换是指，将对象从一种给定的类型转换（convert）为另一种相关类型。</p><h2 id="转换规则（简介）">转换规则（简介）</h2><p>类型所能表示的值的范围决定了转换的过程：</p><ol><li><p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。</p></li><li><p>当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。</p></li><li><p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p></li><li><p>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p></li><li><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。</p></li><li><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p></li></ol><h2 id="含有无符号类型的表达式">含有无符号类型的表达式</h2><p>当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。</p><blockquote><p>如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a＊b的式子中，如果a = -1，b = 1，而且a和b都是int，则表达式的值显然为-1。然而，如果a是int，而b是unsigned，则结果须视在当前机器上int所占位数而定。在我们的环境里，结果是4294967295。</p></blockquote><p>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值。</p><p>无符号数不会小于0这一事实同样关系到循环的写法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以降序的形式逐个输出数字10到0</span><br><span class="line">for (int i = 10; i &gt;= 0; --i)</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">// 错误：变量u永远也不会小于0，循环条件一直成立</span><br><span class="line">for (unsigned u = 10, u &gt;= 0; --u)</span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><blockquote><p>当u等于0时这次迭代输出0，然后继续执行for语句里的表达式。表达式–u从u当中减去1，得到的结果-1并不满足无符号数的要求，此时-1被自动地转换成一个合法的无符号数。假设int类型占32位，则当u等于0时，–u的结果将会是4294967295。</p></blockquote><h1>字面值常量</h1><p>字面值常量（literal）：形如42的值，一望而知。</p><p>每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p><h2 id="整型和浮点型字面值">整型和浮点型字面值</h2><p>可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 //十进制</span><br><span class="line">024 //八进制</span><br><span class="line">0x14 //十六进制</span><br></pre></td></tr></table></figure><p>整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。</p><blockquote><p>十进制字面值的类型是<code>int</code>、<code>long</code>和<code>long long</code>中尺寸最小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>和<code>unsigned long long</code>（即，带符号的和无符号的<code>int</code>、<code>long</code>、<code>long long</code>）中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型<code>short</code>没有对应的字面值。</p></blockquote><blockquote><p>尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</p></blockquote><p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.14159</span><br><span class="line">3.14159E0</span><br><span class="line">0.</span><br><span class="line">0e0</span><br><span class="line">.001</span><br></pre></td></tr></table></figure><p>默认的，浮点型字面值是一个<code>double</code>。</p><h2 id="字符和字符串字面值">字符和字符串字面值</h2><p>由单引号括起来的一个字符称为<code>char</code>型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;a&#x27; // 字符字面值</span><br><span class="line">&quot;Hello World!&quot; // 字符串字面值</span><br></pre></td></tr></table></figure><p>字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（′\0′），因此，字符串字面值的实际长度要比它的内容多1。</p><blockquote><p>例如，字面值’A’表示的就是单独的字符A，而字符串&quot;A&quot;则代表了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。</p></blockquote><p>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当书写的字符串字面值比较长，写在一行里不太合适时，分多行书写字符串字面值</span><br><span class="line">std::cout &lt;&lt; &quot;a really, really long string literal &quot;</span><br><span class="line">          &lt;&lt; &quot;that spans two lines&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h2 id="转义序列">转义序列</h2><p>有两类字符程序员不能直接使用：一类是不可打印（nonprintable）的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。 这些情况需要用到转义序列（escape sequence）。</p><p>C++语言规定的转义序列包括：</p><blockquote><p>换行符 <code>\n</code><br>纵向制表符 <code>\v</code><br>反斜线 <code>\\</code><br>回车符 <code>\r</code><br>横向制表符 <code>\t</code><br>退格符 <code>\b</code><br>问号 <code>\?</code><br>进纸符 <code>\f</code><br>报警（响铃）符 <code>\a</code><br>双引号 <code>\&quot;</code><br>单引号 <code>\'</code></p></blockquote><p>在程序中，上述转义序列被当作一个字符使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; &#x27;\n&#x27;;          // 转到新一行</span><br><span class="line">std::cout &lt;&lt; &quot;\tHi!\n&quot;;     // 输出一个制表符，输出&quot;Hi!&quot;，转到新一行</span><br></pre></td></tr></table></figure><p>我们也可以使用泛化的转义序列，其形式是<code>\x</code>后紧跟1个或多个十六进制数字，或者<code>\</code>后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。</p><blockquote><p>假设使用的是Latin-1字符集，以下是一些示例：（对应ASCII表）<br><code>\7</code> 响铃<br><code>\12</code> 换行符<br><code>\40</code> 空格<br><code>\0</code> 空字符<br><code>\115</code> 字符M<br><code>\x4d</code> 字符M</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; &quot;Hi! \x4dO\115!\n&quot;;    // 输出&quot;Hi MOM!&quot;，转到新一行</span><br><span class="line">std::cout &lt;&lt; &#x27;\115&#x27; &lt;&lt; &#x27;\n&#x27;;        // 输出&quot;M&quot;，转到新一行</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果反斜线<code>\</code>后面跟着的八进制数字超过3个，只有前3个数字与<code>\</code>构成转义序列。例如，<code>&quot;\1234&quot;</code>表示2个字符，即八进制数123对应的字符以及字符4。相反，<code>\x</code>要用到后面跟着的所有数字，例如，<code>&quot;\x1234&quot;</code>表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的<code>char</code>型数据占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。</p></blockquote><h2 id="指定字面值的类型">指定字面值的类型</h2><p>通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p><p>字符和字符串字面值：</p><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">含义</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">Unicode 16 字符</td><td style="text-align:center">char16_t</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">Unicode 32 字符</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">宽字符</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center">u8</td><td style="text-align:center">UTF-8 （仅用于字符串字面值常量）</td><td style="text-align:center">char</td></tr></tbody></table><p>整型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">u 或 U</td><td style="text-align:center">unsigned</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">ll 或 LL</td><td style="text-align:center">long long</td></tr></tbody></table><p>浮点型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">f 或 F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long double</td></tr></tbody></table><blockquote><p>当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L&#x27;a&#x27;        // 宽字符型字面值，类型是 wchar_t</span><br><span class="line">u8&quot;hi!&quot;     // UTF-8 字符串字面值，类型是 char</span><br><span class="line">42ULL       // 无符号整型字面值，类型是 unsigned long long</span><br><span class="line">1E-3F       // 单精度浮点型字面值，类型是 float</span><br><span class="line">3.14159L    // 扩展精度浮点型字面值，类型是 long double</span><br></pre></td></tr></table></figure><p>对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。</p><blockquote><p>如果后缀中有<code>U</code>，则该字面值属于无符号类型，也就是说，以<code>U</code>为后缀的十进制数、八进制数或十六进制数都将从<code>unsigned int</code>、<code>unsigned long</code>和<code>unsigned long long</code>中选择能匹配的空间最小的一个作为其数据类型。如果后缀中有<code>L</code>，则字面值的类型至少是<code>long</code>；如果后缀中有<code>LL</code>，则字面值的类型将是<code>long long</code>和<code>unsigned long long</code>中的一种。显然我们可以将<code>U</code>与<code>L</code>或<code>LL</code>合在一起使用。例如，以<code>UL</code>为后缀的字面值的数据类型将根据具体数值情况或者取<code>unsigned long</code>，或者取<code>unsigned long long</code>。</p></blockquote><h2 id="布尔字面值和指针字面值">布尔字面值和指针字面值</h2><p><code>true</code>和<code>false</code>是布尔类型的字面值。</p><p><code>nullptr</code>是指针字面值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算术类型 </tag>
            
            <tag> 类型转换 </tag>
            
            <tag> 字面值常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>术语表-Chapter1</title>
      <link href="/2022/01/01/7-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter1/"/>
      <url>/2022/01/01/7-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter1/</url>
      
        <content type="html"><![CDATA[<p><code>参数（实参，argument）</code>：向函数传递的值。</p><p><code>赋值（assignment）</code>：抹去一个对象的当前值，用一个新值取代之。</p><p><code>程序块（block）</code>：零条或多条语句的序列，用花括号包围。</p><p><code>缓冲区（buffer）</code>：一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。我们可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout；程序非正常终止时也会刷新cout。</p><p><code>内置类型（built-in type）</code>：由语言定义的类型，如int。</p><p><code>Cerr</code>：一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到cerr的数据是不缓冲的。cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容。</p><p><code>字符串字面值常量（character string literal）</code>：术语stringliteral的另一种叫法。</p><p><code>cin</code>：一个istream对象，用来从标准输入读取数据。</p><p><code>类（class）</code>：一种用于定义自己的数据结构及其相关操作的机制。类是C++中最基本的特性之一。标准库类型中，如istream和ostream都是类。</p><p><code>类类型（class type）</code>：类定义的类型。类名即为类型名。</p><p><code>clog</code>：一个ostream对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。clog通常用于报告程序的执行信息，存入一个日志文件中。</p><p><code>注释（comment）</code>：被编译器忽略的程序文本。C++有两种类型的注释：单行注释和界定符对注释。单行注释以//开始，从//到行尾的所有内容都是注释。界定符对注释以/＊开始，其后的所有内容都是注释，直至遇到＊/为止。</p><p><code>条件（condition）</code>：求值结果为真或假的表达式。通常用值0表示假，用非零值表示真。</p><p><code>cout</code>：一个ostream对象，用于将数据写入标准输出。通常用于程序的正常输出内容。</p><p><code>花括号（curly brace）</code>：花括号用于划定程序块边界。左花括号（{）为程序块开始，右花括号（}）为结束。</p><p><code>数据结构（data structure）</code>：数据及其上所允许的操作的一种逻辑组合。</p><p><code>编辑-编译-调试（edit-compile-debug）</code>：使程序能正确执行的开发过程。</p><p><code>文件结束符（end-of-file）</code>：系统特定的标识，指出文件中无更多数据了。</p><p><code>表达式（expression）</code>：最小的计算单元。一个表达式包含一个或多个运算对象，通常还包含一个或多个运算符。表达式求值会产生一个结果。例如，假设i和j是int对象，则i+j是一个表达式，它产生两个int值的和。</p><p><code>for语句（for statement）</code>：迭代语句，提供重复执行能力。通常用来将一个计算反复执行指定次数。</p><p><code>函数（function）</code>：具名的计算单元。</p><p><code>函数体（function body）</code>：语句块，定义了函数所执行的动作。</p><p><code>函数名（function name）</code>：函数为人所知的名字，也用来进行函数调用。</p><p><code>头文件（header）</code>：使类或其他名字的定义可被多个程序使用的一种机制。程序通过#include指令使用头文件。</p><p><code>if语句（if statement）</code>：根据一个特定条件的值进行条件执行的语句。如果条件为真，执行if语句体。否则，执行else语句体（如果存在的话）。</p><p><code>初始化（initialize）</code>：在一个对象创建的时候赋予它一个值。</p><p><code>iostream</code>：头文件，提供了面向流的输入输出的标准库类型。</p><p><code>istream</code>：提供了面向流的输入的库类型。</p><p><code>库类型（library type）</code>：标准库定义的类型，如istream。</p><p><code>main</code>：操作系统执行一个C++程序时所调用的函数。每个程序必须有且只有一个命名为main的函数。</p><p><code>操纵符（manipulator）对象</code>，如<code>std::endl</code>，在读写流的时候用来“操纵”流本身。</p><p><code>成员函数（member function）</code>：类定义的操作。通常通过调用成员函数来操作特定对象。</p><p><code>方法（method）</code>：成员函数的同义术语。</p><p><code>命名空间（namespace）</code>：将库定义的名字放在一个单一位置的机制。命名空间可以帮助避免不经意的名字冲突。C++标准库定义的名字在命名空间std中。</p><p><code>ostream</code>：标准库类型，提供面向流的输出。</p><p><code>形参列表（parameter list）</code>：函数定义的一部分，指出调用函数时可以使用什么样的实参，可能为空列表。</p><p><code>返回类型（return type）</code>：函数返回值的类型。</p><p><code>源文件（source file）</code>：包含C++程序的文件。</p><p><code>标准错误（standard error）</code>：输出流，用于报告错误。标准输出和标准错误通常关联到程序执行所在的窗口。</p><p><code>标准输入（standard input）</code>：输入流，通常与程序执行所在窗口相关联。</p><p><code>标准库（standard library）</code>：一个类型和函数的集合，每个C++编译器都必须支持。标准库提供了支持IO操作的类型。C++程序员倾向于用“库”指代整个标准库，还倾向于用库类型表示标准库的特定部分，例如用“iostream库”表示标准库中定义IO类的部分。</p><p><code>标准输出（standard output）</code>：输出流，通常与程序执行所在窗口相关联。</p><p><code>语句（statement）</code>：程序的一部分，指定了当程序执行时进行什么动作。一个表达式接一个分号就是一条语句；其他类型的语句包括语句块、if语句、for语句和while语句，所有这些语句内都包含其他语句。</p><p><code>std</code>：标准库所使用的命名空间。<code>std::cout</code>表示我们要使用定义在命名空间std中的名字cout。</p><p><code>字符串常量（string literal）</code>：零或多个字符组成的序列，用双引号包围（“a string literal”）。</p><p><code>未初始化的变量（uninitialized variable）</code>：未赋予初值的变量。类类型的变量如果未指定初值，则按类定义指定的方式进行初始化。定义在函数内部的内置类型变量默认是不初始化的，除非有显式的初始化语句。试图使用一个未初始化变量的值是错误的。未初始化变量是bug的常见成因。</p><p><code>变量（variable）</code>：具名对象。</p><p><code>while语句（while statement）</code>：迭代语句，提供重复执行直至一个特定条件为假的机制。循环体会执行零次或多次，依赖于循环条件求值结果。</p><p><code>() 运算符（() operator）</code>：调用运算符。跟随在函数名之后的一对括号“()”，起到调用函数的效果。传递给函数的实参放置在括号内。</p><p><code>++ 运算符（++ operator）</code>：递增运算符。将运算对象的值加1，<code>++i</code>等价于<code>i=i+1</code>。</p><p><code>+= 运算符（+= operator）</code>：复合赋值运算符，将右侧运算对象加到左侧运算对象上；<code>a+=b</code>等价于<code>a=a+b</code>。</p><p><code>. 运算符（.operator）</code>：点运算符。左侧运算对象必须是一个类类型对象，右侧运算对象必须是此对象的一个成员的名字。运算结果即为该对象的这个成员。</p><p><code>:: 运算符（:: operator）</code>：作用域运算符。其用处之一是访问命名空间中的名字。例如，<code>std::cout</code>表示命名空间std中的名字cout。</p><p><code>= 运算符（= operator）</code>：将右侧运算对象的值赋予左侧运算对象所表示的对象。</p><p><code>-- 运算符（-- operator）</code>：递减运算符。将运算对象的值减1，<code>--i</code>等价于<code>i=i-1</code>。</p><p><code>&lt;&lt; 运算符（&lt;&lt; operator）</code>：输出运算符。将右侧运算对象的值写到左侧运算对象表示的输出流：<code>cout &lt;&lt;&quot;hi&quot;</code>表示将hi写到标准输出。输出运算符可以连接：<code>cout &lt;&lt;&quot;hi&quot; &lt;&lt;&quot;bye&quot;</code>表示将输出hibye。</p><p><code>&gt;&gt; 运算符（&gt;&gt; operator）</code>：输入运算符。从左侧运算对象所指定的输入流读取数据，存入右侧运算对象中：<code>cin &gt;&gt;i</code>表示从标准输入读取下一个值，存入i中。输入运算符可以连接：<code>cin &gt;&gt;i&gt;&gt;j</code>表示先读取一个值存入i，再读取一个值存入j。</p><p><code>\#include</code>：头文件包含指令，使头文件中代码可被程序使用。</p><p><code>== 运算符（== operator）</code>：相等运算符。检测左侧运算对象是否等于右侧运算对象。</p><p><code>!= 运算符（!= operator）</code>：不等运算符。检测左侧运算对象是否不等于右侧运算对象。</p><p><code>&lt;= 运算符（&lt;= operator）</code>：小于等于运算符。检测左侧运算对象是否小于等于右侧运算对象。</p><p><code>&lt; 运算符（&lt; operator）</code>：小于运算符。检测左侧运算对象是否小于右侧运算对象。</p><p><code>&gt;= 运算符（&gt;= operator）</code>：大于等于运算符。检测左侧运算对象是否大于等于右侧运算对象。</p><p><code>&gt; 运算符（&gt; operator）</code>：大于运算符。检测左侧运算对象是否大于右侧运算对象。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识C++(下)</title>
      <link href="/2021/10/27/6-%E5%88%9D%E8%AF%86cpp-%E4%B8%8B/"/>
      <url>/2021/10/27/6-%E5%88%9D%E8%AF%86cpp-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1>类</h1><p>类(class)：一个类定义了一个类型(class type)，其类型名就是类名，以及与其关联的一组操作。</p><p>如：<code>sales_item</code>类定义了一个名为<code>sales_item</code>的类型</p><p>与内置类型如<code>int</code>一样，我们可以定义类类型的变量，如：<code>sales_item item</code>表示<code>item</code>是一个<code>sales_item</code>类型的对象，通常简单表述为“一个<code>sale-item</code>对象”，或者，“一个<code>sales_item</code>”</p><h1>头文件</h1><p>头文件：通常根据其中定义的类的名字来命名，通常使用<code>.h</code>作为头文件的后缀，但也有些习惯用<code>.H</code>、<code>.hpp</code>或<code>.hxx</code>。标准库头文件通常不带后缀</p><p>头文件的作用：通过使用头文件来使用标准库设施，或者是访问为自己的应用程序所定义的类</p><p>通过<code>#include</code>指令使用头文件时，若是标准库的头文件，则用尖括号<code>&lt;&gt;</code>包围头文件名，如<code>#include &lt;iostream&gt;</code>，若是不属于标准库的头文件，则用双引号<code>&quot;&quot;</code>包围，如<code>#include &quot;sales_item&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 头文件 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识C++(中)</title>
      <link href="/2021/10/27/5-%E5%88%9D%E8%AF%86cpp-%E4%B8%AD/"/>
      <url>/2021/10/27/5-%E5%88%9D%E8%AF%86cpp-%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1>while</h1><p>while 语句的形式是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p><code>while</code>语句持续地交替检测<code>condition</code>和执行<code>statement</code>，直至<code>condition</code>为假为止</p><h1>语句块</h1><p>语句块(block)，是指用花括号<code>&#123;&#125;</code>包围的零条或多条语句的序列</p><p>语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = 0, val = 1;</span><br><span class="line">while (val &lt;= 10)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + val;        // 等价于 sum += val;</span><br><span class="line">        val = val + 1;          // 等价于 ++ val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1>for</h1><p><code>for</code>语句包含循环头和循环体，循环头控制循环体的执行次数</p><p>循环头：初始化语句(init-statement)、循环条件(condition)、表达式(expression)，即：<br><code>for (init-statement; condition; expression)</code></p><p><strong>初始化语句只在<code>for</code>循环入口处执行一次。在初始化语句中定义的变量，在循环结束之后是不能使用的</strong></p><p>循环体每次执行前都会先检查循环条件</p><p>表达式在<code>for</code>循环体之后执行（若循环体不被执行，则表达式亦不会被执行）</p><p>执行完表达式后，<code>for</code>语句重新检测循环条件，循环持续至循环条件为假</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">for (int val = 1; val &lt;= 10; ++ val)</span><br><span class="line">&#123;</span><br><span class="line">    sum += val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例中，初始化语句中定义的变量<code>val</code>在<code>for</code>语句结束后即失效</p><h1>for与while</h1><h2 id="for">for</h2><p>一般用于循环次数已知的情况，并且<code>for</code>循环可以节省内存以及代码简洁，在初始化语句中定义一个局部变量，循环结束后，局部变量即被释放</p><h2 id="while">while</h2><p>一般用于循环次数不确定的情况，并且通常需要在循环之前定义变量</p><h1>读取数量不定的输入数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0, value = 0;</span><br><span class="line">    // 读取数据直至遇到文件尾，计算所有读入的值的和</span><br><span class="line">    while (std::cin &gt;&gt; value)</span><br><span class="line">        sum += value;</span><br><span class="line">    std::cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例中，数据读取操作是在<code>while</code>的循环条件中完成的</p><p><code>while</code>循环条件的求值就是执行表达式<code>std::cin &gt;&gt; value</code>，表达式<code>std::cin &gt;&gt; value</code>返回输入运算符<code>&gt;&gt;</code>左侧运算对象，即<code>std::cin</code>，因此，该循环条件实际上是检测<code>std::cin</code></p><p>当我们使用一个<code>istream</code>对象如<code>cin</code>作为条件时，其效果是检测流(stream)的状态，当遇到文件结束符(end-of-file)或遇到一个无效的输入时(例如读入的值不是一个整数)，<code>istream</code>对象的状态会变为无效。进一步地，无效状态的<code>istream</code>对象会使条件变为假，循环结束</p><p>键盘输入文件结束符：<code>Ctrl + Z</code>然后按<code>Enter</code>或<code>Return</code>键(windows系统)，<code>Ctrl + D</code>键(UNIX系统、Mac OS X系统)</p><h1>if</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件<code>condition</code>为真，执行条件之后的语句块<code>statement</code>，否则不予执行</p><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件<code>condition</code>为真时执行<code>statement1</code>，否则执行<code>statement2</code></p><p>示例：用<code>if</code>语句统计输入序列中每个值连续出现了多少次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cin;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int currentNum, num;            // currentNum为当前统计的数字，num为新读取的数字</span><br><span class="line">    if (cin &gt;&gt; currentNum)          // 初始化当前统计数字</span><br><span class="line">    &#123;</span><br><span class="line">        int count = 1;              // 初始化当前统计数字的出现次数</span><br><span class="line">        while (cin &gt;&gt; num)          // 读取下一个数字</span><br><span class="line">        &#123;</span><br><span class="line">            if (num == currentNum)  // 如果新输入数字与当前统计的数字相同，出现次数加一</span><br><span class="line">                ++ count;</span><br><span class="line">            else                    // 如果不同，输出当前统计数字的出现次数，并更新所统计的数字，重置计数器</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; currentNum &lt;&lt; &quot; occurs &quot; &lt;&lt; count &lt;&lt; &quot; times &quot; &lt;&lt; endl;</span><br><span class="line">                currentNum = num;</span><br><span class="line">                count = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; currentNum &lt;&lt; &quot; occurs &quot; &lt;&lt; count &lt;&lt; &quot; times &quot; &lt;&lt; endl;     // 输出文件最后一个数字的出现次数</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> while </tag>
            
            <tag> for </tag>
            
            <tag> if </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识C++(上)</title>
      <link href="/2021/10/26/4-%E5%88%9D%E8%AF%86cpp-%E4%B8%8A/"/>
      <url>/2021/10/26/4-%E5%88%9D%E8%AF%86cpp-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1>main</h1><p><code>main</code>函数的返回类型必须是int，即整数类型</p><p>多数系统中，<code>main</code>的返回值用于指示状态：返回值0表示成功，非0返回值通常用来指出错误类型</p><p>当<code>return</code>语句包括一个值时，<strong>该返回值的类型必须与函数返回类型相容</strong>，如<code>main</code>函数的返回值0是int类型的值</p><h1>编译、运行程序</h1><p>源文件：带后缀<code>.c</code>、<code>.cxx</code>、<code>.cpp</code>、<code>.cp</code>、<code>.c</code>的程序文件</p><p>可执行文件：windows系统的<code>.exe</code>文件，UNIX系统的<code>.out</code>文件<br><em>注：windows系统运行一个可执行文件时，需提供可执行文件的文件名，可以忽略其拓展名<code>.exe</code>，而UNIX系统则需要使用完整的文件名(包含文件拓展名)</em></p><p><code>.</code>后面跟一个反斜线，即<code>.\</code>，指出文件在当前目录中，如<code>.\prog1.exe</code></p><p>运行GUN编译器的命令：<code>g++ -o prog1 prog1.cc</code>，其中，<code>-o prog1</code>是编译器参数，指定可执行文件的文件名。此命令生成名为<code>prog1</code>(UNIX)或<code>prog1.exe</code>(windows)的可执行文件。若省略<code>-o prog1</code>，则生成<code>a.out</code>(UNIX)或<code>a.exe</code>(windows)可执行文件</p><h1>输入与输出</h1><p>标准库<code>iostream</code>: 包含输入流<code>istream</code>与输出流<code>ostream</code></p><p>IO对象: <code>cin</code>(标准输入)、<code>cout</code>(标准输出)、<code>cerr</code>(输出警告与错误信息)、<code>clog</code>(输出程序运行时的一般性信息)</p><p><code>&lt;&lt;</code>: 输出运算符，将给定值写到给定的<code>ostream</code>对象中，如: <code>std::cout&lt;&lt;&quot;Enter two number&quot;;</code></p><p><code>&gt;&gt;</code>: 输入运算符，从给定的<code>istream</code>读入数据，并存入给定对象中，如: <code>std::cin&gt;&gt;v1;</code></p><p><code>endl</code>: 操纵符，写入<code>endl</code>的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流(stream)</p><p>流(stream)：一个流就算一个字符序列，是从IO设备读出或写入IO设备的。术语“流”想要表达的是，随着时间的推移，字符是顺序生成或消耗的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Enter two number&quot; &lt;&lt; std::endl;</span><br><span class="line">int v1 = 0, v2 = 0;</span><br><span class="line">std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>include</h1><p>程序使用标准库时，必须包含相关的头文件，如: <code>#include &lt;iostream&gt;</code>告诉编译器使用<code>iostream</code>库</p><p>尖括号内的名字即指出了一个头文件，如<code>iostream</code>、<code>array</code>、<code>cmath</code>、<code>algorithm</code>等</p><p><code>#include</code>指令和头文件的名字必须写在同一行中，<strong>不用以分号结束</strong></p><p>通常情况下，<code>#include</code>指令必须出现在所有函数之外</p><p>一般将一个程序的所有<code>#include</code>指令都放在源文件的开始位置</p><h1>命名空间</h1><p>命名空间可以避免名字定义冲突以及使用库中相同名字导致的冲突，标准库定义的所有名字都在命名空间<code>std</code>中</p><p>通过命名空间使用标准库有一个副作用：<strong>当使用标准库中的一个名字时，必须显式说明使用的是命名空间<code>std</code>中的名字</strong></p><p><code>::</code>: 作用域操作符，编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字</p><p><code>std::</code>: 指出名字是定义在<code>std</code>的命名空间(namespace)中的，如: <code>std::cin</code>、<code>std::cout</code>、<code>std::endl</code>分别指出<code>cin</code>、<code>cout</code>、<code>endl</code>是命名空间<code>std</code>中的</p><p><code>using</code>声明: 一开始对<code>cin</code>、<code>cout</code>、<code>endl</code>使用<code>using</code>声明，后续不需要添加<code>std::</code>形式的前缀即可使用它们。注意，<strong>每行的<code>using</code>声明都要以分号结束</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::cin;</span><br><span class="line">using std::endl;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Enter two number&quot; &lt;&lt; endl;</span><br><span class="line">int v1 = 0, v2 = 0;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">cout &lt;&lt; &quot;The product of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 * v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>注释</h1><p>单行注释: 以双斜线<code>//</code>开始，以换行符结束。这种注释可以包含任何文本，包括额外的双斜线</p><p>界定符对注释：以界定符<code>/*</code>开始，以界定符<code>*/</code>结束，可以包含除<code>*/</code>外的任意内容，包括换行符。因此，界定符对注释可以跨越程序中的多行</p><p>注释界定符可以放置于任何允许放置制表符、空格符或换行符的地方</p><p>当注释界定符跨越多行，最好能显示指出其内部的程序行都属于多行注释的一部分，C++ Primer所采用的风格是：注释内的每行都以一个星号开头，从而指出整个范围都是多行注释的一部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line">/*</span><br><span class="line">* 简单主函数</span><br><span class="line">* 读取两个数，求它们的和</span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //提示用户输入两个数</span><br><span class="line">    std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;</span><br><span class="line">    int v1 = 0, v2 = 0;     //保存用于读取输入数据的变量</span><br><span class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;   //读取输入数据</span><br><span class="line">    std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2</span><br><span class="line">              &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释界定符对通常用于多行解释，而双斜线注释常用于半行和单行附注</strong></p><p>注意：<strong>注释界定符不能嵌套</strong>，因为界定符对以<code>/*</code>开始，以<code>*/</code>结束</p><p>调试时，通常需要注释掉一些代码，由于这些代码本身可能包含界定符对形式的注释，若继续采用界定符对进行注释则可能导致注释嵌套错误，因此，调试时注释的最好的方式是用单行注释方式注释掉代码段的每一行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /*</span><br><span class="line">// * 单行注释中的任何内容都会被忽略</span><br><span class="line">// * 包括内部的注释对也一样会被忽略</span><br><span class="line">// */</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> main </tag>
            
            <tag> return </tag>
            
            <tag> 可执行文件 </tag>
            
            <tag> include </tag>
            
            <tag> 命名空间 </tag>
            
            <tag> 注释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode使用</title>
      <link href="/2021/10/26/3-vscode%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/26/3-vscode%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>vscode快捷键</h1><h2 id="主命令框">主命令框</h2><p>Ctrl + Shift + P: 打开命令面板</p><h2 id="编辑器与窗口">编辑器与窗口</h2><p>Ctrl + K, V: 打开预览面板</p><p>Ctrl + `: 打开/关闭终端</p><p>Ctrl + Tab: 文件之间切换</p><p>Ctrl + W: 关闭当前窗口</p><h2 id="代码编辑">代码编辑</h2><p>Ctrl + F: 查找</p><p>Ctrl + H: 查找替换</p><p>Ctrl + Shift + T: 重新打开刚关闭的编辑页面</p><p>Ctrl + Backspace: 删除上一个单词</p><p>Ctrl + N: 新建文件</p><p>Ctrl + S: 保存</p><h2 id="光标">光标</h2><p>Home: 光标移动至行首</p><p>End: 光标移动至行末</p><p>Ctrl + Home: 光标移至文件开头</p><p>Ctrl + End: 光标移至文件末尾</p><p>Shift + Home: 选择从光标到行首的内容</p><p>Shift + End: 选择从光标到行尾的内容</p><p>Alt + Up: 向上移动一行</p><p>Alt + Down: 向下移动一行</p><h2 id="调试、运行">调试、运行</h2><p>Ctrl + Shift + B: 重启调试</p><p>Ctrl + F5: 运行但不调试</p><p>F5: 启动调试</p><h1>终端Terminal指令</h1><h2 id="hexo">hexo</h2><p><code>hexo n &quot; &quot;</code>: 新建md文件</p><p><code>hexo c</code>: 清理</p><p><code>hexo g</code>: 生成</p><p><code>hexo d</code>: 部署到github</p><h2 id="g">g++</h2><p><code>g++ hello.cpp -o hello.exe</code>: 输出编译后的结果到指定的文件file中 (输出指定的可执行文件 hello.exe)，-o不仅可以指定输出的可执行文件，还可以指定中间文件的输出</p><p><code>g++ -o hello.exe hello.cpp</code>: 同上</p><p><code>g++ hello.cpp</code>: 输出的是 a.exe</p><p><code>g++ -E -o hello.i hello.cpp</code>: 对源文件进行预处理，预处理后生成.i(或者是 .ii)文件，对hello.cpp进行预处理生成hello.i文件</p><p><code>g++ -S -o hello.s hello.cpp</code>: 只进行预处理和编译，生成汇编文件hello.s</p><p><code>g++ -c -o hello.o hello.cpp</code>: 只进行预处理，编译，汇编操作，生成.o (.obj)文件，不进行链接</p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2021/10/24/2-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/10/24/2-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1>安装git</h1><ol><li>下载：<a href="https://git-scm.com/download">https://git-scm.com/download</a></li><li>安装：除了选择安装路径外，一直点next就行</li></ol><p>可参考教程<a href="https://blog.csdn.net/hahameier/article/details/86312530">https://blog.csdn.net/hahameier/article/details/86312530</a></p><h1>安装node.js</h1><ol><li>下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装：除了选择路径以外，一直点next就行</li></ol><h1>安装hexo框架</h1><h2 id="进入命令行">进入命令行</h2><p>打开命令行窗口：按<code>win+r</code>键，输入<code>cmd</code>，回车，后续操作均在命令行进行</p><h2 id="查看node-js版本">查看node.js版本</h2><ol><li>查看node版本：输入<code>node -v</code>，回车</li><li>查看npm版本：输入<code>npm -v</code>，回车</li></ol><h2 id="安装cnpm">安装cnpm</h2><ol><li>安装cnpm镜像源：输入<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>，回车，等待…</li><li>查看cnpm版本：输入<code>cnpm -v</code>，回车</li></ol><h2 id="安装hexo">安装hexo</h2><ol><li>安装hexo框架：输入<code>cnpm install -g hexo-cli</code>，回车</li><li>查看hexo版本：输入<code>hexo -v</code>，回车</li></ol><h1>搭建博客</h1><h2 id="新建blog文件">新建blog文件</h2><ol><li>找到git安装路径下的<code>git-cmd.exe</code>，以管理员权限打开</li><li>输入<code>mkdir e:\blog</code>并回车，实现在<code>e:\</code>路径下创建blog文件夹</li><li>配置路径，输入<code>cd e:\blog</code>回车，输入<code>e:</code>，回车</li></ol><h2 id="生成博客">生成博客</h2><ol><li>初始化博客：输入<code>hexo init</code>，回车，等待…直到出现<code>INFO Starting blogging with Hexo</code></li><li>启动本地博客服务：输入<code>hexo s</code>，回车，得到本地访问地址<code>http://localhost:4000</code></li><li>访问本地博客：浏览器打开<code>localhost:4000</code></li></ol><h2 id="安装git插件">安装git插件</h2><ol><li>配置到blog目录，<code>cd e:\blog</code></li><li>安装部署插件：输入<code>cnpm install --save hexo-deployer-git</code>并回车，等待安装完成，如若出现warning可直接忽略</li></ol><h2 id="配置git">配置git</h2><ol><li>打开<strong>git bash</strong></li><li>输入<code>git config --global user.email YourEmail</code>，其中<code>YourEmail</code>是github邮箱</li><li>输入<code>git config --global user.name YourName</code>，<code>YourName</code>是github用户名</li></ol><h2 id="创建github仓库">创建github仓库</h2><ol><li>登录github网页的个人账户</li><li>右上角<code>New repository</code>新建仓库</li><li><code>Repository name</code>命名为个人用户名<code>YourName</code>加上<code>.github.io</code>，即，仓库名为<code>YourName.github.io</code></li></ol><h2 id="配置-config-yml">配置_config.yml</h2><ol><li>使用记事本打开<code>e:\blog</code>路径下的<code>_config.yml</code>文件</li><li>找到<code>Deployment</code>板块，配置如下</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line"> type: git</span><br><span class="line">repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure><p>其中，<code>repo</code>后面的链接为个人github仓库的链接</p><p><strong>注：冒号后面需要有英文环境下的空格</strong></p><h2 id="部署到github仓库">部署到github仓库</h2><ol><li>cmd命令行配置到路径<code>e:\blog</code></li><li>部署：输入<code>hexo d</code>并回车，部署到Github仓库里</li><li>等待弹窗，输入github账户密码，即配置完成</li></ol><h1>hexo相关命令</h1><ol><li><code>hexo clean</code>：清理</li><li><code>hexo n</code>：新建</li><li><code>hexo g</code>：生成博客</li><li><code>hexo s</code>：启动本地博客服务</li><li><code>hexo d</code>：部署到远端github博客</li></ol><h1>参考</h1><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1635071237&amp;unique_k=kYdWS1">视频教程</a></p><p><a href="https://blog.csdn.net/zgd826237710/article/details/99671027?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163507159316780261929572%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163507159316780261929572&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-99671027.pc_search_ecpm_flag&amp;utm_term=hexo%E4%B8%BB%E9%A2%98&amp;spm=1018.2226.3001.4187">hexo主题</a></p><p>个人博客地址：<a href="https://jiankychen.github.io/">https://jiankychen.github.io/</a></p><p><a href="https://zhuanlan.zhihu.com/p/108898992?utm_source=wechat_session">解决 Github 连接不上的问题</a></p><p><a href="https://jingyan.baidu.com/article/63f2362893f7e10208ab3df8.html">如何配置HOSTS文件</a></p><p><a href="https://www.cnblogs.com/philobing/p/15670470.html">HOSTS文件配置</a></p><p><a href="https://jingyan.baidu.com/article/3c343ff7b8fe550d377963e7.html">修改hosts文件提示没有权限保存怎么办</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2021/10/24/1-markdown/"/>
      <url>/2021/10/24/1-markdown/</url>
      
        <content type="html"><![CDATA[<h1>Markdown</h1><p><a href="https://blog.csdn.net/lanxuezaipiao/article/details/44307757?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&amp;spm=1001.2101.3001.4242.0">markdown基本语法-文字版</a></p><p><a href="https://www.bilibili.com/video/BV1JA411h7Gw/?spm_id_from=333.788.recommend_more_video.2">markdown基本语法-视频版</a></p><p><a href="https://zhuanlan.zhihu.com/p/208791140">编辑器测评</a></p><p>编辑器推荐：<strong>vscode</strong>，Joplin，Typora，sublime，Moeditor</p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"string","short_name":"Junzhou","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"images/pwaicons/36.png","sizes":"36x36","type":"image/png"},{"src":"images/pwaicons/48.png","sizes":"48x48","type":"image/png"},{"src":"images/pwaicons/72.png","sizes":"72x72","type":"image/png"},{"src":"images/pwaicons/96.png","sizes":"96x96","type":"image/png"},{"src":"images/pwaicons/144.png","sizes":"144x144","type":"image/png"},{"src":"images/pwaicons/192.png","sizes":"192x192","type":"image/png"},{"src":"images/pwaicons/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
