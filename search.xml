<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 1491. 去掉最低工资和最高工资后的平均工资</title>
      <link href="/2022/03/15/LeetCode1491-%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B9%B3%E5%9D%87%E5%B7%A5%E8%B5%84/"/>
      <url>/2022/03/15/LeetCode1491-%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B9%B3%E5%9D%87%E5%B7%A5%E8%B5%84/</url>
      
        <content type="html"><![CDATA[<h1>1491. 去掉最低工资和最高工资后的平均工资</h1><p><a href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/">LeetCode 1491</a></p><p>给你一个整数数组<code>salary</code>，数组里每个数都是<strong>唯一</strong>的，其中<code>salary[i]</code>是第<code>i</code>个员工的工资。</p><p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p><p></p><p>示例 1：</p><pre><code>输入：salary = [4000,3000,1000,2000]输出：2500.00000解释：最低工资和最高工资分别是 1000 和 4000 。去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500</code></pre><p>示例 2：</p><pre><code>输入：salary = [1000,2000,3000]输出：2000.00000解释：最低工资和最高工资分别是 1000 和 3000 。去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000</code></pre><p>示例 3：</p><pre><code>输入：salary = [6000,5000,4000,3000,2000,1000]输出：3500.00000</code></pre><p>示例 4：</p><pre><code>输入：salary = [8000,9000,2000,3000,6000,1000]输出：4750.00000</code></pre><h2 id="Method">Method</h2><p>逐个比较，更新最大值和最小值，并累加求和，最后再减去最大值和最小值。注意，求平均值时，被除数或者除数要转换成<code>double</code>型，这样才能保留小数点后的计算结果。</p><pre><code>double average(vector&lt;int&gt;&amp; salary) &#123;    int min = salary[0], max = salary[0], sum = 0;    for (int i = 0; i &lt; salary.size(); i++)    &#123;        if (salary[i] &gt; max) max = salary[i];        else if (salary[i] &lt; min) min = salary[i];        sum += salary[i];    &#125;;    double ans = double(sum - max - min) / (salary.size() - 2); // 注意这里被除数或除数要变成double型    return ans;</code></pre><blockquote><p>时间复杂度：<code>O(n)</code>。选取最大值、最小值和求和的过程的时间代价都是<code>O(n)</code>，故渐进时间复杂度为<code>O(n)</code>。</p><p>空间复杂度：<code>O(1)</code>。这里只用到了常量级别的辅助空间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1523. 在区间范围内统计奇数数目</title>
      <link href="/2022/03/15/LeetCode1523-%E5%9C%A8%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%BB%9F%E8%AE%A1%E5%A5%87%E6%95%B0%E6%95%B0%E7%9B%AE/"/>
      <url>/2022/03/15/LeetCode1523-%E5%9C%A8%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%BB%9F%E8%AE%A1%E5%A5%87%E6%95%B0%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1>1523. 在区间范围内统计奇数数目</h1><p><a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range/">LeetCode 1523</a></p><p>给你两个非负整数<code>low</code>和<code>high</code>。请你返回<code>low</code>和<code>high</code>之间（包括二者）奇数的数目。</p><p></p><p>示例 1：</p><pre><code>输入：low = 3, high = 7输出：3解释：3 到 7 之间奇数数字为 [3,5,7] 。</code></pre><p>示例 2：</p><pre><code>输入：low = 8, high = 10输出：1解释：8 到 10 之间奇数数字为 [9] 。</code></pre><h2 id="Method-前缀和思想">Method: 前缀和思想</h2><blockquote><p>暴力枚举<code>[low,high]</code>中的所有元素会超出时间限制。</p></blockquote><p>可以使用前缀和思想来解决这个问题，定义<code>pre(x)</code>为区间<code>[0,x]</code>中奇数的个数，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">pre(x)=(x+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>。因此<code>[low,high]</code>之间的奇数数目为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pre(high)−pre(low−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><pre><code>int pre(int x)&#123; // 返回[0,x]之间的奇数数目    return (x + 1) / 2;&#125;int countOdds(int low, int high) &#123; // [low,high]之间的奇数数目=[0,high]之间的奇数数目-[0,low-1]之间的奇数数目    return pre(high) - pre(low - 1);&#125;</code></pre><blockquote><p>时间复杂度：<code>O(1)</code>。</p><p>空间复杂度：<code>O(1)</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22-表达式基础</title>
      <link href="/2022/03/15/22-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/15/22-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>表达式</strong>通常由<strong>运算符</strong>和<strong>运算对象</strong>组成</p><p><strong>字面值</strong>和<strong>变量</strong>是最简单的表达式</p><h1>基本概念</h1><p>一元运算符：作用于一个运算对象的运算符，如取地址符<code>&amp;</code>和解引用符<code>*</code></p><p>二元运算符：作用于两个运算对象的运算符，如相等运算符<code>==</code>和乘法运算符<code>*</code></p><p>三元运算符：作用于三个运算对象，如条件运算符<code>_ ? _ : _</code></p><h2 id="组合运算符和运算对象">组合运算符和运算对象</h2><p>表达式的求值结果，依赖于运算符的<strong>优先级</strong>、<strong>结合律</strong>以及<strong>运算对象的求值顺序</strong></p><blockquote><p>优先级：例如，<code>*</code>优先级高于<code>+</code><br>结合律：通常是从左往右，遇到括号时则是由内到外<br>求值顺序：例如，<code>f1() + f2()</code>，对于<code>f1()</code>和<code>f2()</code>的计算，没有明确的顺序</p></blockquote><h2 id="重载运算符">重载运算符</h2><p>当运算符作用于类类型的运算对象时，用户可以自行定义其含义</p><blockquote><p>这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载运算符</p></blockquote><p><code>IO</code>库的<code>&gt;&gt;</code>和<code>&lt;&lt;</code>运算符以及<code>string</code>对象、<code>vector</code>对象和迭代器使用的运算符都是重载的运算符</p><p>使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的</p><p><strong>运算对象的个数、运算符的优先级和结合律都是无法改变的</strong></p><h2 id="左值和右值">左值和右值</h2><p>C++的表达式要么是右值，要么就是左值，即，非左即右</p><blockquote><p>C语言：左值可以位于赋值语句的左侧，右值则不能</p></blockquote><p>C++语言则复杂得多：</p><ol><li>右值：取不到地址的表达式</li><li>左值：能取到地址的表达式</li><li>常量对象为代表的左值不能作为赋值语句的左侧运算对象。（即，不能修改常量对象的值）</li><li>某些表达式的求值结果是对象，但它们是右值。（例如，临时的对象<code>1+a</code>无法取地址，故而是右值）</li></ol><p><strong>当一个对象被用作右值的时候，用的是对象的值（内容）</strong></p><p><strong>当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</strong></p><blockquote><p>在需要右值的地方可以用左值来代替。当一个左值被当成右值使用时，实际使用的是它的内容（值）</p><p>不能把右值当成左值（也就是位置）使用</p></blockquote><p><strong>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值</strong></p><p><strong>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code>和<code>vector</code>的下标运算符的求值结果都是左值</strong></p><p>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本（之前章节所用的形式）所得的结果也是左值</p><p>关键字<code>decltype</code>与表达式：<strong>如果表达式的求值结果是左值，<code>decltype</code>作用于该表达式（不是变量）得到一个引用类型</strong>。例如，对于<code>int *p</code>，因为解引用运算符（即，<code>*p</code>）生成左值，所以<code>decltype(*p)</code>的结果是引用类型，即<code>int&amp;</code>；另一方面，因为取地址运算符（即，<code>&amp;p</code>）生成右值，所以<code>decltype(&amp;p)</code>的结果是<code>int**</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 278. 第一个错误的版本</title>
      <link href="/2022/03/15/LeetCode278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/"/>
      <url>/2022/03/15/LeetCode278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1>278. 第一个错误的版本</h1><p><a href="https://leetcode-cn.com/problems/first-bad-version/">LeetCode 278</a></p><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有<code>n</code>个版本<code>[1,2,...,n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用<code>isBadVersion(version)</code>接口来判断版本号<code>version</code>是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用<code>API</code>的次数。</p><p>示例 1：</p><pre><code>输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。</code></pre><p>示例 2：</p><pre><code>输入：n = 1, bad = 1输出：1</code></pre><h2 id="Method-二分查找">Method: 二分查找</h2><p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。</p><p>将左右边界分别初始化为<code>1</code>和<code>n</code>，其中<code>n</code>是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p><p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧<code>O(logn)</code>次。</p><pre><code>int firstBadVersion(int n) &#123;    int left = 1, right = n;    while (left &lt; right) &#123; // 循环直至区间左右端点相同        int mid = left + (right - left) / 2; // 防止计算时溢出        if (isBadVersion(mid)) &#123;            right = mid; // 答案在区间 [left, mid] 中        &#125; else &#123;            left = mid + 1; // 答案在区间 [mid+1, right] 中        &#125;    &#125;    // 此时有 left == right，区间缩为一个点，即为答案    return left;&#125;</code></pre><blockquote><p>复杂度分析</p><p>时间复杂度：<code>O(logn)</code>，其中<code>n</code>是给定版本的数量。</p><p>空间复杂度：<code>O(1)</code>。我们只需要常数的空间保存若干变量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 557. 反转字符串中的单词 III</title>
      <link href="/2022/03/15/LeetCode557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/"/>
      <url>/2022/03/15/LeetCode557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/</url>
      
        <content type="html"><![CDATA[<h1>557. 反转字符串中的单词 III</h1><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">LeetCode 557</a></p><p>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>示例 1：</p><pre><code>输入：s = &quot;Let's take LeetCode contest&quot;输出：&quot;s'teL ekat edoCteeL tsetnoc&quot;</code></pre><p>示例 2:</p><pre><code>输入： s = &quot;God Ding&quot;输出：&quot;doG gniD&quot;</code></pre><h2 id="Method-1-双指针（原地解法）">Method 1: 双指针（原地解法）</h2><p>当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符……如此反复，就可以在原空间上翻转单词。</p><p>具体流程如下：</p><ol><li>指针<code>left</code>指向第一个字符或空字符前一个字符（双指针中的左端指针）</li><li>指针<code>search</code>向右搜索</li><li>当<code>search</code>搜索到空字符或尾后时，将<code>search - 1</code>赋给双指针中的右端指针<code>right</code></li><li>将<code>left</code>和<code>right</code>之间的所有字符反转</li></ol><p>重复上述操作，直到所有字符均已被反转</p><pre><code>string reverseWords(string s) &#123;    int search = 0;    auto n = s.size();    while (search &lt; n)    &#123;        int left = search;                            // left指向第一个字符或空字符后一个字符        while (s[search] != ' ' &amp;&amp; search &lt; n)        // 向右搜索，直到遇到空字符或者最后一个字符        &#123;            search++;        &#125;;        int right = search - 1;                       // right指向空字符前一个位置，即，单词最后一个字符所在位置        while (left &lt; right)                          // 反转单词        &#123;            swap(s[left], s[right]);            left++;            right--;        &#125;;        search++;                                     // 继续搜索    &#125;;    return s;&#125;</code></pre><blockquote><p>复杂度分析</p><p>时间复杂度：<code>O(N)</code>。字符串中的每个字符要么在<code>O(1)</code>的时间内被交换到相应的位置，要么因为是空格而保持不动。</p><p>空间复杂度：<code>O(1)</code>。因为不需要开辟额外的数组。</p></blockquote><h2 id="Method-2-双指针（使用额外空间）">Method 2: 双指针（使用额外空间）</h2><p>开辟一个新字符串。从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词并得到单词的起止位置。随后，将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串。</p><pre><code>string reverseWords(string s) &#123;    string ret;    int length = s.length();    int i = 0;    while (i &lt; length) &#123;        int start = i;        while (i &lt; length &amp;&amp; s[i] != ' ') &#123;            i++;        &#125;        for (int p = start; p &lt; i; p++) &#123;            ret.push_back(s[start + i - 1 - p]);        &#125;        while (i &lt; length &amp;&amp; s[i] == ' ') &#123;            i++;            ret.push_back(' ');        &#125;    &#125;    return ret;&#125;</code></pre><blockquote><p>复杂度分析</p><p>时间复杂度：<code>O(N)</code>，其中<code>N</code>为字符串的长度。原字符串中的每个字符都会在<code>O(1)</code>的时间内放入新字符串中。</p><p>空间复杂度：<code>O(N)</code>。开辟了与原字符串等大的空间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 344. 反转字符串</title>
      <link href="/2022/03/15/LeetCode344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/03/15/LeetCode344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1>344. 反转字符串</h1><p><a href="https://leetcode-cn.com/problems/reverse-string/">LeetCode 344</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组<code>s</code>的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用<code>O(1)</code>的<strong>额外空间</strong>解决这一问题。</p><p>示例 1：</p><pre><code>输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p>示例 2：</p><pre><code>输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><h2 id="Method-双指针">Method: 双指针</h2><ol><li>将<code>left</code>指向字符数组首元素，<code>right</code>指向字符数组尾元素。</li><li>当<code>left &lt; right</code>：交换<code>s[left]</code>和<code>s[right]</code>；<code>left</code>指针右移一位；<code>right</code>指针左移一位。</li><li>当<code>left &gt;= right</code>，反转结束，返回字符数组即可。</li></ol><p>程序如下：</p><pre><code>void reverseString(vector&lt;char&gt;&amp; s) &#123;    int left = 0, right = s.size() - 1;    while (left &lt; right)    &#123;        char temp = s[right];        s[right] = s[left];        s[left] = temp;        left++;        right--;    &#125;;&#125;</code></pre><blockquote><p>复杂度分析<br>时间复杂度：<code>O(N)</code>，其中<code>N</code>为字符数组的长度。一共执行了<code>N/2</code>次的交换。<br>空间复杂度：<code>O(1)</code>。只使用了常数空间来存放若干变量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
      <link href="/2022/03/14/LeetCode167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/14/LeetCode167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1>167. 两数之和 II - 输入有序数组</h1><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167</a></p><p>给你一个下标从<code>1</code>开始的整数数组 numbers，该数组已按<strong>非递减顺序排列</strong>，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是<code>numbers[index1]</code>和<code>numbers[index2]</code>，则<code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>。</p><p>以长度为<code>2</code>的整数数组<code>[index1, index2]</code>的形式返回这两个整数的下标<code>index1</code>和<code>index2</code>。</p><p>你可以假设每个输入<strong>只对应唯一的答案</strong>，而且你<strong>不可以</strong>重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p>示例 1：</p><pre><code>输入：numbers = [2,7,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</code></pre><p>示例 2：</p><pre><code>输入：numbers = [2,3,4], target = 6输出：[1,3]解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。</code></pre><p>示例 3：</p><pre><code>输入：numbers = [-1,0], target = -1输出：[1,2]解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</code></pre><h2 id="Method-1-双指针">Method 1: 双指针</h2><p>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较：</p><ol><li>如果两个元素之和等于目标值，则发现了唯一解。</li><li>如果两个元素之和小于目标值，则将左侧指针右移一位。</li><li>如果两个元素之和大于目标值，则将右侧指针左移一位。</li></ol><p>移动指针之后，重复上述操作，直到找到答案。</p><pre><code>vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;    int i = 0, j = numbers.size() - 1;    while (i &lt; j)    &#123;        if (numbers[i] == target - numbers[j])            return &#123;i + 1, j + 1&#125;;        else if (numbers[i] &lt; target - numbers[j])            i++;        else            j--;    &#125;;    return &#123;-1, -1&#125;;&#125;</code></pre><blockquote><p>复杂度分析：</p><p>时间复杂度：<code>O(n)</code>，其中<code>n</code>是数组的长度。两个指针移动的总次数最多为<code>n</code>次</p><p>空间复杂度：<code>O(1)</code></p></blockquote><h2 id="Method-2-二分查找">Method 2: 二分查找</h2><p>在数组中找到两个数，使得它们的和等于目标值，可以首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。</p><pre><code>vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;    for (int i = 0; i &lt; numbers.size(); ++i) &#123;        int low = i + 1, high = numbers.size() - 1;        while (low &lt;= high) &#123;            int mid = (high - low) / 2 + low;            if (numbers[mid] == target - numbers[i]) &#123;                return &#123;i + 1, mid + 1&#125;;            &#125; else if (numbers[mid] &gt; target - numbers[i]) &#123;                high = mid - 1;            &#125; else &#123;                low = mid + 1;            &#125;        &#125;    &#125;    return &#123;-1, -1&#125;;&#125;</code></pre><blockquote><p>复杂度分析</p><p>时间复杂度：<code>O(nlogn)</code>，其中<code>n</code>是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是<code>O(n)</code>，寻找第二个数使用二分查找，时间复杂度是<code>O(logn)</code>，因此总时间复杂度是<code>O(nlogn)</code>。</p><p>空间复杂度：<code>O(1)</code></p></blockquote><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/">题解：推荐使用双指针方法</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 283. 移动零</title>
      <link href="/2022/03/14/LeetCode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2022/03/14/LeetCode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1>283. 移动零</h1><p><a href="https://leetcode-cn.com/problems/move-zeroes/">LeetCode 283</a></p><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><pre><code>输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p>示例 2:</p><pre><code>输入: nums = [0]输出: [0]</code></pre><h2 id="Method-1-翻转数组">Method 1: 翻转数组</h2><ol><li>设索引为<code>i</code>，若<code>nums[i]</code>为<code>0</code>，则翻转第<code>i</code>至第<code>nums.size()-1-num</code>位。</li><li>翻转第<code>i</code>位至第<code>nums.size()-2-num</code>位，将非零元素翻转回原来的顺序。注意，经过这次翻转，需要重新对第<code>i</code>位进行判断，因为新数组的第<code>i</code>位实际上是最初数组的第<code>i+1</code>位</li></ol><blockquote><p>因为末尾已有<code>num</code>个<code>0</code>，需要将第<code>i</code>位上的<code>0</code>放到第<code>n-1-num</code>位上，才能使得两次翻转后非零元素的顺序不变 并且 之前找到的<code>0</code>仍在末尾。</p></blockquote><pre><code>// 翻转left至right之间的所有元素void reverse(vector&lt;int&gt;&amp; nums, int left, int right)&#123;    while (left &lt; right)    &#123;        swap(nums[left], nums[right]);        left++;        right--;    &#125;;&#125;void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size(), i = 0, num = 0;    while (i &lt; n - num)    &#123;        if (nums[i] == 0)        &#123;            reverse(nums, i, n - 1 - num);      // 末尾已有num个0，将第i位上的0放到第n-1-num位上，执行翻转操作            reverse(nums, i, n - 2 - num);      // 保持末尾的num+1个0不动，翻转第i位至第n-2-num位，可使非零元素恢复原顺序            num++;                  // 因为移动了一个0到最末尾，故而i可以少移动一位        &#125;        else            i++;    &#125;;&#125;</code></pre><h2 id="Method-2-双指针">Method 2: 双指针</h2><p>使用双指针，左指针指向当前的搜索位置，右指针指向补0位置。当左指针搜索到0时，将左指针与右指针之间的数左移一位，右指针位置赋0，同时右指针左移一位。</p><pre><code>void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    int i = 0, j = n - 1;    while (i &lt; j)    &#123;        if (nums[i] == 0)    // 第i位为0时，将第i+1至j位均向左移动一位，第j位赋值0，向左移动指针j        &#123;            for (int k = i + 1; k &lt;= j; k++)                nums[k-1] = nums[k];            nums[j] = 0;            j--;        &#125;        else i++;           // 第i位不为0时，指针i继续向右移动    &#125;;&#125;</code></pre><h2 id="Method-3-双指针（两次遍历）">Method 3: 双指针（两次遍历）</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/">题解</a></p><p>指针<code>i</code>和<code>j</code>，指针<code>i</code>用于遍历搜索，指针<code>j</code>用来记录当前有多少非<code>0</code>元素。</p><p>第一次遍历的时候每遇到一个非<code>0</code>元素就将其往数组左边挪，第一次遍历完后，<code>j</code>指针的下标就指向了最后一个非<code>0</code>元素下标。</p><p>第二次遍历的时候，起始位置就从<code>j</code>开始到结束，将剩下的这段区域内的元素全部置为<code>0</code>。</p><pre><code>void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    // 指针j记录非0元素数，只要nums[i]非零就都赋给nums[j]，然后i,j向右移位，循环终止时，j所在位置是最后一个非0元素的下一位，即，赋0的起点    int j = 0;    for (int i = 0; i &lt; nums.size(); i++)    &#123;        if (nums[i] != 0)        &#123;            nums[j] = nums[i];            j++;        &#125;    &#125;;    // 从第j位开始赋0    for (int i = j; i &lt; nums.size(); i++)        nums[i] = 0;&#125;;</code></pre><h2 id="Method-3-双指针（一次遍历）">Method 3: 双指针（一次遍历）</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/">题解</a></p><p>这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点<code>x</code>，然后把所有小于等于<code>x</code>的元素放到<code>x</code>的左边，大于<code>x</code>的元素放到其右边。</p><p>这里用<code>0</code>当做这个中间点，把不等于<code>0</code>的放到中间点的左边，等于<code>0</code>的放到其右边。</p><p>指针<code>i</code>用于遍历搜索，指针<code>j</code>用来记录当前有多少非<code>0</code>元素，只要<code>nums[i]!=0</code>，我们就交换<code>nums[i]</code>和<code>nums[j]</code>（也可以直接将nums[i]赋给），并且将<code>i</code>,<code>j</code>右移。</p><p>Code 1：</p><pre><code>void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int j = 0;    for (int i = 0; i &lt; nums.size(); i++)    &#123;        if (nums[i] != 0)        &#123;            int temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;            j++;        &#125;    &#125;;&#125;</code></pre><p>Code 2：</p><pre><code>void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int j = 0;    for (int i = 0; i &lt; nums.size(); i++)    &#123;        if (nums[i] != 0)        &#123;            if (i &gt; j)  // #1            &#123;                nums[j] = nums[i];                nums[i] = 0;            &#125;            j++;        &#125;    &#125;;&#125;</code></pre><p>与<code>Code 1</code>相比，<code>Code 2</code>优化<code>#1</code>处。<code>Code 2</code>避免了数组开头的非零元素的交换，也就是阻止<code>i == j</code>时交换。当<code>i &gt; j</code> 时，只需要把 <code>i</code> 的值赋值给<code>j</code>并把原位置的值置<code>0</code>。同时这里也把交换操作换成了赋值操作，理论上能更节省时间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 189. 轮转数组</title>
      <link href="/2022/03/14/LeetCode189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/14/LeetCode189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1>189. 轮转数组</h1><p><a href="https://leetcode-cn.com/problems/rotate-array/">LeetCode 189</a></p><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><pre><code>输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]</code></pre><p>示例 2:</p><pre><code>输入：nums = [-1,-100,3,99], k = 2输出：[3,99,-1,-100]解释: 向右轮转 1 步: [99,-1,-100,3]向右轮转 2 步: [3,99,-1,-100]</code></pre><h2 id="Method-1-使用额外的数组">Method 1: 使用额外的数组</h2><blockquote><p>当我们将数组的元素向右移动<code>k</code>次后，尾部<code>k mod n</code>个元素会移动至数组头部，其余元素向后移动<code>k mod n</code>个位置。</p></blockquote><p>使用额外的数组来将每个元素放至正确的位置。用<code>n</code>表示数组的长度，我们遍历原数组，将原数组下标为<code>i</code>的元素放至新数组下标为<code>(i + k) mod n</code>的位置，最后将新数组拷贝至原数组即可</p><pre><code>void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;    int n = nums.size();    vector&lt;int&gt; temp(n);    for (int i = 0; i &lt;= n - 1; i++)        temp[(i + k) % n] = nums[i];    nums.assign(temp.begin(), temp.end());&#125;</code></pre><h2 id="Method-2-数组翻转">Method 2: 数组翻转</h2><p>先将所有元素翻转，这样尾部的<code>k mod n</code>个元素就被移至数组头部，然后我们再翻转<code>[0, k mod n − 1]</code>区间的元素和<code>[k mod n, n − 1]</code>区间的元素即能得到最后的答案</p><img src="/2022/03/14/LeetCode189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/1.png" class=""><pre><code>// 水平翻转nums中left到right之间的元素void reverse(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    while (left &lt; right)    &#123;        swap(nums[left], nums[right]);        left++;        right--;    &#125;;&#125;void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;    int n = nums.size() - 1;    reverse(nums, 0, n);                      // 翻转第0至nums.size()-1个元素    reverse(nums, 0, (k % nums.size()) - 1);  // 翻转第0至k%nums.size()-1个元素    reverse(nums, (k % nums.size()), n);      // 翻转第k%nums.size()至nums.size()-1个元素&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 977. 有序数组的平方</title>
      <link href="/2022/03/14/LeetCode977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2022/03/14/LeetCode977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1>977. 有序数组的平方</h1><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">LeetCode 977</a></p><p>给你一个按<code>非递减顺序</code>排序的整数数组<code>nums</code>，返回<code>每个数字的平方</code>组成的新数组，要求也按<code>非递减顺序</code>排序。</p><p>示例 1：</p><pre><code>输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]</code></pre><p>示例 2：</p><pre><code>输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121]</code></pre><h2 id="Method-1-双指针-2">Method 1: 双指针</h2><p>找出非递减数组<code>nums</code>中正负整数的分界线<code>pos</code>，假定<code>nums[pos] &lt;= 0</code>，当我们将数组<code>nums</code>中的数平方后，那么<code>nums[0]</code>到<code>nums[pos]</code>单调递减，<code>nums[pos+1]</code>到<code>nums[n−1]</code>单调递增。</p><p>令<code>i</code>, <code>j</code>分别指向<code>pos</code>, <code>pos + 1</code>，分以下四种情况进行操作：</p><ol><li><code>pos</code>是最后一个元素，即，数组<code>nums</code>全是非正数，将数组每个元素平方然后按相反顺序排列；</li><li><code>pos + 1</code>是第一个元素，即数组<code>nums</code>全是正数，将数组每个元素平方然后按原顺序排列；</li><li><code>nums[i] * nums[i] &lt;= nums[j] * nums[j]</code>，先放<code>nums[i] * nums[i]</code>；</li><li><code>nums[i] * nums[i] &gt; nums[j] * nums[j]</code>，先放<code>nums[j] * nums[j]</code>；</li></ol><p>程序实现：</p><pre><code>vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;    int mid = -1; // 找到最大的负数或者零所在的位置，即，正负数分界线    for (int i = 0; i &lt; nums.size(); i++)    &#123;        if (nums[i] &lt; 0)            mid = i;        else            break;    &#125;;    vector&lt;int&gt; ans;    int i = mid, j = mid + 1;    while ((i &gt;= 0) || (j &lt; nums.size()))    &#123;        if (i &lt; 0)                  // i 超出nums左边界        &#123;            ans.push_back(nums[j] * nums[j]);            j++;        &#125;        else if (j == nums.size())  // j 超出nums右边界        &#123;            ans.push_back(nums[i] * nums[i]);            i--;        &#125;        else if (nums[i] * nums[i] &lt; nums[j] * nums[j])        &#123;            ans.push_back(nums[i] * nums[i]);            i--;        &#125;        else        &#123;            ans.push_back(nums[j] * nums[j]);            j++;        &#125;    &#125;;    return ans;&#125;</code></pre><h2 id="Method-2-双指针-2">Method 2: 双指针</h2><p>使用两个指针分别指向位置<code>0</code>和<code>n−1</code>，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针</p><pre><code>class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        vector&lt;int&gt; ans(n);     // 注意这里要初始化        for (int i = 0, j = n - 1, pos = n - 1; i &lt;= j;) &#123;            if (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;                ans[pos] = nums[i] * nums[i];                ++i;            &#125;            else &#123;                ans[pos] = nums[j] * nums[j];                --j;            &#125;            --pos;        &#125;        return ans;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 69. x的平方根</title>
      <link href="/2022/03/14/LeetCode69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/2022/03/14/LeetCode69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h1>69. x的平方根</h1><p><a href="https://leetcode-cn.com/problems/sqrtx/">LeetCode 69</a></p><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的算术平方根。</p><p>由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去。</p><p>注意：不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><p></p><p>示例 1：</p><pre><code>输入：x = 4输出：2</code></pre><p>示例 2：</p><pre><code>输入：x = 8输出：2解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</code></pre><h2 id="Method-二分查找-3">Method: 二分查找</h2><p>找到满足<code>k*k &lt;= x</code>的最大整数<code>k</code></p><pre><code>int mySqrt(int x) &#123;    int left = 0, right = x;    while (left &lt;= right)    &#123;        int mid = left + (right - left) / 2;        if ((long long) mid * mid &lt;= x)            left = mid + 1;        else            right = mid - 1;    &#125;;    return right;&#125;</code></pre><p>其中，<code>(long long)</code>强制转换类型，避免<code>mid * mid</code>溢出</p><p>或，考虑<code>mid &lt;= x / mid</code>（此时需另外分析<code>mid == 0</code>的情形）</p><pre><code>int mySqrt(int x) &#123;    int left = 0, right = x;    while (left &lt;= right)    &#123;        int mid = left + (right - left) / 2;        if (mid == 0)            break;        else if (mid &lt;= (x / mid))            left = mid + 1;        else            right = mid - 1;    &#125;;    return right;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Record</title>
      <link href="/2022/03/14/LeetCode-Record/"/>
      <url>/2022/03/14/LeetCode-Record/</url>
      
        <content type="html"><![CDATA[<h1>二分查找</h1><ol start="704"><li><p>二分查找<br><a href="https://leetcode-cn.com/problems/binary-search/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/12/LeetCode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">Hexo</a></p></li><li><p>第一个错误的版本<br><a href="https://leetcode-cn.com/problems/first-bad-version/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/15/LeetCode278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/">Hexo</a></p></li><li><p>搜索插入位置<br><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/12/LeetCode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/">Hexo</a></p></li><li><p>x 的平方根<br><a href="https://leetcode-cn.com/problems/sqrtx/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/14/LeetCode69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/">Hexo</a></p></li></ol><h1>双指针</h1><ol start="977"><li><p>有序数组的平方<br><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/14/LeetCode977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/">Hexo</a></p></li><li><p>轮转数组<br><a href="https://leetcode-cn.com/problems/rotate-array/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/14/LeetCode189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/">Hexo</a></p></li><li><p>移动零<br><a href="https://leetcode-cn.com/problems/move-zeroes/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/14/LeetCode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/">Hexo</a></p></li><li><p>两数之和 II - 输入有序数组<br><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/14/LeetCode167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/">Hexo</a></p></li><li><p>反转字符串<br><a href="https://leetcode-cn.com/problems/reverse-string/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/15/LeetCode344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">Hexo</a></p></li><li><p>反转字符串中的单词 III<br><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">LeetCode</a><br><a href="https://jiankychen.github.io/2022/03/15/LeetCode557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/">Hexo</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/03/12/LeetCode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/03/12/LeetCode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Frameworks">Frameworks</h2><p><img src="leetcode-%E4%BA%8C%E5%88%86%E6%B3%95/1.png" alt=""></p><p><strong>Framework 1: 寻找满足条件的最左边的元素</strong></p><pre><code>while (l &lt; r) &#123;    int mid = l + r &gt;&gt; 1;    if (check(mid))         r = mid;    else         l = mid + 1；&#125;</code></pre><p><strong>Framework 2: 寻找满足条件的最右边的元素</strong></p><pre><code>while (l &lt; r) &#123;    int mid = l + r + 1 &gt;&gt; 1;    if (check(mid))         l = mid;    else         r = mid - 1；&#125;</code></pre><h2 id="LeetCode-35-Search-Insert-position">LeetCode 35. Search Insert position</h2><p><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode 35</a></p><p>选择 Framework 1: 寻找满足条件的最左边的元素</p><pre><code>int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size(); // 可能找到最后一个元素的下一个位置    while (left &lt; right)    &#123;        int mid = (left + right) &gt;&gt; 1;        if (nums[mid] &gt;= target)            right = mid;        else            left = mid + 1;    &#125;;    return right;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 35. 搜索插入位置</title>
      <link href="/2022/03/12/LeetCode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2022/03/12/LeetCode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1>35. Search Insert position</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode 35</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p></p><p>示例 1:</p><pre><code>输入: nums = [1,3,5,6], target = 5输出: 2</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,3,5,6], target = 2输出: 1</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,3,5,6], target = 7输出: 4</code></pre><p>示例 4:</p><pre><code>输入: nums = [1,3,5,6], target = 0输出: 0</code></pre><p>示例 5:</p><pre><code>输入: nums = [1], target = 0输出: 0</code></pre><h2 id="Method-二分查找-2">Method: 二分查找</h2><p>在一个有序数组中找到第一个大于等于 <code>target</code> 的下标</p><pre><code>int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0, right = nums.size() - 1;    while (left &lt;= right)    &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)            left = mid + 1;        else            right = mid - 1;    &#125;;    return left;&#125;</code></pre><p>二分查找需要注意边界条件，比如：循环结束条件中 <code>left</code> 和 <code>right</code> 的关系，更新 <code>left</code> 和 <code>right</code> 位置时要不要加 1 减 1。</p><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">写对二分查找不是套模板并往里面填空，需要仔细分析题意</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>术语表-Chapter3</title>
      <link href="/2022/03/10/21-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter3/"/>
      <url>/2022/03/10/21-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter3/</url>
      
        <content type="html"><![CDATA[<p><code>begin</code>：是<code>string</code>和<code>vector</code>的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。</p><p><code>缓冲区溢出（buffer overflow）</code>：一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括<code>string</code>、<code>vector</code>和<code>数组</code>等。</p><p><code>C风格字符串（C-style string）</code>：以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错。</p><p><code>类模板（class template）</code>：用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个<code>vector</code>对象需要指定元素的类型，例如：<code>vector&lt;int&gt;</code>包含<code>int</code>类型的元素。</p><p><code>编译器扩展（compiler extension）</code>：某个特定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上。</p><p><code>容器（container）</code>：是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。</p><p><code>拷贝初始化（copy initialization）</code>：使用赋值号（<code>=</code>）的初始化形式。新创建的对象是初始值的一个副本。</p><p><code>difference_type</code>：由<code>string</code>和<code>vector</code>定义的一种带符号整数类型，表示两个迭代器之间的距离。</p><p><code>直接初始化（direct initialization）</code>：不使用赋值号（<code>=</code>）的初始化形式。</p><p><code>empty</code>：是<code>string</code>和<code>vector</code>的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假。</p><p><code>end</code>：是<code>string</code>和<code>vector</code>的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针。</p><p><code>getline</code>：在<code>string</code>头文件中定义的一个函数，以一个<code>istream</code>对象和一个<code>string</code>对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入<code>string</code>对象，最后返回<code>istream</code>对象。其中换行符读入但是不保留。</p><p><code>索引（index）</code>：是下标运算符使用的值。表示要在<code>string</code>对象、<code>vector</code>对象或者数组中访问的一个位置。</p><p><code>实例化（instantiation）</code>：编译器生成一个指定的模板类或函数的过程。</p><p><code>迭代器（iterator）</code>：是一种类型，用于访问容器中的元素或者在元素之间移动。</p><p><code>迭代器运算（iterator arithmetic）</code>：是<code>string</code>或<code>vector</code>的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置。</p><p><code>以空字符结束的字符串（null-terminatedstring）</code>：是一个字符串，它的最后一个字符后面还跟着一个空字符（‘\0’）。</p><p><code>尾后迭代器（off-the-end iterator）</code>：<code>end</code>函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一位置。</p><p><code>指针运算（pointer arithmetic）</code>：是指针类型支持的算术运算。指向数组的指针所支持的运算种类与迭代器运算一样。</p><p><code>prtdiff_t</code>：是<code>cstddef</code>头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。</p><p><code>push_back</code>：是<code>vector</code>的成员，向<code>vector</code>对象的末尾添加元素。</p><p><code>范围for语句（range for）</code>：一种控制语句，可以在值的一个特定集合内迭代。</p><p><code>size</code>：是<code>string</code>和<code>vector</code>的成员，分别返回字符的数量或元素的数量。返回值的类型是<code>size_type</code>。</p><p><code>size_t</code>：是<code>cstddef</code>头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。</p><p><code>size_type</code>：是<code>string</code>和<code>vector</code>定义的类型的名字，能存放下任意<code>string</code>对象或<code>vector</code>对象的大小。在标准库中，<code>size_type</code>被定义为无符号类型。</p><p><code>string</code>：是一种标准库类型，表示字符的序列。</p><p><code>using声明（using declaration）</code>：令命名空间中的某个名字可被程序直接使用。<code>using 命名空间::名字</code>；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分<code>命名空间::</code>。</p><p><code>值初始化（value initialization）</code>：是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值。</p><p><code>vector</code>：是一种标准库类型，容纳某指定类型的一组元素。</p><p><code>++运算符（++ operator）</code>：是迭代器和指针定义的递增运算符。执行“加1”操作使得迭代器指向下一个元素。</p><p><code>[ ]运算符（[ ] operator）</code>：下标运算符。<code>obj[j]</code>得到容器对象<code>obj</code>中位置<code>j</code>的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引是<code>obj.size()-1</code>。下标运算符的返回值是一个对象。如果<code>p</code>是指针、<code>n</code>是整数，则p[n]与*(p+n)等价。</p><p><code>-&gt;运算符（-&gt;operator）</code>：箭头运算符，该运算符综合了解引用操作和点操作。<code>a-&gt;b</code>等价于<code>(*a).b</code>。</p><p><code>&lt;&lt;运算符（&lt;&lt;operator）</code>：标准库类型<code>string</code>定义的输出运算符，负责输出<code>string</code>对象中的字符。</p><p><code>&gt;&gt;运算符（&gt;&gt;operator）</code>：标准库类型<code>string</code>定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个<code>string</code>对象。</p><p><code>!运算符（! operator）</code>：逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假。</p><p><code>&amp;&amp;运算符（&amp;&amp;operator）</code>：逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。</p><p><code>||运算符（|| operator）</code>：逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象。</p><blockquote><p>小结</p><ol><li><p><code>string</code>和<code>vector</code>是两种最重要的标准库类型。<code>string</code>对象是一个可变长的字符序列，<code>vector</code>对象是一组同类型对象的容器。</p></li><li><p>迭代器允许对容器中的对象进行间接访问，对于<code>string</code>对象和<code>vector</code>对象来说，可以通过迭代器访问元素或者在元素间移动。</p></li><li><p>数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型<code>string</code>和<code>vector</code>类似的功能。一般来说，应该优先选用标准库提供的类型，之后再考虑C++语言内置的低层的替代品数组或指针。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维数组</title>
      <link href="/2022/03/10/20-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/10/20-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。</p><p>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：</p><pre><code>int ia[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组// array of size 10; each element is a 20-element array whose elements are arrays of 30 intsint arr[10][20][30] = &#123;0&#125;; // initialize all elements to 0</code></pre><p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列。</p><h2 id="多维数组的初始化">多维数组的初始化</h2><p><strong>允许使用花括号括起来的一组值初始化多维数组</strong></p><pre><code>int ia[3][4] = &#123;    // three elements; each element is an array of size 4    &#123;0, 1, 2, 3&#125;,   // initializers for the row indexed by 0    &#123;4, 5, 6, 7&#125;,   // initializers for the row indexed by 1    &#123;8, 9, 10, 11&#125;  // initializers for the row indexed by 2&#125;;</code></pre><p>其中内层嵌套着的花括号并非必需的。例如下面的初始化语句，形式上更为简洁，完成的功能和上面这段代码完全一样：</p><pre><code>// equivalent initialization without the optional nested braces for each rowint ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</code></pre><p>类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：</p><pre><code>// explicitly initialize only element 0 in each rowint ia[3][4] = &#123;&#123; 0 &#125;, &#123; 4 &#125;, &#123; 8 &#125;&#125;;</code></pre><p>其他<strong>未列出的元素执行默认值初始化。</strong></p><p>在这种情况下如果再省略掉内层的花括号，结果就大不一样了:</p><pre><code>// explicitly initialize row 0; the remaining elements are value initializedint ix[3][4] = &#123;0, 3, 6, 9&#125;;</code></pre><p>它初始化的是第一行的4个元素，其他元素被初始化为0。</p><h2 id="多维数组的下标引用">多维数组的下标引用</h2><p><strong>可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。</strong></p><p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：</p><pre><code>// assigns the first element of arr to the last element in the last row of iaia[2][3] = arr[0][0][0];int (&amp;row)[4] = ia[1]; // binds row to the second four-element array in ia</code></pre><p>在第一个例子中，在等号左侧，<code>ia[2]</code>得到数组<code>ia</code>的最后一行，此时返回的是表示<code>ia</code>最后一行的那个一维数组而非任何实际元素；对这个一维数组再取下标，得到编号为<code>[3]</code>的元素，也就是这一行的最后一个元素。等号右侧也是类似的。<br>在第二个例子中，把<code>row</code>定义成一个含有4个整数的数组的引用，然后将其绑定到<code>ia</code>的第2行。</p><p>再举一个例子，程序中经常会用到两层嵌套的for循环来处理多维数组的元素：</p><pre><code>constexpr size_t rowCnt = 3, colCnt = 4;int ia[rowCnt][colCnt];   // 12 uninitialized elements// for each rowfor (size_t i = 0; i != rowCnt; ++i) &#123;    // for each column within the row    for (size_t j = 0; j != colCnt; ++j) &#123;        // assign the element's positional index as its value        ia[i][j] = i * colCnt + j;    &#125;&#125;</code></pre><p>外层的<code>for</code>循环遍历<code>ia</code>的所有元素，注意这里的元素是一维数组；内层的<code>for</code>循环则遍历那些一维数组的整数元素。此例中，我们将元素在整个数组中的序号设为该元素的值。</p><h2 id="使用范围for语句处理多维数组">使用范围for语句处理多维数组</h2><pre><code>size_t cnt = 0;for (auto &amp;row : ia)        // for every element in the outer array    for (auto &amp;col : row) &#123; // for every element in the inner array        col = cnt;          // give this element the next value        ++cnt;              // increment cnt    &#125;</code></pre><p>因为要改变元素的值，所以得把控制变量<code>row</code>和<code>col</code>声明成引用类型。第一个<code>for</code>循环遍历<code>ia</code>的所有元素，这些元素是大小为4的数组，因此<code>row</code>的类型就应该是含有4个整数的数组的引用。第二个<code>for</code>循环遍历那些4元素数组中的某一个，因此<code>col</code>的类型是整数的引用。</p><p>在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环：</p><pre><code>for (const auto &amp;row : ia)  // for every element in the outer array    for (auto col : row)    // for every element in the inner array        cout &lt;&lt; col &lt;&lt; endl;</code></pre><p>这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针。</p><p>假设不用引用类型，则循环如下述形式：</p><pre><code>for (auto row : ia)    for (auto col : row)</code></pre><p>程序将无法通过编译。这是因为，像之前一样第一个循环遍历<code>ia</code>的所有元素，注意这些元素实际上是大小为4的数组。因为<code>row</code>不是引用类型，所以编译器初始化<code>row</code>时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的<code>row</code>的类型就是<code>int*</code>，显然内层的循环就不合法了。</p><blockquote><p><strong>要使用<code>范围for</code>语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</strong></p></blockquote><h2 id="指针和多维数组">指针和多维数组</h2><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。</p><p>因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：</p><pre><code>int ia[3][4];     // array of size 3; each element is an array of ints of size 4int (*p)[4] = ia; // p points to an array of four ints（p指向ia的第一行）p = &amp;ia[2];       // p now points to the last element in ia（p指向ia的第三行）</code></pre><p>等号左侧，首先由<code>(*p)</code>知道<code>p</code>是一个指针，由<code>int [4]</code>知道<code>p</code>指向的是一个包含4个整数的数组。等号右侧，<code>ia</code>返回的是<code>&amp;ia[0]</code>，即<code>ia[0]</code>的地址。因此，<code>p</code>指向的是<code>ia[0]</code>，即<code>ia</code>的第一行。</p><p>注意，在上述声明中，圆括号必不可少：</p><pre><code>int *ip[4];    // array of pointers to int（[]优先级高于*，故而ip是一个数组，其元素为整形指针）int (*ip)[4];  // pointer to an array of four ints</code></pre><p>随着C++11新标准的提出，通过使用<code>auto</code>或者<code>decltype</code>就能尽可能地避免在数组前面加上一个指针类型了：</p><pre><code>// print the value of each element in ia, with each inner array on its own line// p points to an array of four intsfor (auto p = ia; p != ia + 3; ++p) &#123;    // q points to the first element of an array of four ints; that is, q points to an int    for (auto q = *p; q != *p + 4; ++q)        cout &lt;&lt; *q &lt;&lt; ' ';    cout &lt;&lt; endl;&#125;</code></pre><p>外层的<code>for</code>循环首先声明一个指针<code>p</code>并令其指向<code>ia</code>的第一个内层数组，然后依次迭代直到<code>ia</code>的全部3行都处理完为止。其中递增运算<code>++p</code>负责将指针<code>p</code>移动到<code>ia</code>的下一行。<br>内层的<code>for</code>循环负责输出内层数组所包含的值。它首先令指针<code>q</code>指向<code>p</code>当前所在行的第一个元素。<code>*p</code>是一个含有4个整数的数组，像往常一样，数组名被自动地转换成指向该数组首元素的指针。内层<code>for</code>循环不断迭代直到我们处理完了当前内层数组的所有元素为止。为了获取内层<code>for</code>循环的终止条件，再一次解引用<code>p</code>得到指向内层数组首元素的指针，给它加上4就得到了终止条件。</p><p>使用标准库函数<code>begin</code>和<code>end</code>也能实现同样的功能，而且看起来更简洁一些:</p><pre><code>// p points to the first array in iafor (auto p = begin(ia); p != end(ia); ++p) &#123;    // q points to the first element in an inner array    for (auto q = begin(*p); q != end(*p); ++q)        cout &lt;&lt; *q &lt;&lt; ' ';   // prints the int value to which q points    cout &lt;&lt; endl;&#125;</code></pre><h2 id="类型别名简化多维数组的指针">类型别名简化多维数组的指针</h2><p>读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名（<a href="https://jiankychen.github.io/2022/03/02/12-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/">处理类型-类型别名</a>）能让这项工作变得简单一点儿，例如：</p><pre><code>using int_array = int[4]; // new style type alias declaration; equivalent typedef declaration: typedef int int_array[4];// print the value of each element in ia, with each inner array on its own linefor (int_array *p = ia; p != ia + 3; ++p) &#123;    for (int *q = *p; q != *p + 4; ++q)        cout &lt;&lt; *q &lt;&lt; ' ';    cout &lt;&lt; endl;&#125;</code></pre><p>程序将类型“4个整数组成的数组”命名为<code>int_array</code>，用类型名<code>int_array</code>定义外层循环的控制变量让程序显得简洁明了。（由<code>*p</code>知道<code>p</code>是一个指针，指向一个包含4个整数的数组。<code>q</code>是一个指向整数的指针。）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 类型别名 </tag>
            
            <tag> 下标运算符 </tag>
            
            <tag> 范围for </tag>
            
            <tag> begin </tag>
            
            <tag> end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/03/05/19-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/05/19-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组是一种类似于标准库类型<code>vector</code>的<strong>数据结构</strong>（数组不是类类型）。与<code>vector</code>相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与<code>vector</code>不同的地方是，<strong>数组的大小确定不变，不能随意向数组中增加元素</strong>。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</p><blockquote><p>如果不清楚元素的确切个数，请使用<code>vector</code>。</p></blockquote><blockquote><p>数组与<code>vector</code>的相似之处是都能存放类型相同的对象，且这些对象本身没有名字，需要通过其所在位置访问。</p><p>数组与<code>vector</code>的最大不同是，数组的大小固定不变，不能随意向数组中增加额外的元素，虽然在某些情境下运行时性能较好，但是与<code>vector</code>相比损失了灵活性。</p><p>具体来说，数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后把原数组的所有元素复制到新数组中去。我们也无法像<code>vector</code>那样使用<code>size</code>函数直接获取数组的维度。如果是字符数组，可以调用<code>strlen</code>函数得到字符串的长度；如果是其他数组，只能使用<code>sizeof(array)/sizeof(array[0])</code>的方式计算数组的维度。</p></blockquote><h1>定义和初始化内置数组</h1><p>数组是一种复合类型。数组的声明形如<code>a[d]</code>，其中<code>a</code>是数组的名字，<code>d</code>是数组的维度。维度说明了数组中元素的个数，因此<strong>必须大于<code>0</code>，必须是一个常量表达式</strong>。</p><pre><code>unsigned cnt = 42;          // not a constant expressionconstexpr unsigned sz = 42; // constant expression                            // constexprint arr[10];                // array of ten intsint *parr[sz];              // array of 42 pointers to intstring bad[cnt];            // error: cnt is not a constant expressionstring strs[get_size()];    // ok if get_size is constexpr, error otherwise</code></pre><p>默认情况下，数组的元素被默认初始化。</p><blockquote><p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p></blockquote><p><strong>定义数组的时候必须指定数组的类型，不允许用<code>auto</code>关键字由初始值的列表推断类型。</strong></p><p>和<code>vector</code>一样，<strong>数组的元素应为对象，因此不存在引用数组。</strong></p><h2 id="显式初始化数组元素">显式初始化数组元素</h2><p>可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。</p><pre><code>const unsigned sz = 3;        // constant expressionint ia1[sz] = &#123;0,1,2&#125;;        // array of three ints with values 0, 1, 2int a2[] = &#123;0, 1, 2&#125;;         // an array of dimension 3int a3[5] = &#123;0, 1, 2&#125;;        // equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;; // same as a4[] =  &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;int a5[2] = &#123;0,1,2&#125;;          // error: too many initializers</code></pre><h2 id="字符数组的特殊性">字符数组的特殊性</h2><p>可以用字符串字面值对字符数组数组初始化，但一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。</p><blockquote><p>单引号内的是字符字面值，双引号内的是字符串字面值。</p></blockquote><pre><code>char a1[] = &#123;'C', '+', '+'&#125;;       // list initialization, no null（字符字面值）char a2[] = &#123;'C', '+', '+', '\0'&#125;; // list initialization, explicit null（字符字面值）char a3[] = &quot;C++&quot;;                 // null terminator added automatically（字符串字面值）const char a4[6] = &quot;Daniel&quot;;       // error: no space for the null!（字符串字面值）</code></pre><p><code>a4</code>的定义是错误的：尽管字符串字面值<code>&quot;Daniel&quot;</code>看起来只有6个字符，但是数组的大小必须至少是7，其中6个位置存放字面值的内容，另外1个存放结尾处的空字符。</p><h2 id="不允许拷贝和赋值">不允许拷贝和赋值</h2><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：</p><pre><code>int a[] = &#123;0, 1, 2&#125;; // array of three intsint a2[] = a;        // error: cannot initialize one array with anothera2 = a;              // error: cannot assign one array to another</code></pre><blockquote><p>若需实现数组的拷贝和赋值，需要逐个元素依次拷贝赋值。</p></blockquote><h2 id="理解复杂的数组声明">理解复杂的数组声明</h2><p>和<code>vector</code>一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。</p><blockquote><p>不存在引用的数组（即，数组的元素不能是引用），但存在数组的引用（可以定义一个引用来绑定数组）</p></blockquote><pre><code>int *ptrs[10];            //  ptrs是含有10个元素（整型指针）的数组（注：[]优先级高于*）int &amp;refs[10];            //  数组里边装引用？错误: 引用不是对象，不存在引用的数组（注：[]优先级高于&amp;，首先判断refs是一个维度为10的数组，数组的元素的类型是int &amp;，即，引用。由于引用不是对象，故语法错误）int (*Parray)[10] = &amp;arr; //  Parray指向一个含有10个整数的数组（注：()优先级高于[]。首先分析(*Parray)，可知Parray是一个指针；然后考虑右边的[10]，可知Parray指向一个维度为10的数组；最后观察左边，知道数组中的元素为int）int (&amp;arrRef)[10] = arr;  //  arrRef引用一个含有10个整数的数组（()优先级高于[]。arrRef是一个引用，所绑定的对象是一个维度为10的数组，数组中的元素为int）</code></pre><p>默认情况下，类型修饰符从右向左依次绑定。对于<code>ptrs</code>来说，从右向左理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字是<code>ptrs</code>，然后知道数组中存放的是指向<code>int</code>的指针。</p><p>但是对于<code>Parray</code>来说，从右向左理解就不太合理了。就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解<code>Parray</code>的含义：首先是圆括号括起来的部分，<code>*Parray</code>意味着<code>Parray</code>是个指针，接下来观察右边，可知道<code>Parray</code>是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是<code>int</code>。这样最终的含义就明白无误了，<code>Parray</code>是一个指针，它指向一个<code>int</code>数组，数组中包含10个元素。</p><p>同理，<code>(&amp;arrRef)</code>表示<code>arrRef</code>是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是<code>int</code>。</p><p>更复杂的：</p><pre><code>int *(&amp;arry)[10] = ptrs; // array是数组的引用，该数组包含10个指向int的指针</code></pre><p>首先，<code>()</code>优先级高于<code>[]</code>，知道<code>arry</code>是一个引用；其次，<code>[]</code>优先级高于<code>*</code>，结合右边可知，<code>arry</code>引用的对象是一个大小为10的数组；最后观察左边知道，数组的元素的类型是指向int的指针。</p><blockquote><p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p></blockquote><h1>访问数组元素</h1><p><strong>数组的元素也能使用<code>范围for</code>语句或<code>下标运算符</code>来访问。</strong></p><p><strong>数组的索引从0开始。</strong></p><p>在使用数组下标的时候，通常将其定义为<code>size_t</code>类型。<code>size_t</code>是一种机器相关的<code>无符号类型</code>，它被设计得足够大以便能表示内存中任意对象的大小。<strong>在<code>cstddef</code>头文件中定义了<code>size_t</code>类型</strong>，这个文件是C标准库<code>stddef.h</code>头文件的C++语言版本。</p><p>数组除了大小固定这一特点外，其他用法与<code>vector</code>基本类似:</p><pre><code>// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100unsigned scores[11] = &#123;&#125;; // 11 buckets, all value initialized to 0unsigned grade;while (cin &gt;&gt; grade) &#123;    if (grade &lt;= 100)        ++scores[grade/10]; // increment the counter for the current cluster&#125;</code></pre><p>本例所用的下标运算符是由C++语言直接定义的，这个运算符能用在数组类型的运算对象上。<code>vector</code>类型所用的下标运算符是库模板<code>vector</code>定义的，只能用于<code>vector</code>类型的运算对象。</p><p>与<code>vector</code>和<code>string</code>一样，当需要遍历数组的所有元素时，最好的办法也是使用<code>范围for</code>语句:</p><pre><code>for (auto i : scores)      // for each counter in scores    cout &lt;&lt; i &lt;&lt; &quot; &quot;;      // print the value of that countercout &lt;&lt; endl;</code></pre><p>检查下标的值：数组的下标应该大于等于0而且小于数组的大小。</p><blockquote><p>要想防止数组下标越界，除了小心谨慎注意细节以及对代码进行彻底的测试之外，没有其他好办法。对于一个程序来说，即使顺利通过编译并执行，也不能肯定它不包含此类致命的错误。</p></blockquote><blockquote><p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p></blockquote><h1>指针和数组</h1><p>使用数组名字的时候编译器一般都会自动地将其替换为<strong>一个指向数组首元素的指针</strong>。</p><pre><code>string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;  // array of stringsstring *p = &amp;nums[0];   // p points to the first element in numsstring *p2 = nums;      // equivalent to p2 = &amp;nums[0]int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsauto ia2(ia); // ia2 is an int* that points to the first element in iaia2 = 42;     // error: ia2 is a pointer, and we can't assign an int to a pointer</code></pre><p>尽管<code>ia</code>是由<code>10</code>个整数构成的数组，但当使用<code>ia</code>作为初始值时，编译器实际执行的初始化过程类似于下面的形式：</p><pre><code>auto ia2(&amp;ia[0]);  // now it's clear that ia2 has type int*</code></pre><p>必须指出的是，<strong>当使用decltype关键字时，上述转换不会发生</strong>，decltype（ia）返回的类型是由10个整数构成的数组：</p><pre><code>// ia3 is an array of ten intsdecltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;   // ia is an array of ints, so is ia3ia3 = p;    // error: can't assign an int* to an arrayia3[4] = i; // ok: assigns the value of i to an element in ia3</code></pre><h2 id="指向数组元素的指针也是迭代器">指向数组元素的指针也是迭代器</h2><p><code>vector</code>和<code>string</code>的迭代器支持的运算，数组的指针全都支持。</p><pre><code>int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p = arr; // p points to the first element in arr++p;          // p points to arr[1]</code></pre><p>使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。</p><blockquote><p>通过数组名字或者数组中首元素的地址都能得到指向首元素的指针；可以设法获取数组尾元素之后的那个并不存在的元素的地址，从而得到指向数组尾元素的下一位置的指针：</p></blockquote><pre><code>    int *e = &amp;arr[10]; // pointer just past the last element in arr</code></pre><blockquote><p>这里显然使用下标运算符索引了一个不存在的元素，<code>arr</code>有10个元素，尾元素所在位置的索引是9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化<code>e</code>。</p></blockquote><p>尾后指针也不指向具体的元素。因此，<strong>不能对尾后指针执行解引用或递增的操作</strong>。</p><p>利用上面得到的指针能重写之前的循环，令其输出arr的全部元素：</p><pre><code>for (int *b = arr; b != e; ++b)    cout &lt;&lt; *b &lt;&lt; endl; // print the elements in arr</code></pre><p><strong>尽管能计算得到尾后指针，但这种用法极易出错。</strong></p><h2 id="标准库函数begin和end">标准库函数begin和end</h2><p>C++11新标准引入了两个名为<code>begin</code>和<code>end</code>的函数。这两个函数与容器中的两个同名成员功能类似，但由于数组不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数：</p><pre><code>int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsint *beg = begin(ia); // pointer to the first element in iaint *last = end(ia);  // pointer one past the last element in ia</code></pre><p><code>begin</code>函数返回指向<code>ia</code>首元素的指针，<code>end</code>函数返回指向<code>ia</code>尾元素下一位置的指针。</p><p><strong><code>begin</code>和<code>end</code>两个函数定义在<code>iterator</code>头文件中</strong>。</p><pre><code>// pbeg points to the first and pend points just past the last element in arrint *pbeg = begin(arr),  *pend = end(arr);// find the first negative element, stopping if we've seen all the elementswhile (pbeg != pend &amp;&amp; *pbeg &gt;= 0)    ++pbeg;</code></pre><h2 id="指针运算">指针运算</h2><p>指向数组元素的指针可以执行表3.6和表3.7列出的所有迭代器运算。这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。</p><p>给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。</p><pre><code>constexpr size_t sz = 5;int arr[sz] = &#123;1,2,3,4,5&#125;;int *ip = arr;     // equivalent to int *ip = &amp;arr[0]int *ip2 = ip + 4; // ip2 points to arr[4], the last element in arr// ok: arr is converted to a pointer to its first element; p points one past the end of arrint *p = arr + sz; // use caution -- do not dereference!int *p2 = arr + 10; // error: arr has only 5 elements; p2 has undefined value</code></pre><p>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。</p><p>两个指针相减的结果的类型是一种名为<code>ptrdiff_t</code>的标准库类型，和<code>size_t</code>一样，<code>ptrdiff_t</code>也是一种定义在<code>cstddef</code>头文件中的机器相关的类型。因为差值可能为负值，所以<code>ptrdiff_t</code>是一种带符号类型。</p><pre><code>auto n = end(arr) - begin(arr); // n is 5, the number of elements in arr</code></pre><p>只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较。</p><pre><code>int *b = arr, *e = arr + sz;while (b &lt; e) &#123;    // use *b    ++b;&#125;int i = 0, sz = 42;int *p = &amp;i, *e = &amp;sz;// undefined: p and e are unrelated; comparison is meaningless!while (p &lt; e)</code></pre><p>如果两个指针分别指向不相关的对象，则不能比较它们。</p><h2 id="解引用和指针运算的交互">解引用和指针运算的交互</h2><p>指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针。</p><pre><code>int ia[] = &#123;0,2,4,6,8&#125;; // array with 5 elements of type intint last = *(ia + 4); // ok: initializes last to 8, the value of ia[4]</code></pre><p>表达式<code>*(ia+4)</code>计算ia前进4个元素后的新地址，解引用该结果指针的效果等价于表达式<code>ia[4]</code>。</p><p>与上一个例子相比，下面这个例子少了一个括号，故而是先解引用ia，然后给解引用的结果再加上4</p><pre><code>last = *ia + 4;  // ok: last = 4, equivalent to ia[0] + 4</code></pre><h2 id="下标和指针">下标和指针</h2><p>如前所述，在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。一个典型的例子是当对数组使用下标运算符时，编译器会自动执行上述转换操作。给定</p><pre><code>int ia[] = &#123;0,2,4,6,8&#125;;  // array with 5 elements of type int</code></pre><p>此时，<code>ia[0]</code>是一个使用了数组名字的表达式，对数组执行下标运算其实是对指向数组元素的指针执行下标运算：</p><pre><code>int i = ia[2];  // ia is converted to a pointer to the first element in ia                // ia[2] fetches the element to which (ia + 2) pointsint *p = ia;    // p points to the first element in iai = *(p + 2);   // equivalent to i = ia[2]</code></pre><p>只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：</p><pre><code>int *p = &amp;ia[2];  // p points to the element indexed by 2int j = p[1];     // p[1] is equivalent to *(p + 1),                // p[1] is the same element as ia[3]int k = p[-2];    // p[-2] is the same element as ia[0]</code></pre><p>注意，这里的<code>p</code>是指向<code>ia[2]</code>的指针，对指针<code>p</code>执行下标运算时，相当于给指针加上（减去）某整数值，即，对指针进行移动。例如上例的<code>p[-2]</code>等价于<code>*(p-2)</code>，也就是<code>ia[0]</code>。</p><p>虽然标准库类型<code>string</code>和<code>vector</code>也能执行下标运算，但是数组与它们相比还是有所不同。<strong>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求</strong>，上面的最后一个例子很好地说明了这一点。内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。</p><blockquote><p>内置的下标运算符所用的索引值不是无符号类型，这一点与<code>vector</code>和<code>string</code>不一样。</p></blockquote><h1>C风格字符串</h1><p>字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串（C-stylecharacter string）。</p><blockquote><p><strong>尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们</strong>。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。</p></blockquote><p>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。</p><h2 id="C标准库String函数">C标准库String函数</h2><p>表3.8列举了C语言标准库提供的一组函数，这些函数可用于操作C风格字符串，它们定义在<code>cstring</code>头文件中，<code>cstring</code>是C语言头文件string.h的C++版本。</p><img src="/2022/03/05/19-%E6%95%B0%E7%BB%84/1.png" class=""><blockquote><p>表3.8所列的函数不负责验证其字符串参数。</p></blockquote><p><strong>传入此类函数的指针必须指向以空字符作为结束的数组</strong>：</p><pre><code>char ca[] = &#123;'C', '+', '+'&#125;;  // not null terminatedcout &lt;&lt; strlen(ca) &lt;&lt; endl;   // disaster: ca isn't null terminated</code></pre><p>此例中，<code>ca</code>虽然也是一个字符数组但它不是以空字符作为结束的，因此上述程序将产生未定义的结果。<code>strlen</code>函数将有可能沿着<code>ca</code>在内存中的位置不断向前寻找，直到遇到空字符才停下来。</p><h2 id="比较字符串">比较字符串</h2><p>比较两个C风格字符串的方法和之前学习过的比较标准库<code>string</code>对象的方法大相径庭。</p><p>比较标准库<code>string</code>对象的时候，用的是普通的关系运算符和相等性运算符：</p><pre><code>string s1 = &quot;A string example&quot;;string s2 = &quot;A different string&quot;;if (s1 &lt; s2)  // false: s2 is less than s1</code></pre><p>如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身：</p><pre><code>const char ca1[] = &quot;A string example&quot;;const char ca2[] = &quot;A different string&quot;;if (ca1 &lt; ca2)  // undefined: compares two unrelated addresses</code></pre><p>谨记之前介绍过的，当使用数组的时候其实真正用的是指向数组首元素的指针。因此，上面的<code>if</code>条件实际上比较的是两个<code>const char *</code>的值。这两个指针指向的并非同一对象，所以将得到未定义的结果。</p><p>要想比较两个C风格字符串需要调用<code>strcmp</code>函数，此时比较的就不再是指针了。如果两个字符串相等，<code>strcmp</code>返回0；如果前面的字符串较大，返回正值；如果后面的字符串较大，返回负值：</p><pre><code>if (strcmp(ca1, ca2) &lt; 0) // same effect as string comparison s1 &lt; s2</code></pre><h2 id="目标字符串的大小由调用者指定">目标字符串的大小由调用者指定</h2><p>连接或拷贝C风格字符串也与标准库<code>string</code>对象的同类操作差别很大。例如，要想把刚刚定义的那两个<code>string</code>对象<code>s1</code>和<code>s2</code>连接起来，可以直接写成下面的形式：</p><pre><code>// initialize largeStr as a concatenation of s1, a space, and s2string largeStr = s1 + &quot; &quot; + s2;</code></pre><p>同样的操作如果放到<code>ca1</code>和<code>ca2</code>这两个数组身上就会产生错误了。表达式<code>ca1 + ca2</code>试图将两个指针相加，显然这样的操作没什么意义，也肯定是非法的。</p><p>正确的方法是使用<code>strcat</code>函数和<code>strcpy</code>函数。不过要想使用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。下面的代码虽然很常见，但是充满了安全风险，极易引发严重错误：</p><pre><code>// disastrous if we miscalculated the size of largeStrstrcpy(largeStr, ca1);     // copies ca1 into largeStrstrcat(largeStr, &quot; &quot;);     // adds a space at the end of largeStrstrcat(largeStr, ca2);     // concatenates ca2 onto largeStr</code></pre><p>一个潜在的问题是，我们在估算<code>largeStr</code>所需的空间时不容易估准，而且<code>largeStr</code>所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码到处都是，程序员根本没法照顾周全。这类代码充满了风险而且经常导致严重的安全泄漏。</p><blockquote><p>对大多数应用来说，使用标准库<code>string</code>要比使用C风格字符串更安全、更高效。</p></blockquote><h1>与旧代码的接口</h1><p>很多C++程序在标准库出现之前就已经写成了，它们肯定没用到<code>string</code>和<code>vector</code>类型。而且，有一些C++程序实际上是与C语言或其他语言的接口程序，当然也无法使用C++标准库。因此，现代的C++程序不得不与那些充满了数组和/或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。</p><h2 id="混用string对象和C风格字符串">混用string对象和C风格字符串</h2><p>此前介绍过，可以使用字符串字面值来初始化<code>string</code>对象：</p><pre><code>string s(&quot;Hello World&quot;);  // s holds Hello World</code></pre><p>更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：</p><ol><li>允许使用以空字符结束的字符数组来初始化<code>string</code>对象或为<code>string</code>对象赋值。</li><li>在<code>string</code>对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在<code>string</code>对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。</li></ol><p>上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用<code>string</code>对象来代替它。例如，不能用<code>string</code>对象直接初始化指向字符的指针。为了完成该功能，<code>string</code>专门提供了一个名为<code>c_str</code>的成员函数：</p><pre><code>char *str = s; // error: can't initialize a char* from a stringconst char *str = s.c_str(); // ok</code></pre><p><code>c_str</code>函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个<code>string</code>对象的一样。结果指针的类型是<code>const char *</code>，从而确保我们不会改变字符数组的内容。</p><p>我们无法保证<code>c_str</code>函数返回的数组一直有效，事实上，如果后续的操作改变了<code>s</code>的值就可能让之前返回的数组失去效用。</p><blockquote><p>如果执行完<code>c_str()</code>函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p></blockquote><h2 id="使用数组初始化vector对象">使用数组初始化vector对象</h2><p>此前介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用<code>vector</code>对象初始化数组。相反的，允许使用数组来初始化<code>vector</code>对象。要实现这一目的，只需<strong>指明要拷贝区域的首元素地址和尾后地址</strong>就可以了：</p><pre><code>int int_arr[] = &#123;0, 1, 2, 3, 4, 5&#125;;// ivec has six elements; each is a copy of the corresponding element in int_arrvector&lt;int&gt; ivec(begin(int_arr), end(int_arr));</code></pre><p>在上述代码中，用于创建<code>ivec</code>的两个指针实际上指明了用来初始化的值在数组<code>int_arr</code>中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。此例中，使用标准库函数<code>begin</code>和<code>end</code>来分别计算<code>int_arr</code>的首指针和尾后指针。在最终的结果中，<code>ivec</code>将包含6个元素，它们的次序和值都与数组<code>int_arr</code>完全一样。</p><p>用于初始化<code>vector</code>对象的值也可能仅是数组的一部分：</p><pre><code>// copies three elements: int_arr[1], int_arr[2], int_arr[3]vector&lt;int&gt; subVec(int_arr + 1, int_arr + 4);</code></pre><p>这条初始化语句用3个元素创建了对象<code>subVec</code>，3个元素的值分别来自<code>int_arr[1]</code>、<code>int_arr[2]</code>和<code>int_arr[3]</code>。</p><blockquote><p><strong>建议：尽量使用标准库类型而非数组</strong></p><p>使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误，特别是声明指针时的语法错误。</p><p>现代的C++程序应当尽量使用<code>vector</code>和迭代器，避免使用内置数组和指针；应该尽量使用<code>string</code>，避免使用C风格的基于数组的字符串。</p></blockquote><p><a href="https://weread.qq.com/web/reader/ff732fe072021a24ff7bb24k636320102206364d3f0ffdc">原文：数组</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 下标运算符 </tag>
            
            <tag> 范围for </tag>
            
            <tag> begin </tag>
            
            <tag> end </tag>
            
            <tag> 字符数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>可以使用下标运算符来访问<code>string</code>对象的字符或<code>vector</code>对象的元素，还有另外一种更通用的机制也可以实现同样的目的，即，<code>迭代器（iterator）</code>。</p><p>除了<code>vector</code>之外，标准库还定义了其他几种容器。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</p><blockquote><p>严格来说，string对象不属于容器类型，但是string支持很多与容器类型类似的操作。vector支持下标运算符，这点和string一样；string支持迭代器，这也和vector是一样的。</p><p><code>string</code>可以理解成<code>vector&lt;char&gt;</code></p></blockquote><p>类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者<code>string</code>对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。</p><h1>使用迭代器</h1><p>获取迭代器不是使用取地址符，有迭代器的类型同时拥有名为<code>begin</code>和<code>end</code>的成员。</p><ol><li><code>begin</code>成员负责返回指向第一个元素（或第一个字符）的迭代器</li><li><code>end</code>成员则负责返回指向容器（或<code>string</code>对象）“尾元素的下一位置”的迭代器。（一个本不存在的元素）。<code>end</code>成员返回的迭代器常被称作<strong>尾后迭代器</strong>或者简称为尾迭代器。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。</li></ol><blockquote><p>试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。</p></blockquote><pre><code>// the compiler determines the type of b and e// b denotes the first element and e denotes one past the last element in vauto b = v.begin(), e = v.end(); // b and e have the same type</code></pre><blockquote><p>如果容器为空，则<code>begin</code>和<code>end</code>返回的是同一个迭代器，都是尾后迭代器。</p></blockquote><p>只要我们知道其支持<code>begin</code>和<code>end</code>，就可以使用<code>auto</code>关键字来定义返回值的类型。因为一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么，利用<code>auto</code>关键字使编译器自行推断即可。</p><h2 id="迭代器运算符">迭代器运算符</h2><img src="/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/1.png" class=""><p>注意，<code>*iter</code>返回的是迭代器<code>iter</code>所指元素的引用。因此可以通过<code>*iter</code>修改<code>iter</code>所指元素的值。</p><pre><code>string s(&quot;some string&quot;);if (s.begin() != s.end()) &#123; // make sure s is not empty    auto it = s.begin();    // it denotes the first character in s    *it = toupper(*it);     // make that character uppercase&#125;</code></pre><p>输出结果将是：<code>Some string</code></p><p>迭代器使用递增（<code>++</code>）运算符来从一个元素移动到下一个元素。</p><p><strong>因为<code>end</code>返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</strong></p><p>例如，利用迭代器及其递增运算符可以把string对象中第一个单词改写为大写形式：</p><pre><code>// process characters in s until we run out of characters or we hit a whitespacefor (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)    *it = toupper(*it); // capitalize the current character</code></pre><p>输出结果将是：<code>SOME string</code></p><blockquote><p>关键概念：泛型编程</p><p>之前已经说过，只有<code>string</code>和<code>vector</code>等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了<code>==</code>和<code>!=</code>，但是它们中的大多数都没有定义<code>&lt;</code>运算符。因此，只要我们养成使用迭代器和<code>!=</code>的习惯，就不用太在意用的到底是哪种容器类型。</p></blockquote><p>使用<code>==</code>和<code>!=</code>来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否则就说这两个迭代器不相等。</p><h2 id="迭代器类型">迭代器类型</h2><p>拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：</p><pre><code>vector&lt;int&gt;::iterator it; // it can read and write vector&lt;int&gt; elementsstring::iterator it2;     // it2 can read and write characters in a stringvector&lt;int&gt;::const_iterator it3; // it3 can read but not write elementsstring::const_iterator it4;      // it4 can read but not write characters</code></pre><p><code>const_iterator</code>和指向常量的指针差不多，能读取但不能修改它所指的元素值。相反，<code>iterator</code>的对象可读可写。</p><p>如果<code>vector</code>对象或<code>string</code>对象是一个常量，只能使用<code>const_iterator</code>；如果<code>vector</code>对象或<code>string</code>对象不是常量，那么既能使用<code>iterator</code>也能使用<code>const_iterator</code>。</p><blockquote><p>术语：迭代器和迭代器类型</p><p>迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义的迭代器类型，还可能是指某个迭代器对象。</p><p>重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。</p><p>每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套操作。</p></blockquote><h2 id="begin和end运算符">begin和end运算符</h2><p><code>begin</code>和<code>end</code>返回的具体类型由对象是否是常量决定，如果对象是常量，<code>begin</code>和<code>end</code>返回<code>const_iterator</code>；如果对象不是常量，返回<code>iterator</code>：</p><pre><code>vector&lt;int&gt; v;const vector&lt;int&gt; cv;auto it1 = v.begin();  // it1 has type vector&lt;int&gt;::iteratorauto it2 = cv.begin(); // it2 has type vector&lt;int&gt;::const_iterator</code></pre><p>有时候我们希望即使对象不是常量，我们也想使用<code>const_iterator</code>。为了便于专门得到<code>const_iterator</code>类型的返回值，C++11新标准引入了两个新函数，分别是<code>cbegin</code>和<code>cend</code>：</p><pre><code>auto it3 = v.cbegin(); // it3 has type vector&lt;int&gt;::const_iterator</code></pre><p>类似于<code>begin</code>和<code>end</code>，上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论<code>vector</code>对象（或<code>string</code>对象）本身是否是常量，返回值都是<code>const_iterator</code>。</p><h2 id="结合解引用和成员访问操作">结合解引用和成员访问操作</h2><p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。</p><p>例如，对于一个由字符串组成的<code>vector</code>对象来说，要想检查其元素是否为空，令<code>it</code>是该<code>vector</code>对象的迭代器，只需检查<code>it</code>所指字符串是否为空就可以了，其代码如下所示：</p><pre><code>vector&lt;string&gt; v;auto it = v.begin();(*it).empty(); // dereferences it and calls the member empty on the resulting object</code></pre><p>注意，<code>(*it).empty()</code>中的圆括号必不可少，该表达式的含义是先对<code>it</code>解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由<code>it</code>来执行，而非<code>it</code>解引用的结果:</p><pre><code>*it.empty();   // error: attempts to fetch the member named empty from it, but it is an iterator and has no member named empty</code></pre><p>为了简化形如<code>(*it).empty()</code>的表达式，C++语言定义了箭头运算符（<code>-&gt;</code>）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it).mem</code>表达的意思相同。</p><pre><code>it-&gt;empty;     // it-&gt;mem is a synonym for (* it).mem.</code></pre><p>下例程序将输出三行<code>hello the world!!</code></p><pre><code>// print each line in text up to the first blank linevector&lt;string&gt; text(3, &quot;hello the world!!&quot;);for (auto it = text.cbegin(); it != text.cend() &amp;&amp; !it-&gt;empty(); ++it)    cout &lt;&lt; *it &lt;&lt; endl;</code></pre><p>值得注意的是，因为循环从头到尾只是读取<code>text</code>的元素而未向其中写值，所以使用了<code>cbegin</code>和<code>cend</code>来控制整个迭代过程。</p><h2 id="某些对vector对象的操作会使迭代器失效">某些对vector对象的操作会使迭代器失效</h2><p>虽然<code>vector</code>对象可以动态地增长，但是也会有一些副作用。</p><ol><li>一个限制是不能在<code>范围for</code>循环中向<code>vector</code>对象添加元素。</li><li>另外一个限制是任何一种可能改变<code>vector</code>对象容量的操作，比如<code>push_back</code>，都会使该<code>vector</code>对象的迭代器失效。</li></ol><blockquote><p>谨记，<strong>但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</strong></p></blockquote><h1>迭代器运算</h1><p>迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都有支持递增运算的迭代器。类似的，也能用<code>==</code>和<code>!=</code>对任意标准库类型的两个有效迭代器进行比较。</p><p><code>string</code>和<code>vector</code>的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算（iterator arithmetic），其细节由表3.7列出。</p><img src="/2022/03/05/18-%E8%BF%AD%E4%BB%A3%E5%99%A8/2.png" class=""><p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为<code>difference_type</code>的带符号整型数。<code>string</code>和<code>vector</code>都定义了<code>difference_type</code>，因为这个距离可正可负，所以<code>difference_type</code>是带符号类型的。</p><blockquote><p>使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜索完成；如果不是，假如该元素小于要找的元素，则在序列的后半部分继续搜素；假如该元素大于要找的元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中间元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜索。</p></blockquote><pre><code>// text must be sorted// beg and end will denote the range we're searchingauto beg = text.begin(), end = text.end();auto mid = text.begin() + (end - beg)/2; // original midpoint// while there are still elements to look at and we haven't yet found soughtwhile (mid != end &amp;&amp; *mid != sought) &#123;    if (sought &lt; *mid)     // is the element we want in the first half?        end = mid;         // if so, adjust the range to ignore the second half    else                   // the element we want is in the second half        beg = mid + 1;     // start looking with the element just after mid    mid = beg + (end - beg)/2;  // new midpoint&#125;</code></pre><p>程序的一开始定义了三个迭代器：<code>beg</code>指向搜索范围内的第一个元素、<code>end</code>指向尾元素的下一位置、<code>mid</code>指向中间的那个元素。初始状态下，搜索范围是名为<code>text</code>的<code>vector&lt;string&gt;</code>的全部范围。</p><p>循环部分先检查搜索范围是否为空，如果<code>mid</code>和<code>end</code>的当前值相等，说明已经找遍了所有元素。此时条件不满足，循环终止。当搜索范围不为空时，可知<code>mid</code>指向了某个元素，检查该元素是否就是我们所要搜索的，如果是，也终止循环。</p><p>当进入到循环体内部后，程序通过某种规则移动<code>beg</code>或者<code>end</code>来缩小搜索的范围。如果<code>mid</code>所指的元素比要找的元素<code>sought</code>大，可推测若<code>text</code>含有<code>sought</code>，则必出现在<code>mid</code>所指元素的前面。此时，可以忽略<code>mid</code>后面的元素不再查找，并把<code>mid</code>赋给<code>end</code>即可。另一种情况，如果<code>*mid</code>比<code>sought</code>小，则要找的元素必出现在<code>mid</code>所指元素的后面。此时，通过令<code>beg</code>指向<code>mid</code>的下一个位置即可改变搜索范围。因为已经验证过<code>mid</code>不是我们要找的对象，所以在接下来的搜索中不必考虑它。</p><p>循环过程终止时，<code>mid</code>或者等于<code>end</code>或者指向要找的元素。如果<code>mid</code>等于<code>end</code>，说明<code>text</code>中没有我们要找的元素。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iterator </tag>
            
            <tag> const_iterator </tag>
            
            <tag> begin </tag>
            
            <tag> end </tag>
            
            <tag> cbegin </tag>
            
            <tag> cend </tag>
            
            <tag> 箭头运算符 </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库类型vector</title>
      <link href="/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/"/>
      <url>/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/</url>
      
        <content type="html"><![CDATA[<p>标准库<strong>类型</strong><code>vector</code>表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为<code>vector</code>“容纳着”其他对象，所以它也常被称作<code>容器（container）</code>。</p><p>要想使用vector，必须包含适当的头文件:</p><pre><code>#include &lt;vector&gt;using std::vector;</code></pre><p>C++语言既有类模板（class template），也有函数模板，其中<code>vector</code>是一个类模板。</p><p><code>vector</code>是模板而非类型，由<code>vector</code>生成的类型必须包含<code>vector</code>中元素的类型，例如<code>vector&lt;int&gt;</code>, <code>vector&lt;vector&lt;int&gt;&gt;</code>。</p><blockquote><p>组成<code>vector</code>的元素也可以是<code>vector</code>。</p></blockquote><pre><code>vector&lt;int&gt; ivec;             // ivec holds objects of type intvector&lt;Sales_item&gt; Sales_vec; // holds Sales_itemsvector&lt;vector&lt;string&gt;&gt; file;  // vector whose elements are vectors</code></pre><p>引用不是对象，所以不存在包含引用的<code>vector</code>。</p><h1>定义和初始化vector对象</h1><img src="/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/1.png" class=""><p>可以默认初始化<code>vector</code>对象，从而创建一个指定类型的空<code>vector</code>。</p><p>之前已经讲过，C++语言提供了几种不同的初始化方式。在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。目前已经介绍过的两种例外情况是：其一，使用拷贝初始化时（即使用<code>=</code>时），只能提供一个初始值；其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：</p><pre><code>vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;  // list initializationvector&lt;string&gt; v2(&quot;a&quot;, &quot;an&quot;, &quot;the&quot;);  // errorvector&lt;int&gt; v3(10, 1); // v3 has ten elements with value 1vector&lt;int&gt; v4&#123;10, 1&#125;; // v4 has two elements with values 10 and 1</code></pre><h1>向vector对象中添加元素</h1><p>根据上述初始化<code>vector</code>对象的方法可知，<code>vector</code>对象直接初始化的方式适用于三种情况：初始值已知且数量较少、初始值是另一个<code>vector</code>对象的副本、所有元素的初始值都一样。</p><p>对于一般情况，可以先创建一个空<code>vector</code>，然后在运行时再利用<code>vector</code>的成员函数<code>push_back</code>向其中添加元素。<code>push_back</code>负责把一个值当成<code>vector</code>对象的尾元素“压到（push）”<code>vector</code>对象的“尾端（back）”。</p><pre><code>vector&lt;int&gt; v2;        // empty vectorfor (int i = 0; i != 100; ++i)    v2.push_back(i);    // append sequential integers to v2// at end of loop v2 has 100 elements, values 0 . . . 99// read words from the standard input and store them as elements in a vectorstring word;vector&lt;string&gt; text;       // empty vectorwhile (cin &gt;&gt; word) &#123;    text.push_back(word);  // append word to text&#125;</code></pre><p>C++标准要求<code>vector</code>应该能在运行时高效快速地添加元素。因此既然<code>vector</code>对象能高效地增长，那么在定义<code>vector</code>对象的时候设定其大小也就没什么必要了，事实上如果这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的<code>vector</code>对象，再在运行时向其中添加具体值。</p><p>特别需要注意一点：如果循环体内部包含有向<code>vector</code>对象添加元素的语句，则不能使用<code>范围for</code>循环。</p><blockquote><p><code>范围for</code>语句体内不应改变其所遍历序列的大小。</p></blockquote><h1>其他vector操作</h1><p>除了push_back之外，vector还提供了几种其他操作，大多数都和string的相关操作类似:</p><img src="/2022/03/04/17-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector/2.png" class=""><pre><code>vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8,9&#125;;for (auto &amp;i : v)     // for each element in v (note: i is a reference)    i *= i;           // square the element valuefor (auto i : v)      // for each element in v    cout &lt;&lt; i &lt;&lt; &quot; &quot;; // print the elementcout &lt;&lt; endl;</code></pre><p><code>vector</code>的<code>empty</code>和<code>size</code>两个成员与<code>string</code>的同名成员功能完全一致：<code>empty</code>检查<code>vector</code>对象是否包含元素然后返回一个布尔值；<code>size</code>则返回<code>vector</code>对象中元素的个数，返回值的类型是由<code>vector</code>定义的<code>size_type</code>类型。</p><p>要使用<code>size_type</code>，需首先指定它是由哪种类型定义的。<code>vector</code>对象的类型总是包含着元素的类型:</p><pre><code>vector&lt;int&gt;::size_type // okvector::size_type      // error</code></pre><p>各个相等性运算符和关系运算符也与<code>string</code>的相应运算符功能一致。</p><p>使用下标运算符能获取到指定的元素。<code>vector</code>对象的下标也是从0开始计起，下标的类型是相应的<code>size_type</code>类型。此外，也能通过计算得到<code>vector</code>内对象的索引，然后直接获取索引位置上的元素。</p><p>假设有一组成绩的集合，其中成绩的取值是从0到100。以10分为一个分数段，要求统计各个分数段各有多少个成绩:</p><pre><code>// count the number of grades by clusters of ten: 0--9, 10--19, . .. 90--99, 100vector&lt;unsigned&gt; scores(11, 0); // 11 buckets, all initially 0unsigned grade;while (cin &gt;&gt; grade) &#123;      // read the grades    if (grade &lt;= 100)       // handle only valid grades        ++scores[grade/10]; // increment the counter for the current clustercout &lt;&lt; scores &lt;&lt; endl;&#125;</code></pre><p>如果输入的成绩如下：<code>42 65 95 100 39 67 95 76 88 76 83 92 76 93</code><br>则输出的结果应该是：<code>0 0 0 1 1 0 2 3 2 4 1</code></p><blockquote><p>使用下标的时候必须清楚地知道它是否在合理范围。</p></blockquote><p>不能通过<code>vector</code>对象的下标形式来添加元素:</p><pre><code>vector&lt;int&gt; ivec;   // empty vectorfor (decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec[ix] = ix;  // disaster: ivec has no elements</code></pre><p>这段代码是错误的：<code>ivec</code>是一个空<code>vector</code>，根本不包含任何元素，当然也就不能通过下标去访问任何元素！如前所述，正确的方法是使用<code>push_back</code>：</p><pre><code>for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec.push_back(ix);  // ok: adds a new element with value ix</code></pre><p>注意，这里不能使用范围for语句，只能使用传统的for循环。因为<code>vector</code>序列长度改变</p><p><strong><code>vector</code>对象（以及<code>string</code>对象）的<code>下标运算符</code>可用于访问已存在的元素，而不能用于添加元素。</strong></p><p>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出（buffer overflow）指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。</p><p>因此，<strong>如需要对<code>vector</code>对象或<code>string</code>对象使用for语句，则尽量使用范围for，以免溢出。</strong></p><p><a href="https://weread.qq.com/web/reader/ff732fe072021a24ff7bb24k341323f021e34173cb3824c">原文：标准库类型vector</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
            <tag> push_back </tag>
            
            <tag> 下标运算符 </tag>
            
            <tag> 范围for </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库类型string</title>
      <link href="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/"/>
      <url>/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/</url>
      
        <content type="html"><![CDATA[<p>标准库<strong>类型</strong><code>string</code>表示可变长的字符序列，<strong>使用<code>string</code>类型必须首先包含<code>string</code>头文件</strong>。作为标准库的一部分，<strong><code>string</code>定义在命名空间<code>std</code>中</strong>。</p><pre><code>#include &lt;string&gt;using std::string;</code></pre><h1>定义和初始化string对象</h1><img src="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/1.png" class=""><p>拷贝初始化（copy initialization）: 使用等号（<code>=</code>）初始化一个变量，编译器把等号右侧的初始值拷贝到新创建的对象中去。</p><p>直接初始化（direct initialization）: 不使用等号。</p><p><code>string</code>接受无参数的初始化方式，所以<strong>不论<code>string</code>对象定义在函数内还是函数外，默认初始化都是得到空串。</strong></p><p>如果提供了一个<strong>字符串字面值</strong>，则该字面值中<strong>除了最后那个空字符外</strong>的其他所有字符都被拷贝到新创建的<code>string</code>对象中去。</p><h1>string对象上的操作</h1><p><code>string</code>对象的大多数操作：</p><img src="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/2.png" class=""><blockquote><p><code>is&gt;&gt;s</code>读取时不包括空格符；<code>getline(is,s)</code>读取整行，包含空格符。</p></blockquote><h2 id="读写string对象">读写string对象</h2><p>可以使用IO操作符读写<code>string</code>对象：</p><pre><code>// Note: #include and using declarations must be added to compile this codeint main()&#123;    string s;          // empty string    cin &gt;&gt; s;          // read a whitespace-separated string into s    cout &lt;&lt; s &lt;&lt; endl; // write s to the output    return 0;&#125;</code></pre><blockquote><p><strong>在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</strong></p></blockquote><p>如上所述，如果程序的输入是“　　Hello World！　　”（注意开头和结尾处的空格），则输出将是“Hello”，输出结果中没有任何空格。</p><p>和内置类型的输入输出操作一样，<code>string</code>对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写在一起：</p><pre><code>string s1, s2;cin &gt;&gt; s1 &gt;&gt; s2; // read first input into s1, second into s2cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; // write both strings</code></pre><p>假设给上面这段程序输入与之前一样的内容“ Hello World! ”，输出将是“HelloWorld!”。</p><h2 id="读取未知数量的string对象">读取未知数量的string对象</h2><pre><code>int main()&#123;    string word;    while (cin &gt;&gt; word)       // read until end-of-file        cout &lt;&lt; word &lt;&lt; endl; // write each word followed by a new line    return 0;&#125;</code></pre><p>一旦遇到文件结束标记或非法输入，循环也就结束了。</p><h2 id="使用getline读取一整行">使用getline读取一整行</h2><p><strong><code>getline</code>能在最终得到的字符串中保留输入时的空白符。</strong></p><p><code>getline</code>函数的参数是一个输入流和一个<code>string</code>对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个<code>string</code>对象中去（注意不存换行符）。</p><p><strong><code>getline</code>只要一遇到换行符就结束读取操作并返回结果</strong>，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空<code>string</code>。</p><p>和输入运算符一样，<code>getline</code>也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用<code>getline</code>的结果作为条件。例如：</p><pre><code>int main()&#123;    string line;    // read input a line at a time until end-of-file    while (getline(cin, line))        cout &lt;&lt; line &lt;&lt; endl;    return 0;&#125;</code></pre><blockquote><p><strong>触发<code>getline</code>函数返回的那个换行符实际上被丢弃掉了，得到的<code>string</code>对象中并不包含该换行符。</strong></p></blockquote><h2 id="string-size-type类型">string::size_type类型</h2><p><code>size</code>函数返回<code>string</code>对象的长度（即<code>string</code>对象中字符的个数），返回的是一个<code>string::size_type</code>类型的值。</p><blockquote><p><code>string</code>类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型<code>size_type</code>即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字<code>size_type</code>是在类<code>string</code>中定义的。</p></blockquote><p><code>string::size_type</code>类型的对象，是一个无符号类型的值，而且能足够存放下任何<code>string</code>对象的大小。<strong>所有用于存放<code>string</code>类的<code>size</code>函数返回值的变量，都应该是<code>string::size_type</code>类型的。</strong></p><p>在C++11新标准中，允许编译器通过<code>auto</code>或者<code>decltype</code>来推断变量的类型：</p><pre><code>auto len = line.size(); // len has type string::size_type</code></pre><p>由于<code>size</code>函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int，则表达式<code>s.size()&lt;n</code>的判断结果几乎肯定是<code>true</code>。这是因为负值n会自动地转换成一个比较大的无符号值。</p><blockquote><p>如果一条表达式中已经有了<code>size()</code>函数就不要再使用<code>int</code>了，这样可以避免混用<code>int</code>和<code>unsigned</code>可能带来的问题。</p></blockquote><h2 id="比较string对象">比较string对象</h2><p><code>string</code>类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较<code>string</code>对象中的字符，并且对大小写敏感。</p><p>相等性运算符（<code>==</code>和<code>！=</code>）、关系运算符（<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>）都依照（大小写敏感的）字典顺序：</p><ol><li>如果两个<code>string</code>对象的长度不同，而且较短<code>string</code>对象的每个字符都与较长<code>string</code>对象对应位置上的字符相同，就说较短<code>string</code>对象小于较长string对象。</li><li>如果两个<code>string</code>对象在某些对应的位置上不一致，则<code>string</code>对象比较的结果其实是<code>string</code>对象中第一对相异字符比较的结果。</li></ol><h2 id="为string对象赋值">为string对象赋值</h2><p>对于string类而言，允许把一个对象的值赋给另外一个对象：</p><pre><code>string st1(10, 'c'), st2; // st1 is cccccccccc; st2 is an empty stringst1 = st2; // assignment: replace contents of st1 with a copy of st2        // both st1 and st2 are now the empty string</code></pre><h2 id="两个string对象相加">两个string对象相加</h2><p>两个<code>string</code>对象相加得到一个新的<code>string</code>对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。</p><pre><code>string s1  = &quot;hello, &quot;, s2 = &quot;world\n&quot;;string s3 = s1 + s2;   // s3 is hello, world\ns1 += s2;   // equivalent to s1 = s1 + s2</code></pre><h2 id="字面值和string对象相加">字面值和string对象相加</h2><p>标准库允许把字符字面值和字符串字面值转换成<code>string</code>对象，所以在需要<code>string</code>对象的地方就可以使用这两种字面值来替代。</p><pre><code>string s1 = &quot;hello&quot;, s2 = &quot;world&quot;; // no punctuation in s1 or s2string s3 = s1 + &quot;, &quot; + s2 + '\n';</code></pre><p>当把<code>string</code>对象和字符字面值及字符串字面值混在一条语句中使用时，<strong>必须确保每个加法运算符（<code>+</code>）的两侧的运算对象至少有一个是<code>string</code></strong>：</p><pre><code>string s4 = s1 + &quot;, &quot;;           // ok: adding a string and a literalstring s5 = &quot;hello&quot; + &quot;, &quot;;      // error: no string operandstring s6 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has a string operand, equivalent to string s6 = (s1 + &quot;, &quot;) + &quot;world&quot;;string s7 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can't add string literals, equivalent to string s7 = (&quot;hello&quot; + &quot;, &quot;) + s2;</code></pre><blockquote><p>因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型<code>string</code>的对象。切记，字符串字面值与<code>string</code>是不同的类型。</p></blockquote><h1>处理string对象中的字符</h1><p>我们经常需要单独处理<code>string</code>对象中的字符，比如检查一个<code>string</code>对象是否包含空白，或者把<code>string</code>对象中的字母改成小写，再或者查看某个特定的字符是否出现等。</p><p>这类处理的一个关键问题是如何获取字符本身。另一个关键问题是要知道能改变某个字符的特性。</p><p>在cctype头文件中定义了一组标准库函数处理这部分工作:</p><img src="/2022/03/03/16-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/3.png" class=""><blockquote><p>建议：使用C++版本的C标准库头文件<br>C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如<code>name.h</code>，C++则将这些文件命名为<code>cname</code>。也就是去掉了<code>.h</code>后缀，而在文件名<code>name</code>之前添加了字母<code>c</code>，这里的<code>c</code>表示这是一个属于C语言标准库的头文件。<br>一般来说，C++程序应该使用名为<code>cname</code>的头文件而不使用<code>name.h</code>的形式。在名为<code>cname</code>的头文件中定义的名字从属于命名空间<code>std</code>，而定义在名为<code>.h</code>的头文件中的则不然。</p></blockquote><h2 id="使用基于范围的for语句处理每个字符">使用基于范围的for语句处理每个字符</h2><p>C++11新标准提供的一种语句：<code>范围for（rangefor）</code>语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：</p><pre><code>for (declaration : expression)    statement</code></pre><p>其中，<code>expression</code>部分是一个对象，用于表示一个序列。<code>declaration</code>部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，<code>declaration</code>部分的变量会被初始化为<code>expression</code>部分的下一个元素值。</p><p>一个<code>string</code>对象表示一个字符的序列，因此<code>string</code>对象可以作为<code>范围for</code>语句中的<code>expression</code>部分。</p><pre><code>string str(&quot;some string&quot;);// print the characters in str one character to a linefor (auto c : str)      // for every char in str    cout &lt;&lt; c &lt;&lt; endl;  // print the current character followed by a newline</code></pre><p><code>for</code>循环把变量<code>c</code>和<code>str</code>联系了起来，其中我们定义循环控制变量的方式与定义任意一个普通变量是一样的。此例中，通过使用<code>auto</code>关键字让编译器来决定变量<code>c</code>的类型，这里<code>c</code>的类型是<code>char</code>。每次迭代，<code>str</code>的下一个字符被拷贝给<code>c</code>，因此该循环可以读作“对于字符串<code>str</code>中的每个字符<code>c</code>，”执行某某操作。此例中的“某某操作”即输出一个字符，然后换行。</p><p>举个稍微复杂一点的例子，使用<code>范围for</code>语句和<code>ispunct</code>函数来统计<code>string</code>对象中标点符号的个数：</p><pre><code>string s(&quot;Hello World!!!&quot;);// punct_cnt has the same type that s.size returns; see § 2.5.3 (p. 70)decltype(s.size()) punct_cnt = 0;// count the number of punctuation characters in sfor (auto c : s)        // for every char in s    if (ispunct(c))     // if the character is punctuation        ++punct_cnt;    // increment the punctuation countercout &lt;&lt; punct_cnt    &lt;&lt; &quot; punctuation characters in &quot; &lt;&lt; s &lt;&lt; endl;</code></pre><p>程序的输出结果将是：<code>3 punctuation characters in Hello World!!!</code><br>这里我们使用<code>decltype</code>关键字声明计数变量<code>punct_cnt</code>，它的类型是<code>s.size</code>函数返回值的类型，也就是<code>string：：size_type</code>。</p><h2 id="使用范围for语句改变字符串中的字符">使用范围for语句改变字符串中的字符</h2><p>如果想要改变<code>string</code>对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。</p><p>假设我们想要把字符串改写为大写字母的形式。为了做到这一点可以使用标准库函数<code>toupper</code>，该函数接收一个字符，然后输出其对应的大写形式。这样，为了把整个<code>string</code>对象转换成大写，只要对其中的每个字符调用<code>toupper</code>函数并将结果再赋给原字符就可以了：</p><pre><code>string s(&quot;Hello World!!!&quot;);// convert s to uppercasefor (auto &amp;c : s)   // for every char in s (note: c is a reference)    c = toupper(c); // c is a reference, so the assignment changes the char in scout &lt;&lt; s &lt;&lt; endl;</code></pre><p>上述代码的输出结果将是：<code>HELLO WORLD!!!</code><br>每次迭代时，变量<code>c</code>引用<code>string</code>对象<code>s</code>的下一个字符，赋值给<code>c</code>也就是在改变<code>s</code>中对应字符的值。</p><h2 id="只处理一部分字符">只处理一部分字符</h2><p>如果要处理string对象中的每一个字符，使用<code>范围for</code>语句是个好主意。然而，有时我们需要访问的只是其中一个字符，或者访问多个字符但遇到某个条件就要停下来。</p><p>要想访问<code>string</code>对象中的单个字符有两种方式：</p><ol><li>使用下标</li><li>使用迭代器</li></ol><p>下标运算符（<code>[ ]</code>）接收的输入参数是<code>string::size_type</code>类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。</p><p><strong><code>string</code>对象的下标从0计起。</strong></p><blockquote><p><code>string</code>对象的下标必须大于等于0而小于<code>s.size()</code>。因为string对象的下标从0计起，最后一个字符的下标应该是<code>s.size() - 1</code>。使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问空<code>string</code>也会引发不可预知的结果。因此，只要对<code>string</code>对象使用了下标，都要确认在那个位置上确实有值。</p></blockquote><p>下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由<code>string::size_type</code>表达的无符号类型。</p><pre><code>if (!s.empty())            // make sure there's a character to print    cout &lt;&lt; s[0] &lt;&lt; endl;  // print the first character in s</code></pre><p>只要字符串未被<code>const</code>限定符限制为常量，就能利用下标运算符为字符串中指定位置的字符赋新值。</p><pre><code>string s(&quot;some string&quot;);if (!s.empty())             // make sure there's a character in s[0]    s[0] = toupper(s[0]);   // assign a new value to the first character in s</code></pre><p>程序的输出结果将是：<code>Some string</code></p><pre><code>// process characters in s until we run out of characters or we hit a whitespacefor (decltype(s.size()) index = 0;    index != s.size() &amp;&amp; !isspace(s[index]); ++index)        s[index] = toupper(s[index]); // capitalize the current character</code></pre><p>程序的输出结果将是：<code>SOME string</code><br>在上述程序中，<code>for</code>循环使用变量<code>index</code>作为<code>s</code>的下标，<code>index</code>的类型是由<code>decltype</code>关键字决定的。首先把<code>index</code>初始化为<code>0</code>，这样第一次迭代就会从<code>s</code>的首字符开始；之后每次迭代将<code>index</code>加1以得到<code>s</code>的下一个字符。循环体负责将当前的字母改写为大写形式。</p><p>需要注意的是，上例使用了逻辑与运算符（<code>&amp;&amp;</code>）。如果参与运算的两个运算对象都为真，则逻辑与结果为真；否则结果为假。对这个运算符来说最重要的一点是，C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。如上例所示，这条规定确保了只有当下标取值在合理范围之内时才会真的用此下标去访问字符串。也就是说，只有在<code>index</code>达到<code>s.size()</code>之前才会执行<code>s[index]</code>。</p><p>再次强调，注意检查下标的合法性。一种简便易行的方法是，<strong>总是设下标的类型为<code>string::size_type</code></strong>，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于<code>size()</code>的值就可以了。</p><h2 id="使用下标执行随机访问">使用下标执行随机访问</h2><p>直接获取对应位置的字符，而不是从前往后依次访问。</p><p>编写一个程序把0到15之间的十进制数转换成对应的十六进制形式：</p><pre><code>const string hexdigits = &quot;0123456789ABCDEF&quot;; // possible hex digits (Note that it is a const string.)cout &lt;&lt; &quot;Enter a series of numbers between 0 and 15&quot;     &lt;&lt; &quot; separated by spaces. Hit ENTER when finished: &quot;     &lt;&lt; endl;string result;        // will hold the resulting hexify'd stringstring::size_type n;  // hold numbers from the inputwhile (cin &gt;&gt; n)    if (n &lt; hexdigits.size())    // ignore invalid input        result += hexdigits[n];  // fetch the indicated hex digitcout &lt;&lt; &quot;Your hex number is: &quot; &lt;&lt; result &lt;&lt; endl;</code></pre><p>假设输入的内容如下：<code>12 0 5 15 8 15</code><br>程序的输出结果将是：<code>Your hex number is: C05F8F</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 下标运算符 </tag>
            
            <tag> 范围for </tag>
            
            <tag> string </tag>
            
            <tag> string::size_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命名空间的using声明</title>
      <link href="/2022/03/03/15-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E/"/>
      <url>/2022/03/03/15-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><code>std::cin</code>的意思就是要使用命名空间<code>std</code>中的名字<code>cin</code>。</p><p><code>using</code>声明具有如下的形式：</p><pre><code>using namespace::name;</code></pre><p>一旦声明了上述语句，就可以直接访问命名空间中的名字。</p><pre><code>#include &lt;iostream&gt;// using declaration; when we use the name cin, we get the one from the namespace stdusing std::cin;int main()&#123;    int i;    cin &gt;&gt; i;       // ok: cin is a synonym for std::cin    cout &lt;&lt; i;      // error: no using declaration; we must use the full name    std::cout &lt;&lt; i; // ok: explicitly use cout from namepsace std    return 0;&#125;</code></pre><h1>每个名字都需要独立的using声明</h1><p>按照规定，每个<code>using</code>声明引入命名空间中的一个成员。因此，用到的每个名字都必须有自己的声明语句，而且<strong>每句话都得以分号结束。</strong></p><pre><code>#include &lt;iostream&gt;// using declarations for names from the standard libraryusing std::cin;using std::cout;using std::endl;int main()&#123;    cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; endl;    int v1, v2;    cin &gt;&gt; v1 &gt;&gt; v2;    cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2        &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; endl;    return 0;&#125;</code></pre><h1>头文件不应包含using声明</h1><p>位于头文件的代码一般来说不应该使用<code>using</code>声明。</p><blockquote><p>因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个<code>using</code>声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 头文件 </tag>
            
            <tag> using声明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>术语表-Chapter2</title>
      <link href="/2022/03/02/14-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter2/"/>
      <url>/2022/03/02/14-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter2/</url>
      
        <content type="html"><![CDATA[<p><code>地址（address）</code>：是一个数字，根据它可以找到内存中的一个字节。</p><p><code>别名声明（alias declaration）</code>：为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词。</p><p><code>算术类型（arithmetic type）</code>：布尔值、字符、整数、浮点数等内置类型。</p><p><code>数组（array）</code>：是一种数据结构，存放着一组未命名的对象，可以通过索引来访问这些对象。</p><p><code>auto</code>：是一个类型说明符，通过变量的初始值来推断变量的类型。</p><p><code>基本类型（base type）</code>：是类型说明符，可用<code>const</code>修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符。</p><p><code>绑定（bind）</code>：令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。</p><p><code>字节（byte）</code>：内存中可寻址的最小单元，大多数机器的字节占8位。</p><p><code>类成员（class member）</code>：类的组成部分。</p><p><code>复合类型（compound type）</code>：是一种类型，它的定义以其他类型为基础。</p><p><code>const</code>：是一种类型修饰符，用于说明永不改变的对象。<code>const</code>对象一旦定义就无法再赋新值，所以必须初始化。</p><p><code>常量指针（const pointer）</code>：是一种指针，它的值永不改变。</p><p><code>常量引用（const reference）</code>：是一种习惯叫法，含义是指向常量的引用。</p><p><code>常量表达式（const expression）</code>：能在编译时计算并获取结果的表达式。</p><p><code>constexpr</code>：是一种函数，用于代表一条常量表达式。</p><p><code>转换（conversion）</code>：一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换。</p><p><code>数据成员（data member）</code>：组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。</p><p><code>声明（declaration）</code>：声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用。</p><p><code>声明符（declarator）</code>：是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。</p><p><code>decltype</code>：是一个类型说明符，从变量或表达式推断得到类型。</p><p><code>默认初始化（default initialization）</code>：当对象未被显式地赋予初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值。</p><p><code>定义（definition）</code>：为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用。</p><p><code>转义序列（escape sequence）</code>：字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数。</p><p><code>全局作用域（global scope）</code>：位于其他所有作用域之外的作用域。</p><p><code>头文件保护符（header guard）</code>：使用预处理变量以防止头文件被某个文件重复包含。</p><p><code>标识符（identifier）</code>：组成名字的字符序列，标识符对大小写敏感。</p><p><code>类内初始值（in-class initializer）</code>：在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内。</p><p><code>在作用域内（in scope）</code>：名字在当前作用域内可见。</p><p><code>被初始化（initialized）</code>：变量在定义的同时被赋予初始值，变量一般都应该被初始化。</p><p><code>内层作用域（inner scope）</code>：嵌套在其他作用域之内的作用域。</p><p><code>整型（integral type）</code>：参见算术类型。</p><p><code>列表初始化（list initialization）</code>：利用花括号把一个或多个初始值放在一起的初始化形式。</p><p><code>字面值（literal）</code>：是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值。</p><p><code>局部作用域（local scope）</code>：是块作用域的习惯叫法。</p><p><code>底层const（low-level const）</code>：一个不属于顶层的<code>const</code>，类型如果由底层常量定义，则不能被忽略。</p><p><code>成员（member）</code>：类的组成部分。</p><p><code>不可打印字符（nonprintable character）</code>：不具有可见形式的字符，如控制符、退格、换行符等。</p><p><code>空指针（null pointer）</code>：值为0的指针，空指针合法但是不指向任何对象。</p><p><code>nullptr</code>：是表示空指针的字面值常量。</p><p><code>对象（object）</code>：是内存的一块区域，具有某种类型，变量是命名了的对象。</p><p><code>外层作用域（outer scope）</code>：嵌套着别的作用域的作用域。</p><p><code>指针（pointer）</code>：是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0。</p><p><code>指向常量的指针（pointer to const）</code>：是一个指针，存放着某个常量对象的地址。指向常量的指针不能用来改变它所指对象的值。</p><p><code>预处理器（preprocessor）</code>：在C++编译过程中执行的一段程序。</p><p><code>预处理变量（preprocessor variable）</code>：由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。</p><p><code>引用（reference）</code>：是某个对象的别名。</p><p><code>对常量的引用（reference to const）</code>：是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。</p><p><code>作用域（scope）</code>：是程序的一部分，在其中某些名字有意义。</p><p>C++有几级作用域：全局、类、块</p><p><code>全局（global）</code>——名字定义在所有其他作用域之外。</p><p><code>类（class）</code>——名字定义在类内部。命名空间（namespace）——名字定义在命名空间内部。</p><p><code>块（block）</code>——名字定义在块内部。名字从声明位置开始直至声明语句所在的作用域末端为止都是可用的。</p><p><code>分离式编译（separate compilation）</code>：把程序分割为多个单独文件的能力。</p><p><code>带符号类型（signed）</code>：保存正数、负数或0的整型。</p><p><code>字符串（string）</code>：是一种库类型，表示可变长字符序列。</p><p><code>struct</code>：是一个关键字，用于定义类。</p><p><code>临时值（temporary）</code>：编译器在计算表达式结果时创建的无名对象。为某表达式创建了一个临时值，则此临时值将一直存在直到包含有该表达式的最大的表达式计算完成为止。</p><p><code>顶层const（top-level const）</code>：是一个<code>const</code>，规定某对象的值不能改变。</p><p><code>类型别名（type alias）</code>：是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义。</p><p><code>类型检查（type checking）</code>：是一个过程，编译器检查程序使用某给定类型对象的方式与该类型的定义是否一致。</p><p><code>类型说明符（type specifier）</code>：类型的名字。</p><p><code>typedef</code>：为某类型定义一个别名。当关键字<code>typedef</code>作为声明的基本类型出现时，声明中定义的名字就是类型名。</p><p><code>未定义（undefined）</code>：即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题。</p><p><code>未初始化（uninitialized）</code>：变量已定义但未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为。</p><p><code>无符号类型（unsigned）</code>：保存大于等于0的整型。</p><p><code>变量（variable）</code>：命名的对象或引用。C++语言要求变量要先声明后使用。</p><p><code>void*</code>：可以指向任意非常量的指针类型，不能执行解引用操作。</p><p><code>void类型</code>：是一种有特殊用处的类型，既无操作也无值。不能定义一个<code>void</code>类型的变量。</p><p><code>字（word）</code>：在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节。</p><p><code>&amp;运算符（&amp;operator）</code>：取地址运算符。</p><p><code>*运算符（* operator）</code>：解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。</p><p><code>#define</code>：是一条预处理指令，用于定义一个预处理变量。</p><p><code>#endif</code>：是一条预处理指令，用于结束一个<code>#ifdef</code>或<code>#ifndef</code>区域。</p><p><code>#ifdef</code>：是一条预处理指令，用于判断给定的变量是否已经定义。</p><p><code>#ifndef</code>：是一条预处理指令，用于判断给定的变量是否尚未定义。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义数据结构</title>
      <link href="/2022/03/02/13-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/02/13-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p><p>C++语言允许用户以类的形式自定义数据类型，而库类型<code>string</code>、<code>istream</code>、<code>ostream</code>等也都是以类的形式定义的。</p><h1>定义Sales_data类型</h1><pre><code>struct Sales_data&#123;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;&#125;;</code></pre><p>这里的类以关键字<code>struct</code>开始，紧跟着类名和类体（其中类体部分可以为空）。类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。</p><p><strong>类体右侧的表示结束的花括号后必须写一个分号</strong>，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：</p><pre><code>struct Sales_data &#123; /* ... */ &#125; accum, trans, *salesptr; // equivalent, but better way to define these objectsstruct Sales_data &#123; /* ... */ &#125;;Sales_data accum, trans, *salesptr;</code></pre><p>分号表示声明符（通常为空）的结束。</p><p>一般来说，最好不要把对象的定义和类的定义放在一起。</p><p>用户也可以使用C++语言提供的另外一个关键字<code>class</code>来定义自己的数据结构。</p><p>类的定义可以与<code>main</code>函数放在同一个文件内，但是，我们通常在头文件中定义类，并且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如，我们应该把Sales_data类定义在名为Sales_data.h的头文件中。</p><h1>类数据成员</h1><p>类体定义类的成员，我们上面定义的类只有数据成员（datamember）。</p><p>类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他<code>Sales_data</code>的对象。</p><p>定义数据成员的方法：首先说明一个基本类型，随后紧跟一个或多个声明符。</p><p>C++11新标准规定，可以为数据成员提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p><blockquote><p>对类内初始值的限制：要么放在花括号里，要么放在等号右边，而不能使用圆括号。</p></blockquote><h1>使用Sales_data类</h1><p><a href="https://weread.qq.com/web/reader/ff732fe072021a24ff7bb24k1ff325f02181ff1de7742fc">详见：自己动手实现对于Sales_data类的操作</a></p><p>关键在于，使用点操作符(<code>.</code>)读入对象的成员，如</p><pre><code>Sales_data data1;                               // data1为Sales_data类型的对象std::cin &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold;   // 写入对象data1的bookNo成员和units_sold成员</code></pre><h1>编写自己的头文件</h1><p>为了确保各个文件中类的定义一致，<strong>类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。</strong></p><p>头文件通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量等。</p><p>头文件也经常用到其他头文件的功能。因此，有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地工作。</p><blockquote><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p></blockquote><h2 id="预处理器概述">预处理器概述</h2><p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>（preprocessor），它由C++语言从C语言继承而来。</p><blockquote><p>预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能<code>#include</code>，当预处理器看到<code>#include</code>标记时就会用指定的头文件的内容代替<code>#include</code>。</p></blockquote><p>C++程序还会用到的一项预处理功能是<strong>头文件保护符</strong>（headerguard），头文件保护符依赖于预处理变量。</p><blockquote><p>预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</p></blockquote><p>使用这些功能就能有效地防止重复包含的发生：</p><pre><code>#ifndef SALES_DATA_H    // SALES_DATA_H即为预处理变量，ifndef是if not defined的缩写。若未定义SALES_DATA_H，则执行后续操作，直到遇到#endif指令#define SALES_DATA_H#include &lt;string&gt;struct Sales_data &#123;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;&#125;;#endif</code></pre><p>第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直至遇到#endif为止。此时，预处理变量SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，则#ifndef的检查结果将为假，编译器将忽略#ifndef到#endif之间的部分。</p><blockquote><p>预处理变量无视C++语言中关于作用域的规则。</p></blockquote><p>整个程序中的预处理变量包括头文件保护符必须唯一，<strong>通常的做法是基于头文件中类的名字来构建保护符的名字</strong>，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，<strong>一般把预处理变量的名字全部大写</strong>。</p><blockquote><p>头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> struct </tag>
            
            <tag> 点运算符 </tag>
            
            <tag> 头文件 </tag>
            
            <tag> 预处理器 </tag>
            
            <tag> 头文件保护符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理类型</title>
      <link href="/2022/03/02/12-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/03/02/12-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>类型别名</h1><p>类型别名（type alias）是某种类型的同义词。</p><p>有两种方法可用于定义类型别名:</p><ol><li><p>传统的方法是使用关键字<code>typedef</code>：</p><pre><code> typedef double wages;   // wages是double的同义词 typedef wages base, *p; // base是double的同义词, p是double*的同义词</code></pre></li></ol><p>其中，关键字<code>typedef</code>作为声明语句中的基本数据类型的一部分出现。含有<code>typedef</code>的声明语句定义的不再是变量而是类型别名。这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。</p><ol start="2"><li><p>新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名：</p><pre><code> using SI = Sales_item;  // SI是Sales_item的同义词</code></pre></li></ol><p>这种方法用关键字<code>using</code>作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p><p>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：</p><pre><code>wages hourly, weekly;    // 等效于double hourly, weekly;SI item;                 // 等效于Sales_item item</code></pre><h2 id="指针、常量和类型别名">指针、常量和类型别名</h2><p>如果某个类型别名指代的是复合类型或常量，当一条声明语句用到了类型别名时，<strong>不能简单地用原复合类型来代替类型别名。</strong></p><p>例如下面的声明语句用到了类型<code>pstring</code>，它实际上是类型<code>char *</code>的别名：</p><pre><code>typedef char *pstring;const pstring cstr = 0; // cstr是一个指向char对象的常量指针，相当于char *const cstr = 0;const pstring *ps;      // ps是一个指针，它的对象是一个指向char的常量指针。因为const pstring是一个指向char的常量指针类型</code></pre><p>上述两条声明语句的基本数据类型都是<code>const pstring</code>，和过去一样，<code>const</code>是对给定类型的修饰。<code>pstring</code>实际上是指向<code>char</code>的指针，因此，<code>const pstring</code>就是指向char的常量指针，而非指向常量字符的指针。</p><blockquote><p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：</p></blockquote><pre><code>const pstring cstr = 0;   //cstr是指向char的常量指针const char *cstr = 0;     //对const pstring cstr的错误理解，将cstr错当成一个指向char常量的指针</code></pre><h1>auto类型说明符</h1><p>C++11新标准引入了<code>auto</code>类型说明符，<code>auto</code>让编译器通过初始值来推算变量的类型。</p><p><code>auto</code>定义的变量必须有初始值：</p><pre><code>//根据val1和val2相加的结果来推断item的类型auto item = val1 + val2;</code></pre><p>使用<code>auto</code>也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p><pre><code>auto i = 0, *p = &amp;i;      // ok: i是一个int型变量，p是一个指向int型对象的指针auto sz = 0, pi = 3.14;   // error: sz和pi的类型不一致，根据sz会推导为int型，但pi会推断为float/double型</code></pre><h2 id="复合类型、常量和auto">复合类型、常量和auto</h2><p>编译器推断出来的<code>auto</code>类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p><ol><li><p>当引用被用作初始值时，真正参与初始化的其实是引用对象的值，此时编译器以引用对象的类型作为<code>auto</code>的类型：</p><pre><code> int i = 0, &amp;r = i; auto a = r;  // a是int型（r是int型对象i的引用）</code></pre></li><li><p>其次，<code>auto</code>一般会忽略掉顶层<code>const</code>，同时底层<code>const</code>则会保留下来</p><pre><code> const int ci = i, &amp;cr = ci; auto b = ci;  // b是一个int型（顶层const被忽略） auto c = cr;  // c是一个int型 auto d = &amp;i;  // d是一个指向int的指针 auto e = &amp;ci; // e是一个指向int常量的指针（底层const被保留）</code></pre></li><li><p>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要明确指出：</p><pre><code> const auto f = ci; // ci的类型是int，f是一个int常量（顶层const）</code></pre></li><li><p>可以将引用的类型设为<code>auto</code>，此时原来的初始化规则（引用的初始化规则）仍然适用：</p><pre><code> auto &amp;g = ci;       // g is a const int&amp;. 因为ci是int常量，不允许存在通过g修改ci的风险，故而g是常量引用 auto &amp;h = 42;       // error: 不能为非常量引用绑定字面值。字面值常量42的类型为int，故auto推断为int型，此时存在通过h修改42的风险，故而语法错误 const auto &amp;j = 42; // ok: 可以为常量引用绑定字面值</code></pre></li></ol><p>设置一个类型为<code>auto</code>的引用时，初始值中的顶层常量属性仍然保留。即，不能通过引用修改所指对象的值。</p><ol start="5"><li><p>要在一条语句中定义多个变量，切记，符号<code>&amp;</code>和<code>*</code>只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：</p><pre><code> auto k = ci, &amp;l = i;    // k是int型对象，l是int型对象i的引用 auto &amp;m = ci, *p = &amp;ci; // m是一个int型常量引用，p是指向int常量的指针 auto &amp;n = i, *p2 = &amp;ci; //error: 根据i推断的类型是int; 根据&amp;ci推断的类型是const int。（存在通过p2修改ci的风险）</code></pre></li></ol><h1>decltype类型指示符</h1><p>C++11新标准引入了类型说明符d<code>ecltype</code>，它的作用是选择并返回操作数的数据类型。</p><p>编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p><pre><code>decltype(f()) sum = x;</code></pre><p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。</p><p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：</p><pre><code>const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x的类型是const intdecltype(cj) y = x; // y的类型是const int&amp;decltype(cj) z;     // error: z是一个引用，必须初始化</code></pre><blockquote><p>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。在decltype中，引用和引用所指对象是不同的数据类型，如上例，ci是const int型，而cj是const int&amp;型。</p></blockquote><h2 id="decltype和引用">decltype和引用</h2><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p><pre><code>//decltype的结果可以是引用类型int i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b;  // ok: 加法的结果是int型，故而b是一个（未初始化）的int对象decltype(*p) c;     // error: c是int&amp;型，必须初始化</code></pre><p>因为<code>r</code>是一个引用，因此<code>decltype(r)</code>的结果是引用类型。如果想让结果类型是<code>r</code>所指的类型，可以把<code>r</code>作为表达式的一部分，如<code>r+0</code>，显然这个表达式的结果将是一个具体值而非一个引用。</p><p>如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，<code>decltype(*p)</code>的结果类型就是<code>int&amp;</code>，而非<code>int</code>。</p><p>如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式,所以这样的<code>decltype</code>就会得到引用类型：</p><pre><code>// decltype of a parenthesized variable is always a referencedecltype((i)) d;    // error: d是int&amp;，必须初始化decltype(i) e;      // ok: e是一个（未被初始化的）int</code></pre><blockquote><p><code>decltype((variable))</code>（注意是双层括号）的结果永远是引用，而<code>decltype(variable)</code>结果只有当<code>variable</code>本身就是一个引用时才是引用。</p></blockquote><blockquote><p><code>auto</code>和<code>decltype</code>的区别主要有三个方面：</p><ol><li><p><code>auto</code>类型说明符用编译器计算变量的初始值来推断其类型，而<code>decltype</code>虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。</p></li><li><p>编译器推断出来的<code>auto</code>类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，<code>auto</code>一般会忽略掉顶层<code>const</code>，而把底层<code>const</code>保留下来。与之相反，<code>decltype</code>会保留变量的顶层<code>const</code>。</p></li><li><p>与<code>auto</code>不同，<code>decltype</code>的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类型别名 </tag>
            
            <tag> typedef </tag>
            
            <tag> using </tag>
            
            <tag> auto </tag>
            
            <tag> decltype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const限定符</title>
      <link href="/2022/03/01/11-const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
      <url>/2022/03/01/11-const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>用关键字<code>const</code>对变量的类型加以限定，使得变量成为常量：</p><pre><code>const int bufSize = 512;</code></pre><p><code>const</code>对象一旦创建后其值就不能再改变，所以，<code>const</code>对象必须初始化。初始值可以是任意复杂的表达式。</p><h2 id="初始化和const">初始化和const</h2><p>对于<code>const</code>类型的对象，只能执行不改变其内容的操作。</p><blockquote><p>可以利用<code>const</code>对象去初始化指针，因为const对象是常量，而不是变量。</p></blockquote><h2 id="默认状态下，const对象仅在文件内有效">默认状态下，const对象仅在文件内有效</h2><p>默认情况下，<code>const</code>对象被设定为仅在文件内有效。</p><p>某些时候，我们希望只在一个文件中定义<code>const</code>，而在其他多个文件中声明并使用它。解决的办法是，对于<code>const</code>变量不管是声明还是定义都添加<code>extern</code>关键字，这样只需定义一次就可以了。</p><blockquote><p>任何包含了显式初始化的声明，就成为了定义。</p></blockquote><p><strong>如果想在多个文件之间共享<code>const</code>对象，必须在变量的定义之前添加<code>extern</code>关键字。</strong></p><h1>const的引用</h1><p>对常量的引用（reference to const）: 把引用绑定到const对象上。</p><p>对常量的引用不能被用于修改它所绑定的对象。</p><blockquote><p>即，不能够通过该引用修改对象的值，但可以通过其他途径修改该对象的值</p></blockquote><pre><code>const int ci = 1024;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量。不存在通过引用r1修改ci的风险，故而语法正确r1 = 42;int &amp;r2 = ci;       //错误：试图让一个非常量引用指向一个常量对象。存在通过r2修改ci的风险，故而语法错误</code></pre><blockquote><p>术语：常量引用是对const的引用</p></blockquote><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:</p><pre><code>int i = 42;const int &amp;r1 = i;      //允许将const int &amp;绑定到一个普通int对象上。仅仅是说，不能通过r1修改i的值const int &amp;r2 = 42;     //正确：r2是一个对const的引用。不存在通过r2修改42的风险const int &amp;r3 = r1 * 2; //正确：r3是一个对const的引用。不存在通过r3修改r1 * 2的风险int &amp;r4 = r1 * 2;       //错误：r4是一个普通的非常量引用。存在通过r4修改r1 * 2的风险</code></pre><h2 id="对const的引用可能引用一个并非const的对象">对const的引用可能引用一个并非const的对象</h2><blockquote><p>常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。</p></blockquote><pre><code>int i = 42;int &amp;r1 = i;        //引用r1绑定对象iconst int &amp;r2 = i;  //常量引用r2绑定对象i，不允许通过r2修改i的值r1 = 0;             //r1并非常量，i的值修改为0r2 = 0;             //错误：r2是常量引用，不允许通过r2修改i的值</code></pre><h1>指针和const</h1><h2 id="指向常量的指针">指向常量的指针</h2><p>指向常量的指针（pointer toconst）：不能用于改变其所指对象的值。</p><p>要想存放常量对象的地址，只能使用指向常量的指针：</p><pre><code>const double pi = 3.14;     //pi是一个常量double *ptr = &amp;pi;          //错误：ptr是一个普通指针。存在通过解引用*ptr修改pi的值的风险，故语法错误const double *cptr = &amp;pi;   //正确: cptr是一个指向常量的指针。不存在通过*cptr修改pi的值的风险，故语法正确*cptr = 42;                 //错误：cptr是指向常量的指针，不能给*cptr赋值。</code></pre><p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p><pre><code>double dval = 3.14;     //dval是一个双精度浮点数，它的值可以改变cptr = &amp;dval;           //正确，但是不能通过cptr修改dval的值</code></pre><p>和常量引用一样，<strong>指向常量的指针也没有规定其所指的对象必须是一个常量。指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</strong></p><blockquote><p>试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</p></blockquote><h2 id="const指针（常量指针）">const指针（常量指针）</h2><p>指针是对象，允许把指针本身定为常量。</p><p>常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。</p><p>把<code>*</code>放在<code>const</code>关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：</p><pre><code>int errNum = 0;int *const curErr = &amp;errNum;    //curErr将一直指向errNumconst double pi = 3.14;const double *const pip = &amp;pi;  //pi是一个指向常量的常量指针</code></pre><p>要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离<code>curErr</code>最近的符号是<code>const</code>，意味着<code>curErr</code>本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是<code>*</code>，意思是<code>curErr</code>是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个<code>int</code>对象。与之相似，我们也能推断出，<code>pip</code>是一个常量指针，它指向的对象是一个双精度浮点型常量。</p><p><strong>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。</strong></p><blockquote><p>例如，<code>pip</code>是一个指向常量的常量指针，则不论是<code>pip</code>所指的对象值还是<code>pip</code>自己存储的那个地址都不能改变。相反的，<code>curErr</code>指向的是一个一般的非常量整数，那么就完全可以用<code>curErr</code>去修改<code>errNum</code>的值</p></blockquote><h1>顶层const</h1><p>指针本身是不是常量，以及指针所指的对象是不是一个常量，是两个相互独立的问题。</p><p>顶层const（top-levelconst）表示指针本身是个常量。</p><blockquote><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。</p></blockquote><p>底层const（low-level const）表示指针所指的对象是一个常量。</p><p>比较特殊的是，指针类型既可以是顶层const也可以是底层const。</p><pre><code>int i = 0;int *const pi = &amp;i;         //顶层constconst int ci = 42;          //顶层constconst int *p2 = &amp;ci;        //底层constconst int *const p3 = p2;   //底层const，顶层constconst int &amp;r = ci;          //底层const</code></pre><p>当执行对象的拷贝操作时，顶层const不受什么影响（执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响）。</p><pre><code>i = ci;     //正确：拷贝对象ci的值，顶层const对此操作无影响p2 = p3;    //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</code></pre><p>当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</p><pre><code>int *p = p3;        //错误：p3包含底层const的定义，而p没有。存在通过p修改p3所指对象的值的风险，故语法错误p2 = p3;            //正确：p2和p3都是底层const。不存在通过p2修改p3所指对象的值的风险，故语法正确p2 = &amp;i;            //正确：int *能转换成const int *。p2是一个指向常量的指针int &amp;r = ci;        //错误：普通的int &amp;不能绑定int常量。存在通过引用r修改常量ci值的风险，故语法错误const int &amp;r2 = i;  //正确：const int &amp;可以跟一个普通int对象绑定。r2是一个指向常量的指针</code></pre><h1>constexpr和常量表达式</h1><p>常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。</p><blockquote><p><strong>字面值</strong>属于常量表达式，<strong>用常量表达式初始化的<code>const</code>对象</strong>也是常量表达式。</p></blockquote><p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如:</p><pre><code>const int max_files = 20;           //是常量表达式const int limit = max_files + 1;    //是常量表达式int staff_size = 27;                //不是常量表达式（值会改变）const int sz = get_size();          //不是常量表达式（无法在编译过程得到计算结果）</code></pre><h2 id="constexpr变量">constexpr变量</h2><p>C++11新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。声明为<code>constexpr</code>的变量一定是一个常量，而且必须用常量表达式初始化：</p><pre><code>constexpr int mf = 20;          //20是常量表达式constexpr int limit = mf + 1;   //mf+1是常量表达式constexpr int sz = size();      //只有当size是一个constexpr函数时才是一条正确的声明语句</code></pre><p>尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。</p><blockquote><p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p></blockquote><h2 id="字面值类型">字面值类型</h2><p>字面值类型（literal type）</p><p>算术类型、引用和指针都属于字面值类型。</p><p>自定义类<code>Sales_item</code>、<code>IO</code>库、<code>string</code>类型则不属于字面值类型，也就不能被定义成<code>constexpr</code>。</p><p>尽管指针和引用都能定义成<code>constexpr</code>，但它们的初始值却受到严格限制。一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者<code>0</code>，或者是存储于某个固定地址中的对象。</p><blockquote><p>函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。此外，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。</p></blockquote><h2 id="指针和constexpr">指针和constexpr</h2><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</p><blockquote><p>相当于一个常量指针，表示指针本身是常量，无法指向别的对象。</p></blockquote><pre><code>const int *p = nullptr;         //指向常量的指针int const *q1 = nullptr;        //常量指针constexpr int *q2 = nullptr;    //常量指针</code></pre><p>关键在于，<code>constexpr</code>把它所定义的对象置为了顶层const。</p><p>与其他常量指针类似，<code>constexpr</code>指针既可以指向常量也可以指向一个非常量。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> const </tag>
            
            <tag> constexpr </tag>
            
            <tag> 常量表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合类型</title>
      <link href="/2022/02/28/10-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/02/28/10-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>复合类型（compound type）是指基于其他类型定义的类型。例如：引用和指针。</p><p>一条声明语句由一个**基本数据类型（base type）<strong>和紧随其后的一个</strong>声明符（declarator）**列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p><h1>引用</h1><blockquote><p>“引用（reference）”指的其实是“左值引用（lvalue reference）”。</p></blockquote><p>引用（reference）为对象起了另外一个名字。</p><p>通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<code>d</code>是声明的变量名。如下所示，<code>refVal</code>是<code>ival</code>的一个引用。</p><pre><code>int ival = 1024;int &amp;refVal = ival; //refVal指向ival（是ival的另一个名字）int &amp;refVal2;       //报错：引用必须被初始化</code></pre><p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，<strong>引用将和它的初始值对象一直绑定在一起</strong>。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p><h2 id="引用即别名">引用即别名</h2><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p></blockquote><p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：</p><blockquote><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值</p></blockquote><pre><code>&gt; refVal = 2;               //把2赋给refVal指向的对象，即，赋给ival&gt; int ii = refVal;          //与ii = ival执行结果一样&gt; int &amp;refVal3 = refVal;    //正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上&gt; int i = refVal;           //正确：i被初始化为ival的值</code></pre><p><strong>引用本身不是一个对象，所以不能定义引用的引用。</strong></p><h2 id="引用的定义">引用的定义</h2><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：</p><pre><code>int i =1024, i2 = 2048; //i和i2都是intint &amp;r = i, r2 = i2;    //r是i的引用，r2是int型对象int i3 = 1024, &amp;ri = i3;//i3是int型对象，ri是i3的引用int &amp;r3 = i3, &amp;r4 = i2; //r3和r4都是引用</code></pre><p>除了两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起：</p><pre><code>int &amp;refVal4 = 10;      //错误：引用类型的初始值必须是一个对象，而不能是字面值double dval = 3.14;int &amp;refVal5 = dval;    //错误：此处引用类型的初始值必须是int型对象</code></pre><h1>指针</h1><p>指针（pointer）是“指向（point to）”另外一种类型的复合类型。</p><p>与引用类似，指针也实现了对其他对象的间接访问。</p><blockquote><p>指针与引用相比又有很多不同点:</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li><li>指针无须在定义时赋初值。</li></ol></blockquote><p>和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p><p>定义指针类型的方法将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号<code>*</code>：</p><pre><code>int *ip1, *ip2; //ip1和ip2都是指向int型对象的指针double dp, *dp2;//dp2是指向double型对象的指针，dp是double型对象</code></pre><h2 id="获取对象的地址">获取对象的地址</h2><p>指针存放某个对象的地址。要获取某对象的地址，则使用<strong>取地址符（操作符<code>&amp;</code>）</strong>：</p><pre><code>int ival = 42;int *p = &amp;ival; //p存放变量ival的地址，或者说，p是指向变量ival的指针。（把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。）</code></pre><blockquote><p>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p></blockquote><p>除了2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配：</p><pre><code>double dval;double *pd = &amp;dval;     //正确：初始值是double型对象的地址double *pd2 = pd;       //正确：初始值是double对象的指针int *pi = pd;           //错误：指针pi的类型和pd的类型不匹配pi = &amp;dval;             //错误：试图把double型对象的地址赋给int型指针</code></pre><p><strong>声明语句中指针的类型实际上用于确定指针所指向对象的类型</strong>，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</p><h2 id="指针值">指针值</h2><p>指针的值（即地址）应属下列4种状态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>试图拷贝或以其他方式访问无效指针的值都将引发错误。访问无效指针的后果无法预计。</p><p>尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p><h2 id="利用指针访问对象">利用指针访问对象</h2><p>如果指针指向了一个对象，则允许使用<strong>解引用符（操作符*）</strong>，来访问该对象：</p><pre><code>int ival = 42;int *p = &amp;ival; //p是指向变量ival的指针cout &lt;&lt; *p;     //解引用，访问指针所指对象，输出42</code></pre><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：</p><pre><code>*p = 0;     //经由指针p为p所指对象（即，ival）赋值cout &lt;&lt; *p; //输出0</code></pre><p><strong>解引用操作仅适用于那些确实指向了某个对象的有效指针。</strong></p><h2 id="空指针">空指针</h2><p>空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p><pre><code>int *p1 = nullptr;int *p2 = 0;int *p3 = NULL;     //需要首先#include cstdlib</code></pre><p>得到空指针最直接的办法就是用字面值<code>nullptr</code>来初始化指针，<code>nullptr</code>是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。现在的C++程序最好使用<code>nullptr</code>，同时尽量避免使用<code>NULL</code>。</p><p><strong>把<code>int</code>变量直接赋给指针是错误的操作，即使<code>int</code>变量的值恰好等于0也不行。</strong></p><pre><code>int zero = 0;pi = zero;      //错误：不能把int变量直接赋给指针</code></pre><blockquote><p>尽管C++语法上规定“指针无须在定义时初始化”，但使用未经初始化的指针是引发运行时错误的一大原因，且访问未经初始化的指针所引发的后果也是无法预计的。<br>因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。</p></blockquote><h2 id="赋值和指针">赋值和指针</h2><p>指针和引用都能提供对其他对象的间接访问。</p><blockquote><p>引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。<br>指针可以指向新的对象：给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。</p></blockquote><p>赋值永远改变的是等号左侧的对象：</p><pre><code>pi = &amp;ival; //pi的值被改变，现在pi指向了ival*pi = 0;    //ival的值被改变，指针pi并没有改变</code></pre><h2 id="其他指针操作">其他指针操作</h2><p>如果指针的值是0，条件取<code>false</code>。任何非0指针对应的条件值都是<code>true</code>。</p><p>对于两个类型相同的合法指针，可以用相等操作符（<code>==</code>）或不相等操作符（<code>!=</code>）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。</p><blockquote><p>两个指针存放的地址值相同（两个指针相等）有三种可能：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</p></blockquote><h2 id="void-指针">void * 指针</h2><p><code>void *</code>是一种特殊的指针类型，可用于存放任意对象的地址。然而，我们对该地址中到底是个什么类型的对象并不了解：</p><pre><code>double obj = 3.14, *pd = &amp;obj;void *pv = &amp;obj;    //正确：void *能存放任意类型对象的地址pv = pd;            //正确</code></pre><p><code>void *</code>指针的功用：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个<code>void *</code>指针。</p><p>不能直接操作<code>void *</code>指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p><blockquote><p>练习2.23：给定指针<code>p</code>，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，说明原因。</p><p>【出题思路】本题旨在考查指针初始化，读者应该熟悉并掌握C++11的新语法特征<code>nullptr</code>。</p><p>【解答】在C++程序中，应该尽量初始化所有指针，并且尽可能等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为<code>nullptr</code>或者<code>0</code>，这样程序就能检测并知道它有没有指向一个具体的对象了。其中，<code>nullptr</code>是C++11新标准刚刚引入的一个特殊字面值，它可以转换成任意其他的指针类型。在此前提下，判断<code>p</code>是否指向合法的对象，只需把<code>p</code>作为<code>if</code>语句的条件即可，如果<code>p</code>的值是<code>nullptr</code>，则条件为假；反之，条件为真。如果不注意初始化所有指针而贸然判断指针的值，则有可能引发不可预知的结果。一种处理的办法是把<code>if(p)</code>置于<code>try</code>结构中，当程序块顺利执行时，表示<code>p</code>指向了合法的对象；当程序块出错跳转到<code>catch</code>语句时，表示<code>p</code>没有指向合法的对象。</p></blockquote><h1>理解复合类型的声明</h1><p>变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。即，一条定义语句可能定义出不同类型的变量：</p><pre><code>int i = 1024, *p = &amp;i, &amp;r = i;  //i是一个int型对象，p是一个指向int型对象的指针，r是一个int对象的引用</code></pre><p>其中，<code>int</code>是基本数据类型，<code>*</code>和<code>&amp;</code>是类型修饰符，后者是声明符的一部分。</p><h2 id="定义多个变量">定义多个变量</h2><p>在定义语句种，类型修饰符（<code>*</code>和<code>&amp;</code>）仅作用于紧随其后的单个变量，而不是作用于本次定义的全部便了。</p><p>涉及指针或引用的声明，一般有两种写法:</p><ol><li><p>第一种把修饰符和变量标识符写在一起：</p><pre><code> int *p1, *p2;   //p1和p2都是指向int型对象的指针</code></pre></li></ol><p>这种形式着重强调变量具有的复合类型。</p><ol><li><p>第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量：</p><pre><code> int* p1;    //p1是指向int型对象的指针 int* p2;    //p2是指向int型对象的指针</code></pre></li></ol><p>这种形式着重强调本次声明定义了一种复合类型。</p><p>上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其中的一种写法，不要总是变来变去。</p><p>推荐采用第一种写法，将＊（或是&amp;）与变量名连在一起。</p><h2 id="指向指针的指针">指向指针的指针</h2><p>指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。</p><p>通过<code>*</code>的个数可以区分指针的级别。也就是说，<code>**</code>表示指向指针的指针，<code>***</code>表示指向指针的指针的指针，以此类推：</p><pre><code>int ival = 1024;int *pi = &amp;ival;    //pi指向一个int型的数int **ppi = &amp;pi;    //ppi指向一个int型的指针</code></pre><p>下图描述了它们之间的关系:</p><img src="/2022/02/28/10-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/1.png" class=""><p>解引用<code>int</code>型指针会得到一个<code>int</code>型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用:</p><pre><code>cout &lt;&lt; ival;   //direct valuecout &lt;&lt; *pi;    //indirect valuecout &lt;&lt; **ppi;  //doubly indirect value</code></pre><h2 id="指向指针的引用">指向指针的引用</h2><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：</p><pre><code>int i = 42;int *p;         //p是一个指向int型对象的指针int *&amp;r = p;    //r是一个对指针p的引用，即，r是p的别名r = &amp;i;         //给r赋值一个地址，即，令p指向i*r = 0;         //解引用r得到int型对象i（也就是P指向的对象），给i赋值0</code></pre><p>要理解<code>r</code>的类型到底是什么，最简单的办法是从右向左阅读<code>r</code>的定义。离变量名最近的符号（此例中是<code>&amp;r</code>的符号<code>&amp;</code>）对变量的类型有最直接的影响，因此<code>r</code>是一个引用。声明符的其余部分用以确定<code>r</code>引用的类型是什么，此例中的符号<code>*</code>说明<code>r</code>引用的是一个指针。最后，声明的基本数据类型部分指出<code>r</code>引用的是一个<code>int</code>指针。</p><p><strong>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量</title>
      <link href="/2022/02/28/9-%E5%8F%98%E9%87%8F/"/>
      <url>/2022/02/28/9-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。</p><p>对C++程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</p><h1>变量定义</h1><p>变量定义的基本形式是：首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。</p><blockquote><p>列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。</p></blockquote><h2 id="初始值">初始值</h2><p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialized）了。</p><p>在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。</p><p><strong>初始化不是赋值</strong>，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p><h2 id="列表初始化">列表初始化</h2><p>用花括号来初始化变量: 用花括号来初始化变量</p><blockquote><p>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错</p></blockquote><h2 id="默认初始化">默认初始化</h2><p>如果定义变量时没有指定初值，则变量被默认初始化（default initialized）。</p><p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。</p><blockquote><p>定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p></blockquote><p>每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。</p><blockquote><p>绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。例如，<code>string</code>类规定如果没有指定初值则生成一个空串。一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。</p></blockquote><p><strong>未初始化的变量含有一个不确定的值，使用未初始化的变量将带来无法预计的后果。</strong></p><h1>变量声明和定义的关系</h1><p>C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。</p><blockquote><p>前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。</p></blockquote><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separatecompilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p><blockquote><p>如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。</p></blockquote><p>声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。</p><blockquote><p>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</p></blockquote><p>如果想声明一个变量而非定义它，就在变量名前添加关键字<code>extern</code>，而且不要显式地初始化变量。</p><p>任何包含了显式初始化的声明即成为定义: <code>extern</code>语句如果包含初始值就不再是声明，而变成定义了。</p><p>在函数体内部，如果试图初始化一个由<code>extern</code>关键字标记的变量，将引发错误。</p><blockquote><p>包含有<code>extern</code>标记的定义，例如，<code>extern double pi=3.14;</code>，不能放在函数体内部</p></blockquote><blockquote><p>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p></blockquote><p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong></p><h1>标识符</h1><p>C++的标识符（identifier）由字母、数字和下画线组成，其中<strong>必须以字母或下画线开头</strong>。标识符的长度没有限制，但是<strong>对大小写字母敏感</strong>。</p><p><strong>C++关键字和C++操作符替代名不能被用作标识符</strong>。</p><img src="/2022/02/28/9-%E5%8F%98%E9%87%8F/1.png" class="" title="关键字与操作符替代名"><p>用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p><blockquote><p>变量命名规范变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性：</p><ol><li>标识符要能体现实际含义。</li><li>变量名一般用小写字母，如<code>index</code>，不要使用<code>Index</code>或<code>INDEX</code>。</li><li>用户自定义的类名一般以大写字母开头，如<code>Sales_item</code>。</li><li>如果标识符由多个单词组成，则单词间应有明显区分，如下划线命名法<code>student_loan</code>或驼峰命名法<code>studentLoan</code>，不要使用<code>studentloan</code>。</li></ol></blockquote><h1>名字的作用域</h1><p>同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。</p><p>作用域（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。</p><blockquote><p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p></blockquote><p>全局作用域（global scope）、块作用域（block scope）。</p><p>内层作用域（innerscope）、外层作用域（outer scope）。</p><blockquote><p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。</p></blockquote><p>一般来说，在对象第一次被使用的地方附近定义它是一种好的选择。</p><p><strong>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量</strong>。(语法上允许，但实际编程使用时容易出错。)</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量定义 </tag>
            
            <tag> 变量声明 </tag>
            
            <tag> 标识符 </tag>
            
            <tag> 名字作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本内置类型</title>
      <link href="/2022/01/01/8-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/01/01/8-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中，算术类型包含了字符、整数型、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p><h1>算术类型</h1><p>算术类型分为两类：整型（integral，包括字符和布尔类型在内）和浮点型。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th><th style="text-align:center">最小尺寸</th></tr></thead><tbody><tr><td style="text-align:center"><code>bool</code></td><td style="text-align:center">布尔类型</td><td style="text-align:center">未定义</td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center">字符</td><td style="text-align:center">8位</td></tr><tr><td style="text-align:center"><code>wchar_t</code></td><td style="text-align:center">宽字符</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>char16_t</code></td><td style="text-align:center">Unicode字符</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>char32_t</code></td><td style="text-align:center">Unicode字符</td><td style="text-align:center">32位</td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center">短整型</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center">整型</td><td style="text-align:center">16位</td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">32位</td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">64位</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">单精度浮点数</td><td style="text-align:center">6位有效数字</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center">双精度浮点数</td><td style="text-align:center">10位有效数字</td></tr><tr><td style="text-align:center"><code>long double</code></td><td style="text-align:center">拓展精度浮点数</td><td style="text-align:center">10位有效数字</td></tr></tbody></table><p>上述表格列出了C++标准规定的算术类型的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。</p><h2 id="整型与浮点型">整型与浮点型</h2><p>布尔类型（bool）的取值是真（True）或者假（False）。</p><p>基本的字符类型是<code>char</code>，一个<code>char</code>的空间应确保可以存放机器基本字符集（如ASCII表）中任意字符对应的数字值，即，一个<code>char</code>的大小和一个机器字节一样。</p><p><code>wchar_t</code>类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型<code>char16_t</code>和<code>char32_t</code>则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。</p><blockquote><p>Unicode为每种语言中的每个字符设定了统一并且唯一的二进制编码，现在用的是UCS-2，即，2个字节编码。UTF-8，UTF-16，UTF-32均为字符编码方案。</p></blockquote><p>大多数机器的字节（byte）由8比特（bit）构成，字（word）则由32或64比特构成，也就是4或8字节。</p><p>浮点型可表示单精度、双精度和扩展精度值。通常，<code>float</code>以1个字（32比特）来表示，<code>double</code>以2个字（64比特）来表示，<code>long double</code>以3或4个字（96或128比特）来表示。一般来说，类型<code>float</code>和<code>double</code>分别有7和16个有效位。</p><blockquote><p>浮点数在机器内用指数形式表示，分解为：数符，尾数，指数符，指数。</p></blockquote><h2 id="带符号类型和无符号类型">带符号类型和无符号类型</h2><p>除布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。</p><p>带符号类型可以表示正数、负数或0；无符号类型仅能表示大于等于0的值。</p><p>带符号类型：<code>int</code>、<code>short</code>、<code>long</code>、<code>long long</code>；在这些类型名前添加<code>unsigned</code>就可以得到对应的无符号类型，即，无符号类型：<code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code>、<code>unsigned long long</code>。</p><p>类型<code>unsigned int</code>可以缩写为<code>unsigned</code>。</p><p>字符型分为三种：<code>char</code>、<code>signed char</code>、<code>unsigned char</code>。其中，<code>signed char</code>类型和<code>unsigned char</code>类型分别为带符号类型和无符号类型，<code>char</code>类型实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p><p>无符号类型中所有比特都用来存储值。</p><p>C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。</p><blockquote><p><code>8</code>比特的<code>signed char</code>理论上应该可以表示<code>-127</code>至<code>127</code>区间内的值，大多数现代计算机将<code>8</code>比特的<code>signed char</code>实际的表示范围定为 <code>-128~127</code>。</p></blockquote><h2 id="建议：如何选择类型">建议：如何选择类型</h2><p>当明确知晓数值不可能为负时，选用无符号类型。</p><p>使用<code>int</code>执行整数运算。若数值超出<code>int</code>的表示范围，选用<code>long long</code>。</p><p>在算术表达式中不要使用<code>char</code>或<code>bool</code>，只有在存放字符或布尔值时才使用它们。</p><blockquote><p>因为类型<code>char</code>在一些机器上是有符号的，而在另一些机器上又是无符号的，所以使用<code>char</code>进行运算特别容易出问题。如果需要使用一个不大的整数，则应该明确指定类型是<code>signed char</code>或者<code>unsigned char</code>。</p></blockquote><p>执行浮点数运算选用<code>double</code>。</p><blockquote><p>这是因为<code>float</code>通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。<code>long double</code>提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。</p></blockquote><h1>类型转换</h1><p>类型转换是指，将对象从一种给定的类型转换（convert）为另一种相关类型。</p><h2 id="转换规则（简介）">转换规则（简介）</h2><p>类型所能表示的值的范围决定了转换的过程：</p><ol><li><p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为<code>0</code>则结果为<code>false</code>，否则结果为<code>true</code>。</p></li><li><p>当我们把一个布尔值赋给非布尔类型时，初始值为<code>false</code>则结果为<code>0</code>，初始值为<code>true</code>则结果为<code>1</code>。</p></li><li><p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p></li><li><p>当我们把一个整数值赋给浮点类型时，小数部分记为<code>0</code>。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p></li><li><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，<code>8</code>比特大小的<code>unsigned char</code>可以表示<code>0</code>至<code>255</code>区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对<code>256</code>取模后所得的余数。因此，把<code>-1</code>赋给<code>8</code>比特大小的<code>unsigned char</code>所得的结果是<code>255</code>。</p></li><li><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p></li></ol><h2 id="含有无符号类型的表达式">含有无符号类型的表达式</h2><p>当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。</p><blockquote><p>如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如<code>a*b</code>的式子中，如果<code>a = -1</code>，<code>b = 1</code>，而且<code>a</code>和<code>b</code>都是<code>int</code>，则表达式的值显然为<code>-1</code>。然而，如果<code>a</code>是<code>int</code>，而<code>b</code>是<code>unsigned</code>，则结果须视在当前机器上<code>int</code>所占位数而定。在我们的环境里，结果是<code>4294967295</code>。</p></blockquote><p>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值。</p><p>无符号数不会小于0这一事实同样关系到循环的写法。</p><pre><code>// 以降序的形式逐个输出数字10到0for (int i = 10; i &gt;= 0; --i)    std::cout &lt;&lt; i &lt;&lt;std::endl;// 错误：变量u永远也不会小于0，循环条件一直成立for (unsigned u = 10, u &gt;= 0; --u)    std::cout &lt;&lt; u &lt;&lt;std::endl;</code></pre><blockquote><p>当<code>u</code>等于<code>0</code>时这次迭代输出<code>0</code>，然后继续执行<code>for</code>语句里的表达式。表达式<code>--u</code>从<code>u</code>当中减去<code>1</code>，得到的结果<code>-1</code>并不满足无符号数的要求，此时<code>-1</code>被自动地转换成一个合法的无符号数。假设<code>int</code>类型占<code>32</code>位，则当<code>u</code>等于<code>0</code>时，<code>--u</code>的结果将会是<code>4294967295</code>。</p></blockquote><h1>字面值常量</h1><p>字面值常量（literal）：形如42的值，一望而知。</p><p>每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p><h2 id="整型和浮点型字面值">整型和浮点型字面值</h2><p>可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。</p><pre><code>20 //十进制024 //八进制0x14 //十六进制</code></pre><p>整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。</p><blockquote><p>十进制字面值的类型是<code>int</code>、<code>long</code>和<code>long long</code>中尺寸最小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>和<code>unsigned long long</code>（即，带符号的和无符号的<code>int</code>、<code>long</code>、<code>long long</code>）中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型<code>short</code>没有对应的字面值。</p></blockquote><blockquote><p>尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</p></blockquote><p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识:</p><pre><code>3.141593.14159E00.0e0.001</code></pre><p>默认的，浮点型字面值是一个<code>double</code>。</p><h2 id="字符和字符串字面值">字符和字符串字面值</h2><p>由单引号括起来的一个字符称为<code>char</code>型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。</p><pre><code>'a' // 字符字面值&quot;Hello World!&quot; // 字符串字面值</code></pre><p>字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（′\0′），因此，字符串字面值的实际长度要比它的内容多1。</p><blockquote><p>例如，字面值’A’表示的就是单独的字符A，而字符串&quot;A&quot;则代表了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。</p></blockquote><p>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。</p><pre><code>// 当书写的字符串字面值比较长，写在一行里不太合适时，分多行书写字符串字面值std::cout &lt;&lt; &quot;a really, really long string literal &quot;        &lt;&lt; &quot;that spans two lines&quot; &lt;&lt; std::endl;</code></pre><h2 id="转义序列">转义序列</h2><p>有两类字符程序员不能直接使用：一类是不可打印（nonprintable）的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。 这些情况需要用到转义序列（escape sequence）。</p><p>C++语言规定的转义序列包括：</p><blockquote><p>换行符 <code>\n</code><br>纵向制表符 <code>\v</code><br>反斜线 <code>\\</code><br>回车符 <code>\r</code><br>横向制表符 <code>\t</code><br>退格符 <code>\b</code><br>问号 <code>\?</code><br>进纸符 <code>\f</code><br>报警（响铃）符 <code>\a</code><br>双引号 <code>\&quot;</code><br>单引号 <code>\'</code></p></blockquote><p>在程序中，上述转义序列被当作一个字符使用。</p><pre><code>std::cout &lt;&lt; '\n';          // 转到新一行std::cout &lt;&lt; &quot;\tHi!\n&quot;;     // 输出一个制表符，输出&quot;Hi!&quot;，转到新一行</code></pre><p>我们也可以使用泛化的转义序列，其形式是<code>\x</code>后紧跟1个或多个十六进制数字，或者<code>\</code>后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。</p><blockquote><p>假设使用的是Latin-1字符集，以下是一些示例：（对应ASCII表）<br><code>\7</code> 响铃<br><code>\12</code> 换行符<br><code>\40</code> 空格<br><code>\0</code> 空字符<br><code>\115</code> 字符M<br><code>\x4d</code> 字符M</p></blockquote><pre><code>std::cout &lt;&lt; &quot;Hi! \x4dO\115!\n&quot;;    // 输出&quot;Hi MOM!&quot;，转到新一行std::cout &lt;&lt; '\115' &lt;&lt; '\n';        // 输出&quot;M&quot;，转到新一行</code></pre><blockquote><p>注意，如果反斜线<code>\</code>后面跟着的八进制数字超过3个，只有前3个数字与<code>\</code>构成转义序列。例如，<code>&quot;\1234&quot;</code>表示2个字符，即八进制数123对应的字符以及字符4。相反，<code>\x</code>要用到后面跟着的所有数字，例如，<code>&quot;\x1234&quot;</code>表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的<code>char</code>型数据占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。</p></blockquote><h2 id="指定字面值的类型">指定字面值的类型</h2><p>通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p><p>字符和字符串字面值：</p><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">含义</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">Unicode 16 字符</td><td style="text-align:center">char16_t</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">Unicode 32 字符</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">宽字符</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center">u8</td><td style="text-align:center">UTF-8 （仅用于字符串字面值常量）</td><td style="text-align:center">char</td></tr></tbody></table><p>整型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">u 或 U</td><td style="text-align:center">unsigned</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">ll 或 LL</td><td style="text-align:center">long long</td></tr></tbody></table><p>浮点型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">f 或 F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long double</td></tr></tbody></table><blockquote><p>当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了。</p></blockquote><pre><code>L'a'        // 宽字符型字面值，类型是 wchar_tu8&quot;hi!&quot;     // UTF-8 字符串字面值，类型是 char42ULL       // 无符号整型字面值，类型是 unsigned long long1E-3F       // 单精度浮点型字面值，类型是 float3.14159L    // 扩展精度浮点型字面值，类型是 long double</code></pre><p>对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。</p><blockquote><p>如果后缀中有<code>U</code>，则该字面值属于无符号类型，也就是说，以<code>U</code>为后缀的十进制数、八进制数或十六进制数都将从<code>unsigned int</code>、<code>unsigned long</code>和<code>unsigned long long</code>中选择能匹配的空间最小的一个作为其数据类型。如果后缀中有<code>L</code>，则字面值的类型至少是<code>long</code>；如果后缀中有<code>LL</code>，则字面值的类型将是<code>long long</code>和<code>unsigned long long</code>中的一种。显然我们可以将<code>U</code>与<code>L</code>或<code>LL</code>合在一起使用。例如，以<code>UL</code>为后缀的字面值的数据类型将根据具体数值情况或者取<code>unsigned long</code>，或者取<code>unsigned long long</code>。</p></blockquote><h2 id="布尔字面值和指针字面值">布尔字面值和指针字面值</h2><p><code>true</code>和<code>false</code>是布尔类型的字面值。</p><p><code>nullptr</code>是指针字面值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算术类型 </tag>
            
            <tag> 类型转换 </tag>
            
            <tag> 字面值常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>术语表-Chapter1</title>
      <link href="/2022/01/01/7-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter1/"/>
      <url>/2022/01/01/7-%E6%9C%AF%E8%AF%AD%E8%A1%A8-Chapter1/</url>
      
        <content type="html"><![CDATA[<p><code>参数（实参，argument）</code>：向函数传递的值。</p><p><code>赋值（assignment）</code>：抹去一个对象的当前值，用一个新值取代之。</p><p><code>程序块（block）</code>：零条或多条语句的序列，用花括号包围。</p><p><code>缓冲区（buffer）</code>：一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。我们可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout；程序非正常终止时也会刷新cout。</p><p><code>内置类型（built-in type）</code>：由语言定义的类型，如int。</p><p><code>Cerr</code>：一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到cerr的数据是不缓冲的。cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容。</p><p><code>字符串字面值常量（character string literal）</code>：术语stringliteral的另一种叫法。</p><p><code>cin</code>：一个istream对象，用来从标准输入读取数据。</p><p><code>类（class）</code>：一种用于定义自己的数据结构及其相关操作的机制。类是C++中最基本的特性之一。标准库类型中，如istream和ostream都是类。</p><p><code>类类型（class type）</code>：类定义的类型。类名即为类型名。</p><p><code>clog</code>：一个ostream对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。clog通常用于报告程序的执行信息，存入一个日志文件中。</p><p><code>注释（comment）</code>：被编译器忽略的程序文本。C++有两种类型的注释：单行注释和界定符对注释。单行注释以//开始，从//到行尾的所有内容都是注释。界定符对注释以/＊开始，其后的所有内容都是注释，直至遇到＊/为止。</p><p><code>条件（condition）</code>：求值结果为真或假的表达式。通常用值0表示假，用非零值表示真。</p><p><code>cout</code>：一个ostream对象，用于将数据写入标准输出。通常用于程序的正常输出内容。</p><p><code>花括号（curly brace）</code>：花括号用于划定程序块边界。左花括号（{）为程序块开始，右花括号（}）为结束。</p><p><code>数据结构（data structure）</code>：数据及其上所允许的操作的一种逻辑组合。</p><p><code>编辑-编译-调试（edit-compile-debug）</code>：使程序能正确执行的开发过程。</p><p><code>文件结束符（end-of-file）</code>：系统特定的标识，指出文件中无更多数据了。</p><p><code>表达式（expression）</code>：最小的计算单元。一个表达式包含一个或多个运算对象，通常还包含一个或多个运算符。表达式求值会产生一个结果。例如，假设i和j是int对象，则i+j是一个表达式，它产生两个int值的和。</p><p><code>for语句（for statement）</code>：迭代语句，提供重复执行能力。通常用来将一个计算反复执行指定次数。</p><p><code>函数（function）</code>：具名的计算单元。</p><p><code>函数体（function body）</code>：语句块，定义了函数所执行的动作。</p><p><code>函数名（function name）</code>：函数为人所知的名字，也用来进行函数调用。</p><p><code>头文件（header）</code>：使类或其他名字的定义可被多个程序使用的一种机制。程序通过#include指令使用头文件。</p><p><code>if语句（if statement）</code>：根据一个特定条件的值进行条件执行的语句。如果条件为真，执行if语句体。否则，执行else语句体（如果存在的话）。</p><p><code>初始化（initialize）</code>：在一个对象创建的时候赋予它一个值。</p><p><code>iostream</code>：头文件，提供了面向流的输入输出的标准库类型。</p><p><code>istream</code>：提供了面向流的输入的库类型。</p><p><code>库类型（library type）</code>：标准库定义的类型，如istream。</p><p><code>main</code>：操作系统执行一个C++程序时所调用的函数。每个程序必须有且只有一个命名为main的函数。</p><p><code>操纵符（manipulator）对象</code>，如<code>std::endl</code>，在读写流的时候用来“操纵”流本身。</p><p><code>成员函数（member function）</code>：类定义的操作。通常通过调用成员函数来操作特定对象。</p><p><code>方法（method）</code>：成员函数的同义术语。</p><p><code>命名空间（namespace）</code>：将库定义的名字放在一个单一位置的机制。命名空间可以帮助避免不经意的名字冲突。C++标准库定义的名字在命名空间std中。</p><p><code>ostream</code>：标准库类型，提供面向流的输出。</p><p><code>形参列表（parameter list）</code>：函数定义的一部分，指出调用函数时可以使用什么样的实参，可能为空列表。</p><p><code>返回类型（return type）</code>：函数返回值的类型。</p><p><code>源文件（source file）</code>：包含C++程序的文件。</p><p><code>标准错误（standard error）</code>：输出流，用于报告错误。标准输出和标准错误通常关联到程序执行所在的窗口。</p><p><code>标准输入（standard input）</code>：输入流，通常与程序执行所在窗口相关联。</p><p><code>标准库（standard library）</code>：一个类型和函数的集合，每个C++编译器都必须支持。标准库提供了支持IO操作的类型。C++程序员倾向于用“库”指代整个标准库，还倾向于用库类型表示标准库的特定部分，例如用“iostream库”表示标准库中定义IO类的部分。</p><p><code>标准输出（standard output）</code>：输出流，通常与程序执行所在窗口相关联。</p><p><code>语句（statement）</code>：程序的一部分，指定了当程序执行时进行什么动作。一个表达式接一个分号就是一条语句；其他类型的语句包括语句块、if语句、for语句和while语句，所有这些语句内都包含其他语句。</p><p><code>std</code>：标准库所使用的命名空间。<code>std::cout</code>表示我们要使用定义在命名空间std中的名字cout。</p><p><code>字符串常量（string literal）</code>：零或多个字符组成的序列，用双引号包围（“a string literal”）。</p><p><code>未初始化的变量（uninitialized variable）</code>：未赋予初值的变量。类类型的变量如果未指定初值，则按类定义指定的方式进行初始化。定义在函数内部的内置类型变量默认是不初始化的，除非有显式的初始化语句。试图使用一个未初始化变量的值是错误的。未初始化变量是bug的常见成因。</p><p><code>变量（variable）</code>：具名对象。</p><p><code>while语句（while statement）</code>：迭代语句，提供重复执行直至一个特定条件为假的机制。循环体会执行零次或多次，依赖于循环条件求值结果。</p><p><code>() 运算符（() operator）</code>：调用运算符。跟随在函数名之后的一对括号“()”，起到调用函数的效果。传递给函数的实参放置在括号内。</p><p><code>++ 运算符（++ operator）</code>：递增运算符。将运算对象的值加1，<code>++i</code>等价于<code>i=i+1</code>。</p><p><code>+= 运算符（+= operator）</code>：复合赋值运算符，将右侧运算对象加到左侧运算对象上；<code>a+=b</code>等价于<code>a=a+b</code>。</p><p><code>. 运算符（.operator）</code>：点运算符。左侧运算对象必须是一个类类型对象，右侧运算对象必须是此对象的一个成员的名字。运算结果即为该对象的这个成员。</p><p><code>:: 运算符（:: operator）</code>：作用域运算符。其用处之一是访问命名空间中的名字。例如，<code>std::cout</code>表示命名空间std中的名字cout。</p><p><code>= 运算符（= operator）</code>：将右侧运算对象的值赋予左侧运算对象所表示的对象。</p><p><code>-- 运算符（-- operator）</code>：递减运算符。将运算对象的值减1，<code>--i</code>等价于<code>i=i-1</code>。</p><p><code>&lt;&lt; 运算符（&lt;&lt; operator）</code>：输出运算符。将右侧运算对象的值写到左侧运算对象表示的输出流：<code>cout &lt;&lt;&quot;hi&quot;</code>表示将hi写到标准输出。输出运算符可以连接：<code>cout &lt;&lt;&quot;hi&quot; &lt;&lt;&quot;bye&quot;</code>表示将输出hibye。</p><p><code>&gt;&gt; 运算符（&gt;&gt; operator）</code>：输入运算符。从左侧运算对象所指定的输入流读取数据，存入右侧运算对象中：<code>cin &gt;&gt;i</code>表示从标准输入读取下一个值，存入i中。输入运算符可以连接：<code>cin &gt;&gt;i&gt;&gt;j</code>表示先读取一个值存入i，再读取一个值存入j。</p><p><code>\#include</code>：头文件包含指令，使头文件中代码可被程序使用。</p><p><code>== 运算符（== operator）</code>：相等运算符。检测左侧运算对象是否等于右侧运算对象。</p><p><code>!= 运算符（!= operator）</code>：不等运算符。检测左侧运算对象是否不等于右侧运算对象。</p><p><code>&lt;= 运算符（&lt;= operator）</code>：小于等于运算符。检测左侧运算对象是否小于等于右侧运算对象。</p><p><code>&lt; 运算符（&lt; operator）</code>：小于运算符。检测左侧运算对象是否小于右侧运算对象。</p><p><code>&gt;= 运算符（&gt;= operator）</code>：大于等于运算符。检测左侧运算对象是否大于等于右侧运算对象。</p><p><code>&gt; 运算符（&gt; operator）</code>：大于运算符。检测左侧运算对象是否大于右侧运算对象。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识C++(下)</title>
      <link href="/2021/10/27/6-%E5%88%9D%E8%AF%86cpp-%E4%B8%8B/"/>
      <url>/2021/10/27/6-%E5%88%9D%E8%AF%86cpp-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1>类</h1><p>类(class)：一个类定义了一个类型(class type)，其类型名就是类名，以及与其关联的一组操作。</p><p>如：<code>sales_item</code>类定义了一个名为<code>sales_item</code>的类型</p><p>与内置类型如<code>int</code>一样，我们可以定义类类型的变量，如：<code>sales_item item</code>表示<code>item</code>是一个<code>sales_item</code>类型的对象，通常简单表述为“一个<code>sale-item</code>对象”，或者，“一个<code>sales_item</code>”</p><h1>头文件</h1><p>头文件：通常根据其中定义的类的名字来命名，通常使用<code>.h</code>作为头文件的后缀，但也有些习惯用<code>.H</code>、<code>.hpp</code>或<code>.hxx</code>。标准库头文件通常不带后缀</p><p>头文件的作用：通过使用头文件来使用标准库设施，或者是访问为自己的应用程序所定义的类</p><p>通过<code>#include</code>指令使用头文件时，若是标准库的头文件，则用尖括号<code>&lt;&gt;</code>包围头文件名，如<code>#include &lt;iostream&gt;</code>，若是不属于标准库的头文件，则用双引号<code>&quot;&quot;</code>包围，如<code>#include &quot;sales_item&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 头文件 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识C++(中)</title>
      <link href="/2021/10/27/5-%E5%88%9D%E8%AF%86cpp-%E4%B8%AD/"/>
      <url>/2021/10/27/5-%E5%88%9D%E8%AF%86cpp-%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1>while</h1><p>while 语句的形式是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p><code>while</code>语句持续地交替检测<code>condition</code>和执行<code>statement</code>，直至<code>condition</code>为假为止</p><h1>语句块</h1><p>语句块(block)，是指用花括号<code>&#123;&#125;</code>包围的零条或多条语句的序列</p><p>语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块，如：</p><pre><code>int sum = 0, val = 1;while (val &lt;= 10)    &#123;        sum = sum + val;        // 等价于 sum += val;        val = val + 1;          // 等价于 ++ val;    &#125;</code></pre><h1>for</h1><p><code>for</code>语句包含循环头和循环体，循环头控制循环体的执行次数</p><p>循环头：初始化语句(init-statement)、循环条件(condition)、表达式(expression)，即：<br><code>for (init-statement; condition; expression)</code></p><p><strong>初始化语句只在<code>for</code>循环入口处执行一次。在初始化语句中定义的变量，在循环结束之后是不能使用的</strong></p><p>循环体每次执行前都会先检查循环条件</p><p>表达式在<code>for</code>循环体之后执行（若循环体不被执行，则表达式亦不会被执行）</p><p>执行完表达式后，<code>for</code>语句重新检测循环条件，循环持续至循环条件为假</p><pre><code>int sum = 0;for (int val = 1; val &lt;= 10; ++ val)&#123;    sum += val;&#125;</code></pre><p>例中，初始化语句中定义的变量<code>val</code>在<code>for</code>语句结束后即失效</p><h1>for与while</h1><h2 id="for">for</h2><p>一般用于循环次数已知的情况，并且<code>for</code>循环可以节省内存以及代码简洁，在初始化语句中定义一个局部变量，循环结束后，局部变量即被释放</p><h2 id="while">while</h2><p>一般用于循环次数不确定的情况，并且通常需要在循环之前定义变量</p><h1>读取数量不定的输入数据</h1><pre><code>#include &lt;iostream&gt;int main()&#123;    int sum = 0, value = 0;    // 读取数据直至遇到文件尾，计算所有读入的值的和    while (std::cin &gt;&gt; value)        sum += value;    std::cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>例中，数据读取操作是在<code>while</code>的循环条件中完成的</p><p><code>while</code>循环条件的求值就是执行表达式<code>std::cin &gt;&gt; value</code>，表达式<code>std::cin &gt;&gt; value</code>返回输入运算符<code>&gt;&gt;</code>左侧运算对象，即<code>std::cin</code>，因此，该循环条件实际上是检测<code>std::cin</code></p><p>当我们使用一个<code>istream</code>对象如<code>cin</code>作为条件时，其效果是检测流(stream)的状态，当遇到文件结束符(end-of-file)或遇到一个无效的输入时(例如读入的值不是一个整数)，<code>istream</code>对象的状态会变为无效。进一步地，无效状态的<code>istream</code>对象会使条件变为假，循环结束</p><p>键盘输入文件结束符：<code>Ctrl + Z</code>然后按<code>Enter</code>或<code>Return</code>键(windows系统)，<code>Ctrl + D</code>键(UNIX系统、Mac OS X系统)</p><h1>if</h1><pre><code>if (condition)&#123;    statement;&#125;</code></pre><p>条件<code>condition</code>为真，执行条件之后的语句块<code>statement</code>，否则不予执行</p><p>或者</p><pre><code>if (condition)&#123;    statement1;&#125;else&#123;    statement2;&#125;</code></pre><p>条件<code>condition</code>为真时执行<code>statement1</code>，否则执行<code>statement2</code></p><p>示例：用<code>if</code>语句统计输入序列中每个值连续出现了多少次</p><pre><code>#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main()&#123;    int currentNum, num;            // currentNum为当前统计的数字，num为新读取的数字    if (cin &gt;&gt; currentNum)          // 初始化当前统计数字    &#123;        int count = 1;              // 初始化当前统计数字的出现次数        while (cin &gt;&gt; num)          // 读取下一个数字        &#123;            if (num == currentNum)  // 如果新输入数字与当前统计的数字相同，出现次数加一                ++ count;            else                    // 如果不同，输出当前统计数字的出现次数，并更新所统计的数字，重置计数器            &#123;                cout &lt;&lt; currentNum &lt;&lt; &quot; occurs &quot; &lt;&lt; count &lt;&lt; &quot; times &quot; &lt;&lt; endl;                currentNum = num;                count = 1;            &#125;        &#125;        cout &lt;&lt; currentNum &lt;&lt; &quot; occurs &quot; &lt;&lt; count &lt;&lt; &quot; times &quot; &lt;&lt; endl;     // 输出文件最后一个数字的出现次数    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> while </tag>
            
            <tag> for </tag>
            
            <tag> if </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识C++(上)</title>
      <link href="/2021/10/26/4-%E5%88%9D%E8%AF%86cpp-%E4%B8%8A/"/>
      <url>/2021/10/26/4-%E5%88%9D%E8%AF%86cpp-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1>main</h1><p><code>main</code>函数的返回类型必须是int，即整数类型</p><p>多数系统中，<code>main</code>的返回值用于指示状态：返回值0表示成功，非0返回值通常用来指出错误类型</p><p>当<code>return</code>语句包括一个值时，<strong>该返回值的类型必须与函数返回类型相容</strong>，如<code>main</code>函数的返回值0是int类型的值</p><h1>编译、运行程序</h1><p>源文件：带后缀<code>.c</code>、<code>.cxx</code>、<code>.cpp</code>、<code>.cp</code>、<code>.c</code>的程序文件</p><p>可执行文件：windows系统的<code>.exe</code>文件，UNIX系统的<code>.out</code>文件<br><em>注：windows系统运行一个可执行文件时，需提供可执行文件的文件名，可以忽略其拓展名<code>.exe</code>，而UNIX系统则需要使用完整的文件名(包含文件拓展名)</em></p><p><code>.</code>后面跟一个反斜线，即<code>.\</code>，指出文件在当前目录中，如<code>.\prog1.exe</code></p><p>运行GUN编译器的命令：<code>g++ -o prog1 prog1.cc</code>，其中，<code>-o prog1</code>是编译器参数，指定可执行文件的文件名。此命令生成名为<code>prog1</code>(UNIX)或<code>prog1.exe</code>(windows)的可执行文件。若省略<code>-o prog1</code>，则生成<code>a.out</code>(UNIX)或<code>a.exe</code>(windows)可执行文件</p><h1>输入与输出</h1><p>标准库<code>iostream</code>: 包含输入流<code>istream</code>与输出流<code>ostream</code></p><p>IO对象: <code>cin</code>(标准输入)、<code>cout</code>(标准输出)、<code>cerr</code>(输出警告与错误信息)、<code>clog</code>(输出程序运行时的一般性信息)</p><p><code>&lt;&lt;</code>: 输出运算符，将给定值写到给定的<code>ostream</code>对象中，如: <code>std::cout&lt;&lt;&quot;Enter two number&quot;;</code></p><p><code>&gt;&gt;</code>: 输入运算符，从给定的<code>istream</code>读入数据，并存入给定对象中，如: <code>std::cin&gt;&gt;v1;</code></p><p><code>endl</code>: 操纵符，写入<code>endl</code>的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流(stream)</p><p>流(stream)：一个流就算一个字符序列，是从IO设备读出或写入IO设备的。术语“流”想要表达的是，随着时间的推移，字符是顺序生成或消耗的</p><pre><code>#include &lt;iostream&gt;int main()&#123;std::cout &lt;&lt; &quot;Enter two number&quot; &lt;&lt; std::endl;int v1 = 0, v2 = 0;std::cin &gt;&gt; v1 &gt;&gt; v2;std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;return 0;&#125;</code></pre><h1>include</h1><p>程序使用标准库时，必须包含相关的头文件，如: <code>#include &lt;iostream&gt;</code>告诉编译器使用<code>iostream</code>库</p><p>尖括号内的名字即指出了一个头文件，如<code>iostream</code>、<code>array</code>、<code>cmath</code>、<code>algorithm</code>等</p><p><code>#include</code>指令和头文件的名字必须写在同一行中，<strong>不用以分号结束</strong></p><p>通常情况下，<code>#include</code>指令必须出现在所有函数之外</p><p>一般将一个程序的所有<code>#include</code>指令都放在源文件的开始位置</p><h1>命名空间</h1><p>命名空间可以避免名字定义冲突以及使用库中相同名字导致的冲突，标准库定义的所有名字都在命名空间<code>std</code>中</p><p>通过命名空间使用标准库有一个副作用：<strong>当使用标准库中的一个名字时，必须显式说明使用的是命名空间<code>std</code>中的名字</strong></p><p><code>::</code>: 作用域操作符，编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字</p><p><code>std::</code>: 指出名字是定义在<code>std</code>的命名空间(namespace)中的，如: <code>std::cin</code>、<code>std::cout</code>、<code>std::endl</code>分别指出<code>cin</code>、<code>cout</code>、<code>endl</code>是命名空间<code>std</code>中的</p><p><code>using</code>声明: 一开始对<code>cin</code>、<code>cout</code>、<code>endl</code>使用<code>using</code>声明，后续不需要添加<code>std::</code>形式的前缀即可使用它们。注意，<strong>每行的<code>using</code>声明都要以分号结束</strong></p><pre><code>#include &lt;iostream&gt;using std::cout;using std::cin;using std::endl;void main()&#123;cout &lt;&lt; &quot;Enter two number&quot; &lt;&lt; endl;int v1 = 0, v2 = 0;cin &gt;&gt; v1 &gt;&gt; v2;cout &lt;&lt; &quot;The product of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 * v2 &lt;&lt; endl;&#125;</code></pre><h1>注释</h1><p>单行注释: 以双斜线<code>//</code>开始，以换行符结束。这种注释可以包含任何文本，包括额外的双斜线</p><p>界定符对注释：以界定符<code>/*</code>开始，以界定符<code>*/</code>结束，可以包含除<code>*/</code>外的任意内容，包括换行符。因此，界定符对注释可以跨越程序中的多行</p><p>注释界定符可以放置于任何允许放置制表符、空格符或换行符的地方</p><p>当注释界定符跨越多行，最好能显示指出其内部的程序行都属于多行注释的一部分，C++ Primer所采用的风格是：注释内的每行都以一个星号开头，从而指出整个范围都是多行注释的一部分</p><pre><code># include &lt;iostream&gt;/** 简单主函数* 读取两个数，求它们的和*/int main()&#123;//提示用户输入两个数std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;int v1 = 0, v2 = 0;     //保存用于读取输入数据的变量std::cin &gt;&gt; v1 &gt;&gt; v2;   //读取输入数据std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2&lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;return 0;&#125;</code></pre><p><strong>注释界定符对通常用于多行解释，而双斜线注释常用于半行和单行附注</strong></p><p>注意：<strong>注释界定符不能嵌套</strong>，因为界定符对以<code>/*</code>开始，以<code>*/</code>结束</p><p>调试时，通常需要注释掉一些代码，由于这些代码本身可能包含界定符对形式的注释，若继续采用界定符对进行注释则可能导致注释嵌套错误，因此，调试时注释的最好的方式是用单行注释方式注释掉代码段的每一行</p><pre><code>// /*// * 单行注释中的任何内容都会被忽略// * 包括内部的注释对也一样会被忽略// */</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> main </tag>
            
            <tag> return </tag>
            
            <tag> 可执行文件 </tag>
            
            <tag> include </tag>
            
            <tag> 命名空间 </tag>
            
            <tag> 注释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode使用</title>
      <link href="/2021/10/26/3-vscode%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/26/3-vscode%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>vscode快捷键</h1><h2 id="主命令框">主命令框</h2><p>Ctrl + Shift + P: 打开命令面板</p><h2 id="编辑器与窗口">编辑器与窗口</h2><p>Ctrl + K, V: 打开预览面板</p><p>Ctrl + `: 打开/关闭终端</p><p>Ctrl + Tab: 文件之间切换</p><p>Ctrl + W: 关闭当前窗口</p><h2 id="代码编辑">代码编辑</h2><p>Ctrl + F: 查找</p><p>Ctrl + H: 查找替换</p><p>Ctrl + Shift + T: 重新打开刚关闭的编辑页面</p><p>Ctrl + Backspace: 删除上一个单词</p><p>Ctrl + N: 新建文件</p><p>Ctrl + S: 保存</p><h2 id="光标">光标</h2><p>Home: 光标移动至行首</p><p>End: 光标移动至行末</p><p>Ctrl + Home: 光标移至文件开头</p><p>Ctrl + End: 光标移至文件末尾</p><p>Shift + Home: 选择从光标到行首的内容</p><p>Shift + End: 选择从光标到行尾的内容</p><p>Alt + Up: 向上移动一行</p><p>Alt + Down: 向下移动一行</p><h2 id="调试、运行">调试、运行</h2><p>Ctrl + Shift + B: 重启调试</p><p>Ctrl + F5: 运行但不调试</p><p>F5: 启动调试</p><h1>终端Terminal指令</h1><h2 id="hexo">hexo</h2><p><code>hexo n &quot; &quot;</code>: 新建md文件</p><p><code>hexo c</code>: 清理</p><p><code>hexo g</code>: 生成</p><p><code>hexo d</code>: 部署到github</p><h2 id="g">g++</h2><p><code>g++ hello.cpp -o hello.exe</code>: 输出编译后的结果到指定的文件file中 (输出指定的可执行文件 hello.exe)，-o不仅可以指定输出的可执行文件，还可以指定中间文件的输出</p><p><code>g++ -o hello.exe hello.cpp</code>: 同上</p><p><code>g++ hello.cpp</code>: 输出的是 a.exe</p><p><code>g++ -E -o hello.i hello.cpp</code>: 对源文件进行预处理，预处理后生成.i(或者是 .ii)文件，对hello.cpp进行预处理生成hello.i文件</p><p><code>g++ -S -o hello.s hello.cpp</code>: 只进行预处理和编译，生成汇编文件hello.s</p><p><code>g++ -c -o hello.o hello.cpp</code>: 只进行预处理，编译，汇编操作，生成.o (.obj)文件，不进行链接</p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2021/10/24/2-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/10/24/2-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1>安装git</h1><ol><li>下载：<a href="https://git-scm.com/download">https://git-scm.com/download</a></li><li>安装：除了选择安装路径外，一直点next就行</li></ol><p>可参考教程<a href="https://blog.csdn.net/hahameier/article/details/86312530">https://blog.csdn.net/hahameier/article/details/86312530</a></p><h1>安装node.js</h1><ol><li>下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装：除了选择路径以外，一直点next就行</li></ol><h1>安装hexo框架</h1><h2 id="进入命令行">进入命令行</h2><p>打开命令行窗口：按<code>win+r</code>键，输入<code>cmd</code>，回车，后续操作均在命令行进行</p><h2 id="查看node-js版本">查看node.js版本</h2><ol><li>查看node版本：输入<code>node -v</code>，回车</li><li>查看npm版本：输入<code>npm -v</code>，回车</li></ol><h2 id="安装cnpm">安装cnpm</h2><ol><li>安装cnpm镜像源：输入<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>，回车，等待…</li><li>查看cnpm版本：输入<code>cnpm -v</code>，回车</li></ol><h2 id="安装hexo">安装hexo</h2><ol><li>安装hexo框架：输入<code>cnpm install -g hexo-cli</code>，回车</li><li>查看hexo版本：输入<code>hexo -v</code>，回车</li></ol><h1>搭建博客</h1><h2 id="新建blog文件">新建blog文件</h2><ol><li>找到git安装路径下的<code>git-cmd.exe</code>，以管理员权限打开</li><li>输入<code>mkdir e:\blog</code>并回车，实现在<code>e:\</code>路径下创建blog文件夹</li><li>配置路径，输入<code>cd e:\blog</code>回车，输入<code>e:</code>，回车</li></ol><h2 id="生成博客">生成博客</h2><ol><li>初始化博客：输入<code>hexo init</code>，回车，等待…直到出现<code>INFO Starting blogging with Hexo</code></li><li>启动本地博客服务：输入<code>hexo s</code>，回车，得到本地访问地址<code>http://localhost:4000</code></li><li>访问本地博客：浏览器打开<code>localhost:4000</code></li></ol><h2 id="安装git插件">安装git插件</h2><ol><li>配置到blog目录，<code>cd e:\blog</code></li><li>安装部署插件：输入<code>cnpm install --save hexo-deployer-git</code>并回车，等待安装完成，如若出现warning可直接忽略</li></ol><h2 id="配置git">配置git</h2><ol><li>打开<strong>git bash</strong></li><li>输入<code>git config --global user.email YourEmail</code>，其中<code>YourEmail</code>是github邮箱</li><li>输入<code>git config --global user.name YourName</code>，<code>YourName</code>是github用户名</li></ol><h2 id="创建github仓库">创建github仓库</h2><ol><li>登录github网页的个人账户</li><li>右上角<code>New repository</code>新建仓库</li><li><code>Repository name</code>命名为个人用户名<code>YourName</code>加上<code>.github.io</code>，即，仓库名为<code>YourName.github.io</code></li></ol><h2 id="配置-config-yml">配置_config.yml</h2><ol><li><p>使用记事本打开<code>e:\blog</code>路径下的<code>_config.yml</code>文件</p></li><li><p>找到<code>Deployment</code>板块，配置如下</p><pre><code> # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:  type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master</code></pre></li></ol><p>其中，<code>repo</code>后面的链接为个人github仓库的链接</p><p><strong>注：冒号后面需要有英文环境下的空格</strong></p><h2 id="部署到github仓库">部署到github仓库</h2><ol><li>cmd命令行配置到路径<code>e:\blog</code></li><li>部署：输入<code>hexo d</code>并回车，部署到Github仓库里</li><li>等待弹窗，输入github账户密码，即配置完成</li></ol><h1>hexo相关命令</h1><ol><li><code>hexo clean</code>：清理</li><li><code>hexo n</code>：新建</li><li><code>hexo g</code>：生成博客</li><li><code>hexo s</code>：启动本地博客服务</li><li><code>hexo d</code>：部署到远端github博客</li></ol><h1>参考</h1><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1635071237&amp;unique_k=kYdWS1">视频教程</a></p><p><a href="https://blog.csdn.net/zgd826237710/article/details/99671027?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163507159316780261929572%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163507159316780261929572&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-99671027.pc_search_ecpm_flag&amp;utm_term=hexo%E4%B8%BB%E9%A2%98&amp;spm=1018.2226.3001.4187">hexo主题</a></p><p>个人博客地址：<a href="https://jiankychen.github.io/">https://jiankychen.github.io/</a></p><p><a href="https://zhuanlan.zhihu.com/p/108898992?utm_source=wechat_session">解决 Github 连接不上的问题</a></p><p><a href="https://jingyan.baidu.com/article/63f2362893f7e10208ab3df8.html">如何配置HOSTS文件</a></p><p><a href="https://www.cnblogs.com/philobing/p/15670470.html">HOSTS文件配置</a></p><p><a href="https://jingyan.baidu.com/article/3c343ff7b8fe550d377963e7.html">修改hosts文件提示没有权限保存怎么办</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2021/10/24/1-markdown/"/>
      <url>/2021/10/24/1-markdown/</url>
      
        <content type="html"><![CDATA[<h1>Markdown</h1><p><a href="https://blog.csdn.net/lanxuezaipiao/article/details/44307757?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&amp;spm=1001.2101.3001.4242.0">markdown基本语法-文字版</a></p><p><a href="https://www.bilibili.com/video/BV1JA411h7Gw/?spm_id_from=333.788.recommend_more_video.2">markdown基本语法-视频版</a></p><p><a href="https://zhuanlan.zhihu.com/p/208791140">编辑器测评</a></p><p>编辑器推荐：<strong>vscode</strong>，Joplin，Typora，sublime，Moeditor</p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"string","short_name":"Junzhou","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"images/pwaicons/36.png","sizes":"36x36","type":"image/png"},{"src":"images/pwaicons/48.png","sizes":"48x48","type":"image/png"},{"src":"images/pwaicons/72.png","sizes":"72x72","type":"image/png"},{"src":"images/pwaicons/96.png","sizes":"96x96","type":"image/png"},{"src":"images/pwaicons/144.png","sizes":"144x144","type":"image/png"},{"src":"images/pwaicons/192.png","sizes":"192x192","type":"image/png"},{"src":"images/pwaicons/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
