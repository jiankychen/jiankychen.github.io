<!-- build time:Sat Mar 23 2024 01:17:15 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="队列,栈"><link rel="canonical" href="https://jiankychen.github.io/posts/51f34f0/"><title>LeetCode - 栈与队列专题 - Coding | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">LeetCode - 栈与队列专题</h1><div class="meta"><span class="item" title="创建时间：2022-05-19 22:57:23"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-05-19T22:57:23+08:00">2022-05-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>27k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>45 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/65d0bfef68566882ce0560cab2e87921.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/42bab566f107b9a16542343e0368fb77.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/99fb5ff897a82984470abf5e2a235d94.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/2aabaeb8aca379b991071d1c41632741.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a1f3404a5032323ea4857ac5a6354d2f.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Coding/" itemprop="item" rel="index" title="分类于 Coding"><span itemprop="name">Coding</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/51f34f0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="leetcode-1047-删除字符串中的所有相邻重复项"><a class="anchor" href="#leetcode-1047-删除字符串中的所有相邻重复项">#</a> LeetCode 1047. 删除字符串中的所有相邻重复项</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtYWxsLWFkamFjZW50LWR1cGxpY2F0ZXMtaW4tc3RyaW5nLw==">1047. Remove All Adjacent Duplicates In String</span></p><p>给出由小写字母组成的字符串 <code>S</code> ，<strong>重复项删除操作</strong> 会选择两个相邻且相同的字母，并删除它们。</p><p>在 <code>S</code> 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abbaca&quot;
输出：&quot;ca&quot;
解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;azxxzy&quot;
输出：&quot;ay&quot;
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>匹配问题 都是 栈 的强项</p><p>基本思路：遍历字符串，若当前字符与栈顶元素相等，将栈顶元素移除，否则，将字符压入栈中。遍历完字符串以后，栈内不再含有连续的重复字符，将栈内元素依次弹出、并填充到目标字符串即可</p><h2 id="method-1-栈"><a class="anchor" href="#method-1-栈">#</a> Method 1: 栈</h2><p>由于栈顶元素对应的是字符串的尾端，填充目标字符串时需按从右往左顺序填充</p><p>代码实现：</p><pre><code class="language-cpp">string removeDuplicates(string s) &#123;
    // 将字符依次压入栈，若遇连续相同字符，则将栈顶元素移除
    stack&lt;int&gt; stk;
    for (auto c : s) &#123;
        if (!stk.empty() &amp;&amp; c == stk.top()) stk.pop();
        else stk.push(c);
    &#125;
    // 将栈内字符添加到新字符串中（最先出栈的放到字符串末尾）
    int size = stk.size();
    string res(size, ' ');
    for (int i = size - 1; i &gt;= 0; i--) &#123;
        res[i] = stk.top();
        stk.pop();
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈所需空间（这里没有把目标字符串所需空间考虑在内）</p><blockquote><p>也可以将栈内元素按从左往右顺序填充到目标字符串，然后再对目标字符串进行翻转</p></blockquote><h2 id="method-2-字符串"><a class="anchor" href="#method-2-字符串">#</a> Method 2: 字符串</h2><p>在 C++ 中，由于标准库类型 <code>string</code> 本身就提供了类似 入栈 和 出栈 的接口，可直接将目标字符串作为栈</p><p>代码实现：</p><pre><code class="language-cpp">string removeDuplicates(string s) &#123;
    string res = &quot;&quot;;
    for (auto c : s) &#123; // 从目标字符串尾部移除与 c 相同的字符
        if (!res.empty() &amp;&amp; c == res.back())
            res.pop_back();
        else           // 将字符 c 添加到目标字符串尾部
            res.push_back(c);
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，没有把目标字符串所需空间考虑在内</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzEwNDcuJUU1JTg4JUEwJUU5JTk5JUE0JUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTg5JTgwJUU2JTlDJTg5JUU3JTlCJUI4JUU5JTgyJUJCJUU5JTg3JThEJUU1JUE0JThEJUU5JUExJUI5Lmh0bWw=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtYWxsLWFkamFjZW50LWR1cGxpY2F0ZXMtaW4tc3RyaW5nL3NvbHV0aW9uL3NoYW4tY2h1LXppLWZ1LWNodWFuLXpob25nLWRlLXN1by15b3UteGktNG9oci8=">力扣官方题解</span></li></ul><h1 id="leetcode-150-逆波兰表达式求值"><a class="anchor" href="#leetcode-150-逆波兰表达式求值">#</a> LeetCode 150. 逆波兰表达式求值</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1yZXZlcnNlLXBvbGlzaC1ub3RhdGlvbi8=">LeetCode 150. Evaluate Reverse Polish Notation</span></p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <strong>逆波兰表示法</strong> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>注意：</p><ul><li>有效的算符为 <code>'+'</code> 、 <code>'-'</code> 、 <code>'*'</code> 和 <code>'/'</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 向零截断 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p></p><p><strong>示例 1：</strong></p><pre><code>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
输出：9
解释：((2 + 1) * 3) = 9
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]
输出：6
解释：(4 + (13 / 5)) = 6
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
输出：22
解释：((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>tokens.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>tokens[i]</code> 是一个算符 （ <code>&quot;+&quot;</code> 、 <code>&quot;-&quot;</code> 、 <code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code> ），或是在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>200</mn><mo separator="true">,</mo><mn>200</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-200, 200]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内的一个整数</li></ul><h2 id="思路-2"><a class="anchor" href="#思路-2">#</a> 思路</h2><p>逆波兰表达式，即，<strong>后缀表达式</strong>（运算符写在两个操作数的后面）</p><p>日常使用的是中缀表达式（运算符写在两个操作数的中间）</p><p>例如， <code>2 + 3</code> 就是中缀表达式，对应的后缀表达式是 <code>2 3 +</code></p><p>由此，本题的求解思路为：</p><ol><li><p>定义一个 栈</p></li><li><p>遍历数组 <code>tokens</code> ，若遇到的是数字，则将数字压入栈，若遇到的是 <code>&quot;+&quot;</code> 、 <code>&quot;-&quot;</code> 、 <code>&quot;*&quot;</code> 、 <code>&quot;/&quot;</code> 运算符，则从栈内取出两个数字进行计算，然后将计算结果压入栈中</p></li><li><p>遍历结束时，栈内剩余元素即为整个后缀表达式的计算结果</p></li></ol><p>注意，数组 <code>tokens</code> 内的元素是 <code>string</code> 类型的对象，<strong>将 <code>string</code> 型的数字压入栈前需将其转换成 <code>int</code> 型</strong></p><ul><li>调用 <code>stoi</code> 函数即可，参考 <span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdHJpbmcvc3RvaS8/a3c9c3RvaQ==">cplusplus：std::stoi</span></li></ul><h2 id="method-栈"><a class="anchor" href="#method-栈">#</a> Method: 栈</h2><p>代码实现：</p><pre><code class="language-cpp">// 计算后缀表达式，并将结果压入栈
void compute(stack&lt;int&gt; &amp;stk, string c) &#123;
    int right = stk.top(); // 右操作数
    stk.pop();
    int left = stk.top();  // 左操作数
    stk.pop();
    if (c == &quot;+&quot;) stk.push(left + right);
    else if (c == &quot;-&quot;) stk.push(left - right);
    else if (c == &quot;*&quot;) stk.push(left * right);
    else if (c == &quot;/&quot;) stk.push(left / right);
&#125;

int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
    stack&lt;int&gt; stk;
    for (auto c : tokens) &#123;
        if (c == &quot;+&quot; || c == &quot;-&quot; || c == &quot;*&quot; || c == &quot;/&quot;)
            compute(stk, c);
        else
            stk.push(stoi(c)); // 将 string 类型转成 int 型
    &#125;
    int ans = stk.top();
    stk.pop();
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为 <code>tokens</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈所需空间</p><h1 id="leetcode-155-最小栈"><a class="anchor" href="#leetcode-155-最小栈">#</a> LeetCode 155. 最小栈</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2sv">155. Min Stack</span></p><p>设计一个支持 <code>push</code> ， <code>pop</code> ， <code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素 val 推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li><li><code>pop</code> 、 <code>top</code> 和 <code>getMin</code> 操作总是在 非空栈 上调用</li><li><code>push</code> 、 <code>pop</code> 、 <code>top</code> 和 <code>getMin</code> 最多被调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 次</li></ul><h2 id="method-辅助栈"><a class="anchor" href="#method-辅助栈">#</a> Method: 辅助栈</h2><p>算法思路：</p><p>定义一个元素栈（记作 stk），用于存储每个元素</p><p>定义一个辅助栈（记作 minStk），用于存储与每个元素对应的最小值（与元素值同步插入与删除）</p><ul><li><p>当一个元素要入栈到 stk 时，我们取辅助栈 minStk 的栈顶元素与当前元素比较，将最小值插入辅助栈 minStk 中</p></li><li><p>当一个元素要从 stk 中弹出时，我们把辅助栈 minStk 的栈顶元素也相应弹出</p></li><li><p>在任意时刻，栈 stk 内的元素最小值就是辅助栈 minStk 的栈顶元素</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">class MinStack &#123;
public:
    stack&lt;int&gt; stk;
    stack&lt;int&gt; minStk; // 辅助栈

    MinStack() &#123;
        minStk.push(INT_MAX); // 初始化辅助栈
    &#125;
    
    void push(int val) &#123;
        stk.push(val);
        minStk.push(min(val, minStk.top()));
    &#125;
    
    void pop() &#123;
        stk.pop();
        minStk.pop();
    &#125;
    
    int top() &#123;
        return stk.top();
    &#125;
    
    int getMin() &#123;
        return minStk.top();
    &#125;
&#125;;

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(val);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
</code></pre><p>时间复杂度：入栈、出栈、获取栈顶元素、获取最小元素的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为元素个数，考虑了辅助栈所需的额外空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2svc29sdXRpb24venVpLXhpYW8temhhbi1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p><h1 id="leetcode-20-有效的括号"><a class="anchor" href="#leetcode-20-有效的括号">#</a> LeetCode 20. 有效的括号</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy8=">LeetCode 20. Valid Parentheses</span></p><p>给定一个只包括 <code>'('</code> ， <code>')'</code> ， <code>'&#123;'</code> ， <code>'&#125;'</code> ， <code>'['</code> ， <code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;()&quot;
输出：true
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;()[]&#123;&#125;&quot;
输出：true
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;(]&quot;
输出：false
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code> 仅包含括号 <code>'()[]&#123;&#125;'</code></li></ul><h2 id="思路-3"><a class="anchor" href="#思路-3">#</a> 思路</h2><p>从左往右遍历字符串时，后遇到的左括号需要先匹配，与栈后进先出的特点不谋而合</p><p>因此，<strong>括号匹配问题可以使用 栈 来解决</strong></p><p>基本思路：遍历字符串，若遇到左括号，则将其入栈，若遇到右括号，则将对应栈顶左括号出栈</p><p>考察 括号不匹配 的三种情况：</p><ul><li>存在多余的左括号：在这种情况下，待字符串遍历结束后，栈不为空</li><li>存在多余的右括号：字符串未遍历完，栈已经为空</li><li>括号没有多余，但是括号的方向不对应：在遍历字符串过程中，遍历到的右括号无法与栈顶左括号匹配</li></ul><p>若字符串遍历结束后，栈为空，则说明括号全部匹配</p><h2 id="method-1-栈-map"><a class="anchor" href="#method-1-栈-map">#</a> Method 1: 栈 + map</h2><p>栈 存储的是 待匹配的左括号</p><p>哈希 map 用来存储可以匹配的括号类型，即：哈希表的 key 为右括号，value 为相同类型的左括号，这样查询 2 个括号是否对应只需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间复杂度</p><p>具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9zb2x1dGlvbi95b3UteGlhby1kZS1ndWEtaGFvLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：有效的括号</span> 和 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9zb2x1dGlvbi92YWxpZC1wYXJlbnRoZXNlcy1mdS16aHUtemhhbi1mYS1ieS1qaW40MDc4OTEwODAv">Krahets：有效的括号</span></p><h2 id="method-2-栈"><a class="anchor" href="#method-2-栈">#</a> Method 2: 栈</h2><p>遍历字符串过程中，若遇到左括号，可将对应的右括号压入栈，后续遇到右括号时，只需将其与栈顶元素进行比较即可，若相等，则匹配，否则不匹配</p><p>即，栈 存储的是 与左括号对应的右括号</p><p>代码实现：</p><pre><code class="language-cpp">bool isValid(string s) &#123;
    if (s.size() % 2) return false; // 括号数为奇数，直接返回 false
    stack&lt;int&gt; stk;
    for (auto c : s) &#123; // 范围 for
        // 当 c 为 左括号 时，把对应的 右括号 压入栈
        if (c == '(') stk.push(')');
        else if (c == '[') stk.push(']');
        else if (c == '&#123;') stk.push('&#125;');
        // 当栈为空，或者，c 是 右括号 但 不等于栈顶元素，匹配失败
        else if (stk.empty() || c != stk.top()) return false;
        // c 是 右括号 且 等于栈顶元素，匹配成功，从栈顶移除左括号
        else stk.pop();
    &#125;
    // 所有括号均已遍历完成，若栈为空，则匹配成功
    return stk.empty();
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，遍历字符串</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈所需空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMjAuJUU2JTlDJTg5JUU2JTk1JTg4JUU3JTlBJTg0JUU2JThCJUFDJUU1JThGJUI3Lmh0bWwjJUU5JUEyJTk4JUU1JUE0JTk2JUU4JUFGJTlE">代码随想录：有效的括号</span></p><h1 id="leetcode-225-用队列实现栈"><a class="anchor" href="#leetcode-225-用队列实现栈">#</a> LeetCode 225. 用队列实现栈</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3RhY2stdXNpbmctcXVldWVzLw==">LeetCode 225. Implement Stack using Queues</span></p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（ <code>push</code> 、 <code>top</code> 、 <code>pop</code> 和 <code>empty</code> ）。</p><p>实现 MyStack 类：</p><ul><li><code>void push(int x)</code> 将元素 <code>x</code> 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列，只要是标准的队列操作即可。</li></ul><p></p><p><strong>示例 1：</strong></p><pre><code>输入
[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]
[[], [1], [2], [], [], []]
输出
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>x</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span></li><li>最多调用 100 次 <code>push</code> 、 <code>pop</code> 、 <code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p><strong>进阶：</strong> 你能否仅用一个队列来实现栈。</p><h2 id="思路-4"><a class="anchor" href="#思路-4">#</a> 思路</h2><p>栈 的特点是 后进先出 ，队列 的特点是 先进先出</p><p>可定义一个队列，使得 最先入栈的元素 放在 队首 ，最后入栈的元素 放在 队尾</p><ul><li><p>对于入栈操作，只需将元素添加到队尾</p></li><li><p>对于出栈操作，需将队尾元素移除并返回</p></li><li><p>为获取栈顶元素，可先将栈顶元素出栈，并记录其值（本题定义的 出栈 函数具有返回值），然后再将其压入栈</p></li><li><p>判断栈是否为空，只需判断用来存储栈元素的队列是否为空</p></li></ul><p>特别地，出栈操作可通过两个队列协同实现，也可仅用一个队列实现</p><h2 id="method-两个队列"><a class="anchor" href="#method-两个队列">#</a> Method: 两个队列</h2><p>定义队列 <code>que1</code> ，用于存储 栈 的数据（ 最先入栈的元素 放在 队首 、最后入栈的元素 放在 队尾 ）</p><p>定义队列 <code>que2</code> ，在 出栈 操作中，用于临时存放队列 <code>que1</code> 的前 <code>que1.size() - 1</code> 个元素，以便将 <code>que1</code> 队尾元素移除</p><p>时间复杂度：入栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，出栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，读取栈顶元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，判断栈是否为空 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是元素个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-一个队列"><a class="anchor" href="#method-一个队列">#</a> Method: 一个队列</h2><p>由于队列具有先进先出的特性，无需额外定义一个队列 <code>que2</code> 来实现 出栈 过程中元素的临时存放，即，直接将元素重新入队 <code>que1</code> 即可，这样就能使得最初的队尾元素出现在队首</p><p>代码实现：</p><pre><code class="language-cpp">class MyStack &#123;
public:
    queue&lt;int&gt; que; // 最先入栈的放在 que 队首，最后入栈的放在 que 队尾

    MyStack() &#123;

    &#125;
    
    void push(int x) &#123;
        que.push(x);
    &#125;
    
    int pop() &#123;
        int length = que.size(); // 记录 que1 的长度，注意，不能直接将 que.size() 作为 for 循环的判定条件
        // 将 que 前 length - 1 个元素依次移出，然后放入队尾，使得最初的队尾元素出现在队首
        for (int i = 0; i &lt; length - 1; i++) &#123;
            int temp = que.front();
            que.pop();
            que.push(temp);
        &#125;
        // 记录最初的队尾元素值，并将其移除
        int ans = que.front();
        que.pop();
        return ans;
    &#125;
    
    int top() &#123;
        int ans = pop(); // 复用已经定义的 MyStack 类别的 pop() 函数，将栈顶元素弹出
        push(ans);       // 再将其压入栈
        return ans;
    &#125;
    
    bool empty() &#123;
        return que.empty() ? true : false;
    &#125;
&#125;;

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * bool param_4 = obj-&gt;empty();
 */
</code></pre><p>时间复杂度：入栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，出栈操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，读取栈顶元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，判断栈是否为空 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是元素个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>事实上，也可以将 最后入栈的元素 放在 队首 、最先入栈的元素 放在 队尾 ，即，队列 的 前端 和 后端 分别对应 栈顶 和 栈底 。<br>但是，这种情况下的 入栈 操作则会复杂很多，对应的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，而 出栈 和 读取栈顶元素 则会简单很多，对应的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><br>可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3RhY2stdXNpbmctcXVldWVzL3NvbHV0aW9uL3lvbmctZHVpLWxpZS1zaGkteGlhbi16aGFuLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：用队列实现栈</span></p></blockquote><h1 id="leetcode-227-基本计算器-ii"><a class="anchor" href="#leetcode-227-基本计算器-ii">#</a> LeetCode 227. 基本计算器 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNpYy1jYWxjdWxhdG9yLWlpL2Rlc2NyaXB0aW9uLw==">227. 基本计算器 II</span></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p><p>整数除法仅保留整数部分</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2^{31}, 2^{31} - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的范围内</p><p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数（例如 <code>eval()</code> ）</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;3+2*2&quot;
输出：7
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot; 3/2 &quot;
输出：1
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot; 3+5 / 2 &quot;
输出：5
</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></li><li>s 由整数和算符 ( <code>'+'</code> , <code>'-'</code> , <code>'*'</code> , <code>'/'</code> ) 组成，中间由一些 <strong>空格</strong> 隔开</li><li>s 表示一个 <strong>有效表达式</strong></li><li>表达式中的所有整数都是非负整数，且在范围 [0, 2<sup>31</sup> - 1] 内</li><li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li></ul><h2 id="method-栈-2"><a class="anchor" href="#method-栈-2">#</a> Method: 栈</h2><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>由于乘除优先于加减计算，可以先进行所有乘除运算，并将这些乘除运算的结果放回原表达式的相应位置，最终，整个表达式的结果就等于一系列整数加减后的值</p><p>因此，可以用一个栈保存这些（进行乘除运算后的）整数的值</p><ul><li>对于 <code>'+'</code> 后面的数字，将其直接压入栈中</li><li>对于 <code>'-'</code> 后面的数组，将其相反数压入栈中</li><li>对于 <code>'*'</code> 或 <code>'/'</code> 后面的数字，可直接将其与栈顶元素计算，并使用计算结果替换栈顶元素</li></ul><p>最后将栈中元素进行累加，即可得到字符串表达式的值</p><h2 id="算法流程"><a class="anchor" href="#算法流程">#</a> 算法流程</h2><p>定义 <code>num</code> 为当前处理的整数</p><p>定义变量 <code>sign</code> 为整数之前的运算符（将第一个数字之前的运算符视为加号）</p><p>遍历字符串 <code>s</code></p><ul><li>若当前字符 <code>s[i]</code> 为数字字符，则更新当前整数值 <code>num</code> ： <code>num = num * 10 + (s[i] - '0')</code></li><li>若当前字符 <code>s[i]</code> 为运算符或者字符串最后一个字符，则说明已经遍历到了整数 <code>num</code> 的末尾，此时需根据整数 <code>num</code> 之前的运算符 <code>sign</code> 对 <code>num</code> 进行处理：<ul><li>若 <code>sign</code> 为 <code>'+'</code> ：将 <code>num</code> 压入栈；</li><li>若 <code>sign</code> 为 <code>'-'</code> ：将 <code>- num</code> 压入栈；</li><li>若 <code>sign</code> 为 <code>'*'</code> 或 <code>'/'</code> ：将其与栈顶元素计算，并将栈顶元素替换为计算结果</li></ul></li><li>待处理 <code>num</code> 后，更新 <code>sign</code> 为当前遍历到的运算符</li></ul><p>最后，将栈中元素进行累加</p><blockquote><p>这里可以用 <code>vector</code> 数组模拟栈，以便最后计算栈中元素之和</p></blockquote><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int calculate(string s) &#123;
    vector&lt;int&gt; stk;     // 模拟栈
    int num = 0;         // 当前处理的整数
    char sign = '+';     // 整数前面的运算符
    for (int i = 0; i &lt; s.size(); ++i) &#123;
        // 遇到数字字符，计算对应的整数
        if (isdigit(s[i])) &#123;
            num = num * 10 + (s[i] - '0');
        &#125;
        // 遇到算术符或者字符串末尾，执行算术运算
        if ((!isdigit(s[i]) &amp;&amp; !isspace(s[i])) || i == s.size() - 1) &#123;
            if (sign == '+') &#123;
                stk.push_back(num);
            &#125; else if (sign == '-') &#123;
                stk.push_back(-num);
            &#125; else if (sign == '*') &#123;
                stk.back() *= num;
            &#125; else if (sign == '/') &#123;
                stk.back() /= num;
            &#125;
            sign = s[i]; // 更新 sign 为当前遍历到的运算符
            num = 0;     // 重置整数
        &#125;
    &#125;

    int ans = 0;
    for (int tmp : stk) ans += tmp;
    return ans;
&#125;
</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h2><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNpYy1jYWxjdWxhdG9yLWlpL3NvbHV0aW9ucy82NDg2NDcvamktYmVuLWppLXN1YW4tcWktaWktYnktbGVldGNvZGUtc29sdXRpby1jbTI4Lw==">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNpYy1jYWxjdWxhdG9yLWlpL3NvbHV0aW9ucy82NDg4MzIvc2hpLXlvbmctc2h1YW5nLXpoYW4tamllLWp1ZS1qaXUtamktYmlhby1jNjVrLw==">宫水三叶：双栈解法</span></li></ul><h1 id="leetcode-232-用栈实现队列"><a class="anchor" href="#leetcode-232-用栈实现队列">#</a> LeetCode 232. 用栈实现队列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtcXVldWUtdXNpbmctc3RhY2tzLw==">LeetCode 232. Implement Queue using Stacks</span></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（ <code>push</code> 、 <code>pop</code> 、 <code>peek</code> 、 <code>empty</code> ）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 <code>x</code> 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入
[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]
[[], [1], [2], [], [], []]
输出
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>x</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span></li><li>最多调用 100 次 <code>push</code> 、 <code>pop</code> 、 <code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong> 你能否实现每个操作均摊时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的队列？换句话说，执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个操作的总时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，即使其中一个操作可能花费较长时间。</p><h2 id="思路-5"><a class="anchor" href="#思路-5">#</a> 思路</h2><p>栈具有后进先出的特性</p><p>若将一个栈的所有元素移入到另一个栈中，元素的排列顺序会变得与之前相反</p><h2 id="method"><a class="anchor" href="#method">#</a> Method</h2><p>解题思路：</p><ol><li><p>定义两个栈， <code>stk1</code> 和 <code>stk2</code></p><ul><li>栈 <code>stk1</code> 用来作为存储队列，即，最先入队的在 <code>stk1</code> 栈顶，最后入队的在 <code>stk1</code> 栈底</li><li>栈 <code>stk2</code> 作为临时存储空间，用来协助实现队列的功能</li></ul></li><li><p><code>void push(int x)</code> 函数的实现：</p><ul><li>若 <code>stk1</code> 非空：先将 <code>stk1</code> 内的所有元素都移出来，放进 <code>stk2</code> ，然后将 <code>x</code> 压入栈 <code>stk1</code> ，将 <code>stk2</code> 内的元素移回 <code>stk1</code></li><li>若 <code>stk1</code> 为空，直接将 <code>x</code> 压入栈 <code>stk1</code> 即可</li></ul></li><li><p><code>int pop()</code> 函数的实现：</p><ul><li>记录 <code>stk1</code> 栈顶元素值，并弹出 <code>stk1</code> 栈顶元素，返回其值</li></ul></li><li><p><code>int peek()</code> 函数的实现：</p><ul><li>直接返回 <code>stk1</code> 栈顶元素值即可</li></ul></li><li><p><code>bool empty()</code> 函数的实现：</p><ul><li>判断 <code>stk1</code> 是否为空即可</li></ul></li></ol><blockquote><p>另，也可以 “将最先入队的放 <code>stk1</code> 栈底，最后入队的在 <code>stk1</code> 栈顶” ，此时：入队操作可直接将 <code>x</code> 压入栈 <code>stk1</code> ；出队操作需将 <code>stk1</code> 栈底以上的元素全都临时存放到 <code>stk2</code> ，待 <code>stk1</code> 栈底元素弹出后，再将 <code>stk2</code> 所有元素移回 <code>stk1</code></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">class MyQueue &#123;
public:

    stack&lt;int&gt; stk1;
    stack&lt;int&gt; stk2;

    MyQueue() &#123;

    &#125;
    
    void push(int x) &#123;
        if (!stk1.empty()) &#123; // stk1 非空
            while (!stk1.empty()) &#123; // 将 stk1 元素压入栈 stk2
                stk2.push(stk1.top());
                stk1.pop();
            &#125;
            stk1.push(x);    // 将 x 压入栈 stk1
            while (!stk2.empty()) &#123; // 将 stk2 元素放回栈 stk1
                stk1.push(stk2.top());
                stk2.pop();
            &#125;
        &#125;
        else  // stk1 为空，直接将 x 压入栈 stk1
            stk1.push(x);
    &#125;
    
    int pop() &#123;
        int ans = stk1.top();
        stk1.pop();
        return ans;
    &#125;
    
    int peek() &#123;
        int ans = stk1.top();
        return ans;
    &#125;
    
    bool empty() &#123;
        if (stk1.empty()) return true;
        return false;
    &#125;
&#125;;

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;peek();
 * bool param_4 = obj-&gt;empty();
 */
</code></pre><p>注意，标准库实现的栈和队列，其成员函数 <code>pop()</code> 没有返回值，不能作为右值； <code>top()</code> 具有返回值，可以作为右值</p><p>另外，关于 <code>peek()</code> 函数的实现，可以直接调用已经定义了的 <code>MyQueue</code> 类别的 <code>pop()</code> 函数，即，通过函数的复用来实现。这样可以降低出错的可能性</p><h1 id="leetcode-239-滑动窗口最大值"><a class="anchor" href="#leetcode-239-滑动窗口最大值">#</a> LeetCode 239. 滑动窗口最大值</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">239. Sliding Window Maximum</span></p><p>给你一个整数数组 <code>nums</code> ，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                 最大值
---------------               ------
[1  3  -1]  -3  5  3  6  7       3
1  [3  -1  -3]  5  3  6  7       3
1  3  [-1  -3  5]  3  6  7       5
1  3  -1  [-3  5  3]  6  7       5
1  3  -1  -3  [5  3  6]  7       6
1  3  -1  -3  5  [3  6  7]       7
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1], k = 1
输出：[1]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>k</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code></li></ul><h2 id="思路-6"><a class="anchor" href="#思路-6">#</a> 思路：</h2><p>数组长为 <code>nums.size()</code> ，窗口长为 <code>k</code> ，一共有 <code>nums.size() - k + 1</code> 个窗口</p><p>若采用暴力法，对每个窗口求最大值需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span> 的时间复杂度，则总时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></p><p>针对本题的数据，暴力法会超时</p><p>本题有三种求解思路：可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">力扣官方题解</span></p><ul><li>优先队列（堆）</li><li>单调队列</li><li>分块 + 预处理</li></ul><h2 id="method-1-优先队列"><a class="anchor" href="#method-1-优先队列">#</a> Method 1: 优先队列</h2><p>可以利用 最大化堆，即，根节点元素值最大的二叉堆， 来维护窗口的最大值</p><blockquote><p>有关 最大化堆 ，可参考 <a href="https://jiankychen.github.io/posts/a21107fc">优先级队列</a></p></blockquote><p>算法流程：</p><ol><li><p>定义一个 优先队列 ，其中，队列每个元素都是一个二元组，存储了 <code>nums</code> 数组元素值和元素下标，即： <code>priority_queue&lt;pair&lt;int, int&gt;&gt; que;</code></p></li><li><p>将 <code>nums</code> 数组的前 <code>k</code> 个元素（及下标）加入到优先队列中</p></li><li><p>遍历 <code>nums</code> 数组元素下标 <code>i</code> （从第 <code>k</code> 位元素开始），即，窗口的右边界</p><ul><li>将 <code>(nums[i], i)</code> 加入到 <code>que</code> 中</li><li>若 <code>que</code> 根节点所对应的数组元素下标（即， <code>que.top().second</code> ） 小于 窗口的左边界（即， <code>i - k + 1</code> ），则这个最大值不在窗口范围内，而是在窗口左侧，将其从 <code>que</code> 中移除</li><li>将 <code>que</code> 根节点所对应的数组元素（即， <code>que.top().first</code> ）加入到目标数组中</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;
    priority_queue&lt;pair&lt;int, int&gt;&gt; que;
    vector&lt;int&gt; res(nums.size() - k + 1, 0);
    // 将前 k 个元素添加到优先队列
    for (int i = 0; i &lt; k; i++)
        que.emplace(nums[i], i);
    // 将当前窗口最大值添加到目标数组
    res[0] = que.top().first;
    for (int i = k; i &lt; nums.size(); i++) &#123;
        // 将当前元素添加到优先队列
        que.emplace(nums[i], i);
        // 当前队列的最大值不在窗口内，将其移除
        while (que.top().second &lt; i - k + 1)
            que.pop();
        // 将当前窗口最大值添加到目标数组
        res[i - k + 1] = que.top().first;
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 <code>nums</code> 的长度</p><ul><li>遍历数组的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>将元素添加到优先队列的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> （在最坏情况下，数组 <code>nums</code> 中的元素单调递增，优先队列中包含了所有元素）</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，这里仅考虑了优先队列所需空间，忽略了目标数组所需空间</p><p>参考</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">力扣官方题解：滑动窗口最大值</span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9xdWV1ZS9wcmlvcml0eV9xdWV1ZS8/a3c9cHJpb3JpdHlfcXVldWU=">cplusplus：std::priority_queue</span></li></ul><h2 id="method-2-单调队列"><a class="anchor" href="#method-2-单调队列">#</a> Method 2: 单调队列</h2><p>双向队列：队列的两端都可以 入队 / 出队</p><p>单调队列：从队首到队尾，元素单调递减，或递增</p><p>本题可定义一个 元素单调递减的单调队列 ，以维护窗口内的最大值（即，队列的首端元素为队列最大值）</p><ul><li>若队首元素不在窗口内（即，对应数组下标小于窗口左边界），将其移除</li><li>若队首元素在窗口内，则该元素即为窗口内元素的最大值</li></ul><p>为实现队列元素的单调递减，我们在添加元素时，需做以下考虑：</p><ul><li>若队列尾端元素小于等于当前元素，则将队尾元素移除（因为队尾元素对应的数组下标在当前元素的左侧，当队尾元素小于当前元素时，其不可能成为当前窗口及后续滑动窗口的最大值，可将其从队列中永久移除）</li><li>直到队列尾端元素大于当前元素时，才将当前元素添加到队列中</li></ul><p>算法流程：</p><ol><li>定义一个双向队列： <code>deque&lt;int&gt; que;</code> ，用以实现单调队列</li><li>遍历数组 <code>nums</code> 数组元素下标，定义为窗口的右边界 <code>right</code><ul><li>若队列不为空且当前元素大于等于队尾元素，将队尾元素移除，直到队列为空或当前元素小于新的队尾元素</li><li>将当前元素添加到队尾</li><li>若队首元素的下标小于滑动窗口左侧边界，将其从队首移除，直到队首元素在窗口中为止</li><li>若长为 <code>k</code> 的窗口已形成（即， <code>right &gt;= k - 1</code> ），则将窗口最大值（即，队首元素）添加到目标数组</li></ul></li></ol><blockquote><p>特别地，为便于操作，我们可将数组元素的下标存放在队列中</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;
    deque&lt;int&gt; que;     // 单调队列（从队首到队尾，元素单调递减）
    vector&lt;int&gt; res;    // 目标数组
    for (int left = 0, right = 0; right &lt; nums.size(); right++) &#123;
        // 队列不为空且当前考察元素大于等于队尾元素，将队尾元素移除
        while (!que.empty() &amp;&amp; nums[que.back()] &lt;= nums[right])
            que.pop_back();
        // 将当前元素的下标添加到队尾
        que.push_back(right);
        // 窗口左边界
        left = right - k + 1;
        // 将小于 left 的元素下标从队列移除
        while (que.front() &lt; left)
            que.pop_front();
        // 队列首端对应元素就是窗口最大值
        if (right &gt;= k -1)
            res.push_back(nums[que.front()]);
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 为窗口长度</p><ul><li>队列最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.77777em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 个元素，故，队列所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></li><li>忽略了目标数组所需空间</li></ul><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">力扣官方题解：滑动窗口最大值</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8tZHVpLWxpZS0yMzlodWEtaGM1dS8=">编程狂想曲：动画演示 单调队列 239. 滑动窗口最大值</span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9kZXF1ZS9kZXF1ZS8=">cplusplus：std::deque</span></li></ul><h1 id="leetcode-347-前-k-个高频元素"><a class="anchor" href="#leetcode-347-前-k-个高频元素">#</a> LeetCode 347. 前 K 个高频元素</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90b3Atay1mcmVxdWVudC1lbGVtZW50cy8=">347. Top K Frequent Elements</span></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,1,2,2,3], k = 2
输出：[1,2]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1], k = 1
输出：[1]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶</strong>：你所设计算法的时间复杂度 必须 优于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组大小。</p><h2 id="思路-7"><a class="anchor" href="#思路-7">#</a> 思路</h2><p>解题基本思路：</p><ul><li>统计元素出现频率：利用 <strong>哈希 map</strong> 来统计数组中各元素出现的次数</li><li>对频率排序：利用 <strong>优先级队列</strong> 来对频率进行排序</li><li>根据排序结果找出前 K 个高频元素</li></ul><p>题目只需找出前 K 个高频元素，因此可采用固定大小为 K 的 优先级队列 维护一个长为 K 的有序序列即可，而无需采用 vector 容器对所有元素的频次进行排序</p><p>由于优先级队列（堆）只能移除队首元素，本题采用 <strong>最小化堆（小顶堆）</strong> ，以便移除频次最少的元素</p><p>最小化堆的定义：</p><pre><code class="language-cpp">class comp &#123;
public:
    bool operator() (const pair&lt;int, int&gt; &amp;LHS, const pair&lt;int, int&gt; &amp;RHS) &#123;
        return LHS.second &gt; RHS.second;
    &#125;
&#125;;

priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, comp&gt; que;
</code></pre><blockquote><p>对于堆， <code>LHS.second &gt; RHS.second</code> 建立的是小顶堆， <code>LHS.second &lt; RHS.second</code> 建立的是大顶堆</p><p>对于 <code>sort</code> 函数， <code>LHS.second &gt; RHS.second</code> 得到的是降序排列， <code>LHS.second &lt; RHS.second</code> 得到的是升序排列</p></blockquote><h2 id="method-哈希-map-优先级队列"><a class="anchor" href="#method-哈希-map-优先级队列">#</a> Method: 哈希 map + 优先级队列</h2><p>算法思路：</p><p>定义一个哈希表（ <code>unordered_map</code> ），用于统计数组元素的出现频次，其中，key 为元素值，value 为频次</p><p>定义一个优先级队列，遍历哈希表：</p><ul><li>将哈希表的键值对添加到队列</li><li>若队列长度大于 K ，则从队列中移除频次最少的元素</li></ul><p>从优先级队列中提取出前 K 个高频元素的元素值，将其填充到目标数组中</p><p>代码实现：</p><pre><code class="language-cpp">// 最小化堆的比较函数
class comp &#123;
public:
    bool operator() (const pair&lt;int, int&gt; &amp;LHS, const pair&lt;int, int&gt; &amp;RHS) &#123;
        return LHS.second &gt; RHS.second;
    &#125;
&#125;;

class Solution &#123;
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;
        // 统计数字出现的频次
        unordered_map&lt;int, int&gt; hash;
        for (int i = 0; i &lt; nums.size(); i++)
            hash[nums[i]]++;
        // 利用固定大小为 K 的优先队列扫描哈希表
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, comp&gt; que;
        for (auto it = hash.begin(); it != hash.end(); it++) &#123;
            que.push(*it);
            if (que.size() &gt; k)
                que.pop();
        &#125;
        // 提取出前 K 个高频元素（升序填充到目标数组）
        vector&lt;int&gt; res(k, 0);
        for (int i = 0; i &lt; k; i++) &#123;
            res[i] = que.top().first;
            que.pop();
        &#125;
        return res;
    &#125;
&#125;;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03148em">k</span></span><span class="mclose">)</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 为输出高频元素数</p><ul><li>遍历哈希表的最坏时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>优先级队列的入队 / 出队时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03148em">k</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9xdWV1ZS9wcmlvcml0eV9xdWV1ZS8=">cplusplus：std::priority_queue</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzNDcuJUU1JTg5JThESyVFNCVCOCVBQSVFOSVBQiU5OCVFOSVBMiU5MSVFNSU4NSU4MyVFNyVCNCVBMC5odG1s">代码随想录：前 K 个高频元素</span></li></ul><h1 id="leetcode-394-字符串解码"><a class="anchor" href="#leetcode-394-字符串解码">#</a> LeetCode 394. 字符串解码</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nLw==">394. Decode String</span></p><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code> ，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;3[a]2[bc]&quot;
输出：&quot;aaabcbc&quot;
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;3[a2[c]]&quot;
输出：&quot;accaccacc&quot;
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;
输出：&quot;abcabccdcdcdef&quot;
</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 30</code></li><li><code>s</code> 由小写英文字母、数字和方括号 <code>'[]'</code> 组成</li><li><code>s</code> 保证是一个 <strong>有效</strong> 的输入</li><li><code>s</code> 中所有整数的取值范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>300</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 300]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li></ul><h2 id="method-1-栈-2"><a class="anchor" href="#method-1-栈-2">#</a> Method 1: 栈</h2><p>算法思路：</p><p>利用一个栈来维护字符串中的字母、数字和括号</p><p>遍历字符串 s ：</p><ul><li>如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈</li><li>如果当前的字符为字母或者左括号，直接进栈</li><li>如果当前的字符为右括号，开始出栈，一直到左括号出栈，将出栈序列拼接成一个字符串；然后再取出栈顶的数字（即，字符串重复出现的次数），根据这个数字和字符串构造新字符串并进栈</li></ul><blockquote><p>为便于拼接目标字符串，可以用 vector 容器来模拟栈操作，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9uL3ppLWZ1LWNodWFuLWppZS1tYS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">string decodeString(string s) &#123;
    string res = &quot;&quot;;
    stack&lt;string&gt; stk;
    int ptr = 0;

    while (ptr &lt; s.size()) &#123;
        char cur = s[ptr];
        if (isdigit(cur)) &#123; // 将数字（重复次数）入栈
            string digit = &quot;&quot;;
            while (isdigit(s[ptr])) &#123; // 解析数字
                digit.push_back(s[ptr]);
                ++ptr;
            &#125;
            stk.push(digit);
        &#125; else if (isalpha(cur) || cur == '[') &#123; // 将字母和左括号入栈
            stk.push(string(1, cur));
            ++ptr;
        &#125; else &#123; // 遇到右括号，将与之匹配的左括号及括号中间的字符出栈
            string tmp = &quot;&quot;;
            while (stk.top() != &quot;[&quot;) &#123; // 解析当前括号对所包围的子串
                tmp += stk.top();
                stk.pop();
            &#125;
            stk.pop(); // 出栈：左括号
            int repNum = stoi(stk.top()); // 子串的重复次数
            stk.pop(); // 出栈：重复次数
            string str = &quot;&quot;;
            while (repNum--) // 根据重复次数 repNum 和子串 tmp 解码字符串（例如，由 3 和 a 得到 aaa）
                str += tmp;
            if (stk.empty()) &#123; // 无嵌套情形，可直接将 str 反转然后添加到目标字符串
                reverse(str.begin(), str.end());
                res += str;
            &#125; else &#123; // 可能存在嵌套（例如 &quot;3[a2[c]]&quot;），或者前面有有效字符（例如 &quot;2[abc]ef3[cd]&quot;）
                stk.push(str);
            &#125;
            ++ptr;
        &#125;
    &#125;

    if (!stk.empty()) &#123; // 连接栈内剩余元素，将其反转后添加到目标字符串
        string tmp = &quot;&quot;;
        while (!stk.empty()) &#123;
            tmp += stk.top();
            stk.pop();
        &#125;
        reverse(tmp.begin(), tmp.end());
        res += tmp;
    &#125;

    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert + \vert S \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert s \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span> 是原字符串 s 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert S \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">∣</span></span></span></span> 是解码后得出的字符串 S 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-递归"><a class="anchor" href="#method-2-递归">#</a> Method 2: 递归</h2><p>算法思路：</p><p>定义递归函数，从左向右解析字符串 s ：</p><ul><li>如果当前位置为数字位，后面一定包含一个用方括号表示的字符串，此时可采取以下操作：<ul><li>先解析出一个数字 repNum</li><li>然后解析左括号</li><li>递归解析后面的内容，遇到对应的右括号就返回，得到字母序列 str</li><li>根据字母序列 str 以及重复的次数 repNum 构造新的字符串</li></ul></li><li>如果当前位置是字母位，可直接解析当前字母，然后递归解析后面内容</li></ul><p>代码实现：</p><pre><code class="language-cpp">int getDigits(string&amp; s, int&amp; ptr) &#123; // 从 ptr 位开始提取数字
    int num = 0;
    while (ptr &lt; s.size() &amp;&amp; isdigit(s[ptr])) &#123;
        num = num * 10 + (s[ptr] - '0');
        ++ptr;
    &#125;
    return num;
&#125;

string getString(string&amp; s, int&amp; ptr) &#123;
    if (ptr == s.size() || s[ptr] == ']') return &quot;&quot;;
    string res = &quot;&quot;;
    if (isdigit(s[ptr])) &#123;
        int repNum = getDigits(s, ptr); // 解析 Digits
        ++ptr;                          // 过滤左括号
        string str = getString(s, ptr); // 解析 String
        ++ptr;                          // 过滤右括号
        while (repNum--) res += str;    // 构造目标字符串
    &#125; else if (isalpha(s[ptr])) &#123;
        res = string(1, s[ptr]);        // 解析 Char
        ++ptr;
    &#125;
    return res + getString(s, ptr);
&#125;

string decodeString(string s) &#123;
    int ptr = 0;
    string ans = getString(s, ptr);
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert + \vert S \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert s \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span> 是原字符串 s 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert S \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">∣</span></span></span></span> 是解码后得出的字符串 S 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert s \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，只考虑递归使用的栈空间，不考虑答案所占空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9uL3ppLWZ1LWNodWFuLWppZS1tYS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p><h1 id="leetcode-85-最大矩形"><a class="anchor" href="#leetcode-85-最大矩形">#</a> LeetCode 85. 最大矩形</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXJlY3RhbmdsZS8=">85. Maximal Rectangle</span></p><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/Example1.jpg" alt="" height="200px"></p><pre><code>输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]
输出：6
解释：最大矩形如上图所示。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：matrix = [[&quot;0&quot;]]
输出：0
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：matrix = [[&quot;1&quot;]]
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li>rows == matrix.length</li><li>cols == matrix[i].length</li><li>1 &lt;= row, cols &lt;= 200</li><li>matrix [i][j] 为 '0' 或 '1'</li></ul><h2 id="method-栈-3"><a class="anchor" href="#method-栈-3">#</a> Method: 栈</h2><p>算法思路：</p><p>可以将矩阵拆分成一系列的柱状图，为了计算矩形的最大面积，我们需要计算每个柱状图中的最大矩形面积，并从所有柱状图中找到全局最大值</p><p>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别表示矩阵 matrix 的行数和列数，因此可将矩阵拆分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 个柱状图</p><p>特别地，第 i 个柱状图的范围为矩阵第 0 行至第 i 行，即，matrix [0] 至 matrix [i] ，在该柱状图中，第 j 个柱子的高度为 height [i][j]</p><ul><li>height [i][j] 表示从 (i, 0) 位置开始往下数、以 (i, j) 位置结尾的连续 1 的个数</li></ul><p>其中，某柱状图中的最大矩形面积，可按照 <a href="https://jiankychen.github.io/posts/">LeetCode 84. 柱状图中最大的矩形</a> 中的思路求解</p><p>通过遍历 i（即，遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 个柱状图），求出每一个柱状图的最大矩形面积，即可得出所有柱状图中的最大矩形（即，矩阵中的最大矩形面积）</p><p>代码实现：</p><pre><code class="language-cpp">int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;
    int m = matrix.size();
    int n =matrix[0].size();

    // 预处理，计算每一个柱状图中的每一个柱子高度
    vector&lt;vector&lt;int&gt;&gt; height(m, vector&lt;int&gt;(n, 0));
    for (int i = 0; i &lt; m; i++) &#123;
        for (int j = 0; j &lt; n; j++) &#123;
            if (matrix[i][j] == '1') &#123;
                height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;
            &#125;
        &#125;
    &#125;

    int ans = 0;      // 矩阵中的最大矩形面积
    for (int i = 0; i &lt; m; i++) &#123; // 遍历 m 个柱状图，计算每个柱状图的最大矩形面积
        vector&lt;int&gt; left(n, -1);  // left[j] 表示以 height[j] 为高的矩形的左边界
        vector&lt;int&gt; right(n, n);  // right[j] 表示以 height[j] 为高的矩形的矩形的右边界
        stack&lt;int&gt; stk;           // 单调栈
        for (int j = 0; j &lt; n; j++) &#123; // 维护单调栈，并更新 left 和 right 数组
            while (!stk.empty() &amp;&amp; height[i][stk.top()] &gt;= height[i][j]) &#123;
                right[stk.top()] = j;
                stk.pop();
            &#125;
            if (!stk.empty()) left[j] = stk.top();
            stk.push(j);
        &#125;
        int area = 0; // 第 i 个柱形图的最大矩形面积
        for (int j = 0; j &lt; n; j++) &#123;
            area = max(area, height[i][j] * (right[j] - left[j] - 1));
        &#125;
        ans = max(ans, area); // 更新矩阵的最大矩形面积
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别为矩阵 matrix 的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXJlY3RhbmdsZS9zb2x1dGlvbi96dWktZGEtanUteGluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi1iamx1Lw==">leetcode-solution</span></p><div class="tags"><a href="/tags/%E9%98%9F%E5%88%97/" rel="tag"><i class="ic i-tag"></i> 队列</a> <a href="/tags/%E6%A0%88/" rel="tag"><i class="ic i-tag"></i> 栈</a></div></div><footer><div class="meta"><span class="item"><time title="修改时间：2024-03-23 01:16:15" itemprop="dateModified" datetime="2024-03-23T01:16:15+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2024-03-23 </time></span><span id="posts/51f34f0/" class="item leancloud_visitors" data-flag-title="LeetCode - 栈与队列专题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/51f34f0/" title="LeetCode - 栈与队列专题">https://jiankychen.github.io/posts/51f34f0/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/36b55f59/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;a1f3404a5032323ea4857ac5a6354d2f.jpg" title="KMP 算法"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Data Structure</span><h3>KMP 算法</h3></a></div><div class="item right"><a href="/posts/ed3025a8/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;a1f3404a5032323ea4857ac5a6354d2f.jpg" title="LeetCode - 二叉树专题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 二叉树专题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 1047. 删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">Method 1: 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.</span> <span class="toc-text">Method 2: 字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">LeetCode 150. 逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">Method: 栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">LeetCode 155. 最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">Method: 辅助栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">4.</span> <span class="toc-text">LeetCode 20. 有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%A0%88-map"><span class="toc-number">4.2.</span> <span class="toc-text">Method 1: 栈 + map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E6%A0%88"><span class="toc-number">4.3.</span> <span class="toc-text">Method 2: 栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">5.</span> <span class="toc-text">LeetCode 225. 用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">Method: 两个队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><span class="toc-number">5.3.</span> <span class="toc-text">Method: 一个队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-ii"><span class="toc-number">6.</span> <span class="toc-text">LeetCode 227. 基本计算器 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%A0%88-2"><span class="toc-number">6.1.</span> <span class="toc-text">Method: 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">6.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">6.5.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.6.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">LeetCode 232. 用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method"><span class="toc-number">7.2.</span> <span class="toc-text">Method</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">8.</span> <span class="toc-text">LeetCode 239. 滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">8.1.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">8.2.</span> <span class="toc-text">Method 1: 优先队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">8.3.</span> <span class="toc-text">Method 2: 单调队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-347-%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">9.</span> <span class="toc-text">LeetCode 347. 前 K 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%93%88%E5%B8%8C-map-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">9.2.</span> <span class="toc-text">Method: 哈希 map + 优先级队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">10.</span> <span class="toc-text">LeetCode 394. 字符串解码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%A0%88-2"><span class="toc-number">10.1.</span> <span class="toc-text">Method 1: 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E9%80%92%E5%BD%92"><span class="toc-number">10.2.</span> <span class="toc-text">Method 2: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-number">11.</span> <span class="toc-text">LeetCode 85. 最大矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%A0%88-3"><span class="toc-number">11.1.</span> <span class="toc-text">Method: 栈</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/1b7ed9b4/" rel="bookmark" title="LeetCode Records">LeetCode Records</a></li><li><a href="/posts/32d5c1f6/" rel="bookmark" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></li><li><a href="/posts/2057f45/" rel="bookmark" title="LeetCode - 数组专题">LeetCode - 数组专题</a></li><li><a href="/posts/bc32ab1e/" rel="bookmark" title="LeetCode - 链表专题">LeetCode - 链表专题</a></li><li><a href="/posts/29abbd18/" rel="bookmark" title="LeetCode - 哈希表专题">LeetCode - 哈希表专题</a></li><li><a href="/posts/36947f98/" rel="bookmark" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></li><li class="active"><a href="/posts/51f34f0/" rel="bookmark" title="LeetCode - 栈与队列专题">LeetCode - 栈与队列专题</a></li><li><a href="/posts/ed3025a8/" rel="bookmark" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></li><li><a href="/posts/6012cc6b/" rel="bookmark" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></li><li><a href="/posts/f3b1f59f/" rel="bookmark" title="LeetCode - 贪心专题">LeetCode - 贪心专题</a></li><li><a href="/posts/5e11e767/" rel="bookmark" title="LeetCode - 动态规划专题">LeetCode - 动态规划专题</a></li><li><a href="/posts/611c1217/" rel="bookmark" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></li><li><a href="/posts/691b4be6/" rel="bookmark" title="LeetCode - 单调栈专题">LeetCode - 单调栈专题</a></li><li><a href="/posts/537e2e53/" rel="bookmark" title="LeetCode - 搜索专题">LeetCode - 搜索专题</a></li><li><a href="/posts/242193c5/" rel="bookmark" title="LeetCode - 排序专题">LeetCode - 排序专题</a></li><li><a href="/posts/f994a74a/" rel="bookmark" title="常见输入输出">常见输入输出</a></li><li><a href="/posts/def81c82/" rel="bookmark" title="LeetCode - 模拟专题">LeetCode - 模拟专题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">52</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/36b55f59/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/ed3025a8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/537e2e53/" title="LeetCode - 搜索专题">LeetCode - 搜索专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/850f2080/" title="哈希表">哈希表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/38333d94/" title="C++ 变量和基本类型">C++ 变量和基本类型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/72c3df1c/" title="Dijkstra">Dijkstra</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/242193c5/" title="LeetCode - 排序专题">LeetCode - 排序专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/9e07c79c/" title="C++ 类">C++ 类</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/611c1217/" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/b5c83bc3/" title="初识 C++">初识 C++</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/32d5c1f6/" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/a80d0031/" title="动态规划">动态规划</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">821k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:48</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/51f34f0/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->