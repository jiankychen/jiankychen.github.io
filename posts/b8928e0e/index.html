<!-- build time:Wed Mar 20 2024 23:27:28 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/css/app.css?v=0.2.5"><link rel="canonical" href="https://jiankychen.github.io/posts/b8928e0e/"><title>数据结构简介 - Data Structure | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据结构简介</h1><div class="meta"><span class="item" title="创建时间：2022-03-26 22:28:41"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-26T22:28:41+08:00">2022-03-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>12 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/9b626c5ba21d7cb4dbcba2b507688bbb.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/65d0bfef68566882ce0560cab2e87921.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/470d00578173666b5183f4631e51a421.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/2aabaeb8aca379b991071d1c41632741.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/488297bfd0233b6c6a444f1860e55d45.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a1f3404a5032323ea4857ac5a6354d2f.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Data-Structure/" itemprop="item" rel="index" title="分类于 Data Structure"><span itemprop="name">Data Structure</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/b8928e0e/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><p>数据结构是为实现对计算机数据有效使用的各种数据组织形式，旨在降低各种算法计算的时间与空间复杂度</p><p>常见的数据结构可分为 <em>线性数据结构</em> 与 <em>非线性数据结构</em> ，具体包括：<strong>数组</strong> 、 <strong>链表</strong> 、 <strong>栈</strong> 、 <strong>队列</strong> 、 <strong>树</strong> 、 <strong>图</strong> 、 <strong>散列表</strong> 、 <strong>堆</strong></p><p><img data-src="/posts/b8928e0e/1.png"></p><blockquote><p>不要对数据结构的使用浅尝辄止，而要深挖起内部原理</p></blockquote><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><p>数组是将相同类型的元素存储于 <strong>连续内存空间</strong> 的数据结构，其长度不可变。构建数组时需要在初始化时给定长度，例如：</p><pre><code class="language-cpp">int array[5];

int array[] = &#123;2, 3, 1, 0, 2&#125;;
</code></pre><p>详情可见 <a href="https://jiankychen.github.io/2022/03/05/19-shu-zu/">C++：数组</a></p><p><strong>可变数组</strong> （<strong>标准库类型 <code>vector</code> </strong>）是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：<strong>访问元素</strong>（下标运算符、范围 <code>for</code> 、迭代器）、<strong>添加元素</strong>（成员函数 <code>push_back</code> ）、<strong>删除元素</strong>（成员函数 <code>erase</code> 和 <code>remove</code> ），例如：</p><pre><code class="language-cpp">vector&lt;int&gt; array = &#123;2，3，1，0，2&#125;;

array.push_back(2);         // 添加元素 2 到末尾

vector&lt;int&gt;::iterator it;   // 迭代器
it = array.begin() + 4;     // it 指向第 5 个元素
array.erase(it);            // 删除 it 指向的元素
</code></pre><p>详情可见于<br><a href="https://jiankychen.github.io/2022/03/04/17-biao-zhun-ku-lei-xing-vector/">C++：标准库类型 vector</a><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQU5fWkFORzExMjUvYXJ0aWNsZS9kZXRhaWxzLzEyMDY0MjI0Mz9zcG09MTAwMS4yMTAxLjMwMDEuNjY1MC4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnQubm9uZS10YXNrLWJsb2ctMiU3RWRlZmF1bHQlN0VDVFJMSVNUJTdFUmF0ZS0xLnBjX3JlbGV2YW50X2FhJmFtcDtkZXB0aF8xLXV0bV9zb3VyY2U9ZGlzdHJpYnV0ZS5wY19yZWxldmFudC5ub25lLXRhc2stYmxvZy0yJTdFZGVmYXVsdCU3RUNUUkxJU1QlN0VSYXRlLTEucGNfcmVsZXZhbnRfYWEmYW1wO3V0bV9yZWxldmFudF9pbmRleD0y">vector 删除元素的方法</span></p><h2 id="链表"><a class="anchor" href="#链表">#</a> 链表</h2><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是 <strong>非连续</strong> 的</p><p>每一个节点由两部分组成，一个是数据域，另一个是指针域</p><p>链表的入口节点称为头节点，即， <code>head</code></p><h3 id="链表的类型"><a class="anchor" href="#链表的类型">#</a> 链表的类型</h3><h4 id="单链表"><a class="anchor" href="#单链表">#</a> 单链表</h4><p>单链表中，每个节点的指针域存放的是指向下一个节点的指针，最后一个节点的指针域指向 <code>null</code></p><p><img data-src="/posts/b8928e0e/2-1.png"></p><p>单链表的节点对象具有两个成员变量：<strong>值</strong> <code>val</code> 、 <strong>后继节点指针</strong> <code>next</code></p><p>单链表中的节点只能指向节点的下一个节点</p><h4 id="双链表"><a class="anchor" href="#双链表">#</a> 双链表</h4><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点</p><p><img data-src="/posts/b8928e0e/2-2.png"></p><p>双链表既可以向前查询，又可以向后查询</p><h4 id="循环链表"><a class="anchor" href="#循环链表">#</a> 循环链表</h4><p>链表首尾相连</p><p><img data-src="/posts/b8928e0e/2-3.png"></p><p>循环链表可以用来解决约瑟夫环问题</p><h3 id="链表的存储方式"><a class="anchor" href="#链表的存储方式">#</a> 链表的存储方式</h3><p>链表在内存空间中的分布并不是连续的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理</p><p>链表通过指针域的指针来链接在内存中的各个节点</p><h3 id="链表的定义"><a class="anchor" href="#链表的定义">#</a> 链表的定义</h3><p>以单链表为例，定义链表的节点：</p><pre><code class="language-cpp">// 单链表
struct ListNode &#123;
    int val;        // 节点值
    ListNode *next; // 后继节点指针
    ListNode(int x) : val(x), next(NULL) &#123;&#125; // 节点的构造函数
&#125;;


// // Definition for singly-linked list.
// struct ListNode &#123;
//     int val;
//     ListNode *next;
//     ListNode() : val(0), next(nullptr) &#123;&#125;
//     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
//     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
// &#125;;
</code></pre><p>C++ 默认会生成一个构造函数，但是这个构造函数不会初始化任何成员变量</p><p>如果不自行定义构造函数，而仅仅使用默认构造函数，那么在初始化的时候就不能直接给变量赋值</p><pre><code class="language-cpp">// 自行定义构造函数时节点的初始化操作
ListNode* head = new ListNode(5);

// 使用默认构造函数时节点的初始化操作
ListNode* head = new ListNode();
head-&gt;val = 5;
</code></pre><p>建立链表需要实例化每个节点，并构建各节点的引用指向</p><p>注：需要用箭头运算符（ <code>-&gt;</code> ），其含义为 解引用 + 成员访问</p><h3 id="链表的操作"><a class="anchor" href="#链表的操作">#</a> 链表的操作</h3><h4 id="删除节点"><a class="anchor" href="#删除节点">#</a> 删除节点</h4><p>以删除 D 节点为例：只要将 C 节点的 <code>next</code> 指针 指向 E 节点即可</p><p><img data-src="/posts/b8928e0e/2-4.png" title="删除节点"></p><p>注意，D 节点依然留在内存中，只不过是没有在这个链表里而已。可以再手动释放这个 D 节点的这块内存</p><h4 id="插入节点"><a class="anchor" href="#插入节点">#</a> 插入节点</h4><p>以插入 F 节点为例：将 C 节点的 <code>next</code> 指针指向 F 节点，并将 F 节点的 <code>next</code> 指针指向 D 节点<br><img data-src="/posts/b8928e0e/2-5.png" title="插入节点"></p><p>可以看出链表的增添和删除都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 操作，也不会影响到其他节点</p><p>但是要注意，若要删除第五个节点，需要从头节点查找到第四个节点通过 <code>next</code> 指针进行删除操作，查找的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="性能分析"><a class="anchor" href="#性能分析">#</a> 性能分析</h3><p>链表与数组的特性对比：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">插入 / 删除操作的时间复杂度</th><th style="text-align:center">查询操作的时间复杂度</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">数组</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">数据量固定，频繁查询，较少增删</td></tr><tr><td style="text-align:center">链表</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">数据量不固定，频繁增删，较少查询</td></tr></tbody></table><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFOSU5MyVCRSVFOCVBMSVBOCVFNyU5MCU4NiVFOCVBRSVCQSVFNSU5RiVCQSVFNyVBMSU4MC5odG1sIyVFNSU4RCU5NSVFOSU5MyVCRSVFOCVBMSVBOA==">代码随想录：链表理论基础</span></p><h2 id="stl"><a class="anchor" href="#stl">#</a> STL</h2><p>STL 是 Standard Template Library 的简称，即，标准模板库</p><p>STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分</p><p>在 C++ 标准中，STL 被组织为下面的 13 个头文件: <code>&lt;algorithm&gt;</code> 、 <code>&lt;deque&gt;</code> 、 <code>&lt;functional&gt;</code> 、 <code>&lt;iterator&gt;</code> 、 <code>&lt;vector&gt;</code> 、 <code>&lt;list&gt;</code> 、 <code>&lt;map&gt;</code> 、 <code>&lt;memory&gt;</code> 、 <code>&lt;numeric&gt;</code> 、 <code>&lt;queue&gt;</code> 、 <code>&lt;set&gt;</code> 、 <code>&lt;stack&gt;</code> 和 <code>&lt;utility&gt;</code></p><p>STL 的版本很多，其中，三个最为普遍的 STL 版本：</p><ul><li><p>HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。其他版本的 C++ STL 一般是以 HP STL 为蓝本实现出来的。不过，现在已经很少直接使用此版本的 STL 了</p></li><li><p>PJ STL（全称为 P.J. Plauger STL）由 P.J.Plauger 参照 HP STL 实现出来的，是 HP STL 的一个继承版本。PJ STL 被 Visual C++ 编译器所采用，但不是开源的</p></li><li><p>SGI STL 也是 HP STL 的一个继承版本，和 HP STL 一样，SGI STL 也是开源的，其源代码的可读性可非常好。被 Linux 下的 C++ 编译器 GCC 所采用</p></li></ul><p>接下来介绍的 栈 和 队列 也是 SGI STL 里面的数据结构</p><h2 id="栈"><a class="anchor" href="#栈">#</a> 栈</h2><p>栈（stack）是一种具有 <strong>后进先出</strong>（last in first out）特点的抽象数据结构，使用前需要引入 <code>stack</code> 头文件</p><p>栈不提供迭代器，也不允许遍历</p><p>栈依赖于底层容器完成所有工作，对外提供统一的接口。其中，底层容器是可插拔的，即，我们可以控制使用何种容器来实现栈的功能</p><p>因此，在 STL 中，栈往往不被归类为 容器 ，而被归类为 容器适配器（container adapter）</p><p>栈的底层实现可以是 <code>vector</code> ， <code>deque</code> ， <code>list</code> ，主要使用 数组 和 链表 的底层实现。<strong>对于 SGI STL ，如果不指定，则默认使用 <code>deque</code> 作为底层容器</strong></p><blockquote><p><code>deque</code> 是一个双向队列，，只要封住一端、开通另一端，即可实现栈的逻辑</p></blockquote><p>我们可以指定 vector 为栈的底层实现，其初始化语句为：</p><pre><code>std::stack&lt;int, std::vector&lt;int&gt;&gt; stk; // 使用 vector 为底层容器的栈
</code></pre><p>栈常用的成员函数：</p><ul><li><p><code>push()</code> ：在最顶层加入元素</p></li><li><p><code>pop()</code> ：移除顶层元素</p></li><li><p><code>top()</code> ：返回最顶层数据的值，但不移除它</p></li><li><p><code>empty()</code> ：判断栈是否为空</p></li><li><p><code>size()</code> ：返回栈的大小</p></li></ul><p>须注意：</p><ul><li><p><strong><code>pop()</code> 没有返回值</strong></p></li><li><p><strong><code>top()</code> 具有返回值，并且，可以通过 <code>top()</code> 修改栈顶元素值，即， <code>top()</code> 可以作为左值</strong></p></li></ul><p>参考：<span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGFjay9zdGFjay8/a3c9c3RhY2s=">cplusplus：std::stack</span></p><p>如下图所示，通过 <strong>入栈</strong> <code>push()</code> ，<strong>出栈</strong> <code>pop()</code> ，展示了栈的先入后出特性</p><pre><code class="language-cpp">stack&lt;int&gt; stk;
stk.push(1); // 元素 1 入栈
stk.push(2); // 元素 2 入栈
stk.pop();   // 元素 2 出栈
stk.pop();   // 元素 1 出栈
</code></pre><p><img data-src="/posts/b8928e0e/3.png"></p><h2 id="队列"><a class="anchor" href="#队列">#</a> 队列</h2><p>队列（queue）是一种具有 <strong>先进先出</strong>（first in first out）特点的抽象数据结构，使用前需先引入 <code>queue</code> 头文件</p><p>队列不提供迭代器，不允许有遍历行为</p><p>STL 队列 也不被归类为 容器 ，而被归类为 容器适配器（container adapter）</p><p>队列的底层实现可以是 <code>deque</code> 和 <code>list</code> 。<strong>对于 SGI STL ，如果不指定，则默认使用 <code>deque</code> 作为底层容器</strong></p><p>可以指定 <code>list</code> 为栈的底层实现，其初始化语句为：</p><pre><code>std::queue&lt;int, std::list&lt;int&gt;&gt; que; // 使用 list 为底层容器
</code></pre><p>队列常用的成员函数：</p><ul><li><p><code>push()</code> ：在队尾插入元素</p></li><li><p><code>pop()</code> ：移除队首元素</p></li><li><p><code>front()</code> ：返回队首元素</p></li><li><p><code>back()</code> ：返回队尾元素</p></li><li><p><code>empty()</code> ：判断队列是否为空</p></li><li><p><code>size()</code> ：返回队列中元素的数量</p></li></ul><p>注意：</p><ul><li><strong><code>pop()</code> 没有返回值</strong></li><li><strong><code>front()</code> 具有返回值，并且，可以通过 <code>front()</code> 修改队首元素值，即， <code>front()</code> 可以作为左值</strong></li></ul><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9xdWV1ZS9xdWV1ZS8=">cplusplus：std::queue</span></p><p>如下图所示，通过常用操作 <strong>入队</strong> <code>push()</code> ，<strong>出队</strong> <code>pop()</code> ，展示了队列的先入先出特性</p><pre><code class="language-cpp">queue&lt;int&gt; que;
que.push(1); // 元素 1 入队
que.push(2); // 元素 2 入队
que.pop();   // 出队 -&gt; 元素 1
que.pop();   // 出队 -&gt; 元素 2
</code></pre><p><img data-src="/posts/b8928e0e/4.png"></p><p>此外， <code>queue</code> 还提供了一些运算符。较为常用的是：使用赋值运算符 <code>=</code> 为 <code>queue</code> 赋值</p><p>例如</p><pre><code class="language-cpp">queue&lt;int&gt; q1, q2;
q1.push(1);
q2 = q1;
cout &lt;&lt; q2.front() &lt;&lt; endl;
</code></pre><h3 id="双端队列"><a class="anchor" href="#双端队列">#</a> 双端队列</h3><h3 id="循环队列"><a class="anchor" href="#循环队列">#</a> 循环队列</h3><p>可参考 <span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9kcy9xdWV1ZS8=">OI Wiki：队列</span></p><h2 id="树"><a class="anchor" href="#树">#</a> 树</h2><p>树是一种非线性数据结构，根据子节点数量可分为 <strong>二叉树</strong> 和 <strong>多叉树</strong> ，最顶层的节点称为 <strong>根节点</strong> <code>root</code></p><p>以二叉树为例，每个节点包含三个成员变量：<strong>值</strong> <code>val</code> 、<strong>左子节点</strong> <code>left</code> 、<strong>右子节点</strong> <code>right</code></p><p>二叉树节点的定义：</p><pre><code class="language-cpp">struct TreeNode &#123;
    int val;         // 节点值
    TreeNode *left;  // 左子节点
    TreeNode *right; // 右子节点
    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
&#125;;
</code></pre><p>访问成员变量时需要用箭头运算符（ <code>-&gt;</code> ），其含义为 解引用 + 成员访问</p><p>建立二叉树需要实例化每个节点，并构建各节点的子节点指针</p><p>例如：</p><pre><code class="language-cpp">// 初始化节点
TreeNode *n1 = new TreeNode(3); // 根节点 root
TreeNode *n2 = new TreeNode(4);
TreeNode *n3 = new TreeNode(5);

// 构建子节点指针
n1-&gt;left = n2;
n1-&gt;right = n3;
</code></pre><p>详情可见 <a href="https://jiankychen.github.io/posts/e85d694a">二叉树</a></p><h2 id="堆"><a class="anchor" href="#堆">#</a> 堆</h2><p>堆是一种基于 <strong>完全二叉树</strong> 的数据结构，可使用数组实现</p><p>以堆为原理的排序算法称为 <strong>堆排序</strong> ，基于堆实现的数据结构为 <strong>优先级队列</strong></p><p><strong>优先级队列</strong> ：结点之间的关系是由结点的优先级决定的，而不是由入队的先后次序决定。优先级高的先出队，优先级低的后出队</p><p>堆分为 <strong>最小化堆</strong> 和 <strong>最大化堆</strong></p><ul><li>最大化堆 ：任意节点的值小于等于其父节点的值（根节点最大）</li><li>最小化堆 ：任意节点的值大于等于其父节点的值（根节点最小）</li></ul><p>通过使用 <strong>优先级队列</strong> 的 <strong>压入</strong> <code>push()</code> 和 <strong>弹出</strong> <code>pop()</code> 操作，即可完成 <strong>堆排序</strong></p><pre><code class="language-cpp">
// 初始化最小化堆
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;

// 元素入堆
heap.push(1);
heap.push(4);
heap.push(2);
heap.push(6);
heap.push(8);

// 元素出堆（从小到大）
heap.pop(); // -&gt; 1
heap.pop(); // -&gt; 2
heap.pop(); // -&gt; 4
heap.pop(); // -&gt; 6
heap.pop(); // -&gt; 8
</code></pre><p>详情可见 <a href="https://jiankychen.github.io/posts/a21107fc">优先级队列</a></p><h2 id="哈希表"><a class="anchor" href="#哈希表">#</a> 哈希表</h2><p>哈希表（Hash table ，也被称为散列表）是根据关键码的值而直接进行访问的数据结构</p><p>哈希表可以近似理解成数组，哈希表中的关键码就是数组的索引下标，通过下标可以直接访问数组的元素</p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合当中</strong></p><h3 id="哈希函数"><a class="anchor" href="#哈希函数">#</a> 哈希函数</h3><p>哈希函数（hash function）以关键码的值为参数，将关键码映射为哈希表的索引，即，函数的值即为存储元素的下标</p><h3 id="哈希碰撞"><a class="anchor" href="#哈希碰撞">#</a> 哈希碰撞</h3><p>哈希碰撞是指：不同的关键码映射到同一个地址</p><p>两种解决方案：</p><ul><li>线性探测法：当散列发生冲突时，探测下一个单元，直到发现一个空单元，于是元素将存储在该空单元</li><li>拉链法：将碰撞的节点组成一个链表</li></ul><h3 id="常见的哈希结构"><a class="anchor" href="#常见的哈希结构">#</a> 常见的哈希结构</h3><p>三种哈希结构</p><ul><li>数组</li><li>set （集合）</li><li>map （映射）</li></ul><p>详情可见 <a href="https://jiankychen.github.io/posts/850f2080">哈希表</a></p><h2 id="图"><a class="anchor" href="#图">#</a> 图</h2><p>图是一种非线性结构，由 <strong>顶点</strong> <code>vertex</code> 和 <strong>边</strong> <code>edge</code> 组成</p><p>根据边是否区分方向，图可分为 <strong>有向图</strong> 和 <strong>无向图</strong> ， 这里以无向图为例进行介绍</p><p>如下图所示，此无向图的 顶点 和 边 集合分别为</p><ul><li><p>顶点集合： <code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></p></li><li><p>边集合： <code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;</code></p></li></ul><p><img data-src="/posts/b8928e0e/6.png"></p><p>表示图的方法通常有两种：</p><ol><li><p>邻接矩阵 ：使用数组 <code>vertices</code> 存储顶点，邻接矩阵 <code>edges</code> 存储边。其中， <code>edges[i][j]</code> 表示节点 <code>vertices[i]</code> 和节点 <code>vertices[j]</code> 之间是否有边</p><pre><code class="language-cpp">int vertices[5] = &#123;1, 2, 3, 4, 5&#125;;
int edges[5][5] = &#123;&#123;0, 1, 1, 1, 1&#125;,
                    &#123;1, 0, 0, 1, 0&#125;,
                    &#123;1, 0, 0, 0, 1&#125;,
                    &#123;1, 1, 0, 0, 1&#125;,
                    &#123;1, 0, 1, 1, 0&#125;&#125;;
</code></pre></li><li><p>邻接表 ：使用数组 <code>vertices</code> 存储顶点，邻接表 <code>edges</code> 存储边。其中， <code>edges</code> 是一个二维容器，第一维的 i 代表顶点 <code>vertices[i]</code> ，第二维 <code>edges[i]</code> 存储顶点 <code>vertices[i]</code> 对应的边集合，例如， <code>edges[0] = [1,2,3,4]</code> 表示 <code>vertices[0]</code> 的边集合为 <code>[1,2,3,4]</code></p><pre><code class="language-cpp">int vertices[5] = &#123;1, 2, 3, 4, 5&#125;;
vector&lt;vector&lt;int&gt;&gt; edges;

vector&lt;int&gt; edge_1 = &#123;1, 2, 3, 4&#125;;
vector&lt;int&gt; edge_2 = &#123;0, 3&#125;;
vector&lt;int&gt; edge_3 = &#123;0, 4&#125;;
vector&lt;int&gt; edge_4 = &#123;0, 1, 4&#125;;
vector&lt;int&gt; edge_5 = &#123;0, 2, 3&#125;;
edges.push_back(edge_1);
edges.push_back(edge_2);
edges.push_back(edge_3);
edges.push_back(edge_4);
edges.push_back(edge_5);
</code></pre></li></ol><blockquote><p>邻接矩阵的大小只与节点数量有关，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 为节点数量</p><p>当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费（此时邻接矩阵为稀疏矩阵）</p><p>因此，<strong>邻接表</strong> 适合存储 <strong>顶点较多、边较少</strong> 的 稀疏图 ，<strong>邻接矩阵</strong> 适合存储 <strong>顶点较少、边较多</strong> 的 稠密图</p></blockquote><p>详情可见 <a href="https://jiankychen.github.io/posts/ee040603">图</a></p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9sZWV0Ym9vay9yZWFkL2lsbHVzdHJhdGlvbi1vZi1hbGdvcml0aG0vNTBlNDQ2Lw==">力扣：图解算法数据结构</span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tLw==">cplusplus</span></li></ul></div><footer><div class="meta"><span class="item"><time title="修改时间：2023-04-29 13:17:01" itemprop="dateModified" datetime="2023-04-29T13:17:01+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2023-04-29 </time></span><span id="posts/b8928e0e/" class="item leancloud_visitors" data-flag-title="数据结构简介" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/b8928e0e/" title="数据结构简介">https://jiankychen.github.io/posts/b8928e0e/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/2b0a159a/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg" title="LeetCode 217. 存在重复元素"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode 217. 存在重复元素</h3></a></div><div class="item right"><a href="/posts/fff72920/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;2aabaeb8aca379b991071d1c41632741.jpg" title="剑指 Offer 05. 替换空格"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>剑指 Offer 05. 替换空格</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">链表的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">循环链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">链表的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.</span> <span class="toc-text">链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.</span> <span class="toc-text">链表的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">2.4.1.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">2.4.2.</span> <span class="toc-text">插入节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl"><span class="toc-number">3.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">5.1.</span> <span class="toc-text">双端队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">循环队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">7.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="toc-number">8.2.</span> <span class="toc-text">哈希碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="toc-number">8.3.</span> <span class="toc-text">常见的哈希结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">9.</span> <span class="toc-text">图</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/e8eb0481/" rel="bookmark" title="二分查找">二分查找</a></li><li><a href="/posts/e85d694a/" rel="bookmark" title="二叉树">二叉树</a></li><li><a href="/posts/7db09267/" rel="bookmark" title="算法复杂度">算法复杂度</a></li><li class="active"><a href="/posts/b8928e0e/" rel="bookmark" title="数据结构简介">数据结构简介</a></li><li><a href="/posts/a444b428/" rel="bookmark" title="排序">排序</a></li><li><a href="/posts/afade57b/" rel="bookmark" title="递推与递归">递推与递归</a></li><li><a href="/posts/a80d0031/" rel="bookmark" title="动态规划">动态规划</a></li><li><a href="/posts/a21107fc/" rel="bookmark" title="优先级队列">优先级队列</a></li><li><a href="/posts/850f2080/" rel="bookmark" title="哈希表">哈希表</a></li><li><a href="/posts/ee040603/" rel="bookmark" title="图">图</a></li><li><a href="/posts/36b55f59/" rel="bookmark" title="KMP 算法">KMP 算法</a></li><li><a href="/posts/b754d2ea/" rel="bookmark" title="回溯">回溯</a></li><li><a href="/posts/72c3df1c/" rel="bookmark" title="Dijkstra">Dijkstra</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">251</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/2b0a159a/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/fff72920/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/38849bf2/" title="LeetCode 530. 二叉搜索树的最小绝对差">LeetCode 530. 二叉搜索树的最小绝对差</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/bed222b7/" title="LeetCode 377. 组合总和 IV">LeetCode 377. 组合总和 IV</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/11ea1840/" title="Python 异常、模块、包">Python 异常、模块、包</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/a80d0031/" title="动态规划">动态规划</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/b45c53f3/" title="LeetCode 100. 相同二叉树">LeetCode 100. 相同二叉树</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/933a3849/" title="LeetCode 1523. 在区间范围内统计奇数数目">LeetCode 1523. 在区间范围内统计奇数数目</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/6b429da4/" title="LeetCode 59. 螺旋矩阵 II">LeetCode 59. 螺旋矩阵 II</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/35c387f3/" title="LeetCode 283. 移动零">LeetCode 283. 移动零</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/f95e67ed/" title="LeetCode 10. 正则表达式匹配">LeetCode 10. 正则表达式匹配</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/9147e73d/" title="LeetCode 117. 填充每个节点的下一个右侧节点指针 II">LeetCode 117. 填充每个节点的下一个右侧节点指针 II</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">814k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:37</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/b8928e0e/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->