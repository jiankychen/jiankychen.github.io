<!-- build time:Sun Oct 22 2023 00:32:55 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/css/app.css?v=0.2.5"><link rel="canonical" href="https://jiankychen.github.io/posts/cddca394/"><title>C++ 字符串、向量和数组 - C++ | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ 字符串、向量和数组</h1><div class="meta"><span class="item" title="创建时间：2022-03-03 09:40:55"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-03T09:40:55+08:00">2022-03-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>39k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:04</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ooo.0x0.ooo/2023/10/22/O7GDqP.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/10/22/O7Gm41.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/10/22/O7Gn2p.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/10/22/O7Ghix.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/10/22/O7Gitj.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/10/22/O7G7bU.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/cddca394/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://s2.loli.net/2023/01/01/hnmYMxBAwF9QelU.jpg"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="命名空间的-using-声明"><a class="anchor" href="#命名空间的-using-声明">#</a> 命名空间的 using 声明</h1><p><code>std::cin</code> 的意思就是要使用命名空间 <code>std</code> 中的名字 <code>cin</code></p><p><code>using</code> 声明具有如下的形式：</p><pre><code class="language-cpp">using namespace::name;
</code></pre><p>一旦声明了上述语句，就可以直接访问命名空间中的名字</p><p>例如：</p><pre><code class="language-cpp">#include &lt;iostream&gt;
// using declaration; when we use the name cin, we get the one from the namespace std
using std::cin;
int main() &#123;
    int i;
    cin &gt;&gt; i;       // ok: cin is a synonym for std::cin
    cout &lt;&lt; i;      // error: no using declaration; we must use the full name
    std::cout &lt;&lt; i; // ok: explicitly use cout from namepsace std
    return 0;
&#125;
</code></pre><p>按照规定，每个 <code>using</code> 声明引入命名空间中的一个成员</p><p>因此，<strong>每个名字都必须有自己独立的声明语句</strong>，而且 <strong>每句话都得以分号结束</strong></p><p>例如：</p><pre><code class="language-cpp">#include &lt;iostream&gt;
// using declarations for names from the standard library
using std::cin;
using std::cout;
using std::endl;
int main() &#123;
    cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; endl;
    int v1, v2;
    cin &gt;&gt; v1 &gt;&gt; v2;
    cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2
        &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; endl;
    return 0;
&#125;
</code></pre><p>一般来说，<strong>头文件不应该使用 <code>using</code> 声明</strong></p><p>因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 <code>using</code> 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，可能产生始料未及的名字冲突</p><h1 id="标准库类型-string"><a class="anchor" href="#标准库类型-string">#</a> 标准库类型 string</h1><p>标准库类型 <code>string</code> 表示可变长的字符序列</p><ul><li>使用 <code>string</code> 类型必须首先包含 <code>string</code> 头文件</li><li>作为标准库的一部分， <code>string</code> 定义在命名空间 <code>std</code> 中</li></ul><pre><code class="language-cpp">#include &lt;string&gt;
using std::string;
</code></pre><h2 id="定义和初始化string对象"><a class="anchor" href="#定义和初始化string对象">#</a> 定义和初始化 string 对象</h2><p><code>string</code> 有两类初始化方式</p><ul><li><p>拷贝初始化（copy initialization）: 使用等号来初始化一个变量，编译器把等号右侧的初始值拷贝到新创建的对象中去</p></li><li><p>直接初始化（direct initialization）: 不使用等号</p></li></ul><p><img data-src="/posts/cddca394/1.png"></p><p>需注意：</p><ol><li><p><code>string</code> 接受无参数的初始化方式：<strong>不论 <code>string</code> 对象定义在函数内还是函数外，默认初始化都是得到空串</strong></p></li><li><p>如果提供了一个 <strong>字符串字面值</strong> ，该字面值中 <strong>除了最后那个空字符外</strong> 的所有字符 都被拷贝到新创建的 <code>string</code> 对象中</p></li></ol><h2 id="string对象上的操作"><a class="anchor" href="#string对象上的操作">#</a> string 对象上的操作</h2><p><code>string</code> 对象的大多数操作：<br><img data-src="/posts/cddca394/2.png"></p><p>其中， <code>is &gt;&gt; s</code> 读取时不包括空格符； <code>getline(is, s)</code> 读取整行，包含空格符</p><h3 id="读写string对象"><a class="anchor" href="#读写string对象">#</a> 读写 string 对象</h3><p>可以使用 IO 操作符读写 <code>string</code> 对象：</p><pre><code class="language-cpp">// Note: #include and using declarations must be added to compile this code
int main()
&#123;
    string s;          // empty string
    cin &gt;&gt; s;          // read a whitespace-separated string into s
    cout &lt;&lt; s &lt;&lt; endl; // write s to the output
    return 0;
&#125;
</code></pre><blockquote><p><strong>在执行读取操作时， <code>string</code> 对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止</strong></p></blockquote><p>如上所述，如果程序的输入是 “　　Hello World！　　”（注意开头和结尾处的空格），则输出将是 “Hello”，没有任何空格</p><p>和内置类型的输入输出操作一样， <code>string</code> 对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写在一起：</p><pre><code class="language-cpp">string s1, s2;
cin &gt;&gt; s1 &gt;&gt; s2; // read first input into s1, second into s2
cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; // write both strings
</code></pre><p>假设给上面这段程序输入与之前一样的内容 “Hello World!”，输出将是 “HelloWorld!”</p><h3 id="读取未知数量的string对象"><a class="anchor" href="#读取未知数量的string对象">#</a> 读取未知数量的 string 对象</h3><pre><code class="language-cpp">int main()
&#123;
    string word;
    while (cin &gt;&gt; word)       // read until end-of-file
        cout &lt;&lt; word &lt;&lt; endl; // write each word followed by a new line
    return 0;
&#125;
</code></pre><p>一旦遇到文件结束标记或非法输入，循环也就结束了</p><h3 id="使用getline读取一整行"><a class="anchor" href="#使用getline读取一整行">#</a> 使用 getline 读取一整行</h3><p><strong><code>getline</code> 能在最终得到的字符串中保留输入时的空白符</strong></p><p><code>getline</code> 函数的参数是一个输入流和一个 <code>string</code> 对象，函数从给定的输入流中读入内容，直到遇到换行符为止（换行符也被读进来了），然后把所读的内容存入到那个 <code>string</code> 对象中去（不存换行符）</p><p><strong><code>getline</code> 只要一遇到换行符就结束读取操作并返回结果</strong>，哪怕输入的一开始就是换行符也是如此。如果输入一开始就是换行符，那么所得的结果就是一个空 <code>string</code></p><p>和输入运算符一样， <code>getline</code> 也会返回它的流参数。因此，也能使用 <code>getline</code> 的结果作为判断的条件：</p><pre><code class="language-cpp">int main() &#123;
    string line;
    // read input a line at a time until end-of-file (EOF)
    while (getline(cin, line))
        cout &lt;&lt; line &lt;&lt; endl;
    return 0;
&#125;
</code></pre><p><strong>触发 <code>getline</code> 函数返回的那个换行符实际上被丢弃掉了，得到的 <code>string</code> 对象中并不包含该换行符</strong></p><h3 id="stringsize_type类型"><a class="anchor" href="#stringsize_type类型">#</a> string::size_type 类型</h3><p><code>size</code> 函数返回 <code>string</code> 对象的长度（即 <code>string</code> 对象中字符的个数），返回的是一个 <code>string::size_type</code> 类型的值</p><blockquote><p><code>string</code> 类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型 <code>size_type</code> 即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字 <code>size_type</code> 是在类 <code>string</code> 中定义的</p></blockquote><p><code>string::size_type</code> 类型的对象，是一个<strong>无符号类型</strong>的值，而且能足够存放下任何 <code>string</code> 对象的大小</p><p><strong>所有用于存放 <code>string</code> 类的 <code>size</code> 函数返回值的变量，都应该是 <code>string::size_type</code> 类型的</strong></p><p>在 C++ 11 新标准中，允许编译器通过 <code>auto</code> 或者 <code>decltype</code> 来推断变量的类型：</p><pre><code class="language-cpp">auto len = line.size(); // len has type string::size_type
</code></pre><p>由于 <code>size</code> 函数返回的是一个无符号整型数，如果在表达式中混用了带符号数和无符号数，将可能产生意想不到的结果。例如，假设 <code>n</code> 是一个具有负值的 <code>int</code> ，则表达式 <code>s.size() &lt; n</code> 的判断结果几乎肯定是 <code>true</code> ，因为负值 <code>n</code> 会自动地转换成一个比较大的无符号值</p><blockquote><p>如果一条表达式中已经有了 <code>size()</code> 函数，就不要再使用 <code>int</code> ，以避免混用 <code>int</code> 和 <code>unsigned</code> 可能带来的问题</p></blockquote><h3 id="比较string对象"><a class="anchor" href="#比较string对象">#</a> 比较 string 对象</h3><p><code>string</code> 类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较 <code>string</code> 对象中的字符，并且对大小写敏感。</p><p>相等性运算符（ <code>==</code> 和 <code>！=</code> ）、关系运算符（ <code>&lt;</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&gt;=</code> ）都依照（大小写敏感的）字典顺序：</p><ol><li>如果两个 <code>string</code> 对象的长度不同，而且较短 <code>string</code> 对象的每个字符都与较长 <code>string</code> 对象对应位置上的字符相同，就说较短 <code>string</code> 对象小于较长 string 对象。</li><li>如果两个 <code>string</code> 对象在某些对应的位置上不一致，则 <code>string</code> 对象比较的结果其实是 <code>string</code> 对象中第一对相异字符比较的结果。</li></ol><h3 id="为string对象赋值"><a class="anchor" href="#为string对象赋值">#</a> 为 string 对象赋值</h3><p>对于 <code>string</code> 类而言，允许把一个对象的值赋给另外一个对象：</p><pre><code class="language-cpp">string st1(10, 'c'), st2; // st1 is cccccccccc; st2 is an empty string
st1 = st2; // assignment: replace contents of st1 with a copy of st2
        // both st1 and st2 are now the empty string
</code></pre><h3 id="两个string对象相加"><a class="anchor" href="#两个string对象相加">#</a> 两个 string 对象相加</h3><p>两个 <code>string</code> 对象相加得到一个新的 <code>string</code> 对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。</p><pre><code class="language-cpp">string s1  = &quot;hello, &quot;, s2 = &quot;world\n&quot;;
string s3 = s1 + s2;   // s3 is hello, world\n
s1 += s2;   // equivalent to s1 = s1 + s2
</code></pre><h3 id="字面值和string对象相加"><a class="anchor" href="#字面值和string对象相加">#</a> 字面值和 string 对象相加</h3><p>标准库允许把字符字面值和字符串字面值转换成 <code>string</code> 对象，所以在需要 <code>string</code> 对象的地方就可以使用这两种字面值来替代。</p><pre><code class="language-cpp">string s1 = &quot;hello&quot;, s2 = &quot;world&quot;; // no punctuation in s1 or s2
string s3 = s1 + &quot;, &quot; + s2 + '\n';
</code></pre><p>当把 <code>string</code> 对象和字符字面值及字符串字面值混在一条语句中使用时，<strong>必须确保每个加法运算符（ <code>+</code> ）的两侧的运算对象至少有一个是 <code>string</code> </strong>：</p><pre><code class="language-cpp">string s4 = s1 + &quot;, &quot;;           // ok: adding a string and a literal
string s5 = &quot;hello&quot; + &quot;, &quot;;      // error: no string operand
string s6 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has a string operand, equivalent to string s6 = (s1 + &quot;, &quot;) + &quot;world&quot;;
string s7 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can't add string literals, equivalent to string s7 = (&quot;hello&quot; + &quot;, &quot;) + s2;
</code></pre><blockquote><p>因为某些历史原因，也为了与 C 兼容，C++ 语言中的字符串字面值并不是标准库类型 <code>string</code> 的对象。切记，字符串字面值与 <code>string</code> 是不同的类型。</p></blockquote><h2 id="处理string对象中的字符"><a class="anchor" href="#处理string对象中的字符">#</a> 处理 string 对象中的字符</h2><p>我们经常需要单独处理 <code>string</code> 对象中的字符，比如检查一个 <code>string</code> 对象是否包含空白，或者把 <code>string</code> 对象中的字母改成小写，再或者查看某个特定的字符是否出现等</p><p>这类处理的一个关键问题是如何获取字符本身。另一个关键问题是要知道能改变某个字符的特性</p><p>在 <code>cctype</code> 头文件中定义了一组标准库函数处理这部分工作:<br><img data-src="/posts/cddca394/3.png"></p><h3 id="使用基于范围的for语句处理每个字符"><a class="anchor" href="#使用基于范围的for语句处理每个字符">#</a> 使用基于范围的 for 语句处理每个字符</h3><p>C++ 11 新标准提供的一种语句： <code>范围 for（range for）</code> 语句。这种语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，其语法形式是：</p><pre><code class="language-cpp">for (declaration : expression)
    statement
</code></pre><p>其中， <code>expression</code> 部分是一个对象，用于表示一个序列。 <code>declaration</code> 部分负责定义一个变量，该变量用于访问序列中的基础元素。每次迭代， <code>declaration</code> 部分的变量会被初始化为 <code>expression</code> 部分的下一个元素值</p><p>一个 <code>string</code> 对象表示一个字符的序列，因此 <code>string</code> 对象可以作为 <code>范围 for</code> 语句中的 <code>expression</code> 部分</p><pre><code class="language-cpp">string str(&quot;some string&quot;);
// print the characters in str one character to a line
for (auto c : str)      // for every char in str
    cout &lt;&lt; c &lt;&lt; endl;  // print the current character followed by a newline
</code></pre><p><code>for</code> 循环把变量 <code>c</code> 和 <code>str</code> 联系了起来。此例中，通过使用 <code>auto</code> 关键字让编译器来决定变量 <code>c</code> 的类型，这里 <code>c</code> 的类型是 <code>char</code> 。每次迭代， <code>str</code> 的下一个字符被拷贝给 <code>c</code> ，因此该循环可以读作 “对于字符串 <code>str</code> 中的每个字符 <code>c</code> ，执行某某操作”</p><p>举个稍微复杂一点的例子，使用 <code>范围for</code> 语句和 <code>ispunct</code> 函数来统计 <code>string</code> 对象中标点符号的个数：</p><pre><code class="language-cpp">string s(&quot;Hello World!!!&quot;);
// punct_cnt has the same type that s.size returns
decltype(s.size()) punct_cnt = 0;
// count the number of punctuation characters in s
for (auto c : s)        // for every char in s
    if (ispunct(c))     // if the character is punctuation
        ++punct_cnt;    // increment the punctuation counter
cout &lt;&lt; punct_cnt
    &lt;&lt; &quot; punctuation characters in &quot; &lt;&lt; s &lt;&lt; endl;
</code></pre><p>程序的输出结果将是： <code>3 punctuation characters in Hello World!!!</code><br>这里我们使用 <code>decltype</code> 关键字声明计数变量 <code>punct_cnt</code> ，它的类型是 <code>s.size</code> 函数返回值的类型，也就是 <code>string：：size_type</code></p><h3 id="使用范围for语句改变字符串中的字符"><a class="anchor" href="#使用范围for语句改变字符串中的字符">#</a> 使用范围 for 语句改变字符串中的字符</h3><p>如果想要改变 <code>string</code> 对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符</p><p>假设我们想要把字符串改写为大写字母的形式，为此，可以使用标准库函数 <code>toupper</code> ，该函数接收一个字符，然后输出其对应的大写形式，程序为：</p><pre><code class="language-cpp">string s(&quot;Hello World!!!&quot;);
// convert s to uppercase
for (auto &amp;c : s)   // for every char in s (note: c is a reference)
    c = toupper(c); // c is a reference, so the assignment changes the char in s
cout &lt;&lt; s &lt;&lt; endl;
</code></pre><p>上述代码的输出结果将是： <code>HELLO WORLD!!!</code><br>每次迭代时，变量 <code>c</code> 引用 <code>string</code> 对象 <code>s</code> 的下一个字符，赋值给 <code>c</code> 也就是在改变 <code>s</code> 中对应字符的值</p><h3 id="只处理一部分字符"><a class="anchor" href="#只处理一部分字符">#</a> 只处理一部分字符</h3><p>要想访问 <code>string</code> 对象中的单个字符有两种方式：</p><ol><li>使用下标</li><li>使用迭代器</li></ol><p>下标运算符（ <code>[ ]</code> ）接收的输入参数是 <code>string::size_type</code> 类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用</p><p><strong><code>string</code> 对象的下标从 0 计起</strong></p><p><code>string</code> 对象的下标必须大于等于 0 而小于 <code>s.size()</code> 。因为 <code>string</code> 对象的下标从 0 计起，最后一个字符的下标应该是 <code>s.size() - 1</code></p><p>下标的值称作 “下标” 或 “索引”</p><p>对于任何一个表达式，只要它的值是一个整型值，它就能作为索引</p><p>如果某个索引是带符号类型的值，将自动转换成由 <code>string::size_type</code> 表达的无符号类型</p><pre><code class="language-cpp">if (!s.empty())            // make sure there's a character to print
    cout &lt;&lt; s[0] &lt;&lt; endl;  // print the first character in s
</code></pre><p>只要字符串未被 <code>const</code> 限定符限制为常量，就能利用下标运算符为字符串中指定位置的字符赋新值</p><p>例如：</p><pre><code class="language-cpp">string s(&quot;some string&quot;);
if (!s.empty())             // make sure there's a character in s[0]
    s[0] = toupper(s[0]);   // assign a new value to the first character in s
</code></pre><p>程序的输出结果将是： <code>Some string</code></p><p>再例如：</p><pre><code class="language-cpp">// process characters in s until we run out of characters or we hit a whitespace
for (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !isspace(s[index]); ++index)
    s[index] = toupper(s[index]); // capitalize the current character
</code></pre><p>程序的输出结果将是： <code>SOME string</code></p><p>在上述程序中， <code>for</code> 循环使用变量 <code>index</code> 作为 <code>s</code> 的下标， <code>index</code> 的类型是由 <code>decltype</code> 关键字决定的</p><p>上例使用了逻辑与运算符（ <code>&amp;&amp;</code> ）：如果参与运算的两个运算对象都为真，则逻辑与结果为真；否则结果为假</p><blockquote><p>对逻辑与运算符（ <code>&amp;&amp;</code> ）而言，C++ 语言规定：只有当左侧运算对象为真时，才会检查右侧运算对象的情况</p></blockquote><p>再次强调，注意检查下标的合法性。一种简便易行的方法是，<strong>总是设下标的类型为 <code>string::size_type</code> </strong>，因为此类型是无符号数，可以确保下标不会小于 0 ，此时，代码只需保证下标小于 <code>size()</code> 的值就可以了</p><h3 id="使用下标执行任意访问"><a class="anchor" href="#使用下标执行任意访问">#</a> 使用下标执行任意访问</h3><p>直接获取对应位置的字符，而不是从前往后依次访问</p><p>编写一个程序把 0 到 15 之间的十进制数转换成对应的十六进制形式：</p><pre><code class="language-cpp">const string hexdigits = &quot;0123456789ABCDEF&quot;; // possible hex digits (Note that it is a const string.)
cout &lt;&lt; &quot;Enter a series of numbers between 0 and 15&quot;
        &lt;&lt; &quot; separated by spaces. Hit ENTER when finished: &quot;
        &lt;&lt; endl;
string result;        // will hold the resulting hexify'd string
string::size_type n;  // hold numbers from the input
while (cin &gt;&gt; n)
    if (n &lt; hexdigits.size())    // ignore invalid input
        result += hexdigits[n];  // fetch the indicated hex digit
cout &lt;&lt; &quot;Your hex number is: &quot; &lt;&lt; result &lt;&lt; endl;
</code></pre><p>假设输入的内容如下： <code>12 0 5 15 8 15</code><br>程序的输出结果将是： <code>Your hex number is: C05F8F</code></p><h2 id="成员函数"><a class="anchor" href="#成员函数">#</a> 成员函数</h2><p><img data-src="/posts/cddca394/string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B01.png"></p><p><img data-src="/posts/cddca394/string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B02.png"></p><p><img data-src="/posts/cddca394/string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B03.png"></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYm95dWFpLmNvbS9sZWFybi9jb3Vyc2VzLzE0OC9sZXNzb25zLzI0ODEvc3RlcHMvMD9mcm9tPXF6">https://www.boyuai.com/learn/courses/148/lessons/2481/steps/0?from=qz</span></p><h1 id="标准库类型-vector"><a class="anchor" href="#标准库类型-vector">#</a> 标准库类型 vector</h1><p>标准库<strong>类型</strong> <code>vector</code> 表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为 <code>vector</code> “容纳着” 其他对象，所以它也常被称作 <code>容器（container）</code></p><p>要想使用 <code>vector</code> ，必须包含适当的头文件:</p><pre><code class="language-cpp">#include &lt;vector&gt;
using std::vector;
</code></pre><p>C++ 语言既有类模板（class template），也有函数模板，其中 <code>vector</code> 是一个类模板</p><p>由 <code>vector</code> 生成的类型必须包含 <code>vector</code> 中元素的类型，例如 <code>vector&lt;int&gt;</code> , <code>vector&lt;vector&lt;int&gt;&gt;</code></p><p>组成 <code>vector</code> 的元素也可以是 <code>vector</code></p><pre><code class="language-cpp">vector&lt;int&gt; ivec;             // ivec holds objects of type int
vector&lt;Sales_item&gt; Sales_vec; // holds Sales_items
vector&lt;vector&lt;string&gt;&gt; file;  // vector whose elements are vectors
</code></pre><p>引用不是对象，所以不存在包含引用的 <code>vector</code></p><h2 id="定义和初始化vector对象"><a class="anchor" href="#定义和初始化vector对象">#</a> 定义和初始化 vector 对象</h2><p><img data-src="/posts/cddca394/4.png"></p><p>可以默认初始化 <code>vector</code> 对象，从而创建一个指定类型的空 <code>vector</code></p><p>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：</p><pre><code class="language-cpp">vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;  // list initialization
vector&lt;string&gt; v2(&quot;a&quot;, &quot;an&quot;, &quot;the&quot;);  // error

vector&lt;int&gt; v3(10, 1); // v3 has ten elements with value 1
vector&lt;int&gt; v4&#123;10, 1&#125;; // v4 has two elements with values 10 and 1
</code></pre><h2 id="向vector对象中添加元素"><a class="anchor" href="#向vector对象中添加元素">#</a> 向 vector 对象中添加元素</h2><p><code>vector</code> 对象直接初始化的方式适用于三种情况：</p><ul><li>初始值已知且数量较少</li><li>初始值是另一个 <code>vector</code> 对象的副本</li><li>所有元素的初始值都一样</li></ul><p>一般情况下，可以先创建一个空 <code>vector</code> ，然后在运行时再利用 <code>vector</code> 的成员函数 <code>push_back</code> 向其中添加元素</p><p><code>push_back</code> 函数：把一个值当成 <code>vector</code> 对象的尾元素，“压到（push）” <code>vector</code> 对象的 “尾端（back）”</p><pre><code class="language-cpp">vector&lt;int&gt; v2;        // empty vector
for (int i = 0; i != 100; ++i)
    v2.push_back(i);    // append sequential integers to v2
// at end of loop v2 has 100 elements, values 0 . . . 99


// read words from the standard input and store them as elements in a vector
string word;
vector&lt;string&gt; text;       // empty vector
while (cin &gt;&gt; word) &#123;
    text.push_back(word);  // append word to text
&#125;
</code></pre><p>需要注意：如果循环体内部包含有向 <code>vector</code> 对象添加元素的语句，则不能使用 <code>范围 for</code> 循环</p><blockquote><p><code>范围 for</code> 语句体内不应改变其所遍历序列的大小</p></blockquote><h2 id="其他vector操作"><a class="anchor" href="#其他vector操作">#</a> 其他 vector 操作</h2><p>除了 <code>push_back</code> 之外， <code>vector</code> 还提供了几种其他操作，大多数都和 <code>string</code> 的相关操作类似:<br><img data-src="/posts/cddca394/5.png"></p><p>例如：</p><pre><code class="language-cpp">vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8,9&#125;;
for (auto &amp;i : v)     // for each element in v (note: i is a reference)
    i *= i;           // square the element value
for (auto i : v)      // for each element in v
    cout &lt;&lt; i &lt;&lt; &quot; &quot;; // print the element
cout &lt;&lt; endl;
</code></pre><p><code>vector</code> 的 <code>size</code> 函数返回 <code>vector</code> 对象中元素的个数，返回值的类型是由 <code>vector</code> 定义的 <code>size_type</code> 类型</p><p>要使用 <code>size_type</code> ，需首先指定它是由哪种类型定义的，对于 <code>vector</code> 而言， <code>vector</code> 对象的类型总是包含着元素的类型:</p><pre><code class="language-cpp">vector&lt;int&gt;::size_type // ok
vector::size_type      // error
</code></pre><h3 id="计算-vector-内对象的索引"><a class="anchor" href="#计算-vector-内对象的索引">#</a> 计算 vector 内对象的索引</h3><p>对于 <code>vector</code> ，可以使用下标运算符获取指定的元素</p><p><code>vector</code> 对象的下标也是从 0 开始计起，下标的类型是相应的 <code>size_type</code> 类型</p><p>此外，也能通过计算得到 <code>vector</code> 内对象的索引，然后直接获取索引位置上的元素：例如，假设有一组成绩的集合，其中成绩的取值是从 0 到 100。以 10 分为一个分数段，要求统计各个分数段各有多少个成绩，其代码实现如下：</p><pre><code class="language-cpp">// count the number of grades by clusters of ten: 0--9, 10--19, . .. 90--99, 100
vector&lt;unsigned&gt; scores(11, 0); // 11 buckets, all initially 0
unsigned grade;
while (cin &gt;&gt; grade) &#123;      // read the grades
    if (grade &lt;= 100)       // handle only valid grades
        ++scores[grade / 10]; // increment the counter for the current cluster
cout &lt;&lt; scores &lt;&lt; endl;
&#125;
</code></pre><p>如果输入的成绩如下： <code>42 65 95 100 39 67 95 76 88 76 83 92 76 93</code> ，则输出的结果应该是： <code>0 0 0 1 1 0 2 3 2 4 1</code></p><h3 id="不能用下标形式添加元素"><a class="anchor" href="#不能用下标形式添加元素">#</a> 不能用下标形式添加元素</h3><p>不能通过 <code>vector</code> 对象的下标形式来添加元素</p><pre><code class="language-cpp">vector&lt;int&gt; ivec;   // empty vector
for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
    ivec[ix] = ix;  // disaster: ivec has no elements
</code></pre><p>如前所述，正确的方法是使用 <code>push_back</code> ：</p><pre><code class="language-cpp">for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
    ivec.push_back(ix);  // ok: adds a new element with value ix
</code></pre><p>注意，这里不能使用范围 <code>for</code> 语句，只能使用传统的 <code>for</code> 循环，因为 <code>vector</code> 序列长度发生变化了</p><p><strong><code>vector</code> 对象（以及 <code>string</code> 对象）的下标运算符可用于访问已存在的元素，但不能用于添加元素</strong></p><blockquote><p>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出（buffer overflow）指的就是这类错误，这也是导致 PC 及其他设备上应用程序出现安全问题的一个重要原因</p></blockquote><p><strong>如果需要对 <code>vector</code> 对象或 <code>string</code> 对象使用 for 语句，则尽量使用范围 for，以免溢出</strong></p><h1 id="迭代器"><a class="anchor" href="#迭代器">#</a> 迭代器</h1><p>除了使用下标运算符来访问 <code>string</code> 对象的字符或 <code>vector</code> 对象的元素以外，也可以使用 <code>迭代器（iterator）</code> 访问</p><p>除了 <code>vector</code> 之外，标准库还定义了其他几种容器。<strong>所有标准库容器都可以使用迭代器</strong>，但是其中只有少数几种才同时支持下标运算符</p><p>严格来说， <code>string</code> 对象不属于容器类型，但是 <code>string</code> 支持很多与容器类型类似的操作，例如，下标运算符、迭代器</p><blockquote><p><code>string</code> 可以理解成 <code>vector&lt;char&gt;</code></p></blockquote><p>类似于指针类型，迭代器提供了对对象的间接访问：使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素</p><h2 id="使用迭代器"><a class="anchor" href="#使用迭代器">#</a> 使用迭代器</h2><p>有迭代器的类型同时拥有名为 <code>begin</code> 和 <code>end</code> 的成员</p><ul><li><code>begin</code> ：返回指向第一个元素（或第一个字符）的迭代器</li><li><code>end</code> ：返回指向尾元素的下一位置的迭代器（一个本不存在的元素）， <code>end</code> 返回的迭代器常被称作<strong>尾后迭代器</strong>或者简称为尾迭代器</li></ul><pre><code class="language-cpp">// the compiler determines the type of b and e
// b denotes the first element and e denotes one past the last element in v
auto b = v.begin(), e = v.end(); // b and e have the same type
</code></pre><p>如果容器为空，则 <code>begin</code> 和 <code>end</code> 返回的是同一个迭代器，都是尾后迭代器</p><p>只要我们知道其支持 <code>begin</code> 和 <code>end</code> ，就可以使用 <code>auto</code> 关键字来定义返回值的类型</p><blockquote><p>注意：试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为</p></blockquote><h3 id="迭代器运算符"><a class="anchor" href="#迭代器运算符">#</a> 迭代器运算符</h3><p><img data-src="/posts/cddca394/6.png"></p><p>注意，<strong> <code>*iter</code> 返回的是迭代器 <code>iter</code> 所指元素的引用</strong>。因此，可以通过 <code>*iter</code> 来修改 <code>iter</code> 所指元素的值</p><pre><code class="language-cpp">string s(&quot;some string&quot;);
if (s.begin() != s.end()) &#123; // make sure s is not empty
    auto it = s.begin();    // it denotes the first character in s
    *it = toupper(*it);     // make that character uppercase
&#125;
</code></pre><p>输出结果将是： <code>Some string</code></p><p>迭代器使用递增（ <code>++</code> ）运算符来从一个元素移动到下一个元素</p><p><strong>因为 <code>end</code> 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作</strong></p><p>例如，把 <code>string</code> 对象中第一个单词改写为大写形式：</p><pre><code class="language-cpp">// process characters in s until we run out of characters or we hit a whitespace
for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)
    *it = toupper(*it); // capitalize the current character
</code></pre><p>输出结果将是： <code>SOME string</code></p><p>使用 <code>==</code> 和 <code>!=</code> 来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同，或者都是同一个容器的尾后迭代器，则它们相等；否则，这两个迭代器不相等</p><blockquote><p>关键概念：泛型编程</p><p>只有 <code>string</code> 和 <code>vector</code> 等一些标准库类型有下标运算符，并不是所有标准库容器都能使用下标运算符访问，但是，所有标准库容器都可以使用迭代器</p><p>大多数的标准库容器都没有定义 <code>&lt;</code> 运算符，但是，所有标准库容器的迭代器都定义了 <code>==</code> 和 <code>!=</code></p><p>因此，只要我们养成使用迭代器和 <code>!=</code> 的习惯，就不用太在意用的到底是哪种容器类型</p></blockquote><h3 id="迭代器类型"><a class="anchor" href="#迭代器类型">#</a> 迭代器类型</h3><p>拥有迭代器的标准库类型使用 <code>iterator</code> 和 <code>const_iterator</code> 来表示迭代器的类型：</p><pre><code class="language-cpp">vector&lt;int&gt;::iterator it; // it can read and write vector&lt;int&gt; elements
string::iterator it2;     // it2 can read and write characters in a string
vector&lt;int&gt;::const_iterator it3; // it3 can read but not write elements
string::const_iterator it4;      // it4 can read but not write characters
</code></pre><p><code>const_iterator</code> 类似于指向常量的指针，只能读取，不能修改它所指元素的值</p><p><code>iterator</code> 的对象可读可写</p><p>如果 <code>vector</code> 对象或 <code>string</code> 对象是一个常量，只能使用 <code>const_iterator</code></p><p>如果 <code>vector</code> 对象或 <code>string</code> 对象不是常量，那么，既能使用 <code>iterator</code> 也能使用 <code>const_iterator</code></p><h3 id="begin-和-end-运算符"><a class="anchor" href="#begin-和-end-运算符">#</a> begin 和 end 运算符</h3><p><code>begin</code> 和 <code>end</code> 返回的具体类型由其所指对象决定:</p><ul><li>如果对象是常量， <code>begin</code> 和 <code>end</code> 返回 <code>const_iterator</code></li><li>如果对象不是常量，返回 <code>iterator</code></li></ul><pre><code class="language-cpp">vector&lt;int&gt; v;
const vector&lt;int&gt; cv;
auto it1 = v.begin();  // it1 has type vector&lt;int&gt;::iterator
auto it2 = cv.begin(); // it2 has type vector&lt;int&gt;::const_iterator
</code></pre><p>为了专门得到 <code>const_iterator</code> 类型的返回值，C++ 11 新标准引入了两个新函数，分别是 <code>cbegin</code> 和 <code>cend</code> ：</p><pre><code class="language-cpp">auto it3 = v.cbegin(); // it3 has type vector&lt;int&gt;::const_iterator
</code></pre><p>函数 <code>cbegin</code> 和 <code>cend</code> 分别返回指向容器第一个元素的迭代器、指向最后元素下一位置的迭代器，返回值都是 <code>const_iterator</code> 类型</p><h3 id="结合解引用和成员访问操作"><a class="anchor" href="#结合解引用和成员访问操作">#</a> 结合解引用和成员访问操作</h3><p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能进一步访问它的成员</p><p>例如，对于一个由字符串组成的 <code>vector</code> 对象来说，要想检查其元素是否为空，令 <code>it</code> 是该 <code>vector</code> 对象的迭代器，只需检查 <code>it</code> 所指字符串是否为空就可以了，其代码如下所示：</p><pre><code class="language-cpp">vector&lt;string&gt; v;
auto it = v.begin();

(*it).empty(); // dereferences it and calls the member empty on the resulting object
</code></pre><p>注意， <code>(*it).empty()</code> 中的圆括号必不可少，该表达式的含义是先对 <code>it</code> 解引用，然后再执行点运算符。如果不加圆括号，点运算符将由 <code>it</code> 来执行，而非 <code>*it</code> :</p><pre><code class="language-cpp">*it.empty();   // error: attempts to fetch the member named empty from it, but it is an iterator and has no member named empty
</code></pre><p>为了简化形如 <code>(*it).empty()</code> 的表达式，C++ 定义了箭头运算符（ <code>-&gt;</code> ）</p><p>箭头运算符把解引用和成员访问两个操作结合在一起，即， <code>it-&gt;mem</code> 和 <code>(*it).mem</code> 表达的意思相同</p><pre><code class="language-cpp">it-&gt;empty;     // it-&gt;mem is a synonym for (* it).mem.
</code></pre><p>例如，下列程序将输出三行 <code>hello the world!!</code></p><pre><code class="language-cpp">// print each line in text up to the first blank line
vector&lt;string&gt; text(3, &quot;hello the world!!&quot;);
for (auto it = text.cbegin(); it != text.cend() &amp;&amp; !it-&gt;empty(); ++it)
    cout &lt;&lt; *it &lt;&lt; endl;
</code></pre><h3 id="某些对-vector-对象的操作会使迭代器失效"><a class="anchor" href="#某些对-vector-对象的操作会使迭代器失效">#</a> 某些对 vector 对象的操作会使迭代器失效</h3><p>虽然 <code>vector</code> 对象可以动态地增长，但是也会有一些副作用：</p><ul><li>不能在 <code>范围 for</code> 循环中向 <code>vector</code> 对象添加元素</li><li>任何一种可能改变 <code>vector</code> 对象容量（capacity，而不是 size）的操作，比如 <code>push_back</code> ，都会使该 <code>vector</code> 对象的迭代器失效</li></ul><p>谨记，<strong>如果循环体内使用了迭代器，就不要向相应的容器中添加元素</strong></p><h2 id="迭代器运算"><a class="anchor" href="#迭代器运算">#</a> 迭代器运算</h2><p>所有标准库容器的迭代器都支持递增运算（令迭代器每次移动一个元素）</p><p>可以用 <code>==</code> 和 <code>!=</code> 对任意标准库类型的两个有效迭代器进行比较</p><p>这些运算被称作迭代器运算（iterator arithmetic）</p><p><code>string</code> 和 <code>vector</code> 的迭代器支持更多的运算：</p><ul><li>迭代器的每次移动可以跨过多个元素</li><li>迭代器支持关系运算</li></ul><p><img data-src="/posts/cddca394/7.png"></p><p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离</p><p>两个迭代器的距离，指的是左侧迭代器向右移动多少位置才能追上右侧迭代器，其类型是名为 <code>difference_type</code> 的带符号整型数，因为这个距离可正可负，所以 <code>difference_type</code> 是带符号类型的</p><p><code>string</code> 和 <code>vector</code> 都定义了 <code>difference_type</code></p><p>使用迭代器运算的一个经典算法是二分查找，例如，在升序数组 <code>text</code> 中寻找 <code>sought</code> ：</p><pre><code class="language-cpp">// text must be sorted
// beg and end will denote the range we're searching
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2; // original midpoint
// while there are still elements to look at and we haven't yet found sought
while (mid != end &amp;&amp; *mid != sought) &#123;
    if (sought &lt; *mid)     // is the element we want in the first half?
        end = mid;         // if so, adjust the range to ignore the second half
    else                   // the element we want is in the second half
        beg = mid + 1;     // start looking with the element just after mid
    mid = beg + (end - beg) / 2;  // new midpoint
&#125;
</code></pre><p>程序定义了三个迭代器： <code>beg</code> 指向搜索范围内的第一个元素、 <code>end</code> 指向尾元素的下一位置、 <code>mid</code> 指向中间的那个元素</p><h1 id="数组"><a class="anchor" href="#数组">#</a> 数组</h1><p>数组是一种类似于标准库类型 <code>vector</code> 的<strong>数据结构</strong>（数组不是类类型）</p><ul><li>与 <code>vector</code> 相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问</li><li>与 <code>vector</code> 不同的地方是，<strong>数组的大小确定不变，不能随意向数组中增加元素</strong></li></ul><blockquote><p>数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后把原数组的所有元素复制到新数组中去</p><p>我们也无法像 <code>vector</code> 那样使用 <code>size</code> 函数直接获取数组的维度：如果是字符数组，可以调用 <code>strlen</code> 函数得到字符串的长度；如果是其他数组，只能使用 <code>sizeof(array) / sizeof(array[0])</code> 的方式计算数组的维度</p></blockquote><p>数组在内存空间的地址是连续的</p><p>数组的元素是不能删的，只能覆盖</p><blockquote><p>严格来讲， <code>vector</code> 是容器，不是数组</p></blockquote><h2 id="定义和初始化内置数组"><a class="anchor" href="#定义和初始化内置数组">#</a> 定义和初始化内置数组</h2><p>数组是一种复合类型，数组的声明形如 <code>int a[d]</code> ，其中 <code>a</code> 是数组的名字， <code>d</code> 是数组的维度， <code>int</code> 是数组所存放对象的类型</p><p>维度，即数组中元素的个数，因此 <strong>必须大于 0 ，必须是一个常量表达式</strong></p><pre><code class="language-cpp">unsigned cnt = 42;          // not a constant expression
constexpr unsigned sz = 42; // constant expression, due to constexpr

int arr[10];                // array of ten ints
int *parr[sz];              // array of 42 pointers to int
string bad[cnt];            // error: cnt is not a constant expression
string strs[get_size()];    // ok if get_size is constexpr, error otherwise
</code></pre><p>默认情况下，数组的元素被默认初始化</p><blockquote><p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值</p></blockquote><p><strong>定义数组时必须指定数组的类型，不允许使用 <code>auto</code> 关键字推断类型</strong></p><p><strong>数组的元素应为对象，因此，不存在引用数组</strong></p><h3 id="显式初始化数组元素"><a class="anchor" href="#显式初始化数组元素">#</a> 显式初始化数组元素</h3><p>可以对数组的元素进行列表初始化，此时，允许忽略数组的维度</p><ul><li>如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来</li><li>如果指明了维度，那么初始值的总数量不应该超出指定的维度<ul><li>如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值</li></ul></li></ul><pre><code class="language-cpp">const unsigned sz = 3;        // constant expression
int ia1[sz] = &#123;0,1,2&#125;;        // array of three ints with values 0, 1, 2
int a2[] = &#123;0, 1, 2&#125;;         // an array of dimension 3
int a3[5] = &#123;0, 1, 2&#125;;        // equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;
string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;; // same as a4[] =  &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;
int a5[2] = &#123;0,1,2&#125;;          // error: too many initializers
</code></pre><h3 id="字符数组的特殊性"><a class="anchor" href="#字符数组的特殊性">#</a> 字符数组的特殊性</h3><p>可以用字符串字面值对字符数组数组初始化，但一定要注意，<strong>字符串字面值</strong> 的结尾处还有一个 <strong>空字符</strong> ，这个空字符也会被拷贝到字符数组中去</p><blockquote><p>单引号内的是字符字面值，双引号内的是字符串字面值</p></blockquote><pre><code class="language-cpp">char a1[] = &#123;'C', '+', '+'&#125;;       // 列表初始化，没有空字符（字符字面值）
char a2[] = &#123;'C', '+', '+', '\0'&#125;; // 列表初始化，含有显式的空字符（字符字面值）
char a3[] = &quot;C++&quot;;                 // 含有空字符（字符串字面值）
const char a4[6] = &quot;Daniel&quot;;       // 错误：没有空间存放空字符（字符串字面值）
</code></pre><h3 id="不允许拷贝和赋值"><a class="anchor" href="#不允许拷贝和赋值">#</a> 不允许拷贝和赋值</h3><p>无法直接通过某一个数组的数组名来初始化其他数组或给其他数组赋值</p><pre><code class="language-cpp">int a[] = &#123;0, 1, 2&#125;; // array of three ints
int a2[] = a;        // error: cannot initialize one array with another
a2 = a;              // error: cannot assign one array to another
</code></pre><p>若需实现数组的拷贝和赋值，需要逐个元素依次拷贝赋值</p><h3 id="理解复杂的数组声明"><a class="anchor" href="#理解复杂的数组声明">#</a> 理解复杂的数组声明</h3><p>可以定义一个存放指针的数组</p><p>因为数组本身就是对象，允许定义数组的指针及数组的引用</p><blockquote><p>不存在引用的数组（即，数组的元素不能是引用），但存在数组的引用（可以定义一个引用来绑定数组）</p></blockquote><pre><code class="language-cpp">int *ptrs[10];            //  ptrs是含有10个元素（整型指针）的数组（注：[]优先级高于*）
int &amp;refs[10];            //  错误: 引用不是对象，不存在引用的数组（注：[]优先级高于&amp;，首先判断refs是一个维度为10的数组，数组的元素的类型是int &amp;，即，引用。由于引用不是对象，故语法错误）
int (*Parray)[10] = &amp;arr; //  Parray指向一个含有10个整数的数组（注：()优先级高于[]，首先分析(*Parray)可知Parray是一个指针，然后考虑右边的[10]，可知Parray指向一个维度为10的数组，最后观察左边，知道数组中的元素为int）
int (&amp;arrRef)[10] = arr;  //  arrRef引用一个含有10个整数的数组（注：()优先级高于[]，arrRef是一个引用，所绑定的对象是一个维度为10的数组，数组中的元素为int）
</code></pre><p>默认情况下，类型修饰符从右向左依次绑定</p><p>对于 <code>ptrs</code> 来说，从右向左理解其含义比较简单：</p><ul><li>首先，定义的是一个大小为 10 的数组，数组的名字是 <code>ptrs</code></li><li>然后可以知道，数组中存放的是指向 <code>int</code> 的指针</li></ul><p>但对于 <code>Parray</code> 而言，由于其定义中包含 <code>()</code> 括号，需要按照由内向外的阅读顺序来理解 <code>Parray</code> 的含义：</p><ul><li>首先是圆括号括起来的部分， <code>*Parray</code> 意味着 <code>Parray</code> 是个指针</li><li>接下来观察右边可以知道， <code>Parray</code> 指向一个维度为 10 的数组</li><li>最后观察左边，数组中的元素是 <code>int</code></li><li>因此， <code>Parray</code> 是一个指针，指向一个 <code>int</code> 数组，其中，数组包含 10 个元素</li></ul><p>同理，对于 <code>int (&amp;arrRef)[10]</code> ，我们按照由内向外的顺序阅读： <code>(&amp;arrRef)</code> 表示 <code>arrRef</code> 是一个引用，它引用的对象是一个维度为 10 的数组，数组中元素的类型是 <code>int</code></p><p>更复杂的：</p><pre><code class="language-cpp">int *(&amp;arry)[10] = ptrs; // array是数组的引用，该数组包含10个指向int的指针
</code></pre><p>首先， <code>()</code> 优先级高于 <code>[]</code> ，知道 <code>arry</code> 是一个引用；其次， <code>[]</code> 优先级高于 <code>*</code> ，结合右边可知， <code>arry</code> 引用的对象是一个维度为 10 的数组；最后观察左边知道，数组元素的类型是指向 <code>int</code> 的指针</p><blockquote><p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读</p></blockquote><h2 id="访问数组元素"><a class="anchor" href="#访问数组元素">#</a> 访问数组元素</h2><p><strong>数组的元素也能使用范围 <code>for</code> 或下标运算符来访问</strong></p><p>注意：<strong>数组的索引从 0 开始</strong></p><p>在使用数组下标的时候，通常将其定义为 <code>size_t</code> 类型： <code>size_t</code> 是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小</p><p><strong><code>size_t</code> 类型定义在 <code>cstddef</code> 头文件中</strong>，这个文件是 C 标准库头文件 <code>stddef.h</code> 的 C++ 版本</p><p>数组除了大小固定这一特点外，其他用法与 <code>vector</code> 基本类似</p><pre><code class="language-cpp">// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100
unsigned scores[11] = &#123;&#125;; // 11 buckets, all value initialized to 0
unsigned grade;
while (cin &gt;&gt; grade) &#123;
    if (grade &lt;= 100)
        ++scores[grade / 10]; // increment the counter for the current cluster
&#125;
</code></pre><p>当需要遍历数组的所有元素时，最好的办法也是使用范围 <code>for</code></p><pre><code class="language-cpp">for (auto i : scores)      // for each counter in scores
    cout &lt;&lt; i &lt;&lt; &quot; &quot;;      // print the value of that counter
cout &lt;&lt; endl;
</code></pre><p>数组的下标应该大于等于 0 并且小于数组的大小</p><blockquote><p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误</p></blockquote><h2 id="指针和数组"><a class="anchor" href="#指针和数组">#</a> 指针和数组</h2><p><strong>使用数组名字时</strong>，编译器一般都会自动将其替换为 <strong>一个指向数组首元素的指针</strong></p><pre><code class="language-cpp">string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;  // array of strings
string *p = &amp;nums[0];   // p points to the first element in nums
string *p2 = nums;      // equivalent to p2 = &amp;nums[0]

int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten ints
auto ia2(ia); // ia2 is an int* that points to the first element in ia
ia2 = 42;     // error: ia2 is a pointer, and we can't assign an int to a pointer
</code></pre><p>尽管 <code>ia</code> 是由 10 个整数构成的数组，但是，当使用 <code>ia</code> 作为初始值时，编译器实际执行的初始化过程类似于下面的形式：</p><pre><code class="language-cpp">auto ia2(&amp;ia[0]);  // now it's clear that ia2 has type int*
</code></pre><p><strong>当使用 <code>decltype</code> 关键字时，上述转换不会发生</strong>，即， <code>decltype(ia)</code> 返回的类型是 由 10 个整数构成的数组</p><pre><code class="language-cpp">// ia3 is an array of ten ints
decltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;   // ia is an array of ints, so is ia3
int *p = ia;
ia3 = p;    // error: can't assign an int* to an array
ia3[4] = i; // ok: assigns the value of i to an element in ia3
</code></pre><h3 id="指向数组元素的指针也是迭代器"><a class="anchor" href="#指向数组元素的指针也是迭代器">#</a> 指向数组元素的指针也是迭代器</h3><p><code>vector</code> 和 <code>string</code> 的迭代器支持的运算，数组的指针全都支持</p><pre><code class="language-cpp">int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;
int *p = arr; // p points to the first element in arr
++p;          // p points to arr[1]
</code></pre><p>因此，使用数组的指针也能遍历数组中的元素。前提是要先获取到指向数组第一个元素的指针，以及 指向数组尾元素下一位置的指针</p><ul><li><p>通过数组名字或者数组中首元素的地址，能得到指向首元素的指针</p></li><li><p>可以设法获取数组尾元素之后的那个并不存在的元素的地址，从而得到指向数组尾元素的下一位置的指针</p><pre><code class="language-cpp">int *e = &amp;arr[10]; // pointer just past the last element in arr
</code></pre><blockquote><p>这里使用下标运算符索引了一个不存在的元素（ <code>arr</code> 有 10 个元素，尾元素所在位置的索引是 9），这个不存在的元素就是用来提供其地址以初始化 <code>e</code></p></blockquote></li></ul><p>可改写此前的循环，令其输出 <code>arr</code> 的全部元素：</p><pre><code class="language-cpp">for (int *b = arr; b != e; ++b)

    cout &lt;&lt; *b &lt;&lt; endl; // print the elements in arr
</code></pre><p>尾后指针不指向具体的元素，因此，<strong>不能对尾后指针执行解引用或递增的操作</strong></p><p><strong>尽管能计算得到尾后指针，但这种用法极易出错</strong></p><h3 id="标准库函数-begin-和-end"><a class="anchor" href="#标准库函数-begin-和-end">#</a> 标准库函数 begin 和 end</h3><p>C++ 11 新标准引入了两个名为 <code>begin</code> 和 <code>end</code> 的函数</p><p><strong><code>begin</code> 和 <code>end</code> 两个函数定义在 <code>iterator</code> 头文件中</strong></p><pre><code class="language-cpp">#include&lt;iterator&gt;
</code></pre><p>这两个函数与容器中的两个同名成员功能类似，但是，由于数组不是类类型，这两个函数并不是数组的成员函数</p><p>因此，调用 <code>begin</code> 和 <code>end</code> 函数时，需要将数组作为它们的参数，例如：</p><pre><code class="language-cpp">int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten ints
int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia);  // pointer one past the last element in ia
</code></pre><pre><code class="language-cpp">// pbeg 指向 arr 第一个元素，end 指向尾后
int *pbeg = begin(arr),  *pend = end(arr);
// 寻找第一个负数
while (pbeg != pend &amp;&amp; *pbeg &gt;= 0)
    ++pbeg;
</code></pre><h3 id="指针运算"><a class="anchor" href="#指针运算">#</a> 指针运算</h3><p>指向数组元素的指针可以执行 <strong>迭代器</strong> 中的所有迭代器运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针上和用在迭代器上意义完全一致</p><p>注意：给指针加上一个整数，需保证新指针仍指向同一数组的某元素，或者指向同一数组的尾元素的下一位置</p><pre><code class="language-cpp">constexpr size_t sz = 5; // #include&lt;cstddef&gt;
int arr[sz] = &#123;1,2,3,4,5&#125;;
int *ip = arr;      // equivalent to int *ip = &amp;arr[0]
int *ip2 = ip + 4;  // ip2 points to arr[4], the last element in arr

// ok: arr is converted to a pointer to its first element; p points one past the end of arr
int *p = arr + sz;  // use caution -- do not dereference!

int *p2 = arr + 10; // error: arr has only 5 elements; p2 has undefined value
</code></pre><p>和迭代器一样，两个指针相减的结果是它们之间的距离，其中，这两个指针必须指向同一个数组当中的元素</p><p>两个指针相减的结果，其类型是一种名为 <code>ptrdiff_t</code> 的标准库类型。和 <code>size_t</code> 一样， <code>ptrdiff_t</code> 也是一种定义在 <code>cstddef</code> 头文件中的机器相关的类型。两个指针相减的差值可能为负值，所以， <code>ptrdiff_t</code> 是一种带符号类型</p><pre><code class="language-cpp">auto n = end(arr) - begin(arr); // n is 5, the number of elements in arr
</code></pre><p>只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较</p><pre><code class="language-cpp">int *b = arr, *e = arr + sz;
while (b &lt; e) &#123;
    // use *b
    ++b;
&#125;
</code></pre><p>如果两个指针分别指向不相关的对象，则不能比较它们</p><pre><code class="language-cpp">int i = 0, sz = 42;
int *p = &amp;i, *e = &amp;sz;
// undefined: p and e are unrelated; comparison is meaningless!
while (p &lt; e)
</code></pre><h3 id="解引用和指针运算的交互"><a class="anchor" href="#解引用和指针运算的交互">#</a> 解引用和指针运算的交互</h3><p>指针加上一个整数所得结果依然是一个指针，如果该指针指向了一个元素，则允许解引用该指针</p><pre><code class="language-cpp">int ia[] = &#123;0,2,4,6,8&#125;; // array with 5 elements of type int
int last = *(ia + 4);   // ok: initializes last to 8, the value of ia[4]
</code></pre><p>表达式 <code>*(ia + 4)</code> 计算 <code>ia</code> 前进 4 个元素后的新地址，解引用该结果指针的效果等价于表达式 <code>ia[4]</code></p><p>相比之下，下列代码少了一个括号，故而是先解引用 <code>ia</code> ，再给解引用的结果加 4</p><pre><code class="language-cpp">last = *ia + 4;  // ok: last = 4, equivalent to ia[0] + 4
</code></pre><h3 id="下标和指针"><a class="anchor" href="#下标和指针">#</a> 下标和指针</h3><p>对数组执行下标运算，其实是对指向数组元素的指针执行下标运算</p><pre><code class="language-cpp">int ia[] = &#123;0,2,4,6,8&#125;;  // array with 5 elements of type int

int i = ia[2];  // ia is converted to a pointer to the first element in ia
                // ia[2] fetches the element to which (ia + 2) points
int *p = ia;    // p points to the first element in ia
i = *(p + 2);   // equivalent to i = ia[2]
</code></pre><p>只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），就可以执行下标运算：</p><pre><code class="language-cpp">int *p = &amp;ia[2];  // p points to the element indexed by 2
int j = p[1];     // p[1] is equivalent to *(p + 1),
                  // p[1] is the same element as ia[3]
int k = p[-2];    // p[-2] is the same element as ia[0]
</code></pre><p>注意，这里的 <code>p</code> 是指向 <code>ia[2]</code> 的指针，对指针 <code>p</code> 执行下标运算时，相当于给指针加上（减去）某整数值，即，对指针进行移动。例如上例的 <code>p[-2]</code> 等价于 <code>*(p - 2)</code> ，也就是 <code>ia[0]</code></p><p>虽然标准库类型 <code>string</code> 和 <code>vector</code> 也能执行下标运算，但是，<strong>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求</strong>。即，内置的下标运算符可以处理负值，当然，结果地址必须指向原指针所指数组中的元素（或是同一数组尾元素的下一位置）</p><h2 id="c-风格字符串"><a class="anchor" href="#c-风格字符串">#</a> C 风格字符串</h2><p>字符串字面值是一种通用结构的实例，这种结构是 C++ 由 C 继承而来的 C 风格字符串（C-stylecharacter string）</p><p><strong>尽管 C++ 支持 C 风格字符串，但在 C++ 程序中最好还是不要使用它们</strong></p><blockquote><p>这是因为 C 风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因</p></blockquote><p>C 风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法</p><h3 id="c-标准库-string-函数"><a class="anchor" href="#c-标准库-string-函数">#</a> C 标准库 string 函数</h3><p>C 风格字符串的处理函数定义在 <code>cstring</code> 头文件中（C 语言头文件 <code>string.h</code> 的 C++ 版本）</p><ul><li><code>strlen(p)</code> （&quot;len&quot; 是指 &quot;length&quot;）</li><li><code>strcmp(p1, p2)</code> （&quot;cmp&quot; 是指 &quot;compare&quot;）</li><li><code>strcat(p1, p2)</code> （&quot;cat&quot; 是指 &quot;concatenate&quot;）</li><li><code>strcpy(p1, p2)</code> （&quot;cpy&quot; 是指 &quot;copy&quot;）</li></ul><p><img data-src="/posts/cddca394/8.png"></p><blockquote><p>所列函数不负责验证其字符串参数</p></blockquote><p><strong>传入此类函数的指针必须指向以空字符作为结束的数组</strong></p><pre><code class="language-cpp">char ca[] = &#123;'C', '+', '+'&#125;;  // not null terminated
cout &lt;&lt; strlen(ca) &lt;&lt; endl;   // disaster: ca isn't null terminated
</code></pre><p>此例中， <code>ca</code> 虽然是一个字符数组，但它不是以空字符作为结束的，因此，上述程序将产生未定义的结果（ <code>strlen</code> 函数可能会沿着 <code>ca</code> 在内存中的位置不断向前寻找，直到遇到空字符才停下来）</p><h3 id="比较字符串"><a class="anchor" href="#比较字符串">#</a> 比较字符串</h3><p>比较两个 C 风格字符串的方法 与 比较标准库 <code>string</code> 对象的方法 大相径庭</p><ul><li><p>比较标准库 <code>string</code> 对象的时候，用的是普通的关系运算符和相等性运算符</p><pre><code class="language-cpp">string s1 = &quot;A string example&quot;;
string s2 = &quot;A different string&quot;;
if (s1 &lt; s2)  // false: s2 is less than s1
</code></pre></li><li><p>如果把这些运算符用在两个 C 风格字符串上，比较的将是指针，而非字符串本身</p><pre><code class="language-cpp">const char ca1[] = &quot;A string example&quot;;
const char ca2[] = &quot;A different string&quot;;
if (ca1 &lt; ca2)  // undefined: compares two unrelated addresses
</code></pre></li></ul><p>正如之前介绍过的，使用数组时，真正用的是指向数组首元素的指针</p><p>因此，上面的 <code>if (ca1 &lt; ca2)</code> 实际是在比较两个 <code>const char *</code> 的值，由于这两个指针指向的并非同一对象，所以将得到未定义的结果</p><p>要想比较两个 C 风格字符串，需要调用 <code>strcmp</code> 函数</p><ul><li>如果两个字符串相等， <code>strcmp</code> 返回 0</li><li>如果前面的字符串较大，返回正值</li><li>如果后面的字符串较大，返回负值</li></ul><pre><code class="language-cpp">if (strcmp(ca1, ca2) &lt; 0) // same effect as string comparison s1 &lt; s2
</code></pre><h3 id="目标字符串的大小由调用者指定"><a class="anchor" href="#目标字符串的大小由调用者指定">#</a> 目标字符串的大小由调用者指定</h3><p>连接或拷贝 C 风格字符串也与标准库 <code>string</code> 对象的同类操作差别很大</p><ul><li><p>要想把刚刚定义的那两个 <code>string</code> 对象 <code>s1</code> 和 <code>s2</code> 连接起来，可以直接写成下面的形式：</p><pre><code class="language-cpp">// initialize largeStr as a concatenation of s1, a space, and s2
string largeStr = s1 + &quot; &quot; + s2;
</code></pre></li><li><p>如果针对 <code>ca1</code> 和 <code>ca2</code> 这两个数组进行同样的操作，就会产生错误。这是因为，表达式 <code>ca1 + ca2</code> 试图将两个指针相加，这样的操作没什么意义，也是非法的</p></li></ul><p>正确的方法是，使用 <code>strcat</code> 函数和 <code>strcpy</code> 函数</p><p>不过要想使用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符</p><p>下面的代码虽然很常见，但是充满了安全风险，极易引发严重错误：</p><pre><code class="language-cpp">// disastrous if we miscalculated the size of largeStr
strcpy(largeStr, ca1);     // copies ca1 into largeStr
strcat(largeStr, &quot; &quot;);     // adds a space at the end of largeStr
strcat(largeStr, ca2);     // concatenates ca2 onto largeStr
</code></pre><p>一个潜在的问题是，在估算 <code>largeStr</code> 所需的空间时，不容易估准，而且， <code>largeStr</code> 所存的内容一旦改变，就必须重新检查其空间是否足够</p><blockquote><p>对大多数应用来说，使用标准库类型 <code>string</code> 要比使用 C 风格字符串更安全、更高效</p></blockquote><h2 id="与旧代码的接口"><a class="anchor" href="#与旧代码的接口">#</a> 与旧代码的接口</h2><p>很多 C++ 程序在标准库出现之前就已经写成了，它们肯定没用到 <code>string</code> 和 <code>vector</code> 类型</p><p>而且，有一些 C++ 程序实际上是与 C 语言或其他语言的接口程序，当然也无法使用 C++ 标准库</p><p>因此，现代的 C++ 程序不得不与那些充满了数组和 / 或 C 风格字符串的代码衔接</p><h3 id="混用-string-对象和-c-风格字符串"><a class="anchor" href="#混用-string-对象和-c-风格字符串">#</a> 混用 string 对象和 C 风格字符串</h3><p>可以使用字符串字面值来初始化 <code>string</code> 对象</p><pre><code class="language-cpp">string s(&quot;Hello World&quot;);  // s holds Hello World
</code></pre><p>更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代</p><ul><li>允许使用以空字符结束的字符数组来初始化 <code>string</code> 对象、为 <code>string</code> 对象赋值</li><li>在 <code>string</code> 对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）</li><li>在 <code>string</code> 对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧的运算对象</li></ul><p>上述性质反过来就不成立了：如果程序的某处需要一个 C 风格字符串，无法直接用 <code>string</code> 对象来代替它。例如，不能用 <code>string</code> 对象直接初始化指向字符的指针</p><p>为了完成该功能， <code>string</code> 专门提供了一个名为 <code>c_str</code> 的成员函数</p><pre><code class="language-cpp">char *str = s; // error: can't initialize a char* from a string
const char *str = s.c_str(); // ok
</code></pre><p><code>c_str</code> 函数的返回值是一个 C 风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个 <code>string</code> 对象的一样</p><p><code>c_str</code> 函数的结果指针的类型是 <code>const char *</code> ，从而确保我们不会改变字符数组的内容</p><p>注意，我们无法保证 <code>c_str</code> 函数返回的数组一直有效，如果后续操作改变了 <code>s</code> 的值，可能会让之前返回的数组失去效用</p><blockquote><p>如果程序想一直都能使用 <code>c_str()</code> 函数返回的数组，最好将该数组重新拷贝一份</p></blockquote><h3 id="使用数组初始化-vector-对象"><a class="anchor" href="#使用数组初始化-vector-对象">#</a> 使用数组初始化 vector 对象</h3><p>此前介绍过，不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用 <code>vector</code> 对象来初始化数组</p><p>但是，允许使用数组来初始化 <code>vector</code> 对象，只需 <strong>指明要拷贝区域的首元素地址和尾后地址</strong> 即可</p><pre><code class="language-cpp">int int_arr[] = &#123;0, 1, 2, 3, 4, 5&#125;;
// ivec has six elements; each is a copy of the corresponding element in int_arr
vector&lt;int&gt; ivec(begin(int_arr), end(int_arr));
// copies three elements: int_arr[1], int_arr[2], int_arr[3]
vector&lt;int&gt; subVec(int_arr + 1, int_arr + 4);
</code></pre><h2 id="尽量使用标准库类型而非数组"><a class="anchor" href="#尽量使用标准库类型而非数组">#</a> 尽量使用标准库类型而非数组</h2><p>使用指针和数组很容易出错</p><ul><li>一部分原因是概念上的问题：指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误</li><li>其他问题则源于语法错误，特别是声明指针时的语法错误</li></ul><p>现代的 C++ 程序应当尽量使用 <code>vector</code> 和迭代器，避免使用内置数组和指针。应该尽量使用 <code>string</code> ，避免使用 C 风格的基于数组的字符串</p><h1 id="多维数组"><a class="anchor" href="#多维数组">#</a> 多维数组</h1><p>严格来说，C++ 语言中没有多维数组，通常所说的多维数组其实是 <strong>数组的数组</strong></p><p>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小</p><pre><code class="language-cpp">int ia[3][4]; // 大小为 3 的数组，每个元素是含有 4 个整数的数组
// array of size 10; each element is a 20-element array whose elements are arrays of 30 ints
int arr[10][20][30] = &#123;0&#125;; // initialize all elements to 0
</code></pre><p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列</p><h2 id="多维数组的初始化"><a class="anchor" href="#多维数组的初始化">#</a> 多维数组的初始化</h2><p><strong>允许使用花括号括起来的一组值初始化多维数组</strong></p><pre><code class="language-cpp">int ia[3][4] = &#123;    // three elements; each element is an array of size 4
    &#123;0, 1, 2, 3&#125;,   // initializers for the row indexed by 0
    &#123;4, 5, 6, 7&#125;,   // initializers for the row indexed by 1
    &#123;8, 9, 10, 11&#125;  // initializers for the row indexed by 2
&#125;;
</code></pre><p>其中，内层嵌套着的花括号并不是必需的</p><p>例如下面的初始化语句，形式上更为简洁，完成的功能和上述代码完全一样：</p><pre><code class="language-cpp">// equivalent initialization without the optional nested braces for each row
int ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;
</code></pre><p>如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：</p><pre><code class="language-cpp">// explicitly initialize only element 0 in each row
int ia[3][4] = &#123; &#123;0&#125;, &#123;4&#125;, &#123;8&#125; &#125;;
</code></pre><p>其他 <strong>未列出的元素执行默认值初始化</strong></p><p>在这种情况下，如果再省略掉内层的花括号，结果就大不一样了:</p><pre><code class="language-cpp">// explicitly initialize row 0; the remaining elements are value initialized
int ix[3][4] = &#123;0, 3, 6, 9&#125;;
</code></pre><p>此时初始化的是第一行的 4 个元素，其他元素被初始化为 0</p><h2 id="多维数组的下标引用"><a class="anchor" href="#多维数组的下标引用">#</a> 多维数组的下标引用</h2><p><strong>可以使用下标运算符来访问多维数组的元素，数组的每个维度对应一个下标运算符</strong></p><p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素</p><p>如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组</p><pre><code class="language-cpp">// assigns the first element of arr to the last element in the last row of ia
ia[2][3] = arr[0][0][0];
int (&amp;row)[4] = ia[1]; // binds row to the second four-element array in ia
</code></pre><p>程序中经常会用到两层嵌套的 <code>for</code> 循环来处理多维数组的元素，例如：</p><pre><code class="language-cpp">constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];   // 12 uninitialized elements
// for each row
for (size_t i = 0; i != rowCnt; ++i) &#123;
    // for each column within the row
    for (size_t j = 0; j != colCnt; ++j) &#123;
        // assign the element's positional index as its value
        ia[i][j] = i * colCnt + j;
    &#125;
&#125;
</code></pre><p>在上例中，外层的 <code>for</code> 循环遍历 <code>ia</code> 的所有元素，注意，这里的元素是一维数组；内层的 <code>for</code> 循环则遍历那些一维数组的整数元素</p><h2 id="使用范围-for-语句处理多维数组"><a class="anchor" href="#使用范围-for-语句处理多维数组">#</a> 使用范围 for 语句处理多维数组</h2><pre><code class="language-cpp">size_t cnt = 0;
for (auto &amp;row : ia)        // for every element in the outer array
    for (auto &amp;col : row) &#123; // for every element in the inner array
        col = cnt;          // give this element the next value
        ++cnt;              // increment cnt
    &#125;
</code></pre><p>要改变数组元素的值，所以得把控制变量 <code>row</code> 和 <code>col</code> 声明成引用类型。第一个 <code>for</code> 循环遍历 <code>ia</code> 的所有元素（大小为 4 的数组），因此 <code>row</code> 的类型就是整数数组的引用；第二个 <code>for</code> 循环遍历那些 4 元素数组中的某一个，因此， <code>col</code> 的类型是整数的引用</p><p>在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做</p><p>举一个例子，考虑如下的循环：</p><pre><code class="language-cpp">for (const auto &amp;row : ia)  // for every element in the outer array
    for (auto col : row)    // for every element in the inner array
        cout &lt;&lt; col &lt;&lt; endl;
</code></pre><p>这个循环中并没有任何写操作，但我们依然将外层循环的控制变量声明成了引用类型，这是 <strong>为了避免数组被自动转成指针</strong></p><p>假设不用引用类型，则循环如下述形式：</p><pre><code class="language-cpp">for (auto row : ia)
    for (auto col : row)
</code></pre><p>程序将无法通过编译</p><p>这是因为：第一个循环遍历 <code>ia</code> 的元素实际是大小为 4 的数组，由于 <code>row</code> 不是引用类型，编译器初始化 <code>row</code> 时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针，这样得到的 <code>row</code> 的类型就是 <code>int*</code> ，显然内层的循环就不合法了</p><p><strong>使用范围 for 语句处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</strong></p><h2 id="指针和多维数组"><a class="anchor" href="#指针和多维数组">#</a> 指针和多维数组</h2><p>使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针</p><p>多维数组实际上是数组的数组，因此，由多维数组名转换得来的指针，实际上是指向第一个内层数组的指针</p><pre><code class="language-cpp">int ia[3][4];     // array of size 3; each element is an array of ints of size 4
int (*p)[4] = ia; // p points to an array of four ints（p 指向 ia 的第一行）
p = &amp;ia[2];       // p now points to the last element in ia（p 指向 ia 的第三行）
</code></pre><p>以 <code>int (*p)[4] = ia</code> 为例：</p><ul><li>对于 <code>=</code> 左侧，首先可以根据 <code>(*p)</code> 知道 <code>p</code> 是一个指针，由 <code>int [4]</code> 可以知道 <code>p</code> 指向的是一个包含 4 个整数的数组</li><li>对于等号右侧， <code>ia</code> 返回的是 <code>&amp;ia[0]</code> ，即 <code>ia[0]</code> 的地址</li><li>因此， <code>p</code> 指向的是 <code>ia[0]</code> ，即 <code>ia</code> 的第一行</li></ul><p>注意，在上述声明中，圆括号必不可少</p><pre><code class="language-cpp">int *ip[4];    // array of pointers to int（[] 优先级高于 * ，故而 ip 是一个数组，其元素为整形指针）
int (*ip)[4];  // pointer to an array of four ints
</code></pre><p>随着 C++ 11 新标准的提出，可以使用 <code>auto</code> 或者 <code>decltype</code> ，以尽可能避免在数组前面加上一个指针类型</p><pre><code class="language-cpp">// print the value of each element in ia, with each inner array on its own line
// p points to an array of four ints
for (auto p = ia; p != ia + 3; ++p) &#123;
    // q points to the first element of an array of four ints; that is, q points to an int
    for (auto q = *p; q != *p + 4; ++q)
        cout &lt;&lt; *q &lt;&lt; ' ';
    cout &lt;&lt; endl;
&#125;
</code></pre><p>在上例中，外层的 <code>for</code> 循环首先声明一个指针 <code>p</code> ，令其指向 <code>ia</code> 的第一个内层数组，然后依次迭代直到 <code>ia</code> 的全部 3 行都处理完为止，其中，递增运算 <code>++p</code> 负责将指针 <code>p</code> 移动到 <code>ia</code> 的下一行</p><p>内层的 <code>for</code> 循环负责输出内层数组所包含的值。它首先令指针 <code>q</code> 指向 <code>p</code> 当前所在行的第一个元素（ <code>p</code> 指向某一个内层数组，则 <code>*p</code> 是一个数组，在使用 <code>*p</code> 时，会被自动地转换成指向首元素的指针）</p><p>使用 <strong>标准库函数 <code>begin</code> 和 <code>end</code> </strong>也能实现同样的功能，而且看起来更简洁一些</p><pre><code class="language-cpp">// p points to the first array in ia
for (auto p = begin(ia); p != end(ia); ++p) &#123;
    // q points to the first element in an inner array
    for (auto q = begin(*p); q != end(*p); ++q)
        cout &lt;&lt; *q &lt;&lt; ' ';   // prints the int value to which q points
    cout &lt;&lt; endl;
&#125;
</code></pre><h2 id="类型别名简化多维数组的指针"><a class="anchor" href="#类型别名简化多维数组的指针">#</a> 类型别名简化多维数组的指针</h2><p>使用类型别名（<strong>处理类型 - 类型别名</strong>）能让 读、写和理解一个指向多维数组的指针 变得简单一些</p><p>例如：</p><pre><code class="language-cpp">using int_array = int[4]; // new style type alias declaration; equivalent typedef declaration: typedef int int_array[4];
// print the value of each element in ia, with each inner array on its own line
for (int_array *p = ia; p != ia + 3; ++p) &#123;
    for (int *q = *p; q != *p + 4; ++q)
        cout &lt;&lt; *q &lt;&lt; ' ';
    cout &lt;&lt; endl;
&#125;
</code></pre><p>程序将类型 “4 个整数组成的数组” 命名为 <code>int_array</code> ，用类型名 <code>int_array</code> 定义外层循环的控制变量（由 <code>*p</code> 知道 <code>p</code> 是一个指针，指向一个包含 4 个整数的数组， <code>q</code> 是一个指向整数的指针）</p><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><code>begin</code> ：是 <code>string</code> 和 <code>vector</code> 的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针</p><p><code>缓冲区溢出（buffer overflow）</code> ：一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括 <code>string</code> 、 <code>vector</code> 和 <code>数组</code> 等</p><p><code>C风格字符串（C-style string）</code> ：以空字符结束的字符数组。字符串字面值是 C 风格字符串，C 风格字符串容易出错</p><p><code>类模板（class template）</code> ：用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个 <code>vector</code> 对象需要指定元素的类型，例如： <code>vector&lt;int&gt;</code> 包含 <code>int</code> 类型的元素</p><p><code>编译器扩展（compiler extension）</code> ：某个特定的编译器为 C++ 语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上</p><p><code>容器（container）</code> ：是一种类型，其对象容纳了一组给定类型的对象。 <code>vector</code> 是一种容器类型</p><p><code>拷贝初始化（copy initialization）</code> ：使用赋值号（ <code>=</code> ）的初始化形式。新创建的对象是初始值的一个副本</p><p><code>difference_type</code> ：由 <code>string</code> 和 <code>vector</code> 定义的一种带符号整数类型，表示两个迭代器之间的距离</p><p><code>直接初始化（direct initialization）</code> ：不使用赋值号（ <code>=</code> ）的初始化形式</p><p><code>empty</code> ：是 <code>string</code> 和 <code>vector</code> 的成员，返回一个布尔值。当对象的大小为 0 时返回真，否则返回假</p><p><code>end</code> ：是 <code>string</code> 和 <code>vector</code> 的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针</p><p><code>getline</code> ：在 <code>string</code> 头文件中定义的一个函数，以一个 <code>istream</code> 对象和一个 <code>string</code> 对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入 <code>string</code> 对象，最后返回 <code>istream</code> 对象。其中换行符读入但是不保留</p><p><code>索引（index）</code> ：是下标运算符使用的值。表示要在 <code>string</code> 对象、 <code>vector</code> 对象或者数组中访问的一个位置</p><p><code>实例化（instantiation）</code> ：编译器生成一个指定的模板类或函数的过程</p><p><code>迭代器（iterator）</code> ：是一种类型，用于访问容器中的元素或者在元素之间移动</p><p><code>迭代器运算（iterator arithmetic）</code> ：是 <code>string</code> 或 <code>vector</code> 的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置</p><p><code>以空字符结束的字符串（null-terminatedstring）</code> ：是一个字符串，它的最后一个字符后面还跟着一个空字符（ <code>'\0'</code> ）</p><p><code>尾后迭代器（off-the-end iterator）</code> ： <code>end</code> 函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一位置</p><p><code>指针运算（pointer arithmetic）</code> ：是指针类型支持的算术运算。指向数组的指针所支持的运算种类与迭代器运算一样</p><p><code>prtdiff_t</code> ：是 <code>cstddef</code> 头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离</p><p><code>push_back</code> ：是 <code>vector</code> 的成员，向 <code>vector</code> 对象的末尾添加元素</p><p><code>范围for语句（range for）</code> ：一种控制语句，可以在值的一个特定集合内迭代</p><p><code>size</code> ：是 <code>string</code> 和 <code>vector</code> 的成员，分别返回字符的数量或元素的数量。返回值的类型是 <code>size_type</code></p><p><code>size_t</code> ：是 <code>cstddef</code> 头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小</p><p><code>size_type</code> ：是 <code>string</code> 和 <code>vector</code> 定义的类型的名字，能存放下任意 <code>string</code> 对象或 <code>vector</code> 对象的大小。在标准库中， <code>size_type</code> 被定义为无符号类型</p><p><code>string</code> ：是一种标准库类型，表示字符的序列</p><p><code>using声明（using declaration）</code> ：令命名空间中的某个名字可被程序直接使用。 <code>using 命名空间::名字</code> ；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分 <code>命名空间::</code></p><p><code>值初始化（value initialization）</code> ：是一种初始化过程。内置类型初始化为 0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值</p><p><code>vector</code> ：是一种标准库类型，容纳某指定类型的一组元素</p><p><code>++运算符（++ operator）</code> ：是迭代器和指针定义的递增运算符。执行 “加 1” 操作使得迭代器指向下一个元素</p><p><code>[ ]运算符（[ ] operator）</code> ：下标运算符。 <code>obj[j]</code> 得到容器对象 <code>obj</code> 中位置 <code>j</code> 的那个元素。索引从 0 开始，第一个元素的索引是 0，尾元素的索引是 <code>obj.size() - 1</code> 。下标运算符的返回值是一个对象。如果 <code>p</code> 是指针、 <code>n</code> 是整数，则 <code>p[n]</code> 与 <code>*(p + n)</code> 等价</p><p><code>-&gt;运算符（-&gt;operator）</code> ：箭头运算符，该运算符综合了解引用操作和点操作。 <code>a-&gt;b</code> 等价于 <code>(*a).b</code></p><p><code>&lt;&lt;运算符（&lt;&lt;operator）</code> ：标准库类型 <code>string</code> 定义的输出运算符，负责输出 <code>string</code> 对象中的字符</p><p><code>&gt;&gt;运算符（&gt;&gt;operator）</code> ：标准库类型 <code>string</code> 定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个 <code>string</code> 对象</p><p><code>!运算符（! operator）</code> ：逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假</p><p><code>&amp;&amp;运算符（&amp;&amp;operator）</code> ：逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象</p><p><code>||运算符（|| operator）</code> ：逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象</p><p>参考：C++ Primer 中文版（第 5 版）</p></div><footer><div class="meta"><span class="item"><time title="修改时间：2023-04-29 13:17:01" itemprop="dateModified" datetime="2023-04-29T13:17:01+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2023-04-29 </time></span><span id="posts/cddca394/" class="item leancloud_visitors" data-flag-title="C++ 字符串、向量和数组" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/cddca394/" title="C++ 字符串、向量和数组">https://jiankychen.github.io/posts/cddca394/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/38333d94/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;10&#x2F;22&#x2F;O7GRmF.jpg" title="C++ 变量和基本类型"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>C++ 变量和基本类型</h3></a></div><div class="item right"><a href="/posts/d91b6109/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;10&#x2F;22&#x2F;O7GRmF.jpg" title="LeetCode 35. 搜索插入位置"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode 35. 搜索插入位置</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84-using-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">命名空间的 using 声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-string"><span class="toc-number">2.</span> <span class="toc-text">标准库类型 string</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">定义和初始化 string 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">string 对象上的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">读写 string 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%9C%AA%E7%9F%A5%E6%95%B0%E9%87%8F%E7%9A%84string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.2.</span> <span class="toc-text">读取未知数量的 string 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8getline%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C"><span class="toc-number">2.2.3.</span> <span class="toc-text">使用 getline 读取一整行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringsize_type%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">string::size_type 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.5.</span> <span class="toc-text">比较 string 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BAstring%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC"><span class="toc-number">2.2.6.</span> <span class="toc-text">为 string 对象赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.2.7.</span> <span class="toc-text">两个 string 对象相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8Cstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.2.8.</span> <span class="toc-text">字面值和 string 对象相加</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">处理 string 对象中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用基于范围的 for 语句处理每个字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E6%94%B9%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">2.3.2.</span> <span class="toc-text">使用范围 for 语句改变字符串中的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%A4%84%E7%90%86%E4%B8%80%E9%83%A8%E5%88%86%E5%AD%97%E7%AC%A6"><span class="toc-number">2.3.3.</span> <span class="toc-text">只处理一部分字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E8%AE%BF%E9%97%AE"><span class="toc-number">2.3.4.</span> <span class="toc-text">使用下标执行任意访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-vector"><span class="toc-number">3.</span> <span class="toc-text">标准库类型 vector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">定义和初始化 vector 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91vector%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.</span> <span class="toc-text">向 vector 对象中添加元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96vector%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">其他 vector 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97-vector-%E5%86%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">计算 vector 内对象的索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%8B%E6%A0%87%E5%BD%A2%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.2.</span> <span class="toc-text">不能用下标形式添加元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">使用迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.1.</span> <span class="toc-text">迭代器运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">迭代器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#begin-%E5%92%8C-end-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.3.</span> <span class="toc-text">begin 和 end 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.4.</span> <span class="toc-text">结合解引用和成员访问操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E5%AF%B9-vector-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">4.1.5.</span> <span class="toc-text">某些对 vector 对象的操作会使迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-number">4.2.</span> <span class="toc-text">迭代器运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.</span> <span class="toc-text">定义和初始化内置数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">5.1.1.</span> <span class="toc-text">显式初始化数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">字符数组的特殊性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">5.1.3.</span> <span class="toc-text">不允许拷贝和赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">5.1.4.</span> <span class="toc-text">理解复杂的数组声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.</span> <span class="toc-text">访问数组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">5.3.</span> <span class="toc-text">指针和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%E4%B9%9F%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">指向数组元素的指针也是迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0-begin-%E5%92%8C-end"><span class="toc-number">5.3.2.</span> <span class="toc-text">标准库函数 begin 和 end</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">5.3.3.</span> <span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">5.3.4.</span> <span class="toc-text">解引用和指针运算的交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">5.3.5.</span> <span class="toc-text">下标和指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.4.</span> <span class="toc-text">C 风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%A0%87%E5%87%86%E5%BA%93-string-%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">C 标准库 string 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.4.2.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%B1%E8%B0%83%E7%94%A8%E8%80%85%E6%8C%87%E5%AE%9A"><span class="toc-number">5.4.3.</span> <span class="toc-text">目标字符串的大小由调用者指定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.5.</span> <span class="toc-text">与旧代码的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E7%94%A8-string-%E5%AF%B9%E8%B1%A1%E5%92%8C-c-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.5.1.</span> <span class="toc-text">混用 string 对象和 C 风格字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-vector-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.2.</span> <span class="toc-text">使用数组初始化 vector 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B%E8%80%8C%E9%9D%9E%E6%95%B0%E7%BB%84"><span class="toc-number">5.6.</span> <span class="toc-text">尽量使用标准库类型而非数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">多维数组的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">多维数组的下标引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4-for-%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.</span> <span class="toc-text">使用范围 for 语句处理多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.4.</span> <span class="toc-text">指针和多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">6.5.</span> <span class="toc-text">类型别名简化多维数组的指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">术语表</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/b5c83bc3/" rel="bookmark" title="初识 C++">初识 C++</a></li><li><a href="/posts/38333d94/" rel="bookmark" title="C++ 变量和基本类型">C++ 变量和基本类型</a></li><li class="active"><a href="/posts/cddca394/" rel="bookmark" title="C++ 字符串、向量和数组">C++ 字符串、向量和数组</a></li><li><a href="/posts/2d2eedc7/" rel="bookmark" title="C++ 表达式">C++ 表达式</a></li><li><a href="/posts/ffed1eef/" rel="bookmark" title="C++ 语句">C++ 语句</a></li><li><a href="/posts/3d6d9e02/" rel="bookmark" title="C++ 函数">C++ 函数</a></li><li><a href="/posts/9e07c79c/" rel="bookmark" title="C++ 类">C++ 类</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://s2.loli.net/2023/01/01/hnmYMxBAwF9QelU.jpg"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">251</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/38333d94/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/d91b6109/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/d81fafae/" title="LeetCode 312. 戳气球">LeetCode 312. 戳气球</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/4491e4cd/" title="LeetCode 152. 乘积最大子数组">LeetCode 152. 乘积最大子数组</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/b8928e0e/" title="数据结构简介">数据结构简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/40131ff6/" title="LeetCode 700. 二叉搜索树中的搜索">LeetCode 700. 二叉搜索树中的搜索</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/bed222b7/" title="LeetCode 377. 组合总和 IV">LeetCode 377. 组合总和 IV</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/b2ace7fe/" title="LeetCode 509. 斐波那契数">LeetCode 509. 斐波那契数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/f9949bc5/" title="LeetCode 589. N 叉树的前序遍历 &#x2F; LeetCode 590. N 叉树的后序遍历">LeetCode 589. N 叉树的前序遍历 / LeetCode 590. N 叉树的后序遍历</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/356d8218/" title="LeetCode 104. 二叉树的最大深度 &#x2F; LeetCode 559. N 叉树的最大深度">LeetCode 104. 二叉树的最大深度 / LeetCode 559. N 叉树的最大深度</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/379f5d4c/" title="LeetCode 69. x 的平方根">LeetCode 69. x 的平方根</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/4cb77bf3/" title="LeetCode 105. 从前序与中序遍历序列构造二叉树">LeetCode 105. 从前序与中序遍历序列构造二叉树</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">814k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:37</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/cddca394/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->