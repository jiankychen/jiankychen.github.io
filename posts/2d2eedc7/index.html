<!-- build time:Wed Mar 20 2024 23:41:11 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://jiankychen.github.io/posts/2d2eedc7/"><title>C++ 表达式 - C++ | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ 表达式</h1><div class="meta"><span class="item" title="创建时间：2022-03-15 22:18:43"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-15T22:18:43+08:00">2022-03-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>26k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>43 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/8fe50780c15461b629c9aeab5a7f2acd.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/470d00578173666b5183f4631e51a421.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/99fb5ff897a82984470abf5e2a235d94.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/488297bfd0233b6c6a444f1860e55d45.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/42bab566f107b9a16542343e0368fb77.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/2d2eedc7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="表达式基础"><a class="anchor" href="#表达式基础">#</a> 表达式基础</h1><p><strong>表达式</strong> 通常由 <strong>运算符</strong> 和 <strong>运算对象</strong> 组成</p><p><strong>字面值</strong> 和 <strong>变量</strong> 是最简单的表达式</p><h2 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h2><p>一元运算符：作用于一个运算对象的运算符，如取地址符 <code>&amp;</code> 和解引用符 <code>*</code></p><p>二元运算符：作用于两个运算对象的运算符，如相等运算符 <code>==</code> 和乘法运算符 <code>*</code></p><p>三元运算符：作用于三个运算对象，如条件运算符 <code>_ ? _ : _</code></p><h3 id="组合运算符和运算对象"><a class="anchor" href="#组合运算符和运算对象">#</a> 组合运算符和运算对象</h3><p>表达式的求值结果，依赖于运算符的 <strong>优先级</strong> 、<strong>结合律</strong> 以及 <strong>运算对象的求值顺序</strong></p><ul><li>优先级：例如， <code>*</code> 优先级高于 <code>+</code></li><li>结合律：通常是从左往右，遇到括号时则是由内到外</li><li>求值顺序：例如， <code>f1() + f2()</code> ，对于 <code>f1()</code> 和 <code>f2()</code> 的计算，没有明确的顺序</li></ul><h3 id="重载运算符"><a class="anchor" href="#重载运算符">#</a> 重载运算符</h3><p>C++ 定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作</p><p>当运算符作用于类类型的运算对象时，用户可以自行定义其含义</p><p>这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载运算符（overloaded operator）</p><p><code>IO</code> 库的 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 运算符以及 <code>string</code> 对象、 <code>vector</code> 对象和迭代器使用的运算符都是重载的运算符</p><p>使用重载运算符时，运算对象的类型和返回值的类型都由该运算符定义</p><p><strong>运算对象的个数、运算符的优先级和结合律都是无法改变的</strong></p><h3 id="左值和右值"><a class="anchor" href="#左值和右值">#</a> 左值和右值</h3><p>C++ 的表达式要么是右值（rvalue，读作 “are-value”），要么就是左值（lvalue，读作 “ell-value”），即，非左即右</p><p>对于 C 语言：左值可以位于赋值语句的左侧，右值则不能</p><p>相比于 C 语言的左值和右值，C++ 会复杂很多：</p><ul><li>右值：取不到地址的表达式</li><li>左值：能取到地址的表达式</li><li>常量对象为代表的左值不能作为赋值语句的左侧运算对象（即，不能修改常量对象的值）</li><li>某些表达式的求值结果是对象，但它们是右值（例如，临时的对象 <code>1 + a</code> 无法取地址，故而是右值）</li></ul><p><strong>当一个对象被用作右值时，用的是对象的值（内容）</strong></p><p><strong>当对象被用作左值时，用的是对象的身份（在内存中的位置）</strong></p><p>在需要右值的地方可以用左值来代替，当一个左值被当成右值使用时，实际使用的是它的内容（值）</p><p>但是，不能把右值当成左值（也就是位置）使用</p><p>常见的运算符：</p><ul><li><p>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也依然是一个左值</p></li><li><p>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值</p></li><li><p>内置解引用运算符、下标运算符、迭代器解引用运算符、 <code>string</code> 和 <code>vector</code> 的下标运算符的求值结果都是左值</p></li><li><p>内置类型和迭代器的递增递减运算符作用于左值运算对象</p></li></ul><p>使用关键字 <code>decltype</code> 时：如果表达式的求值结果是左值， <code>decltype</code> 作用于该表达式（不是变量）将会得到一个引用类型</p><blockquote><p>例如，对于 <code>int *p</code> ，因为解引用运算符（即， <code>*p</code> ）生成左值，所以 <code>decltype(*p)</code> 的结果是引用类型，即 <code>int&amp;</code> ；另一方面，因为取地址运算符（即， <code>&amp;p</code> ）生成右值，所以 <code>decltype(&amp;p)</code> 的结果是 <code>int**</code> ，即，一个指向整型指针的指针</p></blockquote><h2 id="优先级与结合律"><a class="anchor" href="#优先级与结合律">#</a> 优先级与结合律</h2><p>复合表达式（compound expression）是指含有两个或多个运算符的表达式</p><p>计算复合表达式的值，要根据优先级与结合律决定运算符和运算对象的组合方式</p><p>高优先级运算符的运算对象 比 低优先级运算符的运算对象 更为紧密地组合在一起</p><ul><li>例如，乘法和除法的优先级相同且都高于加法的优先级，因此，乘法和除法的运算对象会首先组合在一起，然后才能轮到加法和减法的运算对象</li></ul><p>如果优先级相同，则其组合规则由结合律确定</p><ul><li>算术运算符满足左结合律，即，如果运算符的优先级相同，将按照从左向右的顺序组合运算对象</li></ul><h3 id="括号无视优先级与结合律"><a class="anchor" href="#括号无视优先级与结合律">#</a> 括号无视优先级与结合律</h3><p>括号无视普通的组合规则：在表达式中，括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合</p><pre><code class="language-cpp">// parentheses result in alternative groupings
cout &lt;&lt; (6 + 3) *  (4 / 2 + 2) &lt;&lt; endl;    // prints 36
cout &lt;&lt; ((6 + 3) *  4) / 2 + 2 &lt;&lt; endl;    // prints 20
cout &lt;&lt; 6 + 3 * 4  / (2 + 2) &lt;&lt; endl;      // prints 9
</code></pre><h3 id="优先级与结合律有何影响"><a class="anchor" href="#优先级与结合律有何影响">#</a> 优先级与结合律有何影响</h3><p>优先级会影响程序的正确性</p><pre><code class="language-cpp">int ia[] = &#123;0,2,4,6,8&#125;; // array with five elements of type int
int last = *(ia + 4);   // initializes last to 8, the value of ia [4]
last = *ia + 4;          // last = 4, equivalent to ia [0] + 4
</code></pre><p>结合律对表达式产生影响的一个典型示例是输入输出运算：IO 相关的运算符满足左结合律，因此，可以把几个 IO 运算组合在一条表达式当中</p><pre><code class="language-cpp">cin &gt;&gt; v1 &gt;&gt; v2; // read into v1 and then into v2
</code></pre><h2 id="求值顺序"><a class="anchor" href="#求值顺序">#</a> 求值顺序</h2><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，并且，在大多数情况下，不会明确指定求值的顺序</p><p>例如，对于下列表达式，我们知道 f1 和 f2 一定会在执行乘法之前被调用，但是我们无法知道到底是先调用 f1 还是先调用 f2</p><pre><code class="language-cpp">int i = f1() * f2();
</code></pre><p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为</p><p>例如， <code>&lt;&lt;</code> 运算符没有明确规定何时以及如何对运算对象求值，因此，下面的输出表达式是未定义的</p><pre><code class="language-cpp">int i = 0;
cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i &lt;&lt; endl; // undefined
</code></pre><p>特别地，有 4 种运算符明确规定了运算对象的求值顺序：</p><ul><li>逻辑与（ <code>&amp;&amp;</code> ）运算符：先求左侧运算对象的值，只有当左侧运算对象的值为真时，才继续求右侧运算对象的值</li><li>逻辑或（ <code>||</code> ）运算符</li><li>条件（ <code>? :</code> ）运算符</li><li>逗号（ <code>,</code> ）运算符</li></ul><h3 id="求值顺序-优先级-结合律"><a class="anchor" href="#求值顺序-优先级-结合律">#</a> 求值顺序、优先级、结合律</h3><p>运算对象的求值顺序与优先级和结合律无关</p><p>例如，对于 f () + g () * h () + j () 这一表达式而言</p><ul><li>优先级规定：g () 的返回值和 h () 的返回值相乘</li><li>结合律规定：f () 的返回值先与 g () 和 h () 的乘积相加，所得结果再与 j () 的返回值相加</li><li>这些函数的调用顺序并没有明确规定</li></ul><p>如果 f 、g 、h 和 j 是无关函数，并且，不会改变同一对象的状态，也不执行 IO 任务，那么函数的调用顺序不受限制；反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为</p><p>建议：</p><ul><li>在不确定优先级和结合律的时候，最好加上括号来限定表达式的组合关系</li><li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用该运算对象</li></ul><blockquote><p>特别地，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时，第二条规则无效</p><p>例如，在表达式 <code>*++iter</code> 中，递增运算符改变 iter 的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算</p><p>显然，这是一种很常见的用法，不会造成什么问题</p></blockquote><h1 id="算术运算符"><a class="anchor" href="#算术运算符">#</a> 算术运算符</h1><p>如下所示，<strong>在算术运算符中，优先级最高的是正号和负号，其次是乘法和除法，最低是加法和减法</strong></p><p><img data-src="/posts/2d2eedc7/pic1.png"></p><p>优先级高的运算符比优先级低的运算符组合得更紧密</p><p>以上所有算术运算符都满足 <strong>左结合律</strong> ，即，当优先级相同时，按照从左向右的顺序组合运算对象</p><p>除非另做特殊说明，算术运算符都能作用于任意算术类型以及任意能转换为算术类型的类型</p><p>算术运算符的运算对象和求值结果都是右值</p><p>一元正号运算符、加法运算符和减法运算符都能作用于指针</p><ul><li><p>When applied to a pointer or arithmetic value, unary plus returns a (possibly promoted) copy of the value of its operand.</p></li><li><p>The unary minus operator returns the result of negating a (possibly promoted) copy of the value of its operand.</p></li></ul><pre><code class="language-cpp">int i = 1024;
int k = -i; // i is -1024

bool b = true;
bool b2 = -b; // b2 is true!
</code></pre><p>对大多数运算符而言，布尔类型的运算对象将被提升为 <code>int</code> 类型</p><p>如上所示，布尔变量 b 的值为真，参与运算时将被提升成整数值 1 ，对它求负后的结果是 -1</p><blockquote><p>算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是 0 的情况；另外一部分则源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时就会产生溢出</p></blockquote><p>除法运算符 <code>/</code> 作用于两个整数时，所得结果仍为整数（向 0 取整，即直接切除小数部分）</p><pre><code class="language-cpp">int ival1 = 21/6;  // ival1 is 3; result is truncated; remainder is discarded
int ival2 = 21/7;  // ival2 is 3; no remainder; result is an integral value
</code></pre><p>在除法运算中，如果两个运算对象的符号相同则商为正（如果不为 0 的话），否则商为负</p><p>运算符 <code>%</code> 俗称 “取余” 或 “取模” 运算符，计算两个整数相除所得的余数，其中，参与取余运算的运算对象必须是整数类型</p><pre><code class="language-cpp">int ival = 42;
double dval = 3.14;
ival % 12;   // ok: result is 6
ival % dval; // error: floating-point operand
</code></pre><p>根据取余运算的定义，如果 m 和 n 是整数且 n 非 0 ，则表达式 <code>(m / n) * n + m % n</code> 的求值结果与 m 相等，隐含的意思是，<strong>如果 m % n 不等于 0 ，则它的符号和 m 相同</strong></p><pre><code class="language-cpp"> 21 % 6;   /*  result is 3   */
 21 / 6;   /*  result is 3   */
 21 % 7;   /*  result is 0   */
 21 / 7;   /*  result is 3   */
-21 % -8;  /*  result is -5  */
-21 / -8;  /*  result is 2   */
 21 % -5;  /*  result is 1   */
 21 / -5;  /*  result is -4  */
</code></pre><blockquote><p>C++ 语言的早期版本允许 m % n 的符号匹配 n 的符号，而且 m /n 的结果向负无穷一侧取整，这一方式在新标准中已经被禁止使用了。除了 - m 导致溢出的特殊情况，其他时候 (- m) /n 和 m / (- n) 都等于 - (m /n) ，(- m) % n 和 m % (- n) 都等于 - (m % n)</p></blockquote><h1 id="逻辑和关系运算符"><a class="anchor" href="#逻辑和关系运算符">#</a> 逻辑和关系运算符</h1><p>关系运算符作用于算术类型或指针类型</p><p>逻辑运算符作用于任意能转换成布尔值的类型</p><p>逻辑运算符和关系运算符的返回值都是布尔类型，并且，运算对象和求值结果都是右值</p><p><img data-src="/posts/2d2eedc7/pic2.png"></p><h2 id="逻辑运算符"><a class="anchor" href="#逻辑运算符">#</a> 逻辑运算符</h2><h3 id="逻辑与-逻辑或"><a class="anchor" href="#逻辑与-逻辑或">#</a> 逻辑与、逻辑或</h3><p>逻辑与运算符（ <code>&amp;&amp;</code> ）：当且仅当两个运算对象都为真时，结果为真</p><p>逻辑或运算符（ <code>||</code> ）：只要两个运算对象中的任意一个为真，结果就为真</p><p>逻辑与运算符、逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值</p><ul><li>对于逻辑与运算符，当且仅当左侧运算对象为真时才对右侧运算对象求值</li><li>对于逻辑或运算符，当且仅当左侧运算对象为假时才对右侧运算对象求值</li></ul><blockquote><p>这种策略称为短路求值（short-circuit evaluation</p></blockquote><h3 id="逻辑非"><a class="anchor" href="#逻辑非">#</a> 逻辑非</h3><p>逻辑非运算符（ <code>!</code> ）：将运算对象的值取反后返回</p><h2 id="关系运算符"><a class="anchor" href="#关系运算符">#</a> 关系运算符</h2><p>关系运算符：比较运算对象的大小关系并返回布尔值</p><p>关系运算符都满足左结合律</p><p>由于关系运算符的求值结果是布尔值，将几个关系运算符连写在一起则会产生意想不到的结果：</p><pre><code class="language-cpp">// oops! this condition compares k to the bool result of i &lt; j
if (i &lt; j &lt; k) // true if k is greater than 1!
</code></pre><p>在以上 <code>if</code> 语句的条件中，首先把 i、j 和第一个 <code>&lt;</code> 运算符组合在一起，然后将返回的布尔值作为第二个 <code>&lt;</code> 运算符的左侧运算对象</p><p>正确的用法应该是</p><pre><code class="language-cpp">// ok: condition is true if i is smaller than j and j is smaller than k
if (i &lt; j &amp;&amp; j &lt; k) &#123; /* ...  */ &#125;
</code></pre><h3 id="相等性测试与布尔字面值"><a class="anchor" href="#相等性测试与布尔字面值">#</a> 相等性测试与布尔字面值</h3><p>如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为 <code>if</code> 语句的条件：</p><pre><code class="language-cpp">if (val)  &#123; /*  ...  */ &#125; // true if val is any nonzero value
if (!val) &#123; /*  ...  */ &#125; // true if val is zero
</code></pre><p>在上面的两个条件中，编译器都将 val 转换成布尔值。如果 val 非 0 则第一个条件为真，如果 val 值为 0 则第二个条件为真</p><p>有时会试图将上面的真值测试写成如下形式：</p><pre><code class="language-cpp">if (val == true) &#123; /* ...   */ &#125; // true only if val is equal to 1!
</code></pre><p>但是这种写法存在两个问题：首先，与之前的代码相比，这种写法较长而且不太直接；更重要的一点是，如果 val 不是布尔值，这样的比较就失去了原来的意义</p><p>如果 val 不是布尔值，那么在比较之前会首先把 true 转换成 val 的类型，即，如果 val 不是布尔值，代码可以改写成如下形式：</p><pre><code class="language-cpp">if (val == 1) &#123; /* ... */ &#125;
</code></pre><p>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象</p><blockquote><p>当布尔值转换成其他算术类型时，false 会转换成 0 ，而 true 会转换成 1</p></blockquote><h1 id="赋值运算符"><a class="anchor" href="#赋值运算符">#</a> 赋值运算符</h1><p><strong>赋值运算符的左侧运算对象必须是一个可修改的左值</strong></p><pre><code class="language-cpp">int i = 0, j = 0, k = 0; // initializations, not assignment
const int ci = i;        // initialization, not assignment
 
1024 = k;      // error: literals are rvalues
i + j = k;     // error: arithmetic expressions are rvalues
ci = k;        // error: ci is a const (nonmodifiable) lvalue
</code></pre><p><strong>赋值运算的结果是它的左侧运算对象</strong>，并且，结果的类型就是左侧运算对象的类型</p><p>如果赋值运算符的左右两个运算对象的类型不同，则右侧运算对象将转换成左侧运算对象的类型</p><pre><code class="language-cpp">int k = 0;
k = 3.14159;    //  result: type int, value 3
</code></pre><p>C++ 11 新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象</p><ul><li><p>如果左侧运算对象是内置类型，初始值列表最多只能包含一个值。而且，即使进行类型转换的话，该值所占空间不应该大于目标类型的空间</p></li><li><p>对于类类型而言，赋值运算的细节由类本身决定。例如，vector 模板重载了赋值运算符，并且允许接收初始值列表（当赋值发生时，用右侧运算对象的元素替换左侧运算对象的元素）</p></li></ul><pre><code class="language-cpp">int k = 0;
k = &#123;3.14&#125;;                 // error: narrowing conversion

vector&lt;int&gt; vi;             // initially empty
vi = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // vi now has ten elements, values 0 through 9
</code></pre><p>无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量，并将其赋给左侧运算对象</p><h2 id="赋值运算满足右结合律"><a class="anchor" href="#赋值运算满足右结合律">#</a> 赋值运算满足右结合律</h2><p>与其他二元运算符不同的是，<strong>赋值运算符满足右结合律</strong></p><pre><code class="language-cpp">int ival, jval;
ival = jval = 0; // ok: each assigned 0
</code></pre><p>在上例中，靠右赋值运算 <code>jval = 0</code> 作为靠左赋值运算符的右侧运算对象，因为赋值运算返回的是其左侧运算对象，靠右赋值运算的结果（即 jval ）将会被赋给 ival</p><p>对于多重赋值语句中的每一个对象，它的类型要么与右边对象的类型相同、要么可由右边对象的类型转换得到</p><pre><code class="language-cpp">int ival, *pval; // ival is an int; pval is a pointer to int
ival = pval = 0; // error: cannot assign the value of a pointer to an int

string s1, s2;
s1 = s2 = &quot;OK&quot;;  // string literal &quot;OK&quot; converted to string
</code></pre><p>上例中，ival 和 pval 的类型不同，而且 pval 的类型（ <code>int*</code> ）无法转换成 ival 的类型（ <code>int</code> ），因此，尽管 0 能赋给任何对象，但第一条赋值语句依然是非法的。与之相反，第二条赋值语句是合法的，这是因为字符串字面值可以转换成 <code>string</code> 对象并赋给 s2 ，而 s2 和 s1 的类型相同，所以 s2 的值可以继续赋给 s1</p><h2 id="赋值运算优先级较低"><a class="anchor" href="#赋值运算优先级较低">#</a> 赋值运算优先级较低</h2><p>赋值运算的优先级相对较低，通常需要给赋值部分加上括号使其符合我们的原意</p><p>例如，以下代码</p><pre><code class="language-cpp">// a verbose and therefore more error-prone way to write this loop
int i = get_value();  // get the first value
while (i != 42) &#123;
    // do something ...
    i = get_value();  // get remaining values
&#125;
</code></pre><p>可改写为</p><pre><code class="language-cpp">// a better way to write our loop---what the condition does is now clearer
int i;
while ((i = get_value()) != 42) &#123;
    // do something ...
&#125;
</code></pre><p>与第一个版本相比，第二个版本的 <code>while</code> 条件更容易表达我们的真实意图：不断循环读取数据直至遇到 42 为止。其处理过程为，首先将 get_value 函数的返回值赋给 i ，然后比较 i 和 42 是否相等</p><p>注意，如果不加括号的话，含义会有很大变化：比较运算符 <code>!=</code> 会将 get_value 函数的返回值与 42 进行比较</p><blockquote><p>赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号</p></blockquote><h2 id="切勿混淆相等运算符和赋值运算符"><a class="anchor" href="#切勿混淆相等运算符和赋值运算符">#</a> 切勿混淆相等运算符和赋值运算符</h2><p>C++ 语言允许用赋值运算作为条件</p><p>例如以下语句，在条件部分中，首先把 j 的值赋给 i ，然后检查 i 是否为真。如果 j 不为 0 ，条件将为真</p><pre><code class="language-cpp">if (i = j)
</code></pre><p>然而，下列代码</p><pre><code class="language-cpp">if (i == j)
</code></pre><p>则是在判断 i 与 j 是否相等</p><h2 id="复合赋值运算符"><a class="anchor" href="#复合赋值运算符">#</a> 复合赋值运算符</h2><p>我们经常需要对某个对象施以某种运算，然后再把计算的结果赋给该对象，例如：</p><pre><code class="language-cpp">int sum = 0;
// sum values from 1 through 10 inclusive
for (int val = 1; val &lt;= 10; ++val)
    sum += val; //  equivalent to sum = sum + val
</code></pre><p><strong>复合赋值操作常常应用于算术运算符或者位运算符</strong></p><pre><code class="language-cpp">+=   -=    *=   /=   %=         // 算术运算符

&lt;&lt;=  &gt;&gt;=   &amp;=   ^=   |=         // 位运算符
</code></pre><p>其中，任意一种复合运算符都等价于</p><pre><code class="language-cpp">a = a operator b;
</code></pre><p>唯一区别在于左侧运算对象的求值次数：</p><ul><li>使用复合运算符只求值一次</li><li>使用普通的运算符则求值两次<ul><li>一次是作为右边子表达式的一部分求值</li><li>另一次是作为赋值运算的左侧运算对象求值</li></ul></li></ul><p>当然，这种区别除了对程序性能有些许影响外，几乎可以忽略不计</p><h1 id="递增和递减运算符"><a class="anchor" href="#递增和递减运算符">#</a> 递增和递减运算符</h1><p>递增运算符（ <code>++</code> ）和递减运算符（ <code>--</code> ）分别对运算对象执行加 1 和减 1 操作</p><p>递增运算符和递减运算符可应用于迭代器</p><blockquote><p>很多迭代器本身不支持算术运算，但可以通过递增运算符和递减运算符移动迭代器</p></blockquote><p>递增和递减运算符有两种形式：</p><ul><li>前置版本（prefix）：运算符首先将运算对象加 1（或减 1），然后将改变后的对象作为求值结果</li><li>后置版本（postfix）：将运算对象加 1（或减 1），但是求值结果是运算对象改变之前那个值的副本</li></ul><pre><code class="language-cpp">int i = 0, j;
j = ++i; // j = 1, i = 1
j = i++; // j = 1, i = 2
</code></pre><p>这两种运算符必须作用于左值运算对象</p><ul><li>前置版本将对象本身作为左值返回</li><li>后置版本将对象原始值的副本作为右值返回</li></ul><p>建议：<strong>尽可能使用前置版本的递增和递减运算符</strong></p><ul><li>前置版本的递增运算符把值加 1 后直接返回，避免了不必要的工作</li><li>后置版本需要将原始值存储下来，以便于返回这个未修改的内容</li></ul><blockquote><p>如果我们不需要递增（递减）运算符修改前的值，那么后置版本的操作就是一种浪费</p></blockquote><h2 id="解引用和递增运算符的结合"><a class="anchor" href="#解引用和递增运算符的结合">#</a> 解引用和递增运算符的结合</h2><p>如果在一个表达式中，我们既希望将变量加 1（或减 1）、又希望使用它原来的值，可以使用递增和递减运算符的后置版本</p><pre><code class="language-cpp">auto pbeg = v.begin();
// 输出元素，直到到达尾后或者遇到第一个负数
while (pbeg != v.end() &amp;&amp; *beg &gt;= 0)
    cout &lt;&lt; *pbeg++ &lt;&lt; endl; // 输出当前值，并将 pbeg 向前移动
</code></pre><p>由于 <strong>后置递增运算符的优先级高于解引用运算符</strong> ，在上例中，*pbeg++ 等价于 *(pbeg++)：pbeg++ 把 pbeg 的值加 1，然后返回 pbeg 初始值的副本作为其求值结果，即，解引用运算符的运算对象是 pbeg 未增加时的值</p><p>形如 *pbeg++ 的表达式，可能一开始不太容易理解，但其实这是一种被广泛使用的、有效的写法</p><p>例如， <code>cout &lt;&lt; *iter++ &lt;&lt; endl;</code> 要比下面的等价语句更简洁、也更少出错</p><pre><code class="language-cpp">cout &lt;&lt; *iter &lt;&lt; endl;
++iter;
</code></pre><h3 id="运算对象可按任意顺序求值"><a class="anchor" href="#运算对象可按任意顺序求值">#</a> 运算对象可按任意顺序求值</h3><p>大多数运算符都没有规定运算对象的求值顺序，这在一般情况下不会有什么影响。但是，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了</p><p>递增运算符和递减运算符会改变运算对象的值，因此，需要提防这两个运算符在复合表达式中的使用</p><p>例如，以下程序使用 <code>for</code> 循环将输入的第一个单词改成大写形式，其中，解引用 it 和递增 it 两项任务是分开进行的</p><pre><code class="language-cpp">for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)
    *it = toupper(*it); // capitalize the current character
</code></pre><p>如果将解引用 it 和递增 it 结合到一块，即，如下所示，将产生未定义的行为。这是因为：赋值运算符左右两端的运算对象都用到了 beg ，然而，右侧的运算对象改变了 beg 的值</p><pre><code class="language-cpp">while (beg != s.end() &amp;&amp; !isspace(*beg))
    *beg = toupper(*beg++);   // 错误：该赋值语句未定义
</code></pre><h1 id="成员访问运算符"><a class="anchor" href="#成员访问运算符">#</a> 成员访问运算符</h1><p>点运算符（ <code>.</code> ）和箭头运算符（ <code>&gt;</code> ）可共同用于访问成员，其中，点运算符获取类对象的一个成员，箭头运算符与点运算符有关</p><p>表达式 <code>ptr-&gt;mem</code> 等价于 <code>(*ptr).mem</code></p><pre><code class="language-cpp">string s1 = &quot;a string&quot;, *p = &amp;s1;
auto n = s1.size(); // run the size member of the string s1
n = (*p).size();    // run size on the object to which p points
n = p-&gt;size();      // equivalent to (*p).size()
</code></pre><p>其中，因为 <strong>解引用运算符的优先级低于点运算符</strong> ，执行解引用运算的子表达式两端必须加上括号</p><p>如果不加括号，即：</p><pre><code class="language-cpp">// run the size member of p, then dereference the result!
*p.size();    // error: p is a pointer and has no member named size
</code></pre><p>表达式试图访问对象 p 的 size 成员，然而，p 本身是一个指针且不包含任何成员，所以，上述语句无法通过编译</p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值</p><p>点运算符：</p><ul><li>如果成员所属的对象是左值，那么结果是左值</li><li>如果成员所属的对象是右值，那么结果是右值</li></ul><h1 id="条件运算符"><a class="anchor" href="#条件运算符">#</a> 条件运算符</h1><p>条件运算符（ <code>? :</code> ）可以把简单的 if-else 逻辑嵌入到单个表达式当中</p><p>条件运算符按照如下形式使用：</p><pre><code>cond  ? expr1  : expr2;
</code></pre><p>其中，cond 是判断条件的表达式，而 expr1 和 expr2 是两个类型相同（或者，可以转换为某个公共类型）的表达式</p><p>条件运算符的执行过程是：首先求 cond 的值，如果条件为真，则对 expr1 求值并返回该值，否则，对 expr2 求值并返回该值</p><p>例如，可以使用条件运算符来判断成绩是否合格:</p><pre><code class="language-cpp">string finalgrade = (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;
</code></pre><p>当条件运算符的两个表达式都是左值（或者，能转换成同一种左值类型）时，运算的结果是左值；否则，运算的结果是右值</p><h2 id="嵌套条件运算符"><a class="anchor" href="#嵌套条件运算符">#</a> 嵌套条件运算符</h2><p>允许在条件运算符的内部嵌套另外一个条件运算符</p><p>即，条件表达式可以作为另外一个条件运算符的 cond 或 expr</p><p>例如，可以使用嵌套的条件运算符将成绩分成三档：优秀（high pass）、合格（pass）和不合格（fail）：</p><pre><code class="language-cpp">finalgrade = (grade &gt; 90) ? &quot;high pass&quot;
                          : (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;
</code></pre><p>上述语句首先检查成绩是否在 90 分以上，如果是，执行符号 <code>?</code> 后面的表达式，得到 &quot;high pass&quot; ；如果否，执行符号 <code>:</code> 后面的分支，即，继续检查成绩是否在 60 分以下，如果是，得到 &quot;fail&quot; ；否则，得到 &quot;pass&quot;</p><p><strong>条件运算符满足右结合律，即，运算对象（一般）按照从右向左的顺序组合</strong></p><p>因此，在上面的代码中，靠右边的条件运算（比较成绩是否小于 60）构成了靠左边的条件运算的 <code>:</code> 分支</p><blockquote><p>随着条件运算嵌套层数的增加，代码的可读性急剧下降，因此，条件运算的嵌套最好别超过两到三层</p></blockquote><h2 id="在输出表达式中使用条件运算符"><a class="anchor" href="#在输出表达式中使用条件运算符">#</a> 在输出表达式中使用条件运算符</h2><p>条件运算符的优先级非常低，因此，<strong>当一条长表达式中嵌套了条件运算表达式时，通常需要在它两端加上括号</strong></p><p>例如：有时需要根据条件值输出两个对象中的一个，如果写这条语句时没把括号写全就有可能产生意想不到的结果：</p><pre><code class="language-cpp">cout &lt;&lt; ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;); // 输出 pass 或者 fail
cout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;   // 输出 1 或者 0
cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //  错误：试图比较 cout 和 60
</code></pre><p>在第二个条件运算表达式中，grade 和 60 的比较结果是 <code>&lt;&lt;</code> 运算符的运算对象，因此，如果 grade &lt; 60 为真，输出 1，否则，输出 0。 <code>&lt;&lt;</code> 运算符的返回值是 <code>cout</code> ，接下来， <code>cout</code> 将作为条件运算符的条件。也就是说，第二条表达式等价于</p><pre><code class="language-cpp">cout &lt;&lt; (grade &lt; 60);    // 输出 1 或者 0
cout ?  &quot;fail&quot; : &quot;pass&quot;; // 根据 cout 的值（true 或者 false）产生对应的字面值
</code></pre><p>在第三个条件运算语句中，<strong>小于运算符的优先级低于移位运算符</strong> ，所以会先输出 grade，然后比较 cout 和 60 ，即，等价于：</p><pre><code class="language-cpp">cout &lt;&lt; grade;
cout &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;;
</code></pre><p>因此，第三个条件运算语句是错误的</p><h1 id="位运算符"><a class="anchor" href="#位运算符">#</a> 位运算符</h1><p>位运算符作用于整数类型的运算对象，并将运算对象视为二进制位的集合</p><blockquote><p>一种名为 bitset 的标准库类型也可以表示任意大小的二进制位集合，所以位运算符同样能用于 bitset 类型</p></blockquote><p>位运算符提供检查和设置二进制位的功能</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">功能</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">~</td><td style="text-align:center">位求反</td><td style="text-align:center">~ expr</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td><td style="text-align:center">expr1 &lt;&lt; expr2</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右移</td><td style="text-align:center">expr1 &gt;&gt; expr2</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td><td style="text-align:center">expr1 &amp; expr2</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">位异或</td><td style="text-align:center">expr1 ^ expr2</td></tr><tr><td style="text-align:center">|</td><td style="text-align:center">位或</td><td style="text-align:center">expr1 | expr2</td></tr></tbody></table><p>一般来说，如果运算对象是 “小整型”，则它的值会被自动提升成较大的整数类型</p><p>运算对象可以是带符号的，也可以是无符号的</p><blockquote><p>在执行位运算时，如果运算对象是带符号的且它的值为负，如何处理运算对象的 “符号位” 将依赖于机器。并且，此时的左移操作可能会改变符号位的值，因此是一种未定义的行为</p></blockquote><p>建议 <strong>仅将位运算符用于处理无符号类型</strong></p><h2 id="位求反运算符"><a class="anchor" href="#位求反运算符">#</a> 位求反运算符</h2><p>位求反运算符（~）将运算对象逐位求反（即，将 1 置为 0 、将 0 置为 1 ）后生成一个新值</p><p>特别地，针对 char 类型对象执行位求反运算时，首先会将 char 类型的运算对象提升成 int 类型（提升时，运算对象原来的位保持不变，往高位添加 0 即可），随后将提升后的值逐位求反</p><p>例如：<br><img data-src="/posts/2d2eedc7/Example1.png"></p><h2 id="移位运算符"><a class="anchor" href="#移位运算符">#</a> 移位运算符</h2><p>移位运算符包括左移和右移</p><p>移位运算符的内置含义：对运算对象执行基于二进制位的移动操作</p><ul><li>针对左侧运算对象的内容，移动右侧运算对象所要求的位数</li><li>将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果</li></ul><p>其中，右侧的运算对象一定不能为负，并且，其值必须严格小于结果的位数（否则，会产生未定义的结果）</p><p>左移运算符（&lt;&lt;）在右侧插入值为 0 的二进制位</p><p>右移运算符（&gt;&gt;）的行为依赖于其左侧运算对象的类型：</p><ul><li>如果左侧运算对象是无符号类型，在左侧插入值为 0 的二进制位</li><li>如果左侧运算对象是带符号类型，在左侧插入符号位的副本或值为 0 的二进制位（由具体环境确定）</li></ul><p>无论是左移还是右移，移出边界的位都会被舍弃掉</p><p><img data-src="/posts/2d2eedc7/Example2.png"></p><h3 id="移位运算符满足左结合律"><a class="anchor" href="#移位运算符满足左结合律">#</a> 移位运算符满足左结合律</h3><p>重载运算符的优先级和结合律都与它的内置版本一样</p><p>即，IO 运算符的优先级和结合律与移位运算符一样</p><p>由于移位运算符满足左结合律， <code>cout &lt;&lt; &quot;hi&quot; &lt;&lt; &quot; there&quot; &lt;&lt; endl;</code> 等价于 <code>( (cout &lt;&lt; &quot;hi&quot;) &lt;&lt; &quot; there&quot; ) &lt;&lt; endl;</code></p><p>移位运算符的优先级比算术运算符低，但比关系运算符、赋值运算符和条件运算符高。因此，在一次使用多个运算符时，有必要在适当的地方加上括号使其满足我们的要求</p><p>例如：</p><pre><code class="language-cpp">cout &lt;&lt; 42 + 10;   // 正确：+ 的优先级更高，输出 52
cout &lt;&lt; (10 &lt; 42); // 正确：括号的优先级高，输出 1
cout &lt;&lt; 10 &lt; 42;   // 错误：试图比较 cout 和 42 （等价于 (cout &lt;&lt; 10) &lt; 42;）
</code></pre><h2 id="位与-位或-位异或运算符"><a class="anchor" href="#位与-位或-位异或运算符">#</a> 位与、位或、位异或运算符</h2><p>位与运算：如果两个运算对象的对应位置都是 1，则该位的运算结果为 1，否则为 0</p><p>位或运算：如果两个运算对象的对应位置至少有一个为 1，则该位的运算结果为 1，否则为 0</p><p>位异或运算：位或运算：如果两个运算对象的对应位置有且只有一个为 1，则该位的运算结果为 1，否则为 0</p><blockquote><p>一种常见的错误是混淆位运算符和逻辑运算符：位与（&amp;）和逻辑与（&amp;&amp;）、位或（|）和逻辑或（||）、位求反（~）和逻辑非（!）</p></blockquote><h1 id="sizeof-运算符"><a class="anchor" href="#sizeof-运算符">#</a> sizeof 运算符</h1><p>sizeof 运算符返回一条表达式或一个类型名字所占的字节数</p><p>sizeof 运算符满足右结合律，其所得的值是一个 <code>size_t</code> 类型的常量表达式</p><p>sizeof 运算符的运算对象有两种形式：</p><pre><code class="language-cpp">sizeof (type)

sizeof expr
</code></pre><p>在第二种形式中，sizeof 返回的是表达式结果类型的大小</p><p>需注意的是，sizeof 并不实际计算其运算对象的值</p><pre><code class="language-cpp">Sales_data data, *p;
sizeof(Sales_data);  // Sales_data 类型对象所占的空间大小
sizeof data;         // data 的类型的大小，即 sizeof(Sales_data)
sizeof p;            // 指针所占的空间大小
sizeof *p;           // p 所指类型的大小，即 sizeof(Sales_data)
sizeof data.revenue; // Sales_data 的 revenue 成员所对应的类型的大小
sizeof Sales_data::revenue; // 另一种获取 revenue 大小的方式
</code></pre><p>对于 <code>sizeof *p</code> ：</p><ul><li><code>sizeof</code> 满足右结合律，并且 <code>sizeof</code> 的优先级与 <code>*</code> 运算符一样，所以，表达式按照从右向左的顺序组合，即，等价于 <code>sizeof(*p)</code></li><li><code>sizeof</code> 不会实际求运算对象的值，即便 <code>p</code> 是一个无效（即未初始化）指针也不会有什么影响</li></ul><blockquote><p>可以在 sizeof 的运算对象中解引用一个无效指针，因为指针实际上并没有被真正使用。sizeof 不需要真的解引用指针也能知道它所指对象的类型</p></blockquote><blockquote><p>C++ 11 允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但执行 sizeof 运算时无须提供一个具体的对象，因为 sizeof 不需要真正获取该成员</p></blockquote><p>sizeof 运算符的结果 部分地 依赖于其作用的类型：</p><ul><li>对 char 或者类型为 char 的表达式执行 sizeof 运算，结果为 1</li><li>对引用类型执行 sizeof 运算，结果为被引用对象所占空间的大小</li><li>对指针执行 sizeof 运算，结果为指针本身所占空间的大小</li><li>对解引用指针执行 sizeof 运算，结果为指针指向的对象所占空间的大小，指针不需有效</li><li>对数组执行 sizeof 运算，结果为整个数组所占空间的大小，等价于 对数组中所有的元素各执行一次 sizeof 运算并将所得结果求和（注意， sizeof 运算不会把数组转换成指针来处理）</li><li>对 string 对象或 vector 对象执行 sizeof 运算，结果为该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li></ul><p>因为执行 sizeof 运算能得到整个数组的大小，可以用整个数组的大小除以单个元素的大小，得到数组中的元素个数</p><pre><code class="language-cpp">// sizeof(ia) / sizeof(*ia) 返回 ia 数组中的元素个数
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; // sizeof 返回一个常量表达式
</code></pre><p>因为 sizeof 的返回值是一个常量表达式，所以我们可以用 sizeof 的结果声明数组的维度</p><h1 id="逗号运算符"><a class="anchor" href="#逗号运算符">#</a> 逗号运算符</h1><p>逗号运算符（comma operator）含有两个运算对象，按照从左向右的顺序依次求值</p><p>逗号运算符规定了运算对象求值的顺序：</p><ul><li>首先对左侧的表达式求值，然后将求值结果丢弃掉</li><li>逗号运算符真正的结果是右侧表达式的值</li></ul><p>如果右侧运算对象是左值，那么最终的求值结果也是左值</p><p>逗号运算符经常被用在 for 循环中，例如：</p><pre><code class="language-cpp">vector&lt;int&gt;::size_type cnt = ivec.size();
for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
</code></pre><p>这个循环在 for 语句的表达式中递增 ix、递减 cnt，每次循环迭代时 ix 和 cnt 都会相应改变</p><h1 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h1><p>如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代</p><pre><code class="language-cpp">int ival = 3.541 + 3; // 初始化 ival 为 6
</code></pre><p>在上面的例子中，3 转换成 double 类型，然后执行浮点数加法，所得结果的类型是 double，由于被初始化的对象 ival 为 int 型，需要将加法运算得到的 double 类型的结果转换成 int 类型的值</p><p>隐式转换（implicit conversion）：自动执行的类型转换，无须程序员的介入</p><p>在下面这些情况下，编译器会自动地转换运算对象的类型：</p><ul><li>在大多数表达式中，比 int 类型小的整型值首先提升为较大的整数类型</li><li>在条件中，非布尔值转换成布尔类型</li><li>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型</li><li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型</li><li>函数调用时也会发生类型转换</li></ul><h2 id="算术转换"><a class="anchor" href="#算术转换">#</a> 算术转换</h2><p>算术转换（arithmetic conversion）：把一种算术类型转换成另外一种算术类型</p><p>算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型，例如：</p><ul><li>如果一个运算对象的类型是 long double，那么不论另外一个运算对象的类型是什么都会转换成 long double</li><li>还有一种更普遍的情况：当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型</li></ul><h3 id="整型提升"><a class="anchor" href="#整型提升">#</a> 整型提升</h3><p>整型提升（integral promotion）负责把小整数类型转换成较大的整数类型</p><p>对于 bool、char、signed char、unsigned char、short 和 unsigned short 等类型，只要它们所有可能的值都能存进 int ，它们就会提升成 int 类型；否则，提升成 unsigned int 类型</p><p>较大的 char 类型（wchar_t、char16_t、char32_t）提升成 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中能容纳原类型所有可能值的、最小的一种类型</p><h3 id="无符号类型的运算对象"><a class="anchor" href="#无符号类型的运算对象">#</a> 无符号类型的运算对象</h3><p>如果某个运算对象的类型是无符号类型，转换的结果将依赖于机器中各个整数类型的相对大小。具体而言，首先执行整型提升，然后进一步根据运算对象的类型做进一步转换</p><ul><li>如果结果的类型匹配，无须进行进一步的转换</li><li>如果两个（提升后的）运算对象都是带符号类型或者都是无符号类型，则小类型的运算对象转换成较大的类型</li><li>如果一个运算对象是无符号类型、另外一个运算对象是带符号类型<ul><li>如果无符号类型不小于带符号类型：将带符号的运算对象转换成无符号的</li><li>如果带符号类型大于无符号类型，此时转换的结果依赖于机器<ul><li>如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型</li><li>如果不能，那么带符号类型的运算对象转换成无符号类型</li></ul></li></ul></li></ul><p>要想理解算术转换，办法之一就是研究大量的例子：</p><pre><code class="language-cpp">bool      flag;         char           cval;
short     sval;         unsigned short usval;
int       ival;         unsigned int   uival;
long      lval;         unsigned long  ulval;
float     fval;         double         dval;
3.14159L + 'a'; //  'a' 提升成 int，然后 int 值转换成 long double
dval + ival;    //  ival 转换成 double
dval + fval;    //  fval 转换成 double
ival = dval;    //  dval 转换成 int
flag = dval;    //  如果 dval 为 0，则 flag 为 false，否则 flag 为 true
cval + fval;    //  cval 提升成 int，然后 int 值转换成 float
sval + cval;    //  sval 和 cval 都提升成 int
cval + lval;    //  cval 转换成 long
ival + ulval;   //  ival 转换成 unsigned long
usval + ival;   //  根据 unsigned short 和 int 所占空间的大小进行提升
uival + lval;   //  根据 unsigned int 和 long 所占空间的大小进行转换
</code></pre><h2 id="其他隐式类型转换"><a class="anchor" href="#其他隐式类型转换">#</a> 其他隐式类型转换</h2><p>除了算术转换之外还有几种隐式类型转换，包括如下几种</p><h3 id="数组转换成指针"><a class="anchor" href="#数组转换成指针">#</a> 数组转换成指针</h3><p>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针</p><pre><code class="language-cpp">int ia[10];
int* ip = ia;
</code></pre><p>当数组被用作 decltype 关键字的参数，或者作为取地址符（&amp;）、sizeof 及 typeid 等运算符的运算对象时，上述转换不会发生</p><p>如果用一个引用来初始化数组，上述转换也不会发生</p><h3 id="指针的转换"><a class="anchor" href="#指针的转换">#</a> 指针的转换</h3><p>C++ 规定了几种其他的指针转换方式</p><ul><li>常量整数值 0 或者字面值 nullptr 能转换成任意指针类型</li><li>指向任意非常量的指针能转换成 void*</li><li>指向任意对象的指针能转换成 const void*</li></ul><p>此外，在有继承关系的类型间还有另外一种指针转换的方式</p><h3 id="转换成布尔类型"><a class="anchor" href="#转换成布尔类型">#</a> 转换成布尔类型</h3><p>存在一种从算术类型或指针类型向布尔类型自动转换的机制：如果指针或算术类型的值为 0 ，转换结果是 false ；否则转换结果是 true</p><h3 id="转换成常量"><a class="anchor" href="#转换成常量">#</a> 转换成常量</h3><p>允许将指向非常量类型的指针转换成指向相应的常量类型的指针</p><p>允许将绑定非常量类型的引用转换成绑定相应的常量类型的引用</p><p>也就是说，如果 T 是一种类型，我们就能将指向 T 的指针或引用分别转换成指向 const T 的指针或引用</p><pre><code class="language-cpp">int i;
const int &amp;j = i;
const int *p = &amp;i;
</code></pre><p>相反的转换并不存在，因为它试图删除掉底层 const</p><pre><code class="language-cpp">int &amp;r = j, *q = p; // 错误：不允许 const 转换成非常量
</code></pre><h3 id="类类型定义的转换"><a class="anchor" href="#类类型定义的转换">#</a> 类类型定义的转换</h3><p>类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换</p><p>我们之前已经使用过类类型转换：一处是在需要标准库 string 类型的地方使用 C 风格字符串；另一处是在条件部分读入 istream</p><pre><code class="language-cpp">string s, t = &quot;a value&quot;;  // 字符串字面值转换成 string 类型
while (cin &gt;&gt; s)          // while 的条件部分把 cin 转换成 bool 值
</code></pre><h2 id="显式转换"><a class="anchor" href="#显式转换">#</a> 显式转换</h2><p>有时我们希望显式地将对象强制转换成另外一种类型，即，<strong>强制类型转换</strong>（cast）</p><p>例如，如果想在下面的代码中执行浮点数除法，就需要使用某种方法将 i 和（或）j 显式地转换成 double</p><pre><code class="language-cpp">int i, j;
double slope = i / j;
</code></pre><blockquote><p>虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的</p></blockquote><h3 id="命名的强制类型转换"><a class="anchor" href="#命名的强制类型转换">#</a> 命名的强制类型转换</h3><p>一个命名的强制类型转换具有如下形式：</p><pre><code class="language-cpp">cast-name&lt;type&gt;(expression);
</code></pre><p>其中，type 是转换的目标类型，expression 是要转换的值，cast-name 是 <strong>static_cast</strong>、<strong>dynamic_cast</strong>、<strong>const_cast</strong> 和 <strong>reinterpret_cast</strong> 中的一种</p><p>如果 type 是引用类型，则结果是左值</p><p>cast-name 指定了执行的是哪种转换（dynamic_cast 支持运行时类型识别）</p><h3 id="static_cast"><a class="anchor" href="#static_cast">#</a> static_cast</h3><p>任何具有明确定义的类型转换，只要不包含底层 const ，都可以使用 static_cast</p><p>例如，将一个运算对象强制转换成 double 类型以便执行浮点数除法：</p><pre><code class="language-cpp">// 进行强制类型转换以便执行浮点数除法
double slope = static_cast&lt;double&gt;(j) / i;
</code></pre><p>当需要把一个较大的算术类型赋值给较小的类型时，static_cast 非常有用</p><ul><li>一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息</li><li>但是当我们执行了显式的类型转换后，警告信息就会被关闭了</li></ul><p>static_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用 static_cast 找回存在于 void* 指针中的值</p><pre><code class="language-cpp">void* p = &amp;d;   // 任何非常量对象的地址都能存入 void*
double *dp = static_cast&lt;double*&gt;(p); // 将 void* 转换回初始的指针类型
</code></pre><p>当我们把指针存放在 void* 中，并且使用 static_cast 将其强制转换回原来的类型时，应该确保指针的值保持不变（即，强制转换的结果将与原始的地址值相等），因此，必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果</p><h3 id="const_cast"><a class="anchor" href="#const_cast">#</a> const_cast</h3><p>const_cast 只能改变运算对象的底层 const：</p><pre><code class="language-cpp">const char *pc;
char *p = const_cast&lt;char*&gt;(pc); // 正确，但通过 p 写值是未定义的行为（因为 pc 所指对象本身是常量）
</code></pre><p>对于将常量对象转换成非常量对象的行为，我们一般称其为 “去掉 const 性质（cast away the const）”</p><p>一旦我们去掉了某个对象的 const 性质，编译器就不回再阻止对该对象的写操作</p><ul><li>如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为</li><li>如果对象是一个常量，再使用 const_cast 执行写操作，会产生未定义的后果</li></ul><p>只有 const_cast 能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误</p><p>不能用 const_cast 改变表达式的类型：</p><pre><code class="language-cpp">const char *cp;
char *q = static_cast&lt;char*&gt;(cp); // 错误: static_cast 不能去掉 const 性质
static_cast&lt;string&gt;(cp); // 正确：字符串字面值转换成 string 类型
const_cast&lt;string&gt;(cp);  // 错误：const_cast 只改变常量属性
</code></pre><p>const_cast 常常用于有函数重载的上下文中</p><h3 id="reinterpret_cast"><a class="anchor" href="#reinterpret_cast">#</a> reinterpret_cast</h3><p>reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释</p><p>例如，假设有如下的转换</p><pre><code class="language-cpp">int *ip;
char *pc = reinterpret_cast&lt;char*&gt;(ip); // 效果类似 C 风格的强制转换
</code></pre><p>我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误</p><blockquote><p>reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解</p></blockquote><p>建议：尽量避免强制类型转换，尤其是 reinterpret_cast</p><h3 id="旧式的强制类型转换"><a class="anchor" href="#旧式的强制类型转换">#</a> 旧式的强制类型转换</h3><p>在早期版本的 C++ 语言中，显式地进行强制类型转换包含两种形式</p><pre><code class="language-cpp">type (expr); // 函数形式的强制类型转换
(type) expr; // C 语言风格的强制类型转换
</code></pre><p>当我们在某处执行旧式的强制类型转换时，如果换成 const_cast 和 static_cast 也合法，则其行为与对应的命名转换一致</p><p>如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能</p><pre><code class="language-cpp">int *ip;
char *pc = (char*) ip; // ip 是指向 int 的指针
</code></pre><h1 id="运算符优先级表"><a class="anchor" href="#运算符优先级表">#</a> 运算符优先级表</h1><p>从上到下，不同表格的优先级按从高到低排列，其中，同一个表格中的多个运算符具有相同的优先级</p><table><thead><tr><th style="text-align:center">结合律</th><th style="text-align:center">运算符</th><th style="text-align:center">功能</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">::</td><td style="text-align:center">全局作用域</td><td style="text-align:center">::name</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">::</td><td style="text-align:center">类作用域</td><td style="text-align:center">class::name</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">::</td><td style="text-align:center">命名空间作用域</td><td style="text-align:center">namespace::name</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">.</td><td style="text-align:center">成员选择</td><td style="text-align:center">object.member</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">-&gt;</td><td style="text-align:center">成员选择</td><td style="text-align:center">pointer-&gt;member</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">[]</td><td style="text-align:center">下标</td><td style="text-align:center">expr1[expr2]</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">()</td><td style="text-align:center">函数调用</td><td style="text-align:center">name(expr_list)</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">()</td><td style="text-align:center">类型构造</td><td style="text-align:center">type(expr_list)</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">++</td><td style="text-align:center">后置递增运算</td><td style="text-align:center">lvalue++</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">--</td><td style="text-align:center">后置递减运算</td><td style="text-align:center">lvalue--</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">typeid</td><td style="text-align:center">类型 ID</td><td style="text-align:center">typeid(type)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">typeid</td><td style="text-align:center">运行时类型 ID</td><td style="text-align:center">typeid(expr)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">explicit cast</td><td style="text-align:center">类型转换</td><td style="text-align:center">cast_name&lt;type&gt;(expr)</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">++</td><td style="text-align:center">前置递增运算</td><td style="text-align:center">++lvalue</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">--</td><td style="text-align:center">前置递减运算</td><td style="text-align:center">--lvalue</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">~</td><td style="text-align:center">位求反</td><td style="text-align:center">~expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">!</td><td style="text-align:center">逻辑非</td><td style="text-align:center">!expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">-</td><td style="text-align:center">一元负号</td><td style="text-align:center">-expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">+</td><td style="text-align:center">一元正号</td><td style="text-align:center">+expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">*</td><td style="text-align:center">解引用</td><td style="text-align:center">*expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">&amp;</td><td style="text-align:center">取地址</td><td style="text-align:center">&amp;expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">()</td><td style="text-align:center">类型转换</td><td style="text-align:center">(type) expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">sizeof</td><td style="text-align:center">对象的大小</td><td style="text-align:center">sizeof expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">sizeof</td><td style="text-align:center">类型的大小</td><td style="text-align:center">sizeof(type)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">sizeof...</td><td style="text-align:center">参数包的大小</td><td style="text-align:center">sizeof...(name)</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">new</td><td style="text-align:center">创建对象</td><td style="text-align:center">new type</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">new[]</td><td style="text-align:center">创建数组</td><td style="text-align:center">new type[size]</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">delete</td><td style="text-align:center">释放对象</td><td style="text-align:center">delete expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">delete[]</td><td style="text-align:center">释放数组</td><td style="text-align:center">delete[] expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">noexcept</td><td style="text-align:center">能否抛出异常</td><td style="text-align:center">noexcept (expr)</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">-&gt;*</td><td style="text-align:center">指向成员选择的指针</td><td style="text-align:center">ptr-&gt;*ptr_to_member</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">.*</td><td style="text-align:center">指向成员选择的指针</td><td style="text-align:center">obj.*ptr_to_member</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">*</td><td style="text-align:center">乘法</td><td style="text-align:center">expr1 * epxr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">/</td><td style="text-align:center">除法</td><td style="text-align:center">expr1 / epxr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">%</td><td style="text-align:center">取模（取余）</td><td style="text-align:center">expr1 % epxr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">+</td><td style="text-align:center">加法</td><td style="text-align:center">expr1 + epxr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">-</td><td style="text-align:center">减法</td><td style="text-align:center">expr1 - expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">向左移位</td><td style="text-align:center">expr1 &lt;&lt; expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">向右移位</td><td style="text-align:center">expr1 &gt;&gt; expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td><td style="text-align:center">expr1 &lt; expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td><td style="text-align:center">expr1 &lt;= expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td><td style="text-align:center">expr1 &gt; expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td><td style="text-align:center">expr1 &gt;= expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">==</td><td style="text-align:center">相等</td><td style="text-align:center">expr1 == expr2</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">!=</td><td style="text-align:center">不相等</td><td style="text-align:center">expr1 != expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td><td style="text-align:center">expr1 &amp; expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">^</td><td style="text-align:center">位异或</td><td style="text-align:center">expr1 ^ expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">|</td><td style="text-align:center">位或</td><td style="text-align:center">expr1 | expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑与</td><td style="text-align:center">expr1 &amp;&amp; expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">||</td><td style="text-align:center">逻辑或</td><td style="text-align:center">expr1 || expr2</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">? :</td><td style="text-align:center">条件</td><td style="text-align:center">expr1 ? expr2 : epxr3</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">=</td><td style="text-align:center">赋值</td><td style="text-align:center">lvalue = expr</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">*=,/=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=</td><td style="text-align:center">复合赋值</td><td style="text-align:center">lvalue += expr 等</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">throw</td><td style="text-align:center">抛出异常</td><td style="text-align:center">throw expr</td></tr></tbody><tbody><tr><td style="text-align:center">结合律</td><td style="text-align:center">运算符</td><td style="text-align:center">功能</td><td style="text-align:center">用法</td></tr><tr><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td><td style="text-align:center">:-:</td></tr><tr><td style="text-align:center">左</td><td style="text-align:center">,</td><td style="text-align:center">逗号</td><td style="text-align:center">expr1, expr2</td></tr></tbody></table><h1 id="术语表"><a class="anchor" href="#术语表">#</a> 术语表</h1><p><strong>算术转换（arithmetic conversion）</strong>：从一种算术类型转换成另一种算术类型。在二元运算符的上下文中，为了保留精度，算术转换通常把较小的类型转换成较大的类型（例如整型转换成浮点型）</p><p><strong>结合律（associativity）</strong>：规定具有相同优先级的运算符如何组合在一起。结合律分为左结合律（运算符从左向右组合）和右结合律（运算符从右向左组合）</p><p><strong>二元运算符（binary operator）</strong>：有两个运算对象参与运算的运算符</p><p><strong>强制类型转换（cast）</strong>：一种显式的类型转换</p><p><strong>复合表达式（compound expression）</strong>：含有多于一个运算符的表达式</p><p><strong>const_cast</strong> ：一种涉及 const 的强制类型转换。将底层 const 对象转换成对应的非常量类型，或者执行相反的转换</p><p><strong>转换（conversion）</strong>：一种类型的值改变成另一种类型的值的过程</p><p><strong>dynamic_cast</strong> ：和继承及运行时类型识别一起使用</p><p><strong>表达式（expression）</strong>：C++ 程序中最低级别的计算。表达式将运算符作用于一个或多个运算对象，每个表达式都有对应的求值结果。表达式本身也可以作为运算对象，这时就得到了对多个运算符求值的复合表达式</p><p><strong>隐式转换（implicit conversion）</strong>：由编译器自动执行的类型转换。假如表达式需要某种特定的类型而运算对象是另外一种类型，此时只要规则允许，编译器就会自动地将运算对象转换成所需的类型</p><p><strong>整型提升（integral promotion）</strong>：把一种较小的整数类型转换成与之最接近的较大整数类型的过程。不论是否真的需要，小整数类型（即 short 、char 等）总是会得到提升</p><p><strong>左值（lvalue）</strong>：是指那些求值结果为对象或函数的表达式。一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象</p><p><strong>运算对象（operand）</strong>：表达式在某些值上执行运算，这些值就是运算对象。一个运算符有一个或多个相关的运算对象</p><p><strong>运算符（operator）</strong>：决定表达式所做操作的符号</p><ul><li>C++ 语言定义了一套运算符并说明了这些运算符作用于内置类型时的含义</li><li>C++ 还定义了运算符的优先级和结合律以及每种运算符处理的运算对象数量</li><li>可以重载运算符使其能处理类类型</li></ul><p><strong>求值顺序（order of evaluation）</strong>：是某个运算符的运算对象的求值顺序</p><ul><li>大多数情况下，编译器可以任意选择运算对象求值的顺序（运算对象一定要在运算符之前得到求值结果）</li><li>只有 &amp;&amp; 、|| 、条件和逗号四种运算符明确规定了求值顺序</li></ul><p><strong>重载运算符（overloaded operator）</strong>：针对某种运算符重新定义的适用于类类型的版本</p><p><strong>优先级（precedence）</strong>：规定了复合表达式中不同运算符的执行顺序。与低优先级的运算符相比，高优先级的运算符组合得更紧密</p><p><strong>reinterpret_cast</strong> ：把运算对象的内容解释成另外一种类型。这种强制类型转换本质上依赖于机器而且非常危险</p><p><strong>结果（result）</strong>：计算表达式得到的值或对象</p><p><strong>右值（rvalue）</strong>：是指一种表达式，其结果是值而非值所在的位置</p><p><strong>短路求值（short-circuit evaluation）</strong>：描述逻辑与运算符和逻辑或运算符的执行过程。如果根据运算符的第一个运算对象就能确定整个表达式的结果，求值终止，此时第二个运算对象将不会被求值</p><p><strong>sizeof</strong> ：是一个运算符，返回存储对象所需的字节数，该对象的类型可能是某个给定的类型名字，也可能由表达式的返回结果确定</p><p><strong>static_cast</strong> ：显式地执行某种定义明确的类型转换，常用于替代由编译器隐式执行的类型转换</p><p><strong>一元运算符（unary operators）</strong>：只有一个运算对象参与运算的运算符</p><p><strong>, 运算符（, operator）</strong>：逗号运算符，是一种从左向右求值的二元运算符。逗号运算符的结果是右侧运算对象的值，当且仅当右侧运算对象是左值时逗号运算符的结果是左值</p><p><strong>? : 运算符（? : operator）</strong>：条件运算符</p><ul><li>cond ? expr1 : expr2 提供 if-then-else 逻辑的表达式：如果条件 cond 为真，对 expr1 求值；否则对 expr2 求值</li><li>expr1 和 expr2 的类型应该相同或者能转换成同一种类型</li><li>expr1 和 expr2 中只有一个会被求值</li></ul><p><strong>&amp;&amp; 运算符（&amp;&amp;operator）</strong>：逻辑与运算符，如果两个运算对象都是真，结果才为真。只有当左侧运算对象为真时才会检查右侧运算对象</p><p><strong>&amp; 运算符（&amp;operator）</strong>：位与运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位都是 1 ，所得结果中该位为 1 ；否则所得结果中该位为 0</p><p><strong>^ 运算符（^ operator）</strong>：位异或运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位有且只有一个是 1 ，所得结果中该位为 1 ；否则所得结果中该位为 0</p><p><strong>|| 运算符（|| operator）</strong>：逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象</p><p><strong>| 运算符（| operator）</strong>：位或运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位至少有一个是 1 ，所得结果中该位为 1 ；否则所得结果中该位为 0</p><p><strong>++ 运算符（++ operator）</strong>：递增运算符。包括两种形式：前置版本和后置版本</p><ul><li>前置递增运算符得到一个左值，它给运算符加 1 并得到运算对象改变后的值</li><li>后置递增运算符得到一个右值，它给运算符加 1 并得到运算对象原始的、未改变的值的副本</li><li>注意：即使迭代器没有定义 + 运算符，也会有 ++ 运算符</li></ul><p><strong>-- 运算符（-- operator）</strong>：递减运算符。包括两种形式：前置版本和后置版本</p><ul><li>前置递减运算符得到一个左值，它从运算符减 1 并得到运算对象改变后的值</li><li>后置递减运算符得到一个右值，它从运算符减 1 并得到运算对象原始的、未改变的值的副本</li><li>注意：即使迭代器没有定义 - 运算符，也会有 -- 运算符</li></ul><p><strong>&lt;&lt; 运算符（ <code>&lt;&lt; operator</code> ）</strong>：左移运算符，将左侧运算对象的值的（可能是提升后的）副本向左移位，移动的位数由右侧运算对象确定。右侧运算对象必须大于等于 0 而且小于结果的位数。左侧运算对象应该是无符号类型，如果它是带符号类型，则一旦移动改变了符号位的值就会产生未定义的结果</p><p><strong>&gt;&gt; 运算符（&gt;&gt; operator）</strong>：右移运算符，除了移动方向相反，其他性质都和左移运算符类似。如果左侧运算对象是带符号类型，那么根据实现的不同新移入的内容也不同，新移入的位可能都是 0 ，也可能都是符号位的副本</p><p><strong>~ 运算符（~ operator）</strong>：位求反运算符，生成一个新的整型值。该值的每一位恰好与（可能是提升后的）运算对象的对应位相反</p><p><strong>! 运算符（! operator）</strong>：逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假</p><p>参考：C++ Primer 中文版（第 5 版）</p></div><footer><div class="meta"><span class="item"><time title="修改时间：2023-04-29 13:17:01" itemprop="dateModified" datetime="2023-04-29T13:17:01+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2023-04-29 </time></span><span id="posts/2d2eedc7/" class="item leancloud_visitors" data-flag-title="C++ 表达式" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/2d2eedc7/" title="C++ 表达式">https://jiankychen.github.io/posts/2d2eedc7/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/4cc2938/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;470d00578173666b5183f4631e51a421.jpg" title="LeetCode 278. 第一个错误的版本"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode 278. 第一个错误的版本</h3></a></div><div class="item right"><a href="/posts/933a3849/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;488297bfd0233b6c6a444f1860e55d45.jpg" title="LeetCode 1523. 在区间范围内统计奇数数目"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode 1523. 在区间范围内统计奇数数目</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">表达式基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">组合运算符和运算对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">重载运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">1.1.3.</span> <span class="toc-text">左值和右值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text">优先级与结合律</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E6%97%A0%E8%A7%86%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">括号无视优先级与结合律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E5%BE%8B%E6%9C%89%E4%BD%95%E5%BD%B1%E5%93%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">优先级与结合律有何影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F-%E4%BC%98%E5%85%88%E7%BA%A7-%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">求值顺序、优先级、结合律</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">逻辑和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E-%E9%80%BB%E8%BE%91%E6%88%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">逻辑与、逻辑或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="toc-number">3.1.2.</span> <span class="toc-text">逻辑非</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">3.2.1.</span> <span class="toc-text">相等性测试与布尔字面值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E6%BB%A1%E8%B6%B3%E5%8F%B3%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">4.1.</span> <span class="toc-text">赋值运算满足右结合律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7%E8%BE%83%E4%BD%8E"><span class="toc-number">4.2.</span> <span class="toc-text">赋值运算优先级较低</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E5%8B%BF%E6%B7%B7%E6%B7%86%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">切勿混淆相等运算符和赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">复合赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">递增和递减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-number">5.1.</span> <span class="toc-text">解引用和递增运算符的结合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1%E5%8F%AF%E6%8C%89%E4%BB%BB%E6%84%8F%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%80%BC"><span class="toc-number">5.1.1.</span> <span class="toc-text">运算对象可按任意顺序求值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">成员访问运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">条件运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">嵌套条件运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E8%BE%93%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">在输出表达式中使用条件运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.</span> <span class="toc-text">位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E6%B1%82%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.1.</span> <span class="toc-text">位求反运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.2.</span> <span class="toc-text">移位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E6%BB%A1%E8%B6%B3%E5%B7%A6%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">移位运算符满足左结合律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E4%B8%8E-%E4%BD%8D%E6%88%96-%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.3.</span> <span class="toc-text">位与、位或、位异或运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">sizeof 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">逗号运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.1.</span> <span class="toc-text">算术转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87"><span class="toc-number">11.1.1.</span> <span class="toc-text">整型提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.1.2.</span> <span class="toc-text">无符号类型的运算对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.2.</span> <span class="toc-text">其他隐式类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%8C%87%E9%92%88"><span class="toc-number">11.2.1.</span> <span class="toc-text">数组转换成指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.2.2.</span> <span class="toc-text">指针的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.2.3.</span> <span class="toc-text">转换成布尔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B8%B8%E9%87%8F"><span class="toc-number">11.2.4.</span> <span class="toc-text">转换成常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.2.5.</span> <span class="toc-text">类类型定义的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.3.</span> <span class="toc-text">显式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.3.1.</span> <span class="toc-text">命名的强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static_cast"><span class="toc-number">11.3.2.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const_cast"><span class="toc-number">11.3.3.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret_cast"><span class="toc-number">11.3.4.</span> <span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A7%E5%BC%8F%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.3.5.</span> <span class="toc-text">旧式的强制类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8"><span class="toc-number">12.</span> <span class="toc-text">运算符优先级表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD%E8%A1%A8"><span class="toc-number">13.</span> <span class="toc-text">术语表</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/b5c83bc3/" rel="bookmark" title="初识 C++">初识 C++</a></li><li><a href="/posts/38333d94/" rel="bookmark" title="C++ 变量和基本类型">C++ 变量和基本类型</a></li><li><a href="/posts/cddca394/" rel="bookmark" title="C++ 字符串、向量和数组">C++ 字符串、向量和数组</a></li><li class="active"><a href="/posts/2d2eedc7/" rel="bookmark" title="C++ 表达式">C++ 表达式</a></li><li><a href="/posts/ffed1eef/" rel="bookmark" title="C++ 语句">C++ 语句</a></li><li><a href="/posts/3d6d9e02/" rel="bookmark" title="C++ 函数">C++ 函数</a></li><li><a href="/posts/9e07c79c/" rel="bookmark" title="C++ 类">C++ 类</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">251</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/4cc2938/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/933a3849/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/9f11d9b/" title="LeetCode 567. 字符串的排列">LeetCode 567. 字符串的排列</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/f84c47a9/" title="LeetCode 24. 两两交换链表中的节点">LeetCode 24. 两两交换链表中的节点</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/d9baf118/" title="LeetCode 344. 反转字符串">LeetCode 344. 反转字符串</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tutorial/" title="分类于 Tutorial">Tutorial</a></div><span><a href="/posts/b84c37ec/" title="vscode 使用">vscode 使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/c2253dcd/" title="LeetCode 39. 组合总和">LeetCode 39. 组合总和</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/1b6e2437/" title="LeetCode 15. 三数之和">LeetCode 15. 三数之和</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/c3291a68/" title="LeetCode 108. 将有序数组转换为二叉搜索树">LeetCode 108. 将有序数组转换为二叉搜索树</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tutorial/" title="分类于 Tutorial">Tutorial</a> <i class="ic i-angle-right"></i> <a href="/categories/Tutorial/LaTeX/" title="分类于 LaTeX">LaTeX</a></div><span><a href="/posts/99cbc47e/" title="LaTeX：跨 tex 文件的交叉引用">LaTeX：跨 tex 文件的交叉引用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/b8a7b240/" title="LeetCode 115. 不同的子序列">LeetCode 115. 不同的子序列</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tutorial/" title="分类于 Tutorial">Tutorial</a> <i class="ic i-angle-right"></i> <a href="/categories/Tutorial/Hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/posts/ace9da28/" title="hexo 博客搭建与配置">hexo 博客搭建与配置</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">814k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:37</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/2d2eedc7/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->