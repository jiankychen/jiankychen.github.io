<!-- build time:Sat Jan 14 2023 20:52:51 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="https://cdn.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="googlec0ba344a01b3df42"><meta name="baidu-site-verification" content="446db506ce6d2a623e74ffbdb8e67313"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/css/app.css?v=0.2.5"><link rel="canonical" href="https://jiankychen.github.io/posts/dfbe564/"><title>基本内置类型 - C++ | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">基本内置类型</h1><div class="meta"><span class="item" title="创建时间：2022-01-01 17:29:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-01-01T17:29:09+08:00">2022-01-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/01/09/36UsBF4oRQWwDyk.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/09/xREJoZTHjWtNae2.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/09/2OkNj6c3dmryAqQ.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/09/RxHYGuXvnFgfhTb.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/09/Xgq4QEwos7zUJ3r.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/01/09/3cAoywjxbQP5Vt7.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/dfbe564/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://s2.loli.net/2023/01/01/hnmYMxBAwF9QelU.jpg"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><p>C++ 定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中，算术类型包含了字符、整数型、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p><h1 id="算术类型"><a class="anchor" href="#算术类型">#</a> 算术类型</h1><p>算术类型分为两类：整型（integral，包括字符和布尔类型在内）和浮点型。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th><th style="text-align:center">最小尺寸</th></tr></thead><tbody><tr><td style="text-align:center"><code>bool</code></td><td style="text-align:center">布尔类型</td><td style="text-align:center">未定义</td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center">字符</td><td style="text-align:center">8 位</td></tr><tr><td style="text-align:center"><code>wchar_t</code></td><td style="text-align:center">宽字符</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>char16_t</code></td><td style="text-align:center">Unicode 字符</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>char32_t</code></td><td style="text-align:center">Unicode 字符</td><td style="text-align:center">32 位</td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center">短整型</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center">整型</td><td style="text-align:center">16 位</td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">32 位</td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center">长整型</td><td style="text-align:center">64 位</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">单精度浮点数</td><td style="text-align:center">6 位有效数字</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center">双精度浮点数</td><td style="text-align:center">10 位有效数字</td></tr><tr><td style="text-align:center"><code>long double</code></td><td style="text-align:center">拓展精度浮点数</td><td style="text-align:center">10 位有效数字</td></tr></tbody></table><blockquote><p>上述表格列出了 C++ 标准规定的算术类型的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸</p></blockquote><h2 id="整型与浮点型"><a class="anchor" href="#整型与浮点型">#</a> 整型与浮点型</h2><p>布尔类型（bool）的取值是真（True）或者假（False）。</p><p>基本的字符类型是 <code>char</code> ，一个 <code>char</code> 的空间应确保可以存放机器基本字符集（如 ASCII 表）中任意字符对应的数字值，即，一个 <code>char</code> 的大小和一个机器字节一样。</p><p><code>wchar_t</code> 类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 <code>char16_t</code> 和 <code>char32_t</code> 则为 Unicode 字符集服务（Unicode 是用于表示所有自然语言中字符的标准）。</p><blockquote><p>Unicode 为每种语言中的每个字符设定了统一并且唯一的二进制编码，现在用的是 UCS-2，即，2 个字节编码。UTF-8，UTF-16，UTF-32 均为字符编码方案。</p></blockquote><p>大多数机器的字节（byte）由 8 比特（bit）构成，字（word）则由 32 或 64 比特构成，也就是 4 或 8 字节。</p><ul><li>计算机以比特序列存储数据</li><li>字节是可寻址的最小内存块</li><li>字是内存的基本单元</li></ul><p>浮点型可表示单精度、双精度和扩展精度值。通常， <code>float</code> 以 1 个字（32 比特）来表示， <code>double</code> 以 2 个字（64 比特）来表示， <code>long double</code> 以 3 或 4 个字（96 或 128 比特）来表示。一般来说，类型 <code>float</code> 和 <code>double</code> 分别有 7 和 16 个有效位。</p><blockquote><p>浮点数在机器内用指数形式表示，分解为：数符，尾数，指数符，指数。</p></blockquote><h2 id="带符号类型和无符号类型"><a class="anchor" href="#带符号类型和无符号类型">#</a> 带符号类型和无符号类型</h2><p>除布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。</p><ul><li>带符号类型可以表示正数、负数或 0</li><li>无符号类型仅能表示大于等于 0 的值。</li></ul><p>带符号类型： <code>int</code> 、 <code>short</code> 、 <code>long</code> 、 <code>long long</code></p><p>在这些类型名前添加 <code>unsigned</code> 就可以得到对应的无符号类型</p><p>即，无符号类型： <code>unsigned int</code> 、 <code>unsigned short</code> 、 <code>unsigned long</code> 、 <code>unsigned long long</code> 。</p><p>类型 <code>unsigned int</code> 可以缩写为 <code>unsigned</code> 。</p><p>字符型分为三种： <code>char</code> 、 <code>signed char</code> 、 <code>unsigned char</code> 。其中， <code>signed char</code> 类型和 <code>unsigned char</code> 类型分别为带符号类型和无符号类型， <code>char</code> 类型实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p><p>无符号类型中所有比特都用来存储值。</p><p>C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。</p><blockquote><p><code>8</code> 比特的 <code>signed char</code> 理论上应该可以表示 <code>-127</code> 至 <code>127</code> 区间内的值，大多数现代计算机将 <code>8</code> 比特的 <code>signed char</code> 实际的表示范围定为 <code>-128~127</code> 。</p></blockquote><h2 id="如何选择类型"><a class="anchor" href="#如何选择类型">#</a> 如何选择类型</h2><p>当明确知晓数值不可能为负时，选用无符号类型。</p><p>使用 <code>int</code> 执行整数运算。若数值超出 <code>int</code> 的表示范围，选用 <code>long long</code> 。</p><p>在算术表达式中不要使用 <code>char</code> 或 <code>bool</code> ，只有在存放字符或布尔值时才使用它们。</p><blockquote><p>因为类型 <code>char</code> 在一些机器上是有符号的，而在另一些机器上又是无符号的，所以使用 <code>char</code> 进行运算特别容易出问题。如果需要使用一个不大的整数，则应该明确指定类型是 <code>signed char</code> 或者 <code>unsigned char</code> 。</p></blockquote><p>执行浮点数运算选用 <code>double</code> 。</p><blockquote><p>这是因为 <code>float</code> 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。 <code>long double</code> 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。</p></blockquote><h1 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h1><p>类型转换是指，将对象从一种给定的类型转换（convert）为另一种相关类型。</p><h2 id="转换规则简介"><a class="anchor" href="#转换规则简介">#</a> 转换规则（简介）</h2><p>类型所能表示的值的范围决定了转换的过程：</p><ol><li><p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为 <code>0</code> 则结果为 <code>false</code> ，否则结果为 <code>true</code> 。</p></li><li><p>当我们把一个布尔值赋给非布尔类型时，初始值为 <code>false</code> 则结果为 <code>0</code> ，初始值为 <code>true</code> 则结果为 <code>1</code> 。</p></li><li><p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p></li><li><p>当我们把一个整数值赋给浮点类型时，小数部分记为 <code>0</code> 。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p></li><li><p>当我们给无符号类型赋一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如， <code>8</code> 比特大小的 <code>unsigned char</code> 可以表示 <code>0</code> 至 <code>255</code> 区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对 <code>256</code> 取模后所得的余数。因此，把 <code>-1</code> 赋给 <code>8</code> 比特大小的 <code>unsigned char</code> 所得的结果是 <code>255</code> 。</p></li><li><p>当我们给带符号类型赋一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p></li></ol><h2 id="含有无符号类型的表达式"><a class="anchor" href="#含有无符号类型的表达式">#</a> 含有无符号类型的表达式</h2><p>当一个算术表达式中既有无符号数又有 int 值时，那个 int 值就会转换成无符号数。</p><p><strong>如果表达式里既有带符号类型又有无符号类型</strong>，当带符号类型取值为负时会出现异常结果，这是因为<strong>带符号数会自动地转换成无符号数</strong></p><p>例如，在一个形如 <code>a * b</code> 的式子中，如果 <code>a = -1</code> ， <code>b = 1</code> ，而且 <code>a</code> 和 <code>b</code> 都是 <code>int</code> ，则表达式的值显然为 <code>-1</code> 。然而，如果 <code>a</code> 是 <code>int</code> ，而 <code>b</code> 是 <code>unsigned</code> ，则结果须视在当前机器上 <code>int</code> 所占位数而定。在我们的环境里，结果是 <code>4294967295</code> 。</p><blockquote><p><strong>切勿混用带符号类型和无符号类型</strong></p></blockquote><p>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值。</p><p>无符号数不会小于 0 这一事实同样关系到循环的写法。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 以降序的形式逐个输出数字 10 到 0</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 错误：变量 u 永远也不会小于 0，循环条件一直成立</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> u <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>u<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>上例中，当 <code>u</code> 等于 <code>0</code> 时这次迭代输出 <code>0</code> ，然后继续执行 <code>for</code> 语句里的表达式。表达式 <code>--u</code> 从 <code>u</code> 当中减去 <code>1</code> ，得到的结果 <code>-1</code> 并不满足无符号数的要求，此时 <code>-1</code> 被自动地转换成一个合法的无符号数。假设 <code>int</code> 类型占 <code>32</code> 位，则当 <code>u</code> 等于 <code>0</code> 时， <code>--u</code> 的结果将会是 <code>4294967295</code> 。</p><h1 id="字面值常量"><a class="anchor" href="#字面值常量">#</a> 字面值常量</h1><p>字面值常量（literal）：形如 42 的值，一望而知。</p><p>每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p><h2 id="整型和浮点型字面值"><a class="anchor" href="#整型和浮点型字面值">#</a> 整型和浮点型字面值</h2><p>可以将整型字面值写作十进制数、八进制数或十六进制数的形式</p><ul><li><p>以 0 开头的整数代表八进制数</p></li><li><p>以 0x 或 0X 开头的代表十六进制数</p><pre><code> 20 //十进制
 024 //八进制
 0x14 //十六进制
</code></pre></li></ul><p>整型字面值具体的数据类型由它的值和符号决定。<strong>默认情况下，十进制字面值是带符号类型，八进制和十六进制字面值既可能是带符号的也可能是无符号的。</strong></p><ul><li>十进制字面值的类型是 <code>int</code> 、 <code>long</code> 和 <code>long long</code> 中尺寸最小的那个（例如，三者当中最小是 int），当然前提是这种类型要能容纳下当前的值</li><li>八进制和十六进制字面值的类型是能容纳其数值的 <code>int</code> 、 <code>unsigned int</code> 、 <code>long</code> 、 <code>unsigned long</code> 、 <code>long long</code> 和 <code>unsigned long long</code> （即，带符号的和无符号的 <code>int</code> 、 <code>long</code> 、 <code>long long</code> ）中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误</li></ul><p>类型 <code>short</code> 没有对应的字面值</p><blockquote><p>尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如 - 42 的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</p></blockquote><p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 或 e 标识:</p><pre><code>3.14159
3.14159E0
0.
0e0
.001
</code></pre><p>默认的，浮点型字面值是一个 <code>double</code> 。</p><h2 id="字符和字符串字面值"><a class="anchor" href="#字符和字符串字面值">#</a> 字符和字符串字面值</h2><p>由单引号括起来的一个字符称为字符型字面值</p><p>双引号括起来的零个或多个字符则构成字符串型字面值</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token char">'a'</span> <span class="token comment">// 字符字面值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token string">"Hello World!"</span> <span class="token comment">// 字符串字面值</span></pre></td></tr></table></figure><p>字符串字面值的类型实际上是由常量字符构成的数组（array）</p><p><strong>编译器在每个字符串字面值的结尾处添加一个空字符 ( <code>'\0'</code> )</strong> 。因此，字符串字面值的实际长度要比它的内容多 1。</p><p>例如，字面值 'A' 表示的就是单独的字符 A，而字符串 &quot;A&quot; 则代表了一个字符的数组，该数组包含两个字符：一个是字母 A、另一个是空字符。</p><p>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 当书写的字符串字面值比较长，写在一行里不太合适时，分多行书写字符串字面值</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a really, really long string literal "</span></pre></td></tr><tr><td data-num="3"></td><td><pre>          <span class="token operator">&lt;&lt;</span> <span class="token string">"that spans two lines"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="转义序列"><a class="anchor" href="#转义序列">#</a> 转义序列</h2><p>有两类字符程序员不能直接使用：</p><ul><li>一类是不可打印（nonprintable）的字符，如退格或其他控制字符，因为它们没有可视的图符</li><li>另一类是在 C++ 语言中有特殊含义的字符（单引号、双引号、问号、反斜线）</li></ul><p>这些情况需要用到转义序列（escape sequence）</p><p>C++ 语言规定的转义序列包括：</p><blockquote><p>换行符 <code>\n</code><br>纵向制表符 <code>\v</code><br>反斜线 <code>\\</code><br>回车符 <code>\r</code><br>横向制表符 <code>\t</code><br>退格符 <code>\b</code><br>问号 <code>\?</code><br>进纸符 <code>\f</code><br>报警（响铃）符 <code>\a</code><br>双引号 <code>\&quot;</code><br>单引号 <code>\'</code></p></blockquote><p>在程序中，上述转义序列被当作一个字符使用。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>          <span class="token comment">// 转到新一行</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\tHi!\n"</span><span class="token punctuation">;</span>     <span class="token comment">// 输出一个制表符，输出 "Hi!"，转到新一行</span></pre></td></tr></table></figure><p>我们也可以使用泛化的转义序列，其形式是：</p><ul><li><strong><code>\x</code> 后紧跟 1 个或多个十六进制数字</strong></li><li><strong><code>\</code> 后紧跟 1 个、2 个或 3 个八进制数字</strong></li></ul><p>其中，数字部分表示的是字符对应的数值</p><blockquote><p>假设使用的是 Latin-1 字符集，以下是一些示例：（对应 ASCII 表）<br><code>\7</code> 响铃<br><code>\12</code> 换行符<br><code>\40</code> 空格<br><code>\0</code> 空字符<br><code>\115</code> 字符 M<br><code>\x4d</code> 字符 M</p></blockquote><p>例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hi! \x4dO\115!\n"</span><span class="token punctuation">;</span>    <span class="token comment">// 输出 "Hi MOM!"，转到新一行</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">'\115'</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>        <span class="token comment">// 输出 "M"，转到新一行</span></pre></td></tr></table></figure><p>注意：</p><ul><li><p>如果反斜线 <code>\</code> 后面跟着的八进制数字超过 3 个，只有前 3 个数字与 <code>\</code> 构成转义序列。例如， <code>&quot;\1234&quot;</code> 表示 2 个字符，即八进制数 123 对应的字符以及字符 4</p></li><li><p>而 <code>\x</code> 要用到后面跟着的所有数字，例如， <code>&quot;\x1234&quot;</code> 表示一个 16 位的字符，该字符由这 4 个十六进制数所对应的比特唯一确定。因为大多数机器的 <code>char</code> 型数据占 8 位，所以上面这个例子可能会报错。一般来说，超过 8 位的十六进制字符，都是与 下一节所示表格的某个前缀作为开头的扩展字符集 一起使用</p></li></ul><h2 id="指定字面值的类型"><a class="anchor" href="#指定字面值的类型">#</a> 指定字面值的类型</h2><p>通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p><p>字符和字符串字面值：</p><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">含义</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">Unicode 16 字符</td><td style="text-align:center">char16_t</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">Unicode 32 字符</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">宽字符</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center">u8</td><td style="text-align:center">UTF-8 （仅用于字符串字面值常量）</td><td style="text-align:center">char</td></tr></tbody></table><p>整型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">u 或 U</td><td style="text-align:center">unsigned</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">ll 或 LL</td><td style="text-align:center">long long</td></tr></tbody></table><p>浮点型字面值：</p><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">f 或 F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">l 或 L</td><td style="text-align:center">long double</td></tr></tbody></table><p>当使用一个长整型字面值时，请使用大写字母 L 来标记，因为小写字母 l 和数字 1 容易混淆</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>L<span class="token char">'a'</span>        <span class="token comment">// 宽字符型字面值，类型是 wchar_t</span></pre></td></tr><tr><td data-num="2"></td><td><pre>u8<span class="token string">"hi!"</span>     <span class="token comment">// UTF-8 字符串字面值，类型是 char</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">42ULL</span>       <span class="token comment">// 无符号整型字面值，类型是 unsigned long long</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">1E-3F</span>       <span class="token comment">// 单精度浮点型字面值，类型是 float</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">3.14159L</span>    <span class="token comment">// 扩展精度浮点型字面值，类型是 long double</span></pre></td></tr></table></figure><p>对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。</p><ul><li>如果后缀中有 <code>U</code> ，则该字面值属于无符号类型，也就是说，以 <code>U</code> 为后缀的十进制数、八进制数或十六进制数都将从 <code>unsigned int</code> 、 <code>unsigned long</code> 和 <code>unsigned long long</code> 中选择能匹配的空间最小的一个作为其数据类型</li><li>如果后缀中有 <code>L</code> ，则字面值的类型至少是 <code>long</code></li><li>如果后缀中有 <code>LL</code> ，则字面值的类型将是 <code>long long</code> 和 <code>unsigned long long</code> 中的一种</li><li>可以将 <code>U</code> 与 <code>L</code> 或 <code>LL</code> 合在一起使用。例如，以 <code>UL</code> 为后缀的字面值的数据类型将根据具体数值情况或者取 <code>unsigned long</code> ，或者取 <code>unsigned long long</code></li></ul><h2 id="布尔字面值和指针字面值"><a class="anchor" href="#布尔字面值和指针字面值">#</a> 布尔字面值和指针字面值</h2><p><code>true</code> 和 <code>false</code> 是布尔类型的字面值</p><p><code>nullptr</code> 是指针字面值</p><p>参考：C++ Primer 中文版（第 5 版）</p></div><footer><div class="meta"><span class="item"><time title="修改时间：2023-01-14 12:06:40" itemprop="dateModified" datetime="2023-01-14T12:06:40+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2023-01-14 </time></span><span id="posts/dfbe564/" class="item leancloud_visitors" data-flag-title="基本内置类型" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/dfbe564/" title="基本内置类型">https://jiankychen.github.io/posts/dfbe564/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/265d235c/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;01&#x2F;09&#x2F;iJOQELCMdU38rcX.jpg" title="术语表 - Chapter 1"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>术语表 - Chapter 1</h3></a></div><div class="item right"><a href="/posts/13ffbe88/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;01&#x2F;09&#x2F;4z8vUcOpyikRolh.jpg" title="变量"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>变量</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">算术类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%B8%8E%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">整型与浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">带符号类型和无符号类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">如何选择类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">转换规则（简介）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">含有无符号类型的表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">字面值常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">整型和浮点型字面值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">字符和字符串字面值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">指定字面值的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8C%E6%8C%87%E9%92%88%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">3.5.</span> <span class="toc-text">布尔字面值和指针字面值</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/65b9c0a0/" rel="bookmark" title="初识 C++ (上)">初识 C++ (上)</a></li><li><a href="/posts/bf7c72c5/" rel="bookmark" title="初识 C++ (中)">初识 C++ (中)</a></li><li><a href="/posts/7ca2f1e1/" rel="bookmark" title="初识 C++ (下)">初识 C++ (下)</a></li><li><a href="/posts/265d235c/" rel="bookmark" title="术语表 - Chapter 1">术语表 - Chapter 1</a></li><li class="active"><a href="/posts/dfbe564/" rel="bookmark" title="基本内置类型">基本内置类型</a></li><li><a href="/posts/13ffbe88/" rel="bookmark" title="变量">变量</a></li><li><a href="/posts/cb70015e/" rel="bookmark" title="复合类型">复合类型</a></li><li><a href="/posts/d2de0515/" rel="bookmark" title="const 限定符">const 限定符</a></li><li><a href="/posts/49ac794f/" rel="bookmark" title="处理类型">处理类型</a></li><li><a href="/posts/13eb466a/" rel="bookmark" title="自定义数据结构">自定义数据结构</a></li><li><a href="/posts/bf5472e6/" rel="bookmark" title="术语表 - Chapter 2">术语表 - Chapter 2</a></li><li><a href="/posts/65b35a95/" rel="bookmark" title="命名空间的 using 声明">命名空间的 using 声明</a></li><li><a href="/posts/287a6bec/" rel="bookmark" title="标准库类型 string">标准库类型 string</a></li><li><a href="/posts/adaa911e/" rel="bookmark" title="标准库类型 vector">标准库类型 vector</a></li><li><a href="/posts/2cf69f40/" rel="bookmark" title="迭代器">迭代器</a></li><li><a href="/posts/340249a9/" rel="bookmark" title="数组">数组</a></li><li><a href="/posts/b8ffc617/" rel="bookmark" title="多维数组">多维数组</a></li><li><a href="/posts/c8534270/" rel="bookmark" title="术语表 - Chapter 3">术语表 - Chapter 3</a></li><li><a href="/posts/764aaa73/" rel="bookmark" title="表达式基础">表达式基础</a></li><li><a href="/posts/94941b44/" rel="bookmark" title="算术运算符">算术运算符</a></li><li><a href="/posts/b720433a/" rel="bookmark" title="逻辑和关系运算符">逻辑和关系运算符</a></li><li><a href="/posts/d8c07e6e/" rel="bookmark" title="赋值运算符">赋值运算符</a></li><li><a href="/posts/f344ccd0/" rel="bookmark" title="递增和递减运算符">递增和递减运算符</a></li><li><a href="/posts/97f7ea6b/" rel="bookmark" title="成员访问运算符">成员访问运算符</a></li><li><a href="/posts/c5633dd8/" rel="bookmark" title="条件运算符">条件运算符</a></li><li><a href="/posts/a3393ec4/" rel="bookmark" title="位运算符">位运算符</a></li><li><a href="/posts/bcbcc37a/" rel="bookmark" title="sizeof 运算符">sizeof 运算符</a></li><li><a href="/posts/beb9f4f/" rel="bookmark" title="逗号运算符">逗号运算符</a></li><li><a href="/posts/61165acd/" rel="bookmark" title="类型转换">类型转换</a></li><li><a href="/posts/7ef1d852/" rel="bookmark" title="运算符优先级表">运算符优先级表</a></li><li><a href="/posts/376af364/" rel="bookmark" title="术语表 - Chapter 4">术语表 - Chapter 4</a></li><li><a href="/posts/d4abf28b/" rel="bookmark" title="语句与语句作用域">语句与语句作用域</a></li><li><a href="/posts/25684c8f/" rel="bookmark" title="条件语句">条件语句</a></li><li><a href="/posts/3d73fa60/" rel="bookmark" title="迭代语句">迭代语句</a></li><li><a href="/posts/68c42004/" rel="bookmark" title="跳转语句">跳转语句</a></li><li><a href="/posts/d1e07041/" rel="bookmark" title="try 语句块和异常处理">try 语句块和异常处理</a></li><li><a href="/posts/1a3d3e5c/" rel="bookmark" title="术语表 - Chapter 5">术语表 - Chapter 5</a></li><li><a href="/posts/1111c3f5/" rel="bookmark" title="函数基础">函数基础</a></li><li><a href="/posts/350b832e/" rel="bookmark" title="参数传递">参数传递</a></li><li><a href="/posts/6944583e/" rel="bookmark" title="返回类型和 return 语句">返回类型和 return 语句</a></li><li><a href="/posts/eefc49a4/" rel="bookmark" title="函数重载">函数重载</a></li><li><a href="/posts/1513ad78/" rel="bookmark" title="特殊用途语言特性">特殊用途语言特性</a></li><li><a href="/posts/a1233158/" rel="bookmark" title="函数匹配">函数匹配</a></li><li><a href="/posts/42aabc7d/" rel="bookmark" title="函数指针">函数指针</a></li><li><a href="/posts/8af7b840/" rel="bookmark" title="术语表 - Chapter 6">术语表 - Chapter 6</a></li><li><a href="/posts/375bbd22/" rel="bookmark" title="定义抽象数据类型">定义抽象数据类型</a></li><li><a href="/posts/760f37e5/" rel="bookmark" title="访问控制与封装">访问控制与封装</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://s2.loli.net/2023/01/01/hnmYMxBAwF9QelU.jpg"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">285</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/265d235c/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/13ffbe88/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/59ae1e23/" title="LeetCode 136. 只出现一次的数字">LeetCode 136. 只出现一次的数字</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/a06c07a7/" title="LeetCode 90. 子集 II">LeetCode 90. 子集 II</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/7c57862a/" title="LeetCode 301. 删除无效的括号">LeetCode 301. 删除无效的括号</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/6ce9cc69/" title="LeetCode 42. 接雨水">LeetCode 42. 接雨水</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/8e9df849/" title="LeetCode 55. 跳跃游戏">LeetCode 55. 跳跃游戏</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/bcf47f8f/" title="LeetCode 19. 删除链表的倒数第 N 个结点">LeetCode 19. 删除链表的倒数第 N 个结点</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/1111c3f5/" title="函数基础">函数基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/7c5d77fa/" title="LeetCode 206. 反转链表">LeetCode 206. 反转链表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/35c387f3/" title="LeetCode 283. 移动零">LeetCode 283. 移动零</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/b97e9d80/" title="LeetCode 438. 找到字符串中所有字母异位词">LeetCode 438. 找到字符串中所有字母异位词</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://cdn.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">833k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">23:08</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/dfbe564/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="https://cdn.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->