<!-- build time:Sun Oct 22 2023 16:01:08 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/css/app.css?v=0.2.5"><link rel="canonical" href="https://jiankychen.github.io/posts/59bf225c/"><title>Python 面向对象 - Python | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Python 面向对象</h1><div class="meta"><span class="item" title="创建时间：2023-02-02 17:48:52"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-02-02T17:48:52+08:00">2023-02-02</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://www.helloimg.com/image/oTnMru"></li><li class="item" data-background-image="https://www.helloimg.com/image/oTH2sh"></li><li class="item" data-background-image="https://www.helloimg.com/image/oTniQS"></li><li class="item" data-background-image="https://www.helloimg.com/image/oTn5uP"></li><li class="item" data-background-image="https://www.helloimg.com/image/oTbZD5"></li><li class="item" data-background-image="https://www.helloimg.com/image/oTnFlA"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Python/" itemprop="item" rel="index" title="分类于 Python"><span itemprop="name">Python</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/59bf225c/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><p>Python 是一种面向对象的编程语言</p><p>简单理解 面向对象 ：基于模板（类）去创建实体（对象），使用对象完成功能开发</p><p>面向对象的三大特征：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>面向对象技术简介</p><ul><li>类（Class）: 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法</li><li>实例化：创建一个类的实例（类的具体对象）</li><li>方法：类中定义的函数</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用</li><li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写</li><li>局部变量：定义在方法中的变量，只作用于当前实例的类</li><li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟 &quot;是一个（is-a）&quot; 关系（即，Dog 是一个 Animal）</li></ul><h1 id="类和对象"><a class="anchor" href="#类和对象">#</a> 类和对象</h1><p>类的组成：</p><ul><li>成员变量：定义在类中的属性（变量）</li><li>成员方法：定义在类中的行为（函数）</li></ul><h2 id="类定义"><a class="anchor" href="#类定义">#</a> 类定义</h2><p>使用关键字 <code>class</code> 定义类：</p><pre><code class="language-python">class Class_Name:
    &lt;statement-1&gt;
    ...
    &lt;statement-N&gt;
</code></pre><p>其中， <code>Class_Name</code> 表示类的名称，通常需要首字母大写</p><h2 id="类对象"><a class="anchor" href="#类对象">#</a> 类对象</h2><p>创建对象（实例化）：</p><pre><code class="language-python">obj = Class_Name()
</code></pre><p>修改对象属性：</p><pre><code class="language-python">obj.var_name = xx
</code></pre><p>删除对象属性：</p><pre><code class="language-python"># 使用 del 关键字删除对象的属性
del obj.var_name
</code></pre><p>删除对象：</p><pre><code class="language-python"># 使用 del 关键字删除对象
del obj
</code></pre><h2 id="类的成员方法"><a class="anchor" href="#类的成员方法">#</a> 类的成员方法</h2><ul><li>函数：定义在类的外部</li><li>方法：定义在类的内部</li></ul><p>在类的内部，使用 <code>def</code> 关键字来定义一个方法，与一般函数定义不同，类的成员方法必须必须有一个额外的第一个参数名称，按照惯例它的名称是 <code>self</code> ，即：</p><pre><code class="language-python">def func_name(self, parameter_1, ..., parameter_N):
    ...
</code></pre><p>其中：</p><ul><li><p><code>self</code> 参数是对类的当前实例的引用，用于访问属于该类的变量。它不必被命名为 <code>self</code> ，但它必须是类中任意函数的首个参数</p></li><li><p>在方法内部，想要访问类的成员变量，必须使用 <code>self</code> 。即，使用 <code>self.var_name</code> 访问成员变量 <code>var_nam</code></p></li><li><p>调用类的成员方法时， <code>self</code> 会被自动传入，即，不需要在实参列表中写出 <code>self</code></p></li></ul><h2 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h2><p>Python 类中的 <code>__init__</code> 方法，称之为 构造方法</p><p>每次使用类创建新对象时，都会自动调用 <code>__init__</code> 方法，并且会将创建类对象时的传入参数自动传递给 <code>__init__</code> 方法</p><p>因此，使用 <code>__init__</code> 方法可以将值赋给对象属性，或者在创建对象时需要执行的其他操作</p><p>注意，构造方法 也是 成员方法，因此：</p><ul><li>定义构造方法时需要在形参列表中写上 <code>self</code> 参数</li><li>在构造方法内部访问成员变量需要使用 <code>self.var_name</code></li></ul><p>例如：</p><pre><code class="language-python"># 定义类
class Person:
    name = None     # 由于定义了 __init__ 方法，可以省略这里的初始化
    age = None      # 由于定义了 __init__ 方法，可以省略这里的初始化

    def __init__(self, name, age):
        self.name = name
        self.age = age


# 创建类对象
p = Person(&quot;John&quot;, 24)

# 打印类对象的属性
print(p.name)
print(p.age)
</code></pre><h2 id="魔术方法"><a class="anchor" href="#魔术方法">#</a> 魔术方法</h2><p>魔术方法（Magic Methods）是 Python 中的内置方法，一般以 <code>__</code> （双下划线）为开头和结尾</p><p>例如：</p><ul><li><code>__init__</code> ：构造方法，当一个实例被创建的时候调用的初始化方法</li><li><code>__del__</code> ：析构方法，当一个实例被销毁的时候调用的方法</li><li><code>__str__</code> ：字符串方法，定义当被 <code>str()</code> 调用或者打印对象时的行为</li><li><code>__lt__</code> ：定义小于号的行为： <code>x &lt; y</code> 调用 <code>x.__lt__(y)</code></li><li><code>__le__</code> ：定义小于等于号的行为： <code>x &lt;= y</code> 调用 <code>x.__le__(y)</code></li><li><code>__eq__</code> ：定义等于号的行为： <code>x == y</code> 调用 <code>x.__eq__(y)</code></li></ul><p>之所以称之为魔法方法，是因为这些方法会在进行特定的操作时会被自动调用</p><p>如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZGFjaGVuemkvcC84MTg1NzkyLmh0bWw=">Python 中类的魔术方法</span></p><h2 id="pass-语句"><a class="anchor" href="#pass-语句">#</a> pass 语句</h2><p><code>pass</code> 是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容</p><p>如果因为某种原因写了无内容的函数定义或类定义，需使用 <code>pass</code> 语句来避免错误</p><p>例如：</p><pre><code class="language-python"># 继承
class DerivedClassName(BaseClassName):
    pass
</code></pre><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3B5dGhvbi9weXRob25fY2xhc3Nlcy5hc3A=">W3school：Python 类和对象</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24zL3B5dGhvbjMtY2xhc3MuaHRtbA==">菜鸟教程：Python3 面向对象</span></li></ul><h1 id="封装"><a class="anchor" href="#封装">#</a> 封装</h1><p>在程序设计中，封装（Encapsulation）是对具体对象的一种抽象，即将某些部分隐藏起来（即，定义成私有成员），在程序外部看不到（即，其他程序无法调用）</p><ul><li>封装数据：保护隐私</li><li>封装方法：隔离复杂度（只保留部分接口对外使用）</li></ul><h2 id="私有成员"><a class="anchor" href="#私有成员">#</a> 私有成员</h2><p>类对象无法直接访问私有成员，但类内其它成员可以直接使用私有成员</p><p>私有成员变量：</p><ul><li>定义：变量名以 <code>__</code> （2 个下划线）开头，例如： <code>__private_attrs</code></li><li>声明该属性为私有属性，只能在类的内部使用，不能在类的外部使用或直接访问</li><li>在类内部的访问方式为： <code>self.__private_attrs</code></li></ul><p>私有成员方法（封装的方法）：</p><ul><li>方法名以 <code>__</code> （2 个下划线）开头，例如： <code>__private_method</code></li><li>声明该方法为私有方法，只能在类的内部调用，不能在类的外部调用</li><li>在类内部的调用方式为： <code>self.__private_method()</code></li></ul><blockquote><p>与 java 等语言不同，Python 的封装并不是真正意义上的外部无法调用。在 Python 中，如果需要在类外调用封装的属性或方法，须采用 <code>对象名._类名__方法名</code> 和 <code>对象名._类名__变量名</code> 的方式（不建议调用）</p></blockquote><p>例如：</p><pre><code class="language-python">class Foo:
    def __init__(self, height, weight):     # 构造方法
        self.height = height
        self.weight = weight
    
    def __heightpow(self):      # 私有方法
        return self.height * self.height
    
    def tell_bmi(self):
        return self.weight / self.__heightpow() # 私有成员可以被类内其它成员直接使用

egon = Foo(1.7, 120)
print(egon.tell_bmi())
print(egon._Foo__heightpow())   # 尽管是私有成员方法，但也可以在类外调用以供查看
</code></pre><h2 id="property"><a class="anchor" href="#property">#</a> property</h2><p>property 是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值（就是一个装饰器）</p><p>将一个类的方法 <code>func_name</code> 用 propery 装饰以后，类对象 <code>obj</code> 可直接通过 <code>obj.func_name</code> 去使用，以遵循统一访问的原则</p><blockquote><p>被 property 装饰的属性会优先于对象的属性被使用</p></blockquote><p>被 propery 装饰的属性分成三种：</p><ul><li>property</li><li>被装饰的函数名.setter</li><li>被装饰的函数名.deleter</li></ul><p>例如， <code>@property</code> 把类中的方法伪装成属性：</p><pre><code class="language-python">from math import pi

class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property   # 装饰器：将一个方法当成一个属性用
    def area(self):
        return self.radius * self.radius * pi

    @property
    def peimeter(self):
        return 2 * pi * self.radius

c = Circle(10)
print(c.area)       # 当成一个属性来调用（即，不需要加括号）
print(c.peimeter)   # 当成一个属性来调用（即，不需要加括号）
</code></pre><p>注意：此时的特性 area 和 perimeter 不能被赋值</p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTWljaGFlbC0tY2hlbi9wLzY3NDA0NTUuaHRtbA==">Python 基础之封装</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGFpeWFuMTIzL3AvNzM2NzM0My5odG1s">Python 封装</span></li></ul><h1 id="继承"><a class="anchor" href="#继承">#</a> 继承</h1><p>继承允许我们定义继承（复制）另一个类的所有方法和属性的类</p><p>继承可以分为：</p><ul><li>单继承：一个类继承另一个类</li><li>多继承：一个类继承多个类，按照顺序从左向右依次继承</li></ul><p>父类是被继承的类，也称为基类</p><p>子类是从另一个类继承所得的类，也称为派生类</p><h2 id="单继承"><a class="anchor" href="#单继承">#</a> 单继承</h2><blockquote><p>任何类都可以是父类，因此，创建父类的语法与创建任何其他类相同</p></blockquote><p>要创建从其他类继承功能的类，只需在创建子类时将父类作为参数传递即可：</p><pre><code class="language-python">class DerivedClassName(BaseClassName):
    &lt;statement-1&gt;
    ...
    &lt;statement-N&gt;
</code></pre><p>其中， <code>DerivedClassName</code> 为子类名， <code>BaseClassName</code> 为父类名</p><blockquote><p>如果不希望向子类中添加任何其他属性或方法，可使用 <code>pass</code> 关键字</p></blockquote><p>例如：</p><pre><code class="language-python"># 创建 Person 类
class Person:
    def __init__(self, fname, lname):
        self.firstname = fname
        self.lastname = lname

    def print_name(self):
    print(self.firstname, self.lastname)

# 创建 Person 类对象，并执行 print_name 方法
x = Person(&quot;Bill&quot;, &quot;Gates&quot;)
x.print_name()


# 创建继承自 Person 类的子类 Student
class Student(Person):
    def __init__(self, fname, lname, gra):
        self.firstname = fname
        self.lastname = lname
        self.grade = gra
    
    def print_info(self):
        print(self.firstname, self.lastname, self.grade)

# 使用 Student 类创建一个对象，然后执行 print_name 和 print_info 方法
y = Student(&quot;Elon&quot;, &quot;Musk&quot;, 6)
y.print_name()
y.print_info()
</code></pre><h2 id="多继承"><a class="anchor" href="#多继承">#</a> 多继承</h2><p>创建子类的语法：</p><pre><code class="language-python">class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    ...
    &lt;statement-N&gt;
</code></pre><p>如果多个父类中含有同名的成员，那么默认按照从左向右顺序依次继承，先继承的保留，后继承的被覆盖</p><h2 id="方法重写"><a class="anchor" href="#方法重写">#</a> 方法重写</h2><p>子类继承父类的成员属性和成员方法后，如果对其 “不满意”，可以在子类重写父类的方法</p><p>即：在子类中重新定义同名的属性或方法</p><p>例如：</p><pre><code class="language-python">class Parent:           # 定义父类
    def myMethod(self):
        print ('调用父类方法')

class Child(Parent):    # 定义子类
    def myMethod(self):  # 重写父类方法
        print ('调用子类方法')

c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
</code></pre><h2 id="调用父类同名成员"><a class="anchor" href="#调用父类同名成员">#</a> 调用父类同名成员</h2><p>一旦在子类中重写父类成员以后，子类的类对象调用成员时将是调用复写后的新成员</p><p>如果需要使用被复写的父类的成员，需要特殊的调用方式:</p><ul><li><p>方式一：通过父类调用（单继承</p><ul><li>调用父类成员变量： <code>父类名.成员变量</code></li><li>调用父类成员方法： <code>父类名.成员方法(self)</code></li></ul></li><li><p>方式二：使用 <code>super()</code> 调用</p><ul><li>调用父类成员变量： <code>super().成员变量</code></li><li>调用父类成员方法： <code>super().成员方法()</code></li></ul></li></ul><p>如果是单继承的情况，可以直接用父类名调用父类方法</p><p>但是，如果是多继承的情况，可能会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题，此时，推荐采用 <code>super()</code> 函数调用，以解决多重继承问题。具体可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24vcHl0aG9uLWZ1bmMtc3VwZXIuaHRtbA==">Python super () 函数</span></p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3B5dGhvbi9weXRob25faW5oZXJpdGFuY2UuYXNw">Python 继承</span></li></ul><h1 id="类型注解"><a class="anchor" href="#类型注解">#</a> 类型注解</h1><p>类型注解：在代码中涉及数据交互的地方，提供数据类型的注解（显式的说明）</p><ul><li>帮助第三方 IDE 工具（如 PyCharm）对代码进行类型推断，协助做代码提示</li><li>帮助开发者自身对变量进行类型注释</li></ul><p>有两种注解：</p><ul><li>变量的类型注解</li><li>函数（方法）的类型注解</li></ul><p>需注意：类型注解仅仅是提示性的，不是决定性的，并不会真正地对类型做验证和判断（也就是说：即使注解的数据类型与实际数据类型不一致，程序也不会报错）</p><h2 id="变量的类型注解"><a class="anchor" href="#变量的类型注解">#</a> 变量的类型注解</h2><p>事实上，对于显式的变量定义，一般无需注解。即便不写类型注解，也可以明确知晓变量的类型</p><p>一般而言，在无法直接看出变量类型时（例如，将函数返回值赋给一个变量时），才会添加变量的类型注解</p><h3 id="方式一常用"><a class="anchor" href="#方式一常用">#</a> 方式一（常用）</h3><p>基础语法：</p><pre><code class="language-python">变量: 类型
</code></pre><p>例如：</p><p>基础数据类型注解：</p><pre><code class="language-python">var1: int = 3
var2: float = 3.14
var3: bool = True
</code></pre><p>类对象类型注解:</p><pre><code class="language-python">class Person:
    pass
p: Person = Person()
</code></pre><p>容器类型简易注解：</p><pre><code class="language-python">mylist: list = [1, 2, 3]
mytuple: tuple = (1, 2, 3)
myset: set = &#123;1, 2, 3&#125;
mydict: dict = &#123;0: &quot;a&quot;, 1: &quot;b&quot;&#125;
mystr: str = &quot;Jiankychen&quot;
</code></pre><p>容器类型详细注解：</p><ul><li>元组类型设置类型详细注解：需要将每一个元素都标记出来</li><li>字典类型设置类型详细注解：需要 2 个类型，第一个是 key ，第二个是 value</li></ul><pre><code class="language-python">mylist: list[int] = [1, 2, 3]
mytuple: tuple[str, int, bool] = (&quot;a&quot;, 0, True)
myset: set[int] = &#123;1, 2, 3&#125;
mydict: dict[int, str] = &#123;0: &quot;a&quot;, 1: &quot;b&quot;&#125;
</code></pre><h3 id="方式二"><a class="anchor" href="#方式二">#</a> 方式二</h3><p>除了使用 <code>变量: 类型</code> 这种语法做注解外，也可以 <strong>在注释中进行类型注解</strong></p><p>基础语法：</p><pre><code class="language-python"># type: 类型
</code></pre><p>例如：</p><pre><code class="language-python">class Person:
    pass

def func():
    return 3.14159

var1 = random.randint(1, 10)    # type: int
var2 = Person()                 # type: Person
var3 = func()                   # type: float
</code></pre><h2 id="函数方法的类型注解"><a class="anchor" href="#函数方法的类型注解">#</a> 函数（方法）的类型注解</h2><h3 id="形参注解"><a class="anchor" href="#形参注解">#</a> 形参注解</h3><p>函数（方法）的形参类型注解语法：</p><pre><code class="language-python">def func_name(形参名: 类型, 形参名: 类型, ...)
    statement
</code></pre><p>例如：</p><pre><code class="language-python">def add(x: int, y: int):
    return x + y
</code></pre><h3 id="返回值注解"><a class="anchor" href="#返回值注解">#</a> 返回值注解</h3><p>函数（方法）的返回值也是可以添加类型注解的，语法如下：</p><pre><code class="language-python">def func_name() -&gt; 返回值类型:
    statement
</code></pre><p>例如：</p><pre><code class="language-python">def func(data: list) -&gt; list:
    return data
</code></pre><h2 id="union-类型"><a class="anchor" href="#union-类型">#</a> Union 类型</h2><p>通过 <code>Union</code> 可以定义联合类型</p><ul><li>导包： <code>from typing import Union</code></li><li>使用： <code>Union[类型, ..., 类型]</code></li></ul><p>在变量注解、函数（方法）形参和返回值注解中，均可使用 <code>Union</code> 联合类型</p><p>例如：</p><pre><code class="language-python">from typing import Union

mylist: list[Union[str, int]] = [1, 2, &quot;3&quot;, &quot;4&quot;]    # list 元素的数据类型可能是 str ，也可能是 int

mydict: dict[str, Union[str, int]] = &#123;&quot;name&quot;: &quot;Jiankychen&quot;, &quot;age&quot;: 24&#125;      # value 的数据类型可能是 str ，也可能是 int

def func(data: Union[int, str]) -&gt; Union[int, str]:
    return data
</code></pre><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVT9wPTEyMg==">黑马程序员 Python 教程：类型注解</span></li></ul><h1 id="多态"><a class="anchor" href="#多态">#</a> 多态</h1><p>多态：多种状态，即：对于某个行为（函数），使用不同的对象将会得到不同的状态</p><p>例如： <code>Cat</code> 类和 <code>Dog</code> 类都有 <code>speak</code> 成员方法， <code>Cat</code> 类对象和 <code>Dog</code> 类对象都能被传入 <code>command</code> 函数；但是由于两个类定义的 <code>speak</code> 方法的功能不一致，传入不同类的对象就会得到不同的状态</p><pre><code class="language-python">class Cat:
    def speak(self):
        print &quot;meow!&quot;

class Dog:
    def speak(self):
        print &quot;woof!&quot;

def command(pet):
    pet.speak()

cat = Cat()
command(cat)    # 输出：meow!

dog = Dog()
command(dog)    # 输出：woof!
</code></pre><p>多态常作用在继承关系上，比如：定义函数（方法），通过类型注解声明需要父类对象，实际传入子类对象进行工作，从而获得不同的工作状态</p><p>例如，可以将上例中的代码修改为：</p><pre><code class="language-python">class Pet:
    def speak(self)
        pass

class Cat(Pet):
    def speak(self):
        print &quot;meow!&quot;

class Dog(Pet):
    def speak(self):
        print &quot;woof!&quot;

def command(pet: Pet):  # 函数形参的类型注解
    pet.speak()

cat = Cat()
command(cat)    # 输出：meow!

dog = Dog()
command(dog)    # 输出：woof!
</code></pre><h2 id="抽象类接口"><a class="anchor" href="#抽象类接口">#</a> 抽象类（接口）</h2><p>抽象方法：没有具体实现的方法（即：方法体是 <code>pass</code> 语句）</p><p>抽象类：包含抽象方法的类，也可以称之为 接口，比如上例中的 <code>Pet</code> 类</p><p>抽象类相当于定义一个标准，包含了一些抽象的方法，要求子类必须实现</p><p>这种设计的意义在于：</p><ul><li>父类用来确定有哪些方法</li><li>具体的方法实现，由子类自行决定</li></ul><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFXNHkxYTdmVT9wPTEyMw==">黑马程序员 Python 教程：多态</span></li></ul></div><footer><div class="meta"><span class="item"><time title="修改时间：2023-02-04 23:03:25" itemprop="dateModified" datetime="2023-02-04T23:03:25+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2023-02-04 </time></span><span id="posts/59bf225c/" class="item leancloud_visitors" data-flag-title="Python 面向对象" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/59bf225c/" title="Python 面向对象">https://jiankychen.github.io/posts/59bf225c/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/ebba65fe/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;www.helloimg.com&#x2F;image&#x2F;oTbMbE" title="pandas 基础"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Python</span><h3>pandas 基础</h3></a></div><div class="item right"><a href="/posts/f416b295/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;www.helloimg.com&#x2F;image&#x2F;oTnFlA" title="SQL 基础"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> SQL</span><h3>SQL 基础</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">类定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">类的成员方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">魔术方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pass-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.6.</span> <span class="toc-text">pass 语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-number">2.1.</span> <span class="toc-text">私有成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property"><span class="toc-number">2.2.</span> <span class="toc-text">property</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="toc-number">3.1.</span> <span class="toc-text">单继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.3.</span> <span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98"><span class="toc-number">3.4.</span> <span class="toc-text">调用父类同名成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">变量的类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E5%B8%B8%E7%94%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">方式一（常用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">4.1.2.</span> <span class="toc-text">方式二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.</span> <span class="toc-text">函数（方法）的类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.1.</span> <span class="toc-text">形参注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.2.</span> <span class="toc-text">返回值注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">Union 类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">5.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">抽象类（接口）</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/2bc936a0/" rel="bookmark" title="Python 基本语法">Python 基本语法</a></li><li><a href="/posts/23926cd4/" rel="bookmark" title="Python 数据容器">Python 数据容器</a></li><li><a href="/posts/78c82d0a/" rel="bookmark" title="Python 文件操作">Python 文件操作</a></li><li><a href="/posts/11ea1840/" rel="bookmark" title="Python 异常、模块、包">Python 异常、模块、包</a></li><li><a href="/posts/b80c5159/" rel="bookmark" title="conda 常用命令">conda 常用命令</a></li><li><a href="/posts/ebba65fe/" rel="bookmark" title="pandas 基础">pandas 基础</a></li><li class="active"><a href="/posts/59bf225c/" rel="bookmark" title="Python 面向对象">Python 面向对象</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">251</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/ebba65fe/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/f416b295/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/23926cd4/" title="Python 数据容器">Python 数据容器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/bcf47f8f/" title="LeetCode 19. 删除链表的倒数第 N 个结点">LeetCode 19. 删除链表的倒数第 N 个结点</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/bbdfe11c/" title="LeetCode 461. 汉明距离">LeetCode 461. 汉明距离</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/74cc4150/" title="LeetCode 452. 用最少数量的箭引爆气球">LeetCode 452. 用最少数量的箭引爆气球</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/38849bf2/" title="LeetCode 530. 二叉搜索树的最小绝对差">LeetCode 530. 二叉搜索树的最小绝对差</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/46ac943d/" title="LeetCode 213. 打家劫舍 II">LeetCode 213. 打家劫舍 II</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/c8de8ad/" title="LeetCode 399. 除法求值">LeetCode 399. 除法求值</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/a04bbb24/" title="LeetCode 515. 在每个树行中找最大值">LeetCode 515. 在每个树行中找最大值</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/3e7ca0d2/" title="剑指 Offer 06. 从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/c10e195a/" title="LeetCode 349. 两个数组的交集">LeetCode 349. 两个数组的交集</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">814k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:37</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/59bf225c/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->