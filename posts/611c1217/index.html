<!-- build time:Sat Mar 23 2024 01:17:14 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="双指针"><link rel="canonical" href="https://jiankychen.github.io/posts/611c1217/"><title>LeetCode - 双指针专题 - Coding | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">LeetCode - 双指针专题</h1><div class="meta"><span class="item" title="创建时间：2022-07-23 16:36:26"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-07-23T16:36:26+08:00">2022-07-23</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>28 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/488297bfd0233b6c6a444f1860e55d45.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/8fe50780c15461b629c9aeab5a7f2acd.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/9b626c5ba21d7cb4dbcba2b507688bbb.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/42bab566f107b9a16542343e0368fb77.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/8491109c4ae2ac88bbf9659a4f6d5ed2.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Coding/" itemprop="item" rel="index" title="分类于 Coding"><span itemprop="name">Coding</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/611c1217/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="leetcode-11-盛最多水的容器"><a class="anchor" href="#leetcode-11-盛最多水的容器">#</a> LeetCode 11. 盛最多水的容器</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLw==">11. Container With Most Water</span></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明</strong>：你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/Example1.jpg" alt="" height="200px"></p><pre><code>输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：height = [1,1]
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>height[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-双指针"><a class="anchor" href="#method-双指针">#</a> Method: 双指针</h2><p>算法思路：</p><p>定义指针 <code>i</code> 和 <code>j</code> ，分别指向水槽的左右边界</p><p>水槽的容积由短板决定，即，水槽容积为 <code>(j - i) * min(height[i], height[j])</code></p><p>在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽的底边宽度变小：</p><ul><li>若将短板向内侧移动， <code>min(height[i], height[j])</code> 可能会变大，因此，下个水槽的容积可能会增大</li><li>若将长板向内侧移动， <code>min(height[i], height[j])</code> ​ 不变或者会变小，因此，下个水槽的容积一定变小</li></ul><p>因此，可以令双指针分别指向 <code>height</code> 的首尾，每次将短板向内侧移动一格，更新最大容积，直到两指针相遇时循环结束，即可获得最大容积</p><p>代码实现：</p><pre><code class="language-cpp">int maxArea(vector&lt;int&gt;&amp; height) &#123;
    int i = 0;
    int j = height.size() - 1;
    int res = 0;
    while (i &lt; j) &#123;
        if (height[i] &lt;= height[j]) &#123;
            res = max(res, (j - i) * height[i]);
            i++;
        &#125; else &#123;
            res = max(res, (j - i) * height[j]);
            j--;
        &#125;
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 <code>height</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-167-两数之和-ii-输入有序数组"><a class="anchor" href="#leetcode-167-两数之和-ii-输入有序数组">#</a> LeetCode 167. 两数之和 II - 输入有序数组</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQv">LeetCode 167</span></p><p>给你一个下标从 1 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code> 。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
</code></pre><h2 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h2><p>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较：</p><ol><li>如果两个元素之和等于目标值，则发现了唯一解。</li><li>如果两个元素之和小于目标值，则将左侧指针右移一位。</li><li>如果两个元素之和大于目标值，则将右侧指针左移一位。</li></ol><p>移动指针之后，重复上述操作，直到找到答案。</p><pre><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;
    int i = 0, j = numbers.size() - 1;
    while (i &lt; j)
    &#123;
        if (numbers[i] == target - numbers[j])
            return &#123;i + 1, j + 1&#125;;
        else if (numbers[i] &lt; target - numbers[j])
            i++;
        else
            j--;
    &#125;;
    return &#123;-1, -1&#125;;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度。两个指针移动的总次数最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-二分查找"><a class="anchor" href="#method-2-二分查找">#</a> Method 2: 二分查找</h2><p>在数组中找到两个数，使得它们的和等于目标值，可以首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。</p><pre><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;
    for (int i = 0; i &lt; numbers.size(); ++i) &#123;
        int low = i + 1, high = numbers.size() - 1;
        while (low &lt;= high) &#123;
            int mid = (high - low) / 2 + low;
            if (numbers[mid] == target - numbers[i]) &#123;
                return &#123;i + 1, mid + 1&#125;;
            &#125; else if (numbers[mid] &gt; target - numbers[i]) &#123;
                high = mid - 1;
            &#125; else &#123;
                low = mid + 1;
            &#125;
        &#125;
    &#125;
    return &#123;-1, -1&#125;;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><ul><li>需要遍历数组一次确定第一个数，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>寻找第二个数使用二分查找，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQvc29sdXRpb24vbGlhbmctc2h1LXpoaS1oZS1paS1zaHUtcnUteW91LXh1LXNodS16dS1ieS1sZWV0LTIv">题解：推荐使用双指针方法</span></p><h1 id="leetcode-189-轮转数组"><a class="anchor" href="#leetcode-189-轮转数组">#</a> LeetCode 189. 轮转数组</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWFycmF5Lw==">LeetCode 189. Rotate Array</span></p><p>给定一个整数数组 <code>nums</code> ，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,4,5,6,7], k = 3
输出：[5,6,7,1,2,3,4]
解释：
    向右轮转 1 步: [7,1,2,3,4,5,6]
    向右轮转 2 步: [6,7,1,2,3,4,5]
    向右轮转 3 步: [5,6,7,1,2,3,4]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释：
    向右轮转 1 步: [99,-1,-100,3]
    向右轮转 2 步: [3,99,-1,-100]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>k</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶：</strong></p><ul><li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><h2 id="method-1-使用额外的数组"><a class="anchor" href="#method-1-使用额外的数组">#</a> Method 1: 使用额外的数组</h2><blockquote><p>当我们将数组的元素向右移动 <code>k</code> 次后，尾部 <code>k mod n</code> 个元素会移动至数组头部，其余元素向后移动 <code>k mod n</code> 个位置。</p></blockquote><p>使用额外的数组来将每个元素放至正确的位置。用 <code>n</code> 表示数组的长度，我们遍历原数组，将原数组下标为 <code>i</code> 的元素放至新数组下标为 <code>(i + k) mod n</code> 的位置，最后将新数组拷贝至原数组即可</p><pre><code class="language-cpp">void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;
    int n = nums.size();
    vector&lt;int&gt; temp(n);
    for (int i = 0; i &lt;= n - 1; i++)
        temp[(i + k) % n] = nums[i];
    nums.assign(temp.begin(), temp.end());
&#125;
</code></pre><h2 id="method-2-数组翻转"><a class="anchor" href="#method-2-数组翻转">#</a> Method 2: 数组翻转</h2><p>先将所有元素翻转，这样尾部的 <code>k mod n</code> 个元素就被移至数组头部，然后我们再翻转 <code>[0, k mod n − 1]</code> 区间的元素和 <code>[k mod n, n − 1]</code> 区间的元素即能得到最后的答案</p><p><img data-src="LeetCode189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/1.png" alt="数组翻转"></p><pre><code class="language-cpp">// 水平翻转 nums 中 left 到 right 之间的元素
void reverse(vector&lt;int&gt;&amp; nums, int left, int right) &#123;
    while (left &lt; right)
    &#123;
        swap(nums[left], nums[right]);
        left++;
        right--;
    &#125;;
&#125;


void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;
    int n = nums.size() - 1;
    reverse(nums, 0, n);                      // 翻转第0至nums.size()-1个元素
    reverse(nums, 0, (k % nums.size()) - 1);  // 翻转第0至k%nums.size()-1个元素
    reverse(nums, (k % nums.size()), n);      // 翻转第k%nums.size()至nums.size()-1个元素
&#125;
</code></pre><h1 id="leetcode-283-移动零"><a class="anchor" href="#leetcode-283-移动零">#</a> LeetCode 283. 移动零</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW92ZS16ZXJvZXMv">LeetCode 283. Move Zeroes</span></p><p>给定一个数组 <code>nums</code> ，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [0,1,0,3,12]
输出：[1,3,12,0,0]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]
输出：[0]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>&lt;</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">-2^{31} &lt;=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li></ul><p><strong>进阶</strong>：你能尽量减少完成的操作次数吗？</p><h2 id="method-双指针-2"><a class="anchor" href="#method-双指针-2">#</a> Method: 双指针</h2><p>算法思路：</p><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移</p><p>因此，每次交换都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变</p><p>代码实现：</p><pre><code class="language-cpp">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;
    int left = 0;
    for (int right = 0; right &lt; nums.size(); ++right) &#123;
        if (nums[right]) &#123;
            swap(nums[left], nums[right]);
            ++left;
        &#125;
    &#125;
&#125;
</code></pre><p>或者：</p><pre><code class="language-cpp">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;
    int left = 0;
    for (int right = 0; right &lt; nums.size(); ++right) &#123;
        if (nums[right]) &#123;
            nums[left] = nums[right];
            ++left;
        &#125;
    &#125;
    for (; left &lt; nums.size(); ++left) &#123;
        nums[left] = 0;
    &#125;
&#125;
</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy9zb2x1dGlvbi95aS1kb25nLWxpbmctYnktbGVldGNvZGUtc29sdXRpb24v">leetcode-solution</span></p><h1 id="leetcode-3-无重复字符的最长子串"><a class="anchor" href="#leetcode-3-无重复字符的最长子串">#</a> LeetCode 3. 无重复字符的最长子串</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">3. Longest Substring Without Repeating Characters</span></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abcabcbb&quot;
输出：3
解释：因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;bbbbb&quot;
输出：1
解释：因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;pwwkew&quot;
输出：3
解释：因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre><h2 id="method-滑动窗口"><a class="anchor" href="#method-滑动窗口">#</a> Method: 滑动窗口</h2><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>使用两个指针表示字符串中的某个子串（或窗口）的左右边界，该窗口容纳无重复字符的子串</p><p>分别定义 <code>left</code> 和 <code>right</code> 作为滑动窗口的左端点和右端点（初始化为 0 ），定义一个 <code>unordered_set</code> 对象 <code>hash</code> 来记录滑动窗口内的元素，利用 <code>ans</code> 记录窗口的最大长度（即，目标值）</p><p>向右移动 <code>right</code> ：</p><ul><li>若窗口内不存在 <code>s[right]</code> 字符（即， <code>hash.find(s[right]) != hash.end()</code> ），可直接将 <code>s[right]</code> 放入窗口</li><li>若窗口内已经存在 <code>s[right]</code> 字符，需移动 <code>left</code> ，将窗口内已有的 <code>s[right]</code> 字符及其左侧字符全都移除出去，然后再将 <code>s[right]</code> 放入窗口</li><li>计算窗口的长度，即， <code>right - left + 1</code> ，并将其与 <code>ans</code> 比较，以更新最大窗口长度</li></ul><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int lengthOfLongestSubstring(string s) &#123;
    unordered_set&lt;char&gt; hash;                       // 记录滑动窗口内的元素
    int left = 0;
    int right = 0;
    int ans = 0;
    while (right &lt; s.size()) &#123;
        while (hash.find(s[right]) != hash.end()) &#123; // s[right] 在窗口内
            hash.erase(s[left]);
            ++left;
        &#125;
        hash.insert(s[right]);                      // 将 s[right] 加入窗口
        ans = max(ans, right - left + 1);           // 更新滑动窗口的最大长度
        ++right;
    &#125;
    return ans;
&#125;
</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串 <code>s</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 为字符集的大小</p><h1 id="leetcode-567-字符串的排列"><a class="anchor" href="#leetcode-567-字符串的排列">#</a> LeetCode 567. 字符串的排列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb24taW4tc3RyaW5nLw==">LeetCode 567. Permutation in String</span></p><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说， <code>s1</code> 的排列之一是 <code>s2</code> 的 子串 。</p><p><strong>示例 1：</strong></p><pre><code>输入：s1 = &quot;ab&quot;, s2 = &quot;eidbaooo&quot;
输出：true
解释：s2 包含 s1 的排列之一 (&quot;ba&quot;)
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s1 = &quot;ab&quot;, s2 = &quot;eidboaoo&quot;
输出：false
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s1.length</code> , <code>s2.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul><h2 id="method-1-滑动窗口"><a class="anchor" href="#method-1-滑动窗口">#</a> Method 1: 滑动窗口</h2><blockquote><p>两个字符串经过排序之后相等，可以说明一个字符串是另一个的排列。（时间复杂度高）</p></blockquote><blockquote><p>只有当两个字符串每个字符的个数均相等时，一个字符串才是另一个字符串的排列</p></blockquote><p>记 <code>s1</code> 的长度为 <code>n</code> ，可以遍历 <code>s2</code> 中每个长度为 <code>n</code> 的子串，判断子串和 <code>s1</code> 中每个字符的个数是否相等，若相等则说明该子串是 <code>s1</code> 的一个排列</p><p>数组 <code>cnt1</code> 统计 <code>s1</code> 中各个字符的个数， <code>cnt2</code> 统计当前遍历的子串中各个字符的个数</p><p>由于需要遍历的子串长度均为 <code>n</code> ，可以使用一个固定长度为 <code>n</code> 的滑动窗口来维护 <code>cnt2</code> ：滑动窗口每向右滑动一次，就多统计一次进入窗口的字符，少统计一次离开窗口的字符。然后，判断 <code>cnt1</code> ​ 是否与 <code>cnt2</code> ​相等，若相等则意味着 <code>s1</code> 的排列之一是 <code>s2</code> 的子串。</p><pre><code class="language-cpp">bool checkInclusion(string s1, string s2) &#123;
    int n1 = s1.size(), n2 = s2.size();
    if (n1 &gt; n2) return false;
    vector&lt;int&gt; cnt1(26),cnt2(26);
    for (int i = 0; i &lt; n1; i++) &#123;  // 统计s1每个字符的出现次数，s2中首个长为n1子串每个字符的出现次数
        ++cnt1[s1[i] - 'a'];
        ++cnt2[s2[i] - 'a'];
    &#125;
    if (cnt1 == cnt2) return true;
    for (int i = n1; i &lt; n2; i++) &#123; // 滑动窗口法（窗长为n1），更新窗口内每个字符的出现次数
        ++cnt2[s2[i] - 'a'];        // 进入窗口的字符
        --cnt2[s2[i- n1] - 'a'];    // 离开窗口的字符
        if (cnt1 == cnt2) return true;
    &#125;
    return false;
&#125;
</code></pre><h2 id="method-2-滑动窗口"><a class="anchor" href="#method-2-滑动窗口">#</a> Method 2: 滑动窗口</h2><p>注意到每次窗口滑动时，只统计了一进一出两个字符，却比较了整个 <code>cnt1</code> 和 <code>cnt2</code> 数组。因此可对上述算法进行优化：用一个变量 <code>diff</code> 来记录 <code>cnt1</code> 与 <code>cnt2</code> 的不同值的个数，这样判断 <code>cnt1</code> 和 <code>cnt2</code> 是否相等就转换成了判断 <code>diff</code> 是否为 <code>0</code></p><p>为简化上述逻辑，可以只用一个数组 <code>cnt</code> ，其中 <code>cnt[x]=cnt2[x]−cnt1[x]</code> ，将 <code>cnt1[x]</code> 与 <code>cnt2[x]</code> 的比较替换成 <code>cnt[x]</code> 与 <code>0</code> 的比较</p><pre><code class="language-cpp">bool checkInclusion(string s1, string s2) &#123;
    int n1 = s1.size(), n2 = s2.size();
    if (n1 &gt; n2) return false;
    // 数组cnt记录的是s1字符串与s2窗口中，每个字符出现次数的差异值：若cnt1 cnt2分别记录s1字符串与s2窗口中每个字符出现次数，则cnt=cnt2-cnt1
    vector&lt;int&gt; cnt(26);        // s1 s2仅包含小写字母
    for (int i = 0; i &lt; n1; i++) &#123;
        --cnt[s1[i] - 'a'];
        ++cnt[s2[i] - 'a'];
    &#125;
    int diff = 0;               // 记录cnt非零元素的个数，即，cnt1与cnt2不相等元素的个数
    for (auto c : cnt)
        if (c != 0)
            ++diff;
    if (diff == 0) return true; // diff等于0，即cnt1与cnt2相同，输出true
    for (int i = n1; i &lt; n2; i++) &#123;
        int x = s2[i] - 'a', y = s2[i - n1] - 'a'; // x对应进入窗口的字符，y对应离开窗口的字符
        if (x == y) continue;           // x等于y时，无需修改cnt和diff
        if (cnt[x] == 0) ++diff;        // cnt1[x]原本等于cnt2[x]，新进入的x导致diff加1
        ++cnt[x];
        if (cnt[x] == 0) --diff;        // 进入窗口的x使得cnt1[x]等于cnt2[x]，故diff减1（该if语句是上一条if语句是互斥的）
        if (cnt[y] == 0) ++diff;
        --cnt[y];
        if (cnt[y] == 0) --diff;
        if (diff == 0) return true;
    &#125;
    return false;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m + \vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串 <code>s1</code> 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 是字符串 <code>s2</code> 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">Σ</span></span></span></span> 是字符集，这道题中的字符集是小写字母，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>26</mn></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert =26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">6</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p><h2 id="method-3-双指针"><a class="anchor" href="#method-3-双指针">#</a> Method 3: 双指针</h2><p>方法一的思路：在保证区间长度为 <code>n</code> 的情况下，去考察是否存在一个区间使得 <code>cnt</code> 的值全为 <code>0</code> 。反过来，还可以在保证 <code>cnt</code> 的值不为正的情况下，去考察是否存在一个区间，其长度恰好为 <code>n</code></p><p>初始时，仅统计 <code>s1</code> 中的字符，则 <code>cnt</code> 的值均不为正，且元素值之和为 <code>- n</code></p><p>用指针 <code>left</code> 和 <code>right</code> 表示考察的区间 <code>[left,right]</code> 。 <code>right</code> 每向右移动一次，就统计一次进入区间的字符 <code>x</code> 。为保证 <code>cnt</code> 的值不为正，若此时 <code>cnt[x] &gt; 0</code> ，则向右移动左指针，减少离开区间的字符的 <code>cnt</code> 值直到 <code>cnt[x] ≤ 0</code></p><p>注意到 <code>[left,right]</code> 的长度每增加 <code>1</code> ， <code>cnt</code> 的元素值之和就增加 <code>1</code> 。当 <code>[left,right]</code> 的长度恰好为 <code>n</code> 时，就意味着 <code>cnt</code> 的元素值之和为 <code>0</code> 。由于 <code>cnt</code> 的值不为正，元素值之和为 <code>0</code> 就意味着所有元素均为 <code>0</code> ，这样我们就找到了一个目标子串</p><pre><code class="language-cpp">bool checkInclusion(string s1, string s2) &#123;
    int n1 = s1.size(), n2 =s2.size();
    if (n1 &gt; n2) return false;
    vector&lt;int&gt; cnt(26);
    for (int i = 0; i &lt; n1; i++)
        --cnt[s1[i] - 'a'];     // cnt的元素值之和为-n1
    int l = 0;
    // 在保证 cnt 的值不为正（所有元素均不为正）的情况下，去考察是否存在一个区间，其长度恰好为 n1
    for (int r = 0; r &lt; n2; r++) &#123;
        int x = s2[r] - 'a';
        ++cnt[x];
        while (cnt[x] &gt; 0) &#123; // x出现次数多，l右移，并更新cnt
            --cnt[s2[l] - 'a'];
            ++l;
        &#125;
        if (r - l + 1 == n1) return true;   // cnt各元素均不为正，且区间[l,r]长度刚好为n1，找到目标
    &#125;
    return false;
    
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m + \vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> ，创建 <code>cnt</code> 需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 的时间。遍历 <code>s1</code> 需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间。双指针遍历 <code>s2</code> 时，由于 <code>left</code> 和 <code>right</code> 都只会向右移动，故这一部分需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 的时间</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-75-颜色分类"><a class="anchor" href="#leetcode-75-颜色分类">#</a> LeetCode 75. 颜色分类</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWNvbG9ycy8=">75. Sort Colors</span></p><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,0,1]
输出：[0,1,2]
</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">\le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>nums[i]</code> 为 <code>0</code> 、 <code>1</code> 或 <code>2</code></li></ul><p><strong>进阶</strong>：你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>可以先统计数组中 0, 1, 2 的个数，再根据它们的数量修改整个数组</p><p>但是，这样需要遍历两次</p><p>为实现一次遍历，可定义双指针，实现原地交换</p><p>考虑以下两种方案：</p><ul><li>ptr0 指向 0 的填充位置，ptr1 指向 1 的填充位置</li><li>ptr0 指向 0 的填充位置，ptr2 指向 2 的填充位置</li></ul><h2 id="method-1双指针"><a class="anchor" href="#method-1双指针">#</a> Method 1：双指针</h2><p>算法思路：</p><p>定义指针 ptr0 指向 0 的填充位置，ptr1 指向 1 的填充位置</p><blockquote><p>[0, ptr0) 区间内的元素全为 0 ，[ptr0, ptr1) 区间内的元素全为 1</p></blockquote><p>初始化 ptr0 为 0 ，初始化 ptr1 为 0</p><p>从左往右遍历数组，记遍历到的位置为 i（i 从 0 开始）：</p><ul><li><p>如果 nums [i] == 0 ，交换 nums [i] 与 nums [ptr0] ，并做以下考虑：</p><ul><li>如果 ptr1 &gt; ptr0 ，交换前的 nums [ptr0] 必定为 1 ，即，交换后的 nums [i] 为 1 ，此时，还需将 nums [i] 与 nums [ptr1] 进行交换（因为 [ptr1, i) 区间对应的元素值全为 2 ）</li><li>无论 ptr1 &gt; ptr0 是否成立，都需将 ptr0 和 ptr1 向右移动一位、将 i 向右移动一位</li></ul></li><li><p>如果 nums [i] == 1 ，交换 nums [i] 与 nums [ptr1] ，并将 ptr1 向右移动一位、将 i 向右移动一位</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">void sortColors(vector&lt;int&gt;&amp; nums) &#123;
    int ptr0 = 0;
    int ptr1 = 0;
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        if (nums[i] == 0) &#123;
            swap(nums[i], nums[ptr0]);
            if (ptr0 &lt; ptr1) &#123;
                swap(nums[i], nums[ptr1]);
            &#125;
            ptr0++;
            ptr1++;
        &#125; else if (nums[i] == 1) &#123;
            swap(nums[i], nums[ptr1]);
            ptr1++;
        &#125;
    &#125;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2双指针"><a class="anchor" href="#method-2双指针">#</a> Method 2：双指针</h2><p>算法思路：</p><p>定义指针 ptr0 指向 0 的填充位置，ptr2 指向 2 的填充位置</p><blockquote><p>[0, ptr0) 区间内的元素全为 0 ，(ptr2, nums.size () - 1] 区间内的元素全为 2</p></blockquote><p>初始化 ptr0 为 0 ，初始化 ptr2 为 nums.size () - 1</p><p>从左往右遍历数组，记遍历到的位置为 i（i 从 0 开始），当 i 超过 ptr2 时，结束遍历：</p><ul><li><p>如果 nums [i] == 0 ，交换 nums [i] 与 nums [ptr0] ，并将 ptr0 向右移动一位、将 i 向右移动一位</p></li><li><p>如果 nums [i] == 2 ，交换 nums [i] 与 nums [ptr2] ，并将 ptr2 向左移动一位，但是，交换所得的 nums [i] 可能是 0 、1、2 中的任意值，需要继续对 nums [i] 进行判断和处理</p></li><li><p>如果 nums [i] == 1 ，无需进行任何交换，直接将 i 右移一位即可</p></li></ul><blockquote><p>当 nums [i] == 0 时，可以在交换 nums [i] 与 nums [ptr0] 以后直接将 i 右移，无需考虑交换后 nums [i] 的取值，这是因为：</p><ul><li>若 i == ptr0 ，实际并未进行交换，新的 nums [i] 就是 0</li><li>若 i &gt; ptr0 ，由于 i 是从左往右遍历的，区间 [ptr0, i - 1] 对应的元素值必定全为 1 ，在交换 nums [i] 与 nums [ptr0] 以后，区间 [0, ptr0] 对应的元素值全为 0 、区间 [ptr0 + 1, i] 对应的元素值全为 1 ，因此，可以直接考虑 i + 1 位置</li></ul></blockquote><p>特别地：当 nums [i] == 2 时，需要将其与 nums [ptr2] 进行交换，由于交换后的 nums [i] 可能是 0 ，即，需要再按照 nums [i] == 0 的情况进行处理。因此，在遍历 nums [i] 时， 我们可以先处理 nums [i] == 2 的情况，再处理 nums [i] == 0 的情况，以简化代码</p><p>代码实现：</p><pre><code class="language-cpp">void sortColors(vector&lt;int&gt;&amp; nums) &#123;
    int ptr0 = 0;
    int ptr2 = nums.size() - 1;
    for (int i = 0; i &lt;= ptr2; i++) &#123;
        while (i &lt;= ptr2 &amp;&amp; nums[i] == 2) &#123;
            swap(nums[i], nums[ptr2]);
            ptr2--;
        &#125;
        if (nums[i] == 0) &#123;
            swap(nums[i], nums[ptr0]);
            ptr0++;
        &#125;
    &#125;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWNvbG9ycy9zb2x1dGlvbi95YW4tc2UtZmVuLWxlaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p><h1 id="leetcode-76-最小覆盖子串"><a class="anchor" href="#leetcode-76-最小覆盖子串">#</a> LeetCode 76. 最小覆盖子串</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv">76. Minimum Window Substring</span></p><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</p><p>注意：</p><ul><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;
输出：&quot;BANC&quot;
解释：The minimum window substring &quot;BANC&quot; includes 'A', 'B', and 'C' from string t.
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;a&quot;, t = &quot;a&quot;
输出：&quot;a&quot;
解释：The entire string s is the minimum window.
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;a&quot;, t = &quot;aa&quot;
输出：&quot;&quot;
解释：Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
</code></pre><p><strong>提示：</strong></p><ul><li>m == s.length</li><li>n == t.length</li><li>1 &lt;= m, n &lt;= 10<sup>5</sup></li><li>s 和 t 由英文字母组成</li></ul><p><strong>进阶</strong>：你能设计一个在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间内解决此问题的算法吗？</p><h2 id="method-1-滑动窗口法-哈希"><a class="anchor" href="#method-1-滑动窗口法-哈希">#</a> Method 1: 滑动窗口法 + 哈希</h2><p>算法思路：</p><p>本题要在字符串 s 中找到一个包含字符串 t 全部字符的最小窗口</p><p>为便于表述，我们做出以下规定：</p><ul><li>若窗口包含字符串 t 全部字符，则该窗口为「可行窗口」</li><li>若窗口内某个字符的数量 大于等于 字符串 t 中该字符的数量，则称该字符为「达标字符」</li></ul><p>可以用滑动窗口的思想来求解：</p><ul><li>移动窗口的右端点（ r 指针），不断扩张窗口</li><li>当窗口为「可行窗口」时，移动窗口的左端点（ l 指针），收缩窗口</li><li>通过在字符串 s 上移动窗口，获取长度最小的「可行窗口」</li></ul><p>为判断当前窗口是否为「可行窗口」，我们做以下考虑：</p><ul><li>定义一个哈希表，unordered_map&lt;char, int&gt; hash ，其中，以 t 中字符作为哈希表的键，以 窗口内该字符的数量 与 t 中该字符的数量 之差作为对应的值（例如，当窗口内字符 'a' 出现 1 次、t 中字符 'a' 出现 2 次时，对应哈希表的值 hash ['a'] 为 -1）</li><li>如果某个字符对应的哈希表键值等于 0 ，则说明这个字符为「达标字符」</li><li>定义 cnt 表示窗口内「达标字符」的个数，定义 k 表示字符串 t 中的字符种类数（即，k = hash.size () ）</li><li>若 cnt 等于 k ，说明当前窗口包含了字符串 t 中的全部字符，即，当前窗口为「可行窗口」</li></ul><p>代码实现：</p><pre><code class="language-cpp">string minWindow(string s, string t) &#123;
    unordered_map&lt;char, int&gt; hash;
    for (auto c : t) hash[c]--;     // hash[c] 表示 窗口中字符 c 的数量与 t 中字符 c 的数量之差
    int k = hash.size();            // t 中字符的类别数
    string ans;
    int cnt = 0;                    // 在窗口内，满足 t 字符串所需数量要求的字符个数
    for (int l = 0, r = 0; r &lt; s.size(); r++) &#123;
        hash[s[r]]++;
        if (hash[s[r]] == 0) cnt++; // s[r] 字符的数量已满足要求
        while (hash[s[l]] &gt; 0) &#123;    // 在确保 s[l] 满足数量要求的前提下，收缩窗口
            hash[s[l]]--;           // s[l] 字符数量减 1
            l++;                    // l 右移
        &#125;
        if (cnt == k) &#123;             // 窗口包含 t 所有字符
            if (ans.empty() || r - l + 1 &lt; ans.size()) &#123;
                ans = s.substr(l, r - l + 1);
            &#125;
        &#125;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串 s 和 t 的长度</p><ul><li>遍历字符串 t 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>遍历字符串 s 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中，最坏情况下，指针 l 和 r 各遍历一次字符串 s</li><li>哈希查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 为字符集的大小（即，字符串 t 中字符的种类数，对应于程序中的 k ）</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcvc29sdXRpb24venVpLXhpYW8tZnUtZ2FpLXppLWNodWFuLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">leetcode-solution</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcvc29sdXRpb24vbGVldGNvZGUtNzYtenVpLXhpYW8tZnUtZ2FpLXppLWNodWFuLWNqYS1sbXF6Lw==">林小鹿</span></li></ul><div class="tags"><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag"><i class="ic i-tag"></i> 双指针</a></div></div><footer><div class="meta"><span class="item"><time title="修改时间：2024-03-23 01:16:15" itemprop="dateModified" datetime="2024-03-23T01:16:15+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2024-03-23 </time></span><span id="posts/611c1217/" class="item leancloud_visitors" data-flag-title="LeetCode - 双指针专题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/611c1217/" title="LeetCode - 双指针专题">https://jiankychen.github.io/posts/611c1217/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/5e11e767/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;470d00578173666b5183f4631e51a421.jpg" title="LeetCode - 动态规划专题"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 动态规划专题</h3></a></div><div class="item right"><a href="/posts/691b4be6/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;e5221f7d85b0900837a45fb933fa34ec.jpg" title="LeetCode - 单调栈专题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 单调栈专题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 11. 盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.1.</span> <span class="toc-text">Method: 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">LeetCode 167. 两数之和 II - 输入有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">Method 1: 双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.</span> <span class="toc-text">Method 2: 二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">LeetCode 189. 轮转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">Method 1: 使用额外的数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="toc-number">3.2.</span> <span class="toc-text">Method 2: 数组翻转</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">4.</span> <span class="toc-text">LeetCode 283. 移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-number">4.1.</span> <span class="toc-text">Method: 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">LeetCode 3. 无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">Method: 滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">LeetCode 567. 字符串的排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">Method 1: 滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">6.2.</span> <span class="toc-text">Method 2: 滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">6.3.</span> <span class="toc-text">Method 3: 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">LeetCode 75. 颜色分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">7.2.</span> <span class="toc-text">Method 1：双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">7.3.</span> <span class="toc-text">Method 2：双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">LeetCode 76. 最小覆盖子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95-%E5%93%88%E5%B8%8C"><span class="toc-number">8.1.</span> <span class="toc-text">Method 1: 滑动窗口法 + 哈希</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/1b7ed9b4/" rel="bookmark" title="LeetCode Records">LeetCode Records</a></li><li><a href="/posts/32d5c1f6/" rel="bookmark" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></li><li><a href="/posts/2057f45/" rel="bookmark" title="LeetCode - 数组专题">LeetCode - 数组专题</a></li><li><a href="/posts/bc32ab1e/" rel="bookmark" title="LeetCode - 链表专题">LeetCode - 链表专题</a></li><li><a href="/posts/29abbd18/" rel="bookmark" title="LeetCode - 哈希表专题">LeetCode - 哈希表专题</a></li><li><a href="/posts/36947f98/" rel="bookmark" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></li><li><a href="/posts/51f34f0/" rel="bookmark" title="LeetCode - 栈与队列专题">LeetCode - 栈与队列专题</a></li><li><a href="/posts/ed3025a8/" rel="bookmark" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></li><li><a href="/posts/6012cc6b/" rel="bookmark" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></li><li><a href="/posts/f3b1f59f/" rel="bookmark" title="LeetCode - 贪心专题">LeetCode - 贪心专题</a></li><li><a href="/posts/5e11e767/" rel="bookmark" title="LeetCode - 动态规划专题">LeetCode - 动态规划专题</a></li><li class="active"><a href="/posts/611c1217/" rel="bookmark" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></li><li><a href="/posts/691b4be6/" rel="bookmark" title="LeetCode - 单调栈专题">LeetCode - 单调栈专题</a></li><li><a href="/posts/537e2e53/" rel="bookmark" title="LeetCode - 搜索专题">LeetCode - 搜索专题</a></li><li><a href="/posts/242193c5/" rel="bookmark" title="LeetCode - 排序专题">LeetCode - 排序专题</a></li><li><a href="/posts/f994a74a/" rel="bookmark" title="常见输入输出">常见输入输出</a></li><li><a href="/posts/def81c82/" rel="bookmark" title="LeetCode - 模拟专题">LeetCode - 模拟专题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">52</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/5e11e767/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/691b4be6/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/3d6d9e02/" title="C++ 函数">C++ 函数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/1b7ed9b4/" title="LeetCode Records">LeetCode Records</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/72c3df1c/" title="Dijkstra">Dijkstra</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/611c1217/" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/23926cd4/" title="Python 数据容器">Python 数据容器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/afade57b/" title="递推与递归">递推与递归</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/SQL/" title="分类于 SQL">SQL</a></div><span><a href="/posts/f416b295/" title="SQL 基础">SQL 基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tutorial/" title="分类于 Tutorial">Tutorial</a> <i class="ic i-angle-right"></i> <a href="/categories/Tutorial/Hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/posts/c61b9a60/" title="shoka 主题的若干改动">shoka 主题的若干改动</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/11ea1840/" title="Python 异常、模块、包">Python 异常、模块、包</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/b8928e0e/" title="数据结构简介">数据结构简介</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">821k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:48</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/611c1217/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->