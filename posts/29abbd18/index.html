<!-- build time:Sat Mar 23 2024 01:17:15 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="哈希表"><link rel="canonical" href="https://jiankychen.github.io/posts/29abbd18/"><title>LeetCode - 哈希表专题 - Coding | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">LeetCode - 哈希表专题</h1><div class="meta"><span class="item" title="创建时间：2022-05-03 21:06:21"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-05-03T21:06:21+08:00">2022-05-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>26k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>44 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/65d0bfef68566882ce0560cab2e87921.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/e5221f7d85b0900837a45fb933fa34ec.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/99fb5ff897a82984470abf5e2a235d94.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/2aabaeb8aca379b991071d1c41632741.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/488297bfd0233b6c6a444f1860e55d45.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Coding/" itemprop="item" rel="index" title="分类于 Coding"><span itemprop="name">Coding</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/29abbd18/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="leetcode-1-两数之和"><a class="anchor" href="#leetcode-1-两数之和">#</a> LeetCode 1. 两数之和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">LeetCode 1. Two Sum</span></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code> ，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,4], target = 6
输出：[1,2]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3], target = 6
输出：[0,1]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> &lt;= <code>nums.length</code> &lt;= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">- 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> &lt;= <code>nums[i]</code> &lt;= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">- 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> &lt;= <code>target</code> &lt;= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>只存在一个有效答案</li></ul><p><strong>进阶</strong>：你可以想出一个时间复杂度小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的算法吗？</p><h3 id="思路"><a class="anchor" href="#思路">#</a> 思路</h3><p>解题思路：遍历数组的下标 <code>i</code> ，判断 <code>target - nums[i]</code> 是否存在，若存在，返回 <code>i</code> 以及 数组中值为 <code>target - nums[i]</code> 的元素的下标</p><p>本题不仅要判读数值是否存在，还要记录其下标，因此采用哈希 map ，其中，元素值 作为 <code>key</code> ，元素在数组中的索引下标作为 <code>value</code></p><h2 id="method-哈希-map"><a class="anchor" href="#method-哈希-map">#</a> Method: 哈希 map</h2><p>由于并不需要 <code>key</code> 有序，可以选择 <code>unordered_map</code></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfbWFwL3Vub3JkZXJlZF9tYXAvP2t3PXVub3JkZXJlZF9tYXA=">std::unoredered_map</span></p><p>解题步骤：</p><ol><li><p>定义 <code>unodered_map</code> 容器，命名为 <code>map</code></p></li><li><p>遍历数组下标 <code>i</code></p><ul><li>查找 <code>target - nums[i]</code> 是否存在于 <code>map</code> 当中</li><li>若存在，返回下标 <code>i</code> 以及 与键值 <code>target - nums[i]</code> 对应的 <code>value</code></li><li>否则，将 <code>nums[i]</code> 以及 <code>i</code> 作为键值对添加到 <code>map</code></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
    unordered_map&lt;int, int&gt; map;
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        auto temp = map.find(target - nums[i]); // find 返回的是迭代器类型
        if (temp != map.end())                  // 找到 target - nums[i]
            return &#123;temp-&gt;second, i&#125;;           // 返回 i 以及 temp 的第二个值
                                                // temp-&gt;first 是 key ，temp-&gt;second 是 value
        map.insert(pair&lt;int, int&gt;(nums[i], i)); // 将 nums[i], i 作为键值对插入到 map
    &#125;
    return &#123;&#125;;
&#125;
</code></pre><blockquote><p><code>unordered_map</code> 的成员函数 <code>find</code> 的返回值是 <code>iterator</code> 类型，解引用后的第一个成员为 <code>key</code> ，第二个成员为 <code>value</code> ，详见 <span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfbWFwL3Vub3JkZXJlZF9tYXAvZmluZC8=">std::unordered_map::find</span></p></blockquote><h1 id="leetcode-128-最长连续序列"><a class="anchor" href="#leetcode-128-最长连续序列">#</a> LeetCode 128. 最长连续序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlLw==">128. Longest Consecutive Sequence</span></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [100,4,200,1,3,2]
输出：4
解释：The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-哈希表"><a class="anchor" href="#method-哈希表">#</a> Method: 哈希表</h2><p>算法思路：</p><p>定义一个哈希表（记作 hash ，即 <code>unordered_map&lt;int&gt; hash</code> ），将数组中的数字作为哈希表的键，将数字所在的连续序列的最大长度作为对应的哈希表值</p><p>遍历数组（记当前遍历到的数字为 num）：</p><ul><li><p>若数字 num 已在哈希表中，跳过</p></li><li><p>若数字 num 不在哈希表中：</p><ul><li><p>找出左侧相邻数 num - 1 所在的连续序列的最大长度，记作 left ，即 left = hash [num - 1]</p></li><li><p>找出右侧相邻数 num + 1 所在的连续序列的最大长度，记作 right ，即 right = hash [num + 1]</p></li><li><p>将 num 左右两侧的连续序列以及 num 进行拼接，计算新的连续序列的长度：len = left + right + 1</p></li><li><p>更新当前数字 num 对应的哈希表值，即 hash [num] = len</p></li><li><p>更新连续序列两个端点对应的哈希表值，即，hash [num - left] = len ，hash [num + right] = len</p></li><li><p>更新整个数组中的最长连续序列的长度，即 ans = max (ans, len)</p></li></ul></li></ul><p>上述算法中，拼接 num 及其左右两侧连续序列时，我们没有更新连续序列中每个数字对应的哈希表值，而只是更新两个端点对应的哈希表值。这是因为：区间 (num - left, num + right) 内数字对应的哈希表值不会被使用，只有 num -left 和 num + right 这两个端点对应的哈希表值可能被使用</p><ul><li>在之后的遍历中，如果遇到 [num - left, num + right] 区间内的数，会直接跳过，无需考察其左右两侧数字所在连续序列的长度</li><li>在之后的遍历中，如果遇到 num - left - 1（或 num + right + 1），由于 num - left（或 num + right）对应的连续序列长度已经更新，可以直接将 num - left - 1（或 num + right + 1）与 num - left（或 num + right）对应的连续序列进行拼接，无需担心结果出错</li></ul><blockquote><p>无论 num 左右两侧是否存在相应的连续序列，上述算法都能奏效（哈希表的值全都初始化为 0 ）</p><ul><li>当 num 左侧或右侧不存在连续序列时，left 或 right 为 0，num - left 或 num + right 就是 num 本身</li><li>当 num 左右两侧均不存在连续序列时，left 和 right 均为 0，num - left 和 num + right 都是 num 本身</li></ul></blockquote><p>代码实现：</p><pre><code class="language-cpp">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;
    unordered_map&lt;int, int&gt; hash; // 哈希表，存储每个数字对应连续序列的长度
    int left = 0;
    int right = 0;
    int len = 0;
    int ans = 0;
    for (int num : nums) &#123;
        if (hash[num] == 0) &#123;
            left = hash[num - 1];     // 左侧数字对应连续序列的长度
            right = hash[num + 1];    // 右侧数字对应连续序列的长度
            len = left + right + 1;   // 拼接左右连续序列
            hash[num] = len;          // 数字 num 对应连续序列的长度
            hash[num - left] = len;   // 更新左侧数字对应序列的端点的键值
            hash[num + right] = len;  // 更新右侧数字对应序列的端点的键值    
            if (len &gt; ans) ans = len; // 更新最大长度     
        &#125;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlL3NvbHV0aW9uL2RvbmctdGFpLWd1aS1odWEtcHl0aG9uLXRpLWppZS1ieS1qYWxhbi8=">jalan</span></p><h1 id="leetcode-1296-划分数组为连续数字的集合"><a class="anchor" href="#leetcode-1296-划分数组为连续数字的集合">#</a> LeetCode 1296. 划分数组为连续数字的集合</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXZpZGUtYXJyYXktaW4tc2V0cy1vZi1rLWNvbnNlY3V0aXZlLW51bWJlcnMvZGVzY3JpcHRpb24v">1296. 划分数组为连续数字的集合</span></p><p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code> ，请你判断是否可以把这个数组划分成一些由 <code>k</code> 个连续数字组成的集合</p><p>如果可以，请返回 <code>true</code> ；否则，返回 <code>false</code></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,3,4,4,5,6], k = 4
输出：true
解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
输出：true
解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3,2,2,1,1], k = 3
输出：true
</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：nums = [1,2,3,4], k = 3
输出：false
解释：数组不能分成几个大小为 3 的子数组。
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>k</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-排序-哈希"><a class="anchor" href="#method-排序-哈希">#</a> Method: 排序 + 哈希</h2><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>题目要求将数组划分成若干个集合，其中，每个集合包含 k 个连续数字</p><p>可以从尚未分组的元素中找出值最小的元素，将其作为集合的第一个元素（记作 x ），于是该集合中数字的范围应为 [x, x + k - 1] 。如果某个数字不存在，则无法将数组划分成符合条件的集合，返回 false</p><p>将 [x, x + k - 1] 这 k 个元素划分到一个集合之后，继续对数组中剩余的数字进行分组，直到 所有元素均已分组 或者 遇到无法分组的情况</p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">bool isPossibleDivide(vector&lt;int&gt;&amp; nums, int k) &#123;
    if (nums.size() % k) return false;          // 数组长度无法被 k 整除，返回 false
    sort(nums.begin(), nums.end());             // 将数组按从小到大排序
    unordered_map&lt;int, int&gt; hashmap;
    for (auto num : nums) ++hashmap[num];       // 统计每个数字的出现次数
    for (int i = 0; i &lt; nums.size() / k; ++i) &#123; // 一共有 nums.size() / k 个集合
        int first = 0;                          // 集合中第一个元素的下标
        while (first &lt; nums.size() &amp;&amp; hashmap[nums[first]] == 0) &#123; // 寻找未被使用的、值最小的元素
            ++first;
        &#125;
        --hashmap[nums[first]];                 // 将 nums[first] 添加到集合（可用次数减 1 ）
        for (int j = 1; j &lt; k; ++j) &#123;           // 寻找剩余的 k - 1 个元素
            if (hashmap[nums[first] + j] == 0)  // 不存在 nums[first] + j 这个数，数字不连续，返回 false
                return false;
            else                                // 存在 nums[first] + j 这个数，将其可用次数减 1
                --hashmap[nums[first] + j];
        &#125;
    &#125;
    return true;
&#125;
</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑哈希表所需空间</p><h2 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h2><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXZpZGUtYXJyYXktaW4tc2V0cy1vZi1rLWNvbnNlY3V0aXZlLW51bWJlcnMvc29sdXRpb25zLzEwMTgwOS9odWEtZmVuLXNodS16dS13ZWktbGlhbi14dS1zaHUtemktZGUtamktaGUtYnktbGUtMi8=">力扣官方题解</span></p><h1 id="leetcode-15-三数之和"><a class="anchor" href="#leetcode-15-三数之和">#</a> LeetCode 15. 三数之和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS8=">LeetCode 15. Three Sum</span></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i]</code> , <code>nums[j]</code> , <code>nums[k]]</code> 满足 <code>i != j</code> 、 <code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 0 且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
    nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
    nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
    nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
    不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
    注意，输出的顺序和三元组的顺序并不重要。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = []
输出：[]
解释：唯一可能的三元组和不为 0 。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [0]
输出：[]
解释：唯一可能的三元组和为 0 。
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路-2"><a class="anchor" href="#思路-2">#</a> 思路</h2><p>暴力法查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，考虑用低复杂度算法</p><p>注意：题目要求 “ <code>i != j</code> , <code>i != k</code> , <code>j != k</code> ” 并且 “任意两个三元组不能相同” ，故而需要在查找时进行剪枝以避免重复，或是查找结束后剔除重复三元组</p><p>本题的难点也在于如何去除重复解</p><p>首先，可以对数组进行排序（最终只需要输出元素值即可，无需输出元素索引，故而可以打乱原数组顺序），将重复的元素值集中，便于去重</p><p>于是，有以下两种方法可以用于查找：</p><ol><li><p>哈希法：采用两层 <code>for</code> 循环分别遍历 <code>i</code> 和 <code>j</code> （按照从左往右的顺序），并采用哈希法检查 <code>[i, j]</code> 区间范围内是否有元素能与 <code>nums[i]</code> ， <code>nums[j]</code> 组成三元组</p></li><li><p>双指针法：采用一个 <code>for</code> 循环遍历 <code>i</code> ，并采用双指针法在 <code>[i + 1, nums.size() - 1]</code> 区间内查找所有能与 <code>nums[i]</code> 组成三元组的元素 <code>nums[left]</code> 和 <code>nums[right]</code> ，其中，指针 <code>left</code> 从 <code>i + 1</code> 位置开始向右遍历，指针 <code>right</code> 从 <code>nums.size() - 1</code> 位置开始向左遍历</p></li></ol><p>两种方法都能实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的时间复杂度，但哈希法不便进行去重操作，因此，建议使用排序与双指针法解题</p><h2 id="method-排序-双指针"><a class="anchor" href="#method-排序-双指针">#</a> Method: 排序 + 双指针</h2><p>解题步骤：</p><ol><li><p>对数组进行排序（从小到大排序）</p></li><li><p>遍历数组下标 <code>i</code></p><ul><li><p>若 <code>nums[i] &gt; 0</code> ，则 <code>i</code> 右侧不存在能与 <code>nums[i]</code> 组成三元组的元素，直接返回结果</p></li><li><p>若 <code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]</code> ，当前 <code>i</code> 能找到的三元组与 <code>i - 1</code> 时找到的完全相同，为避免产生重复解，跳过当前 <code>i</code></p></li><li><p>定义指针 <code>left</code> 指向 <code>i + 1</code> 位置，指针 <code>right</code> 指向 <code>nums.size() - 1</code> 位置，当 <code>left &lt; right</code> 时，执行循环：</p><ul><li>计算 <code>sum = nums[i] + nums[left] + nums[right]</code></li><li>若 <code>sum &gt; 0</code> ，则 <code>nums[right]</code> 偏大，将 <code>right</code> 左移</li><li>若 <code>sum &lt; 0</code> ，则 <code>nums[left]</code> 偏小，将 <code>left</code> 右移</li><li>若 <code>sum == 0</code> ，记录结果，并将 <code>left</code> 右移、将 <code>right</code> 左移，以跳过重复的 <code>nums[left]</code> 和 <code>nums[right]</code></li></ul></li></ul></li></ol><blockquote><p>注意：同一个 <code>i</code> 可以与不同的元素组成多个不同的三元组，因此，在找到一对可行的 <code>nums[left]</code> 和 <code>nums[right]</code> 后仍需继续查找，直到 <code>left &lt; right</code> 不满足</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
    sort(nums.begin(), nums.end()); // 排序
    vector&lt;vector&lt;int&gt;&gt; res;        // 存储结果
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        if (nums[i] &gt; 0) break;
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
        int left = i + 1, right = nums.size() - 1;
        int sum = 0;
        while (left &lt; right) &#123;
            sum = nums[i] + nums[left] + nums[right];
            if (sum &gt; 0) right--;
            if (sum &lt; 0) left++;
            if (sum == 0) &#123;
                res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);
                // 将 left 右移（注意，++left 至少执行一次）
                while (left &lt; right &amp;&amp; nums[left] == nums[++left]);
                // 将 right 左移（注意，--right 至少执行一次）
                while (left &lt; right &amp;&amp; nums[right] == nums[--right]);
            &#125;
        &#125;
    &#125;
    return res;
&#125;
</code></pre><p>需要注意的第一个地方：</p><pre><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
</code></pre><p>这里不能改成 <code>if (nums[i] == nums[i + 1]) continue;</code> ，否则，以数组 <code>nums = [-1, 0, 1, 2, -1, -4]</code> 为例（排序后， <code>nums = [-4, -1, -1, 0, 1, 2]</code> ），查找时将会遗漏 <code>[-1, -1, 2]</code> 这一个三元组。因为当 <code>i = 1</code> 时 <code>nums[1] == nums[2]</code> 条件成立，因此不会进行双指针查找；而当 <code>i = 2</code> 时，只会查找 <code>i</code> 右侧的元素，故而遗失了对 <code>[-1, -1, x]</code> 这几种情况的查找， <code>x</code> 为第二个 <code>-1</code> 右侧的任意值</p><p>&lt;!-- 上述的 Method 1 也是类似道理 --&gt;</p><p>需要注意的第二个地方：</p><pre><code>if (sum == 0) &#123;
    res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);
    while (left &lt; right &amp;&amp; nums[left] == nums[++left]);
    while (left &lt; right &amp;&amp; nums[right] == nums[--right]);
&#125;
</code></pre><p>这里的 <code>++left</code> 和 <code>--right</code> 都至少执行一次：执行一次是因为找到了一个三元组，需要同时移动双指针，以进行下一次的查找；执行多次则是为了跳过重复的 <code>nums[left]</code> 和 <code>nums[right]</code></p><p>并且，注意这里的 <code>nums[left] == nums[++left]</code> 语句，将当前 <code>left</code> 对应元素值与 <code>left</code> 右移之后对应元素值进行比较，不能将其改成 <code>nums[++left] == nums[left]</code> ，也不能改成 <code>nums[left] == nums[left++]</code> 。语句 <code>nums[right] == nums[--right]</code> 同理</p><p>特别地，第二个地方可以改写成</p><pre><code>if (sum == 0) &#123;
    res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);
    // 先将 left 移到最靠右的一个 nums[left]
    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;
    // 先将 right 移到最靠左的一个 nums[right]
    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;
    // 再分别移动一次 left 和 right ，以进行下一次查找
    left++;
    right--;
&#125;
</code></pre><p>另外，当 <code>sum &gt; 0</code> 时，可对 <code>nums[right]</code> 进行去重，以跳过重复的 <code>nums[right]</code> ，即，将 <code>if (sum &gt; 0) right--;</code> 改写为</p><pre><code>if (sum &gt; 0)
    while (left &lt; right &amp;&amp; nums[right] == nums[--right]);
</code></pre><p>或者改写为</p><pre><code>if (sum &gt; 0) &#123;
    right--;
    while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;
&#125;
</code></pre><p>类似地，当 <code>sum &lt; 0</code> 时，也可对 <code>nums[left]</code> 进行去重，以跳过重复的 <code>nums[left]</code></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><ul><li>遍历 <code>i</code> ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>双指针查找：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><ul><li>不考虑存储结果的数组</li><li>仅考虑排序所需栈空间</li></ul><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMTUuJUU0JUI4JTg5JUU2JTk1JUIwJUU0JUI5JThCJUU1JTkyJThDLmh0bWwjJUU1JTkzJTg4JUU1JUI4JThDJUU4JUE3JUEzJUU2JUIzJTk1">代码随想录：三数之和</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS9zb2x1dGlvbi8zc3VtcGFpLXh1LXNodWFuZy16aGktemhlbi15aS1kb25nLWJ5LWp5ZC8=">Krahets：三数之和（排序 + 双指针，易懂图解）</span></li></ul><h1 id="leetcode-18-四数之和"><a class="anchor" href="#leetcode-18-四数之和">#</a> LeetCode 18. 四数之和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvNHN1bS8=">LeetCode 18. Four Sum</span></p><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code> 、 <code>b</code> 、 <code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>target</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路-3"><a class="anchor" href="#思路-3">#</a> 思路</h2><p>需注意区分本题与 <a href="https://jiankychen.github.io/posts/40552b28">LeetCode 454. 四数相加 II</a></p><p>本题的解题方法与 <a href="https://jiankychen.github.io/posts/1b6e2437/">LeetCode 15. 三数之和</a> 基本一致，这里采用 排序 + 双指针 解法</p><h2 id="method-排序-双指针-2"><a class="anchor" href="#method-排序-双指针-2">#</a> Method: 排序 + 双指针</h2><p>解题思路：</p><ol><li><p>对数组 <code>nums</code> 排序</p></li><li><p>采用两个 <code>for</code> 循环分别遍历 <code>i</code> 和 <code>j</code> ，其中， <code>i</code> 从 <code>0</code> 开始遍历， <code>j</code> 从 <code>i + 1</code> 开始遍历（注意，要分别对 <code>nums[i]</code> 和 <code>nums[j]</code> 进行去重）</p></li><li><p>采用双指针法在 <code>[j + 1, nums.size() - 1]</code> 区间内查找所有能与 <code>nums[i]</code> , <code>nums[j]</code> 组成四元组的元素 <code>nums[left]</code> 和 <code>nums[right]</code> ，其中，指针 <code>left</code> 从 <code>j + 1</code> 位置开始向右遍历，指针 <code>right</code> 从 <code>nums.size() - 1</code> 位置开始向左遍历</p></li></ol><p>具体步骤可参考 <a href="https://jiankychen.github.io/posts/1b6e2437/">LeetCode 15. 三数之和</a></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;
    sort(nums.begin(), nums.end());
    vector&lt;vector&lt;int&gt;&gt; res;
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; // 对 nums[i] 去重
        for (int j = i + 1; j &lt; nums.size(); j++) &#123;
            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; // 对 nums[j] 去重
            int left = j + 1, right = nums.size() - 1;
            int temp = nums[i] + nums[j]; // 直接计算 nums[i] + nums[j] + nums[left] + nums[right] 会溢出
            while (left &lt; right) &#123;
                if (nums[left] + nums[right] &lt; target - temp) left++;
                else if (nums[left] + nums[right] &gt; target - temp) right--;
                else &#123;
                    res.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);
                    while (left &lt; right &amp;&amp; nums[left] == nums[++left]); // 对 nums[left] 去重
                    while (left &lt; right &amp;&amp; nums[right] == nums[--right]); // 对 nums[right] 去重
                &#125;
            &#125;
        &#125;
    &#125;
    return res;
&#125;
</code></pre><p>其中，需要注意 <code>nums[i] + nums[j] + nums[left] + nums[right]</code> 会溢出，因此，不能直接将 <code>nums[i] + nums[j] + nums[left] + nums[right]</code> 与 <code>target</code> 比较，可比较 <code>nums[left] + nums[right]</code> 与 <code>target - nums[i] - nums[j]</code></p><p>另外，当 <code>temp2 &lt; target - temp1</code> 时，可跳过重复的 <code>nums[left]</code> ，当 <code>temp2 &gt; target - temp1</code> 时，可跳过重复的 <code>nums[right]</code> ，即，将第 12 至 13 行代码改写为：</p><pre><code>if (temp2 &lt; target - temp1)
    while (left &lt; right &amp;&amp; nums[left] == nums[++left]);
else if (temp2 &gt; target - temp1)
    while (left &lt; right &amp;&amp; nums[right] == nums[--right]);
</code></pre><p>具体可见 <a href="https://jiankychen.github.io/posts/1b6e2437/">LeetCode 15. 三数之和</a></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><ul><li>遍历 <code>i</code> 和 <code>j</code> ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>双指针查找：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，这里不考虑存储结果的数组，仅考虑排序所需栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMTguJUU1JTlCJTlCJUU2JTk1JUIwJUU0JUI5JThCJUU1JTkyJThDLmh0bWw=">代码随想录：四数之和</span></p><h1 id="leetcode-202-快乐数"><a class="anchor" href="#leetcode-202-快乐数">#</a> LeetCode 202. 快乐数</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFwcHktbnVtYmVyLw==">LeetCode 202. Happy Number</span></p><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>快乐数</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为 1</strong>，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 快乐数 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：n = 19
输出：true
解释：
    1 + 81 = 82
    64 + 4 = 68
    36 + 64 = 100
    1 + 0 + 0 = 1
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 2
输出：false
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="思路-4"><a class="anchor" href="#思路-4">#</a> 思路</h2><p>注意到题目说明：</p><ul><li>若各位平方和最终等于 1 ，则 <code>n</code> 为快乐数</li><li>若各位平方和的值循环出现，则 <code>n</code> 不是快乐数</li></ul><p>因此，本题的解题关键在于，在求和过程中，判断数字是否重复出现</p><ul><li>若重复出现，则该数字必定不是快乐数</li><li>若求和结果为 1，则该数字是快乐数</li></ul><h2 id="method-1-哈希-set"><a class="anchor" href="#method-1-哈希-set">#</a> Method 1: 哈希 set</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS91bm9yZGVyZWRfc2V0L3Vub3JkZXJlZF9zZXQvP2t3PXVub3JkZXJlZF9zZXQ=">std::unordered_set</span></p><p>考虑用哈希表 <code>unordered_set</code> 记录求和过程中出现的数字，并判断其是否重复出现</p><p>另，需注意 <code>n</code> 的各位数字平方和的计算</p><ul><li>计算个位数字的平方</li><li>取个位以外的部分</li><li>重复以上两步</li></ul><p>代码实现：</p><pre><code class="language-cpp">int getSum(int n) &#123; // 计算 n 中各位的平方和
    int sum = 0;
    while (n) &#123;
        sum += (n % 10) * (n % 10); // 取 n 的个位数，求其平方，再累加到 sum 上
        n /= 10;                    // 取个位数以外的部分
    &#125;
    return sum;
&#125;

bool isHappy(int n) &#123;
    unordered_set&lt;int&gt; record;
    while (1) &#123;
        int sum = getSum(n);
        if (sum == 1)
            return 1;
        if (record.find(sum) != record.end()) // sum 重复出现
            return 0;
        else
            record.insert(sum);               // sum 第一次出现
        n = sum;                              // 更新当前计算数字
    &#125;
&#125;
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMDIuJUU1JUJGJUFCJUU0JUI5JTkwJUU2JTk1JUIwLmh0bWw=">代码随想录：快乐数</span></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><ul><li>查找给定数字的下一个值的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> ，因为数字的位数由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>10</mn></msub><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{10}{n}) = O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.20696799999999996em"><span style="top:-2.4558600000000004em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.24414em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 确定</li><li>总体的时间复杂度还需考虑循环过程中的数字个数，这里简单起见仅考虑计算下一个值的时间复杂度</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-快慢指针"><a class="anchor" href="#method-2-快慢指针">#</a> Method 2: 快慢指针</h2><p>可以采用类似于 <a href="https://jiankychen.github.io/posts/fe4aea2">LeetCode 142. 环形链表 II</a> 的方法，定义快慢指针，判断是否存在环</p><ul><li>若存在环，则快慢指针一定会在环内相遇，即，数 <code>n</code> 不是快乐数</li><li>否则，快指针会比慢指针先到达数字 1 ，即，数 <code>n</code> 是快乐数</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFwcHktbnVtYmVyL3NvbHV0aW9uL2t1YWktbGUtc2h1LWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：快乐数</span></p><h1 id="leetcode-242-有效的字母异位词"><a class="anchor" href="#leetcode-242-有效的字母异位词">#</a> LeetCode 242. 有效的字母异位词</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS8=">LeetCode 242. Valid Anagram</span></p><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出：true
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;rat&quot;, t = &quot;car&quot;
输出：false
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> , <code>t.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶</strong>：如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="思路-5"><a class="anchor" href="#思路-5">#</a> 思路</h2><p>字母异位词，等价于，两个字符串中字符出现的种类和次数均相等</p><p>利用数组 <code>cnt</code> 来实现一个简单的哈希表，将字符 a 到 z 映射为数组的下标 0 到 25 ，数组的元素值表示相应字符在字符串 <code>s</code> 和 <code>t</code> 里出现的次数的差值</p><p>若 <code>cnt</code> 所有元素值均为 0，字符串 <code>s</code> 和 <code>t</code> 是字母异位词</p><p>代码实现：</p><pre><code class="language-cpp">bool isAnagram(string s, string t) &#123;
    vector&lt;int&gt; cnt(26, 0);     // 计算 s 和 t 各个字母出现次数的差值
    for (auto c : s)
        cnt[c - 'a']++;         // 记录字符串 s 中字符出现的次数
    for (auto c : t)
        cnt[c - 'a']--;         // 记录字符串 t 中字符出现次数的相反数
    for (int i = 0; i &lt; 26; i++)
        if (cnt[i] != 0)        // cnt 元素不为 0 ，则字符串 s 和 t 中的字符不同，不是字母异位词
            return 0;
    return 1;                   // 所有字符出现次数相同，是 s 和 t 是字母异位词
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，常量大小的辅助数组</p><blockquote><p>这一题使用数组来实现哈希法，是因为题目限制了只有 26 个小写字母，哈希值比较集中</p></blockquote><h1 id="leetcode-349-两个数组的交集"><a class="anchor" href="#leetcode-349-两个数组的交集">#</a> LeetCode 349. 两个数组的交集</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1hcnJheXMv">LeetCode 349. Intersection of Two Arrays</span></p><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums1.length</code> , <code>nums2.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums1[i]</code> , <code>nums2[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-6"><a class="anchor" href="#思路-6">#</a> 思路</h2><p>由于数组 <code>nums1</code> 和 <code>nums2</code> 的元素值可能比较分散，使用数组来实现哈希法会造成空间的浪费，故而可以采用 <code>set</code></p><p>注意到题目要求输出的每个元素必须唯一，且不考虑输出结果的顺序，故而选用 <code>unordered_set</code></p><blockquote><p>注：相比于数组而言，直接使用 set 不仅占用空间比数组大，而且速度慢。因此，在 数组元素大小有限 且 哈希值比较集中 时，应尽量用 数组 ，而如果哈希值比较少、特别分散、跨度非常大，则考虑用 set</p></blockquote><h2 id="unordered_set"><a class="anchor" href="#unordered_set">#</a> unordered_set</h2><p>解题步骤：</p><ol><li><p>定义 <code>unordered_set</code> 容器 <code>record</code> 和 <code>ans</code> ，前者存放第一个数组 <code>nums1</code> 的元素，后者记录两数组的交集</p></li><li><p>遍历数组 <code>nums2</code> ：若 <code>nums2</code> 数组的元素 <code>a</code> 能够在 <code>record</code> 中找到（即， <code>record.find(a) != record.end()</code> ），则说明 <code>a</code> 是两数组的公共元素，将其添加到 <code>ans</code> 中</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
    unordered_set&lt;int&gt; record(nums1.begin(), nums1.end());  // 将 nums1 拷贝到 unordered_set 容器
    unordered_set&lt;int&gt; ans;             // 存放结果（两数组的交集）
    for (auto a : nums2)
        if (record.find(a) != record.end())   // nums2 的元素 a 在 nums1 中出现过
            ans.insert(a);              // 将 a 添加到结果
    return vector&lt;int&gt;(ans.begin(), ans.end());   // 返回（先拷贝到 vector ，因为返回值的类型是 vector&lt;int&gt;）
&#125;
</code></pre><h1 id="leetcode-383-赎金信"><a class="anchor" href="#leetcode-383-赎金信">#</a> LeetCode 383. 赎金信</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuc29tLW5vdGUv">LeetCode 383. Ransom Note</span></p><p>给你两个字符串： <code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><pre><code>输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;
输出：false
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;
输出：false
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;
输出：true
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>ransomNote.length</code> , <code>magazine.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="method-哈希"><a class="anchor" href="#method-哈希">#</a> Method: 哈希</h2><p>由于字符串中只有小写字母，可以考虑用 数组 实现哈希法</p><p>解题步骤如下：</p><ol><li><p>定义数组 <code>count</code> ，数组元素的下标表示字符相当于 <code>a</code> 的距离，元素值表示字符在字符串 <code>magazine</code> 中出现的次数</p></li><li><p>依据数组 <code>count</code> 判断 <code>ransomNote</code> 的每个字符是否都在字符串 <code>magazine</code> 内</p><ul><li>由于 <code>magazine</code> 中每个字符只能在 <code>ransomNote</code> 中用一次，在遍历字符串 <code>ransomNote</code> 中的每个字符时，需要维护字符所对应的 <code>count</code> 元素值，即，“用一次就会少一次”</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool canConstruct(string ransomNote, string magazine) &#123;
    vector&lt;int&gt; count(26, 0); // record the letters and their frequency in string magazine
    for (auto c : magazine)
        count[c - 'a']++;
    for (auto c : ransomNote) &#123;
        if (count[c - 'a'])
            count[c - 'a']--; // since each letter in string magazine can only be used once
        else
            return false;     // c cannot be found in string magazine
    &#125;
    return true;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p>由于 <code>ransomNote</code> 和 <code>magazine</code> 都由字母组成， <code>key</code> 分布较为集中。与 set 和 map 相比，采用数组更为省时</p></blockquote><h1 id="leetcode-438-找到字符串中所有字母异位词"><a class="anchor" href="#leetcode-438-找到字符串中所有字母异位词">#</a> LeetCode 438. 找到字符串中所有字母异位词</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy8=">438. Find All Anagrams in a String</span></p><p>给定两个字符串 <code>s</code> 和 <code>p</code> ，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;
输出：[0,6]
解释：
    起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。
    起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;abab&quot;, p = &quot;ab&quot;
输出：[0,1,2]
解释：
    起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。
    起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。
    起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> , <code>p.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><h2 id="method-滑动窗口法"><a class="anchor" href="#method-滑动窗口法">#</a> Method: 滑动窗口法</h2><p>算法思路：</p><p>可以在字符串 s 中构造一个与字符串 p 长度相同的滑动窗口，并在滑动窗口过程中维护每种字母的数量。当每种字母在窗口中的数量等于其在字符串 p 中的数量时，窗口即为字符串 p 的异位词</p><p>特别地，可做以下考虑：</p><ul><li><p>用哈希表来统计滑动窗口与字符串 p 中每种字母的数量差。当某个字母对应的数量差为 0 时，字母在窗口中的数量等于其在字符串 p 中的数量</p></li><li><p>用变量 valid 来记录数量差为 0 的字母的种类数。当 valid 等于哈希表的长度时，窗口就是字符串 p 的字母异位词</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; findAnagrams(string s, string p) &#123;
    vector&lt;int&gt; ans; // 结果数组
    int sLen = s.size();
    int pLen = p.size();
    if (sLen &lt; pLen) return ans;

    unordered_map&lt;char, int&gt; record;
    for (auto c : p)
        ++record[c]; // record[c] 表示需添加到窗口内的字符 c 的数量

    int left = 0;    // 滑动窗口的左边界
    int right = 0;   // 滑动窗口的右边界
    int valid = 0;   // 窗口内已满足数量要求的字符种类数
    while (right &lt; sLen) &#123;
        char c = s[right];
        // 更新窗口的相关数据
        if (record.count(c)) &#123;            // 仅当 p 字符串包含的字符 c 时更新 record 和 valid
            --record[c];                  // c 添加到窗口内，所需字符 c 的数量应减 1
            if (record[c] == 0)           // 字符 c 的数量满足要求，有效字符数加 1
                ++valid;
        &#125;
        // 判断是否需要收缩窗口
        while (right - left + 1 &gt; pLen) &#123; // 窗口长度大于 pLen ，应收缩窗口
            char d = s[left];
            // 更新窗口的相关数据
            if (record.count(d)) &#123;        // 仅当 p 字符串包含的字符 d 时更新 record 和 valid
                if (record[d] == 0)       // 目前字符 d 满足数量要求，但其将被移出，故有效字符数减 1
                    --valid;
                ++record[d];              // d 从窗口内移出，所需字符 d 的数量应加 1
            &#125;
            ++left;                       // 窗口的左边界向右移动
        &#125;
        // 窗口符合条件时，将起始索引加入目标数组
        if (right - left + 1 == pLen) &#123;   // 窗口长度等于字符串 p 长度
            if (valid == record.size())   // 所有字符均满足数量要求，将索引添加到目标数组
                ans.push_back(left);
        &#125;
        ++right;                          // 窗口的右边界向右移动
    &#125;

    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串 s 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 为字符串 p 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\vert \Sigma \vert)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vert \Sigma \vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span></span></span></span> 为字符串 p 中的字符种类数</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy9zb2x1dGlvbi9odWEtZG9uZy1jaHVhbmcta291LXRvbmcteW9uZy1zaS14aWFuZy1qaWUtanVlLXppLS8=">labuladong</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy9zb2x1dGlvbi96aGFvLWRhby16aS1mdS1jaHVhbi16aG9uZy1zdW8teW91LXppLW11LXh6aW4v">leetcode-solution</span></li></ul><h1 id="leetcode-454-四数相加ii"><a class="anchor" href="#leetcode-454-四数相加ii">#</a> LeetCode 454. 四数相加 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvNHN1bS1paS8=">LeetCode 454. 4Sum II</span></p><p>给你四个整数数组 <code>nums1</code> 、 <code>nums2</code> 、 <code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p><ul><li><p><code>0 &lt;= i, j, k, l &lt; n</code></p></li><li><p><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></p></li></ul><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：两个元组如下：
    1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
    2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
</code></pre><p></p><p><strong>提示：</strong></p><ul 28=""><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>28</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 2^{28} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums1[i]</code> , <code>nums2[i]</code> , <code>nums3[i]</code> , <code>nums4[i]</code> \le 2^</li></ul><h2 id="思路-7"><a class="anchor" href="#思路-7">#</a> 思路</h2><p>统计 <code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code> 成立的 <code>(i, j, k, l)</code> 的个数，不用考虑是否有重复的元素值相加</p><p>可以采用 <code>unordered_map</code> 容器记录 任意 <code>nums1[i]</code> 与 <code>nums2[j]</code> 相加的和，将其作为 <code>key</code> ，同时记录 该 <code>key</code> 值出现的次数，将其作为对应的 <code>value</code></p><p>然后遍历 <code>nums3[k]</code> 和 <code>nums4[l]</code> ，看 <code>unordered_map</code> 容器中是否能找到值为 <code>0 - num3[k] - num4[l]</code> 的 <code>key</code> ，将找到的所有 <code>key</code> 对应的 <code>value</code> 进行求和，即为所求</p><h2 id="哈希-map"><a class="anchor" href="#哈希-map">#</a> 哈希 map</h2><p>解题步骤：</p><ol><li>定义一个 <code>unordered_map</code> 容器，命名为 <code>map</code></li><li>遍历数组 <code>nums1</code> 的元素 <code>a</code> 和 数组 <code>nums2</code> 的元素 <code>b</code> ，将 <code>a + b</code> 作为哈希 <code>map</code> 的 <code>key</code> ，将值 <code>a + b</code> 出现的次数作为对应的 <code>value</code></li><li>定义变量 <code>count</code> ，用来记录答案</li><li>遍历数组 <code>nums3</code> 元素 <code>c</code> 和数组 <code>nums4</code> 元素 <code>d</code> ，如果在哈希 <code>map</code> 中找到 <code>0 - (c + d)</code> ，把对应的 <code>value</code> 累加到 <code>count</code></li></ol><p>代码实现：</p><pre><code class="language-cpp">int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;
    // 统计 nums1 和 nums2 数组中任意两元素之和
    unordered_map&lt;int, int&gt; map;
    for (auto a : nums1)
        for (auto b : nums2)
            map[a + b]++;
    // 统计 a + b + c + d = 0 的次数
    int count = 0;
    for (auto c : nums3)
        for (auto d : nums4)
            if (map.find(0 - c - d) != map.end())
                count += map[0 - c - d];
    return count;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><ul><li>两个 <code>for</code> 循环，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>每次哈希查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，哈希 <code>map</code> 所需要的空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0NTQuJUU1JTlCJTlCJUU2JTk1JUIwJUU3JTlCJUI4JUU1JThBJUEwSUkuaHRtbCMlRTUlODUlQjYlRTQlQkIlOTYlRTglQUYlQUQlRTglQTglODAlRTclODklODglRTYlOUMlQUM=">代码随想录：四数相加 II</span></p><h1 id="leetcode-49-字母异位词分组"><a class="anchor" href="#leetcode-49-字母异位词分组">#</a> LeetCode 49. 字母异位词分组</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy8=">49. Group Anagrams</span></p><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>示例 1：</strong></p><pre><code>输入：strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]
输出：[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：strs = [&quot;&quot;]
输出：[[&quot;&quot;]]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：strs = [&quot;a&quot;]
输出：[[&quot;a&quot;]]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>strs.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>strs[i].length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h2 id="method-1-排序-哈希"><a class="anchor" href="#method-1-排序-哈希">#</a> Method 1: 排序 + 哈希</h2><p>算法思路：</p><p>两个字符串互为字母异位词，当且仅当它们包含的字母相同，因此，对两个字母异位词分别进行排序，所得的字符串一定相同</p><p>可以将排序之后的字符串作为哈希表的键，哈希表的值存放每一组字母异位词</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
    unordered_map&lt;string, vector&lt;string&gt;&gt; hash;
    for (auto &amp;s : strs) &#123;
        string key = s;
        sort(key.begin(), key.end());
        hash[key].push_back(s);
    &#125;
    vector&lt;vector&lt;string&gt;&gt; ans;
    for (auto it = hash.begin(); it != hash.end(); it++) &#123;
        ans.push_back(it-&gt;second);
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n k \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03148em">k</span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是 <code>strs</code> 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 是 <code>strs</code> 中字符串的最大长度</p><ul><li>遍历 <code>strs</code> 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>对 <code>strs</code> 中的每个字符串进行排序，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \log{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03148em">k</span></span><span class="mclose">)</span></span></span></span></li><li>哈希查找的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，需要用哈希表存储所有字母异位词</p><h2 id="method-2-计数-哈希"><a class="anchor" href="#method-2-计数-哈希">#</a> Method 2: 计数 + 哈希</h2><p>算法思路：</p><p>两个字母异位词中的每一种字母的出现次数一定相同</p><p>可以使用字符串表示字母的出现次数，将其作为哈希表的键</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy9zb2x1dGlvbi96aS1tdS15aS13ZWktY2ktZmVuLXp1LWJ5LWxlZXRjb2RlLXNvbHV0LWd5b2Mv">leetcode-solution</span></p><h1 id="leetcode-554-砖墙"><a class="anchor" href="#leetcode-554-砖墙">#</a> LeetCode 554. 砖墙</h1><p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p><p>你现在要画一条 <strong>自顶向下</strong> 的、穿过 <strong>最少</strong> 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的</strong> 。</p><p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中， <code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p><p><img data-src="LeetCode554-%E7%A0%96%E5%A2%99/Example.jpg" alt=""></p><p><strong>示例 1：</strong></p><pre><code>输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出：2
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：wall = [[1],[1],[1]]
输出：3
</code></pre><p><strong>提示：</strong></p><ul><li><code>n == wall.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>wall[i].length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>sum(wall[i].length)</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>对于每一行 <code>i</code> ， <code>sum(wall[i])</code> 是相同的</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>wall[i][j]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="method-哈希-2"><a class="anchor" href="#method-哈希-2">#</a> Method: 哈希</h2><h2 id="算法思路-2"><a class="anchor" href="#算法思路-2">#</a> 算法思路</h2><p>穿过最少的砖块 等价于 穿过最多的间隙</p><p>可以使用哈希表记录每个间隙的出现次数（以间隙索引位置为 key ，以间隙出现次数为 value），然后从所有行中找出间隙最大出现次数，利用 <strong>行数 减去 间隙出现最大次数 即为 穿过砖块最小数</strong></p><p>其中，每一行中的间隙的索引 需要按 <strong>前缀和</strong> 方法求得，例如，第一行的第一个间隙的索引为 <code>wall[0][0]</code> ，第二个间隙的索引为 <code>wall[0][0] + wall[0][1]</code> ，第 i 个间隙的索引为 <code>wall[0][0] + ... + wall[0][i]</code></p><p>注意：不能沿着砖墙两侧的最边缘画线，因此不需要统计砖墙两侧的间隙</p><p>如下图所示，间隙 4 在所有行中出现次数最多，出现次数为 4 次，而总行数为 6 ，因此穿过砖块数为 2</p><p><img data-src="LeetCode554-%E7%A0%96%E5%A2%99/Flow.png" alt="" height="150px"></p><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">int leastBricks(vector&lt;vector&lt;int&gt;&gt;&amp; wall) &#123;
    unordered_map&lt;int, int&gt; hash;
    for (int i = 0; i &lt; wall.size(); ++i) &#123;
        int sum = 0;
        for (int j = 0; j &lt; wall[i].size() - 1; ++j) &#123; // 不能沿着最边缘画线
            sum += wall[i][j];                         // 间隙的索引
            ++hash[sum];
        &#125;
    &#125;
    int maxCnt = 0;
    for (auto it : hash) &#123;
        maxCnt = max(maxCnt, it.second);
    &#125;
    return wall.size() - maxCnt;
&#125;
</code></pre><h2 id="复杂度分析-2"><a class="anchor" href="#复杂度分析-2">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为砖块总个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="参考资料-2"><a class="anchor" href="#参考资料-2">#</a> 参考资料</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9icmljay13YWxsL3NvbHV0aW9uL2dvbmctc2h1aS1zYW4teGllLXpoZW5nLW5hbi16ZS1mYW4tc2hpLXktZ3NyaS8=">宫水三叶：使用哈希表求解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9icmljay13YWxsL3NvbHV0aW9uL3podWFuLXFpYW5nLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLTJrbHMv">力扣官方题解</span></li></ul><div class="tags"><a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="tag"><i class="ic i-tag"></i> 哈希表</a></div></div><footer><div class="meta"><span class="item"><time title="修改时间：2024-03-23 01:16:15" itemprop="dateModified" datetime="2024-03-23T01:16:15+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2024-03-23 </time></span><span id="posts/29abbd18/" class="item leancloud_visitors" data-flag-title="LeetCode - 哈希表专题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/29abbd18/" title="LeetCode - 哈希表专题">https://jiankychen.github.io/posts/29abbd18/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/ee040603/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;42bab566f107b9a16542343e0368fb77.jpg" title="图"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Data Structure</span><h3>图</h3></a></div><div class="item right"><a href="/posts/36947f98/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;a1f3404a5032323ea4857ac5a6354d2f.jpg" title="LeetCode - 字符串专题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 字符串专题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 1. 两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%93%88%E5%B8%8C-map"><span class="toc-number">1.1.</span> <span class="toc-text">Method: 哈希 map</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">LeetCode 128. 最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">Method: 哈希表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1296-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">LeetCode 1296. 划分数组为连续数字的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C"><span class="toc-number">3.1.</span> <span class="toc-text">Method: 排序 + 哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">3.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">3.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.</span> <span class="toc-text">LeetCode 15. 三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">4.2.</span> <span class="toc-text">Method: 排序 + 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">5.</span> <span class="toc-text">LeetCode 18. 四数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-number">5.2.</span> <span class="toc-text">Method: 排序 + 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">LeetCode 202. 快乐数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%93%88%E5%B8%8C-set"><span class="toc-number">6.2.</span> <span class="toc-text">Method 1: 哈希 set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">6.3.</span> <span class="toc-text">Method 2: 快慢指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">7.</span> <span class="toc-text">LeetCode 242. 有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">7.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">8.</span> <span class="toc-text">LeetCode 349. 两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered_set"><span class="toc-number">8.2.</span> <span class="toc-text">unordered_set</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-number">9.</span> <span class="toc-text">LeetCode 383. 赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%93%88%E5%B8%8C"><span class="toc-number">9.1.</span> <span class="toc-text">Method: 哈希</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">10.</span> <span class="toc-text">LeetCode 438. 找到字符串中所有字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">Method: 滑动窗口法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0ii"><span class="toc-number">11.</span> <span class="toc-text">LeetCode 454. 四数相加 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">11.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C-map"><span class="toc-number">11.2.</span> <span class="toc-text">哈希 map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">12.</span> <span class="toc-text">LeetCode 49. 字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C"><span class="toc-number">12.1.</span> <span class="toc-text">Method 1: 排序 + 哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%AE%A1%E6%95%B0-%E5%93%88%E5%B8%8C"><span class="toc-number">12.2.</span> <span class="toc-text">Method 2: 计数 + 哈希</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-554-%E7%A0%96%E5%A2%99"><span class="toc-number">13.</span> <span class="toc-text">LeetCode 554. 砖墙</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%93%88%E5%B8%8C-2"><span class="toc-number">13.1.</span> <span class="toc-text">Method: 哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-2"><span class="toc-number">13.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">13.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">13.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-2"><span class="toc-number">13.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/1b7ed9b4/" rel="bookmark" title="LeetCode Records">LeetCode Records</a></li><li><a href="/posts/32d5c1f6/" rel="bookmark" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></li><li><a href="/posts/2057f45/" rel="bookmark" title="LeetCode - 数组专题">LeetCode - 数组专题</a></li><li><a href="/posts/bc32ab1e/" rel="bookmark" title="LeetCode - 链表专题">LeetCode - 链表专题</a></li><li class="active"><a href="/posts/29abbd18/" rel="bookmark" title="LeetCode - 哈希表专题">LeetCode - 哈希表专题</a></li><li><a href="/posts/36947f98/" rel="bookmark" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></li><li><a href="/posts/51f34f0/" rel="bookmark" title="LeetCode - 栈与队列专题">LeetCode - 栈与队列专题</a></li><li><a href="/posts/ed3025a8/" rel="bookmark" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></li><li><a href="/posts/6012cc6b/" rel="bookmark" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></li><li><a href="/posts/f3b1f59f/" rel="bookmark" title="LeetCode - 贪心专题">LeetCode - 贪心专题</a></li><li><a href="/posts/5e11e767/" rel="bookmark" title="LeetCode - 动态规划专题">LeetCode - 动态规划专题</a></li><li><a href="/posts/611c1217/" rel="bookmark" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></li><li><a href="/posts/691b4be6/" rel="bookmark" title="LeetCode - 单调栈专题">LeetCode - 单调栈专题</a></li><li><a href="/posts/537e2e53/" rel="bookmark" title="LeetCode - 搜索专题">LeetCode - 搜索专题</a></li><li><a href="/posts/242193c5/" rel="bookmark" title="LeetCode - 排序专题">LeetCode - 排序专题</a></li><li><a href="/posts/f994a74a/" rel="bookmark" title="常见输入输出">常见输入输出</a></li><li><a href="/posts/def81c82/" rel="bookmark" title="LeetCode - 模拟专题">LeetCode - 模拟专题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">52</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/ee040603/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/36947f98/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/32d5c1f6/" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/ed3025a8/" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/611c1217/" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/23926cd4/" title="Python 数据容器">Python 数据容器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/36947f98/" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/7db09267/" title="算法复杂度">算法复杂度</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/ee040603/" title="图">图</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/a80d0031/" title="动态规划">动态规划</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/59bf225c/" title="Python 面向对象">Python 面向对象</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/afade57b/" title="递推与递归">递推与递归</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">821k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:48</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/29abbd18/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->