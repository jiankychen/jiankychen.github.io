<!-- build time:Sat Mar 23 2024 01:17:14 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="回溯"><link rel="canonical" href="https://jiankychen.github.io/posts/6012cc6b/"><title>LeetCode - 回溯专题 - Coding | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">LeetCode - 回溯专题</h1><div class="meta"><span class="item" title="创建时间：2022-06-24 21:22:40"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-24T21:22:40+08:00">2022-06-24</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>41k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:09</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/42bab566f107b9a16542343e0368fb77.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/8491109c4ae2ac88bbf9659a4f6d5ed2.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a1f3404a5032323ea4857ac5a6354d2f.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/8fe50780c15461b629c9aeab5a7f2acd.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/9b626c5ba21d7cb4dbcba2b507688bbb.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Coding/" itemprop="item" rel="index" title="分类于 Coding"><span itemprop="name">Coding</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/6012cc6b/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="leetcode-131-分割回文串"><a class="anchor" href="#leetcode-131-分割回文串">#</a> LeetCode 131. 分割回文串</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLXBhcnRpdGlvbmluZy8=">131. Palindrome Partitioning</span></p><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;aab&quot;
输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;a&quot;
输出：[[&quot;a&quot;]]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">\le 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">6</span></span></span></span></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>分割问题本质上与组合问题类似，例如字符串 &quot;aaba&quot;</p><ul><li>组合问题：选取一个 &quot;a&quot; 之后，再在 &quot;aba&quot; 中选取第二个，依此类推</li><li>分割问题：分割第一段的 &quot;a&quot; 之后，再在 &quot;aba&quot; 中分割第二段，依此类推</li></ul><p>因此，分割问题也可以抽象成一棵树</p><p><img data-src="LeetCode131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/example.jpg" alt="" height="200px"></p><p>其中， <code>for</code> 循环用于遍历分割线的位置，递归用于将分割线后面的字符做进一步的分割</p><p>根据题中对回文串的定义可知，回文串应为左右对称的字符串，可通过双指针法（定义左、右指针）来判断字符串是否左右对称</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMzEuJUU1JTg4JTg2JUU1JTg5JUIyJUU1JTlCJTlFJUU2JTk2JTg3JUU0JUI4JUIyLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：分割回文串</span></p><h2 id="method-回溯"><a class="anchor" href="#method-回溯">#</a> Method: 回溯</h2><p>算法思路：</p><ol><li><p>确定递归函数的参数</p><ul><li><code>string s</code> ：原始的字符串</li><li><code>int startIndex</code> ：待分割字符串的起始位置</li></ul></li><li><p>递归的终止条件： <code>startIndex</code> 到达字符串 <code>s</code> 的尾后，字符串 <code>s</code> 已分割完成，当前递归结束</p></li><li><p>单层搜索的逻辑</p><ul><li><code>for</code> 循环，遍历分割线的位置 <code>i</code> （也就相当于遍历不同的分割方案）<ul><li>起始位置至分割线之间的字符，即，索引为 <code>[startIndex, i]</code> 的字符，就是当前分割所得的子串，记作 <code>str</code></li><li>判断 <code>str</code> 是否为回文串：若不是回文串，则说明当前分割不可行，需跳过当前分割方案；若是回文串，则进行下一步操作</li><li>将回文串 <code>str</code> 保存到 <code>path</code> （分割所得回文串的集合）当中</li><li>递归到下一层，继续分割 索引为 <code>[i + 1, s.size() - 1]</code> 的字符</li><li>回溯，弹出本次已经填在 <code>path</code> 中的子串 <code>str</code> ，以便遍历其余分割方案</li></ul></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; result;  // 存放所有的分割方案
vector&lt;string&gt; path;            // 存放当前已经分割的回文子串

bool isPalindrome(string str) &#123; // 判断 str 是否为回文串
    if (str.size() == 0) return true;
    for (int l = 0, r = str.size() - 1; l &lt; r; l++, r--) &#123; // 双指针
        if (str[l] != str[r]) return false;
    &#125;
    return true;
&#125;

void backTracking(string s, int startIndex) &#123; // 将以 startIndex 为起始索引的子串进行分割
    if (startIndex == s.size()) &#123; // 分割的起始位置在 s 尾后，说明分割已完成
        result.push_back(path);   // 存储当前的分割方案
        return;
    &#125;
    for (int i = startIndex; i &lt; s.size(); i++) &#123; // 对分割线的位置进行遍历
        // 获取 s 中索引为 [startIndex, i] 的子串
        string str(s.begin() + startIndex, s.begin() + i + 1);
        if (!isPalindrome(str)) continue; // 分割得到的子串不是回文串，跳过当前分割方案
        path.push_back(str);    // 子串是回文串，将其放入 path
        backTracking(s, i + 1); // 递归到下一层，分割字符串 s 中的后续字符
        path.pop_back();        // 回溯，删除已存储的字符串 str
    &#125;
&#125;

vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
    backTracking(s, 0);
    return result;
&#125;
</code></pre><p>其中， <code>string str(s.begin() + startIndex, s.begin() + i + 1);</code> 等效于 <code>string str = s.substr(startIndex, i - startIndex + 1);</code></p><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>上述算法利用了双指针法判断字符串是否为回文串，这会带来重复计算</p><p>以分割 &quot;aaba&quot; 为例</p><ul><li>如果第一次分割子串 &quot;a&quot; ，剩余子串为 &quot;aba&quot; ，则第二次分割需要分别判断 &quot;a&quot; &quot;ab&quot; &quot;aba&quot; 是否为回文串。进一步地，如果第二次分割的子串为 &quot;a&quot; ，则剩余子串为 &quot;ba&quot; ，第三次分割需要分别判断 &quot;b&quot; &quot;ba&quot; 是否为回文串</li><li>如果第一次分割子串为 &quot;ab&quot; ，剩余子串为 &quot;ba&quot; ，第二次分割需要分别判断 &quot;b&quot; &quot;ba&quot; 是否为回文串</li><li>因此，子串 &quot;b&quot; 与 &quot;ba&quot; 被重复判断过</li></ul><p>对此，可以先将字符串 <code>s</code> 中的每个子串进行预处理（判断其是否为回文串），可采用的办法包括：动态规划、记忆化搜索，具体可见 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLXBhcnRpdGlvbmluZy9zb2x1dGlvbi9mZW4tZ2UtaHVpLXdlbi1jaHVhbi1ieS1sZWV0Y29kZS1zb2x1dGlvLTZqa3Yv">力扣官方题解：分割回文串</span></p><p>这里采用动态规划方法进行预处理：</p><ul><li><p><code>f[i][j]</code> 表示索引 <code>[i, j]</code> 之间字符组成的子串是否为回文串</p></li><li><p>状态转移方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mtext>若</mtext><mi>i</mi><mo>≥</mo><mi>j</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>若</mtext><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f[i][j] = \begin{cases} True, \textrm{若} \ i \ge j \\ (f[i + 1][j - 1]) \land (s[i] == s[j]), \textrm{若} \ i &lt; j \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em"><span style="top:-3.69em"><span class="pstrut" style="height:3.008em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord text"><span class="mord textrm cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span><span style="top:-2.25em"><span class="pstrut" style="height:3.008em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord text"><span class="mord textrm cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.55556em;vertical-align:0"></span><span class="mord">∧</span></span></span></span> 表示逻辑与，即，索引 <code>[i, j]</code> 的子串为回文串，有以下三种情况：</p><ul><li>该子串为空</li><li>该子串长度为 1（即 <code>i == j</code> ）</li><li>首尾字符相同（即 <code>s[i] == s[j]</code> ）并且 索引 <code>[i + 1, j - 1]</code> 子串为回文串</li></ul></li></ul><p>由此，只需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间就能判断任意子串为回文串</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; result;
vector&lt;string&gt; path;

vector&lt;vector&lt;int&gt;&gt; f; // 动态规划的结果

void backTracking(string s, int startIndex) &#123;
    if (startIndex == s.size()) &#123;
        result.push_back(path);
        return;
    &#125;
    for (int i = startIndex; i &lt; s.size(); i++) &#123;
        if (!f[startIndex][i]) continue; // 字符串 s[startIndex, i] 不是回文串
        string str(s.begin() + startIndex, s.begin() + i + 1);
        path.push_back(str);
        backTracking(s, i + 1);
        path.pop_back();
    &#125;
&#125;

vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
    f.assign(s.size(), vector&lt;int&gt;(s.size(), true)); // 初始化 f ：值全为 true
    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;        // 计算索引为 [i, j] 的子串是否为回文串
        for (int j = i + 1; j &lt; s.size(); j++) &#123;
            f[i][j] = (s[i] == s[j]) &amp;&amp; (f[i + 1][j - 1]); // 状态转移
        &#125;
    &#125;
    backTracking(s, 0);
    return result;
&#125;
</code></pre><h1 id="leetcode-17-电话号码的字母组合"><a class="anchor" href="#leetcode-17-电话号码的字母组合">#</a> LeetCode 17. 电话号码的字母组合</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyLw==">LeetCode 17. Letter Combinations of a Phone Number</span></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意，1 不对应任何字母。</p><p><img data-src="LeetCode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/map.png" alt=""></p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：digits = &quot;23&quot;
输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：digits = &quot;&quot;
输出：[]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：digits = &quot;2&quot;
输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>digits.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\le 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span></li><li><code>digits[i]</code> is a digit in the range <code>['2', '9']</code> .</li></ul><h2 id="思路-2"><a class="anchor" href="#思路-2">#</a> 思路</h2><p>本题每一个数字代表的是不同集合，也就是求不同集合之间的组合</p><p>首先，需要建立 键盘数字 与 字符串 之间的映射，这里使用字符串数组将数字 0 - 9 与 字母 对应起来</p><pre><code class="language-cpp">const string letterMap[10] = &#123;
    &quot;&quot;,     // 数字 0
    &quot;&quot;,     // 数字 1
    &quot;abc&quot;,  // 数字 2
    &quot;def&quot;,
    &quot;ghi&quot;,
    &quot;jkl&quot;,
    &quot;mno&quot;,
    &quot;pqrs&quot;,
    &quot;tuv&quot;,
    &quot;wxyz&quot;  // 数字 9
&#125;
</code></pre><p>本题可通过回溯算法解题</p><ul><li>递归函数内嵌一个 <code>for</code> 循环， <code>for</code> 循环用于遍历数字所对应的字母（即，遍历 <code>letterMap</code> ）</li><li>递归用于实现对数字的遍历（即，遍历 <code>digits</code> ）</li></ul><p><img data-src="LeetCode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/example.png" alt="" height="200px"></p><h2 id="method-回溯-2"><a class="anchor" href="#method-回溯-2">#</a> Method: 回溯</h2><p>算法思路： <code>for</code> 循环横向遍历，递归纵向遍历，回溯不断调整结果集</p><p>本题输入的 <code>digits[i]</code> 是范围 <code>[2, 9]</code> 之间的数字，因此不需要考虑 0 和 1 这样的特殊情况</p><p>代码实现：</p><pre><code class="language-cpp">const string letterMap[10] = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;

vector&lt;string&gt; result;
string path;

void backtracking(string digits, int index) &#123;
    if (path.size() == digits.size()) &#123;
        result.push_back(path);
        return;
    &#125;
    int num = digits[index] - '0';   // 当前遍历到的数字（index 指向的数字）
    string letters = letterMap[num]; // 当前数字对应的字符串
    for (int i = 0; i &lt; letters.size(); i++) &#123; // for 循环：遍历 letterMap[num] 字符串
        path.push_back(letters[i]);      // 处理节点
        backtracking(digits, index + 1); // 递归到下一层：选取第 index + 1 位数字对应的字母
        path.pop_back();                 // 回溯
    &#125;
&#125;

vector&lt;string&gt; letterCombinations(string digits) &#123;
    if (digits.size() == 0) return result; // 处理 digits 为空这一特殊情况
    backtracking(digits, 0);
    return result;
&#125;
</code></pre><p>须注意： <code>digits</code> 是 <code>string</code> 型的对象，对应的元素 <code>digits[index]</code> 是 <code>char</code> 型，需先将 <code>char</code> 型转换成 <code>int</code> 型才能索引字符串数组 <code>letterMap</code></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>3</mn><mi>m</mi></msup><mo>×</mo><msup><mn>4</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3^m \times 4^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 是输入到 <code>digits</code> 中的、对应键盘上有三个字母的数字个数（包括数字 2、3、4、5、6、8），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是对应四个字母的数字个数（包括数字 7、9），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是输入数字的总个数，对应的字母组合一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mi>m</mi></msup><mo>×</mo><msup><mn>4</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">3^m \times 4^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.747722em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.664392em;vertical-align:0"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归调用的层数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMTcuJUU3JTk0JUI1JUU4JUFGJTlEJUU1JThGJUI3JUU3JUEwJTgxJUU3JTlBJTg0JUU1JUFEJTk3JUU2JUFGJThEJUU3JUJCJTg0JUU1JTkwJTg4Lmh0bWw=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyL3NvbHV0aW9uL2RpYW4taHVhLWhhby1tYS1kZS16aS1tdS16dS1oZS1ieS1sZWV0Y29kZS1zb2x1dGlvLw==">力扣官方题解</span></li></ul><h1 id="leetcode-22-括号生成"><a class="anchor" href="#leetcode-22-括号生成">#</a> LeetCode 22. 括号生成</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy8=">22. Generate Parentheses</span></p><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 3
输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1
输出：[&quot;()&quot;]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span></span></span></span></li></ul><h2 id="method-回溯-3"><a class="anchor" href="#method-回溯-3">#</a> Method: 回溯</h2><p>算法思路：</p><p>回溯函数的参数：</p><ul><li><code>vector&lt;string&gt;&amp; ans</code> ：存放所有可行的组合</li><li><code>string path</code> ：当前遍历的组合</li><li><code>int open</code> ：当前组合中的左括号数量</li><li><code>int close</code> ：当前组合中的右括号数量</li><li><code>int n</code> ：限定的括号对数</li></ul><p>终止条件：括号总数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> ，即，已经有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 对括号时，将当前组合添加到目标数组，当前递归结束</p><p>单层递归的逻辑：</p><ul><li>若左括号数量小于 n ，则可添加左括号，并递归到下一层</li><li>若右括号数量小于左括号数量，则可添加右括号，并递归到下一层</li></ul><p>代码实现：</p><pre><code class="language-cpp">void backTracking(vector&lt;string&gt;&amp; ans, string path, int open, int close, int n) &#123;
    if (path.size() == n * 2) &#123;
        ans.push_back(path);
        return;
    &#125;
    if (open &lt; n) &#123;     // 添加左括号
        path.push_back('(');
        backTracking(ans, path, open + 1, close, n);
        path.pop_back();
    &#125;
    if (close &lt; open) &#123; // 添加右括号
        path.push_back(')');
        backTracking(ans, path, open, close + 1, n);
        path.pop_back();
    &#125;
&#125;

vector&lt;string&gt; generateParenthesis(int n) &#123;
    vector&lt;string&gt; ans;
    backTracking(ans, &quot;&quot;, 0, 0, n);
    return ans;
&#125;
</code></pre><h1 id="leetcode-301-删除无效的括号"><a class="anchor" href="#leetcode-301-删除无效的括号">#</a> LeetCode 301. 删除无效的括号</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtaW52YWxpZC1wYXJlbnRoZXNlcy8=">301. Remove Invalid Parentheses</span></p><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p><p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;()())()&quot;
输出：[&quot;(())()&quot;,&quot;()()()&quot;]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;(a)())()&quot;
输出：[&quot;(a())()&quot;,&quot;(a)()()&quot;]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;)(&quot;
输出：[&quot;&quot;]
</code></pre><p><strong>提示：</strong></p><ul><li>1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span></span></span></span> 25</li><li><code>s</code> 由小写英文字母以及括号 <code>'('</code> 和 <code>')'</code> 组成</li><li><code>s</code> 中至多含 20 个括号</li></ul><h2 id="method-回溯-4"><a class="anchor" href="#method-回溯-4">#</a> Method: 回溯</h2><p>算法思路：</p><p>首先利用括号匹配的规则来计算最少需要删除的左括号数量 lremove 和右括号数量 rremove，即，遍历字符串 s：</p><ul><li>当遇到左括号时：llremove 加 1</li><li>当遇到右括号时：<ul><li>若 llremove 为 0，该右括号无法匹配，故而 rremove 加 1</li><li>若 llremove 不为 0，该右括号可以与之前的左括号匹配，故而 llremove 减 1</li></ul></li></ul><p>然后利用回溯算法遍历所有可能的删除非法括号的方案</p><ul><li>回溯函数的参数：字符串 string str，删除括号的起点 int start，所需删除的左括号数量 llremove，所需删除的右括号数量 rremove</li><li>回溯的终止条件：llremove 与 rremove 同时为 0，无需再删除括号，当前递归结束（在返回之前需要先调用 isValid 函数来检查当前字符串是否合法匹配，若合法匹配则将其记录下来）</li><li>单层搜索过程：遍历 字符串 str 的位置 i<ul><li>如果 i != start 且 str [i] == str [i - 1]，说明在这一层递归中遇到了连续相同的括号，此时我们不需要再重复搜索，故而跳过当前的 i，以此实现去重（比如当前遇到的字符串为 &quot;(((())&quot;，去掉前四个左括号中的任意一个，生成的字符串是一样的）</li><li>如果剩余字符串长度小于 lremove + rremove，当前的方案必然无法得到合法匹配的括号，因此，当前递归结束</li><li>如果 lremove 大于 0 且 str [i] 为左括号，可将当前左括号删除，然后递归到下一层（由于需要删除位置 i 的左括号，递归到下一层的字符串 str 应为 str.substr (0, i) + str.substr (i + 1)，并且起始位置 start 应为 i，lremove 应为 lremove - 1）</li><li>如果 rremove 大于 0 且 str [i] 为右括号，可将当前右括号删除，然后递归到下一层</li></ul></li></ul><p>其中，isValid 函数可按如下方式实现：</p><ul><li>定义 count 作为非法的左括号数量</li><li>遍历字符串 str<ul><li>若遇到左括号，count 加 1</li><li>若遇到右括号<ul><li>如果 count 等于 0，当前右括号无法匹配，返回 false</li><li>如果 count 不为 0，当前右括号可以匹配，count 减 1</li></ul></li></ul></li><li>判断 count 是否为 0，若为 0 则返回 true，否则返回 false</li></ul><blockquote><p>可考虑将 “计算 lremove、rremove” 与 “isValid 函数” 定义成一个可供复用的新函数</p></blockquote><p>代码实现：（本代码使用的是可复用的函数 check，函数返回 {0, 0} 时表示字符串合法）</p><pre><code class="language-cpp">vector&lt;string&gt; res;
vector&lt;string&gt; removeInvalidParentheses(string s) &#123;
    vector&lt;int&gt; remove(2, 0);
    remove = check(s); // 计算需移除的左括号数量和右括号数量
    helper(s, 0, remove[0], remove[1]);
    return res;
&#125;

void helper(string str, int start, int lremove, int rremove) &#123;
    if (lremove == 0 &amp;&amp; rremove == 0) &#123; // 已达到需要删除的最小括号数量
        vector&lt;int&gt; tmp(2, 0);
        tmp = check(str);               // 检查字符串内的括号是否完全匹配
        if (tmp[0] == 0 &amp;&amp; tmp[1] == 0) // 字符串内的括号完全匹配
            res.push_back(str);         // 记录当前方案
        return;
    &#125;
    for (int i = start; i &lt; str.size(); ++i) &#123;
        if (i &gt; start &amp;&amp; str[i] == str[i - 1]) continue; // 去重（连续相同的括号只需搜索一次）
        if (lremove + rremove &gt; str.size() - i) return;  // 剪枝（剩余的字符数小于需删除的括号数）
        if (lremove &gt; 0 &amp;&amp; str[i] == '(')                // 尝试删除一个左括号
            helper(str.substr(0, i) + str.substr(i + 1), i, lremove - 1, rremove);
        if (rremove &gt; 0 &amp;&amp; str[i] == ')')                // 尝试删除一个左括号
            helper(str.substr(0, i) + str.substr(i + 1), i, lremove, rremove - 1);
    &#125;
&#125;

vector&lt;int&gt; check(string&amp; s) &#123;
    int lremove = 0; // 需移除的左括号数量（最小数量）
    int rremove = 0; // 需移除的右括号数量（最小数量）
    for (auto c : s) &#123;
        if (c == '(') ++lremove;         // 左括号加一
        else if (c == ')') &#123;
            if (lremove == 0) ++rremove; // 右括号与左括号不匹配
            else --lremove;              // 右括号与左括号匹配
        &#125;
    &#125;
    return &#123;lremove, rremove&#125;;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times 2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为字符串的长度</p><ul><li>一个长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的字符串最多可能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.664392em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个子序列，遍历所有子序列需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 时间</li><li>每个子序列可能都需要进行一次合法性检测，需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，不考虑返回数组所需空间</p><ul><li>递归调用栈的最大深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次递归调用时都需要复制一次字符串 str，所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtaW52YWxpZC1wYXJlbnRoZXNlcy9zb2x1dGlvbi9zaGFuLWNodS13dS14aWFvLWRlLWd1YS1oYW8tYnktbGVldGNvZGUtOXc4YXUv">leetcode-solution</span></p><h1 id="leetcode-39-组合总和"><a class="anchor" href="#leetcode-39-组合总和">#</a> LeetCode 39. 组合总和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0v">39. Combination Sum</span></p><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><pre><code>输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
    2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
    7 也是一个候选， 7 = 7 。
    仅有这两种组合。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：candidates = [2,3,5], target = 8
输出：[[2,2,2,2],[2,3,3],[3,5]]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：candidates = [2], target = 1
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>candidates.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>candidates[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>candidates</code> 的所有元素互不相同</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>target</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-回溯-5"><a class="anchor" href="#method-回溯-5">#</a> Method: 回溯</h2><p>注意本题 <code>candidates</code> 中的元素可以被无限制重复选取，下一层递归中的 <code>for</code> 循环遍历起点应与当前层相同</p><p>本题对子集的元素数量并没有要求，因此递归返回的条件应为：元素和大于等于目标和</p><p>搜索过程如下所示：</p><p><img data-src="LeetCode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/example.png" alt="" height="200px"></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; candidates, int target, int sum, int startIndex) &#123;
    if (sum &gt; target) return;
    if (sum == target) &#123;
        result.push_back(path);
        return;
    &#125;
    for (int i = startIndex; i &lt; candidates.size(); i++) &#123;
        path.push_back(candidates[i]);
        sum += candidates[i];
        backTracking(candidates, target, sum, i); // 元素可重复选取，下一层从 i 开始
        path.pop_back();
        sum -= candidates[i];
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
    backTracking(candidates, target, 0, 0);
    return result;
&#125;
</code></pre><h2 id="优化剪枝"><a class="anchor" href="#优化剪枝">#</a> 优化（剪枝）</h2><p>可以先对 <code>candidates</code> 进行排序（元素按升序排列）</p><p>在递归过程中，如果当前层的 <code>sum + candidates[i]</code> （即，下一层的 <code>sum</code> ）已经大于 <code>target</code> ，无需再针对当前 <code>candidates[i]</code> 进行下一层的递归，也无需再继续遍历当前层的 <code>candidates</code> 数组（即，无需再进行 <code>for</code> 循环的遍历）</p><p><img data-src="LeetCode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/optimized.png" alt="" height="200px"></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; candidates, int target, int sum, int startIndex) &#123;
    if (sum == target) &#123; // 注意这里无需处理 sum &gt; target 的情况
        result.push_back(path);
        return;
    &#125;
    for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; // 剪枝
        path.push_back(candidates[i]);
        sum += candidates[i];
        backTracking(candidates, target, sum, i);
        path.pop_back();
        sum -= candidates[i];
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
    sort(candidates.begin(), candidates.end()); // 排序，以便剪枝
    backTracking(candidates, target, 0, 0);
    return result;
&#125;
</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwMzkuJUU3JUJCJTg0JUU1JTkwJTg4JUU2JTgwJUJCJUU1JTkyJThDLmh0bWwjJUU1JTg5JUFBJUU2JTlFJTlEJUU0JUJDJTk4JUU1JThDJTk2">代码随想录</span></p><h1 id="leetcode-40-组合总和-ii"><a class="anchor" href="#leetcode-40-组合总和-ii">#</a> LeetCode 40. 组合总和 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWkv">40. Combination Sum II</span></p><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。</p><p><strong>示例 1：</strong></p><pre><code>输入：candidates = [10,1,2,7,6,1,5], target = 8
输出：
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：candidates = [2,5,2,1,2], target = 5
输出：
[
[1,2,2],
[5]
]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>candidates.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>candidates[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>target</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-3"><a class="anchor" href="#思路-3">#</a> 思路</h2><p>本题与 <a href="https://jiankychen.github.io/posts/c2253dcd">LeetCode 39. 组合总和</a> 有较大不同，本题的 <code>candidates</code> 数组包含重复元素，且每个元素只能在子集中出现一次（重复元素可以分别出现一次）</p><p>对此，递归下一层时需要从 <code>i + 1</code> 开始 <code>for</code> 循环的遍历，以使得每个元素最多只使用一次（重复的元素可以分别使用一次）</p><p>但是，如果仅仅是这样的话，结果将会产生重复的组合，以 示例 1 为例，结果为 <code>[[1,1,6],[1,2,5],[1,7],[1,2,5],[1,7],[2,6]]</code> ，可以发现 <code>[1,2,5],[1,7]</code> 这两个重复出现了，此时回溯搜索的第一层如下所示：</p><p><img data-src="LeetCode40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/example.png" alt=""></p><p>可以发现，在当前的递归层中，由于 <code>candidates</code> 数组含有重复元素， <code>for</code> 循环进行横向遍历时会取出重复元素（误当成不同的子树），产生重复的子集 <code>[1,2,5,6,7,10]</code> ，最终导致 <code>[1,2,5],[1,7]</code> 在答案中出现两次</p><p>---&gt; B1[2,5,6,7,10]<br>B [1,2,5,6,7,10] -- 取 2<br>---&gt; B2[1,5,6,7,10]<br>B [1,2,5,6,7,10] -- 取 5<br>---&gt; B3[1,2,6,7,10]<br>B [1,2,5,6,7,10] -- 取 6<br>---&gt; B4[1,2,5,7,10]<br>B [1,2,5,6,7,10] -- 取 7<br>---&gt; B5[1,2,5,6,10]<br>B [1,2,5,6,7,10] -- 取 10<br>---&gt; B6[1,2,5,6,7]<br>```</p><p>因此，还需要对同一层的 <code>for</code> 循环进行去重，避免在同一层递归中取出重复元素</p><h2 id="method-回溯-6"><a class="anchor" href="#method-回溯-6">#</a> Method: 回溯</h2><p>有以下两种方法可以用来去重</p><h2 id="排序"><a class="anchor" href="#排序">#</a> 排序</h2><p>可直接利用 <code>for</code> 循环的起点 <code>index</code> 来实现当前层的去重</p><ul><li>首先须对 <code>candidates</code> 进行排序，使得重复元素的出现是连续的</li><li>在 <code>for</code> 循环遍历 <code>i</code> 的过程中，如果发现 <code>i &gt; index</code> 且 <code>candidates[i] == candidates[i - 1]</code> ，则说明 <code>candidates[i]</code> 这个元素已经处理过了，不能再重复处理，因此，跳过当前 <code>i</code></li></ul><p>类似于 <a href="https://jiankychen.github.io/posts/c2253dcd">LeetCode 39. 组合总和</a> ，可对回溯搜索进行剪枝优化</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; candidates, int target, int sum, int index) &#123;
    if (sum == target) &#123;
        result.push_back(path);
        return;
    &#125;
    for (int i = index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; // 剪枝
        if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue; // 同一层的去重
        path.push_back(candidates[i]);
        sum += candidates[i];
        backTracking(candidates, target, sum, i + 1); // 不含重复元素，下一层从 i + 1 开始遍历
        path.pop_back();
        sum -= candidates[i];
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
    sort(candidates.begin(), candidates.end()); // 排序，以实现 去重 以及 剪枝
    backTracking(candidates, target, 0, 0);
    return result;
&#125;
</code></pre><p>注意：条件 <code>i &gt; index</code> 不能改成 <code>i &gt; 0</code> ，因为当前层的 <code>for</code> 循环是从 <code>index</code> 开始遍历的，只需判断在当前层是否处理过元素 <code>candidates[i]</code> ，而不需要判断上一层是否处理过元素 <code>candidates[i]</code></p><ul><li><code>if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue;</code> 跳过的是同一层的重复元素</li><li><code>if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1]) continue;</code> 不仅会跳过同一层递归里的重复元素，也会跳过不同层次递归的重复元素（即，上一层处理过元素 <code>candidates[index - 1]</code> ，下一层将不能够处理重复元素 <code>candidates[index]</code> ）。在此情况下，针对 示例 1 得到的结果为 <code>[[1,2,5],[1,7],[2,6]]</code> ，缺失了 <code>[1,1,6]</code> 这一组合</li></ul><p>---&gt; B[1,2,5,6,7,10]<br>B [1,2,5,6,7,10] -. 不会再取 1 .- B1 [2,5,6,7,10]<br>B [1,2,5,6,7,10] -- 取 2<br>---&gt; B2[1,5,6,7,10]<br>B [1,2,5,6,7,10] -- 取 5<br>---&gt; B3[1,2,6,7,10]<br>B [1,2,5,6,7,10] -- 取 6<br>---&gt; B4[1,2,5,7,10]<br>B [1,2,5,6,7,10] -- 取 7<br>---&gt; B5[1,2,5,6,10]<br>B [1,2,5,6,7,10] -- 取 10<br>---&gt; B6[1,2,5,6,7]<br>```</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNDAuJUU3JUJCJTg0JUU1JTkwJTg4JUU2JTgwJUJCJUU1JTkyJThDSUkuaHRtbA==">代码随想录：组合总和 II</span></p><h2 id="哈希-排序"><a class="anchor" href="#哈希-排序">#</a> 哈希 + 排序</h2><p>在每一层定义一个哈希表，用来记录 <code>for</code> 循环处理过的元素</p><blockquote><p>这里使用排序是为了剪枝，并不是为了去重</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; candidates, int target, int sum, int index) &#123;
    if (sum == target) &#123;
        result.push_back(path);
        return;
    &#125;
    unordered_set&lt;int&gt; uset; // 用于记录当前层的 for 循环遍历情况
    for (int i = index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; // sum + candidates[i] &lt;= target 用以剪枝
        if (uset.find(candidates[i]) != uset.end()) continue; // 同一层的去重
        uset.insert(candidates[i]);
        path.push_back(candidates[i]);
        sum += candidates[i];
        backTracking(candidates, target, sum, i + 1);
        path.pop_back();
        sum -= candidates[i];
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
    sort(candidates.begin(), candidates.end()); // 排序，便于剪枝
    backTracking(candidates, target, 0, 0);
    return result;
&#125;
</code></pre><p>使用哈希 <code>unordered_set</code> 去重的效率较低（时间复杂度和空间复杂度都比较高）</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5QiU5RSVFNiVCQSVBRiVFNyVBRSU5NyVFNiVCMyU5NSVFNSU4RSVCQiVFOSU4NyU4RCVFOSU5NyVBRSVFOSVBMiU5OCVFNyU5QSU4NCVFNSU4RiVBNiVFNCVCOCU4MCVFNyVBNyU4RCVFNSU4NiU5OSVFNiVCMyU5NS5odG1sI180MC0lRTclQkIlODQlRTUlOTAlODglRTYlODAlQkIlRTUlOTIlOEMtaWk=">代码随想录</span></p><h1 id="leetcode-216-组合总和-iii"><a class="anchor" href="#leetcode-216-组合总和-iii">#</a> LeetCode 216. 组合总和 III</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWlpLw==">LeetCode 216. Combination Sum III</span></p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：k = 3, n = 7
输出：[[1,2,4]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：k = 3, n = 9
输出：[[1,2,6],[1,3,5],[2,3,4]]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：k = 4, n = 1
输出：[]
解释：不存在有效的组合
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>k</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">\le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>60</mn></mrow><annotation encoding="application/x-tex">\le 60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-4"><a class="anchor" href="#思路-4">#</a> 思路</h2><p>类似于 <a href="https://jiankychen.github.io/posts/d1540be5">LeetCode 77. 组合</a> ，旨在查找满足条件的子集，只不过本题多出了一个条件，即， <code>k</code> 个数的和须为 <code>n</code></p><p>因此，需记录递归的路径和，并将递归的终止条件修改为：元素个数等于 <code>k</code> 且 路径和等于 <code>n</code></p><p><img data-src="LeetCode216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/example.png" alt="" height="200px"></p><h2 id="method-回溯-7"><a class="anchor" href="#method-回溯-7">#</a> Method: 回溯</h2><p>算法思路：</p><ol><li><p>定义三个全局变量</p><ul><li><code>vector&lt;vector&lt;int&gt;&gt; result</code> ：所有可行路径</li><li><code>vector&lt;int&gt; path</code> ：当前路径</li><li><code>int sum</code> ：当前路径和</li></ul></li><li><p>确定回溯函数的参数</p><ul><li><code>int k</code> ：目标子集的大小</li><li><code>int n</code> ：目标和</li><li><code>int startIndex</code> ：递归函数体中的 <code>for</code> 循环遍历起始位置</li></ul></li><li><p>回溯的终止条件：已经选取 <code>k</code> 个元素，即， <code>path.size() == k</code></p></li><li><p>单层搜索过程</p><ul><li>若已经选取 <code>k</code> 个元素，进一步判断当前路径和 <code>sum</code> 是否等于目标和 <code>n</code><ul><li>若是，记录当前路径，结束当前递归</li><li>若否，直接结束当前递归</li></ul></li><li>若未选取 <code>k</code> 个元素，利用 <code>for</code> 循环遍历 <code>startIndex</code> 至 <code>9</code> 之间的数，针对其中每个数，执行以下操作：<ul><li>更新当前路径以及路径和：将 <code>i</code> 加入到路径 <code>path</code> 中，并计算 <code>sum = sum + i</code></li><li>继续查找下一个数：递归到下一个数，即， <code>backtracking(k, n, i + 1)</code></li><li>回溯：回退路径 <code>path.pop_back</code> ，回退路径和 <code>sum = sum - i</code></li></ul></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result; // 所有可行路径
vector&lt;int&gt; path; // 当前路径
int sum = 0; // 当前路径的和

void backtracking(int k, int n, int startIndex) &#123;
    if (path.size() == k) &#123;
        if (sum == n) result.push_back(path); // 满足条件，将路径添加到目标数组
        return; // path.size() == k 但sum != n 时，直接返回
    &#125;
    for (int i = startIndex; i &lt;= 9; i++) &#123; // 横向遍历
        path.push_back(i); // 更新路径
        sum += i;          // 更新路径和
        backtracking(k, n, i + 1); // 递归到下一层，查找下一个数
        path.pop_back();   // 回溯
        sum -= i;          // 回溯
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;
    backtracking(k, n, 1);
    return result;
&#125;
</code></pre><h2 id="优化剪枝-2"><a class="anchor" href="#优化剪枝-2">#</a> 优化（剪枝）</h2><p>针对上述算法，可进行以下两个方面的剪枝：</p><ul><li><p>若当前路径和大于 <code>n</code> ，不需要再向下查找（继续查找也无法找到可行解），直接结束当前递归</p></li><li><p>若 可供选择的剩余元素个数（ <code>9 - i + 1</code> ）小于 仍需选择的元素个数（ <code>k - path.size()</code> ），也不需要再继续向下查找</p></li></ul><p>代码实现</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
int sum = 0;

void backtracking(int k, int n, int startIndex) &#123;
    if (sum &gt; n) return; // 剪枝
    if (path.size() == k) &#123;
        if (sum == n) result.push_back(path);
        return;
    &#125;
    for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) &#123; // 剪枝
        path.push_back(i);
        sum += i;
        backtracking(k, n, i + 1);
        path.pop_back();
        sum -= i;
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;
    backtracking(k, n, 1);
    return result;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mi>C</mi><mn>9</mn><mi>k</mi></msubsup><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(C_9^k \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-2.4518920000000004em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.24810799999999997em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mi>C</mi><mn>9</mn><mi>k</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(C_9^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-2.4518920000000004em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.24810799999999997em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 种组合（从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span> 个数中选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 个数），每种组合进行递归判断的时间代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，其中， <code>path</code> 数组所需空间、递归使用的栈空间均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMTYuJUU3JUJCJTg0JUU1JTkwJTg4JUU2JTgwJUJCJUU1JTkyJThDSUlJLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p><h1 id="leetcode-46-全排列"><a class="anchor" href="#leetcode-46-全排列">#</a> LeetCode 46. 全排列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMv">46. Permutations</span></p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 所有可能的全排列 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1]
输出：[[0,1],[1,0]]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]
输出：[[1]]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">\le 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><code>nums</code> 中的所有整数 互不相同</li></ul><h2 id="思路-5"><a class="anchor" href="#思路-5">#</a> 思路</h2><p>本题要求的是数组的全排列，需要区分元素在集合中的先后顺序，即， <code>[1, 2]</code> 与 <code>[2, 1]</code> 是不同的排列</p><p>若将该问题抽象成树结构，则需记录所有叶节点</p><ul><li>因为数组中所有元素都需要处理一次，对应树结构上的叶节点</li><li>需要获取所有可能的排列方式，故而需要遍历所有叶节点</li></ul><p>此前的组合问题、分割问题、子集问题不考虑集合中元素的顺序，即，不管按照什么顺序来选取元素，只要元素组成的集合相同，得到的结果就是相同的</p><ul><li>我们之前采用的选取顺序是：从递归的上层到下层，元素是按照索引逐渐增大的顺序选取的（例如，当前层选择第 <code>i</code> 位元素，下一层只能选择第 <code>i</code> 位以后的元素）</li><li>此时，对于每一层递归而言，“上层已经访问过的元素” 与 “ 尚未访问过的元素 ” 之间具有明确的分界线，故而可以使用 <code>startIndex</code> 来标记 <code>for</code> 循环遍历的起点</li><li>具体可见 <a href="https://jiankychen.github.io/posts/d1540be5">LeetCode 77. 组合</a></li></ul><p>但是在排列问题中，从递归的上层到下层，元素并不全都按照索引递增顺序选取（这是因为，选择元素的先后顺序不同，会得到不同的排列），此时，“上层已经访问过的元素” 与 “ 尚未访问过的元素 ” 之间不存在分界线，因此不能再使用 <code>startIndex</code> 了</p><p>对此，可以引入 <code>used</code> 数组（或者是哈希表）来标记上层已经选取的元素，需注意，递归函数中的 <code>for</code> 循环要从 <code>0</code> 开始</p><h2 id="method-回溯-哈希"><a class="anchor" href="#method-回溯-哈希">#</a> Method: 回溯 + 哈希</h2><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;used) &#123;
    if (path.size() == nums.size()) &#123; // 得到一个全排列，将其添加到结果集
        result.push_back(path);
        return;
    &#125;
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        if (used[nums[i] + 10] == 1) continue; // nums[i] 在之前层次已经使用过
        used[nums[i] + 10] = 1;   // 当前层次使用了 nums[i] ，更新标记
        path.push_back(nums[i]);  // 将 nums[i] 添加到 path
        backTracking(nums, used); // 递归到下一层
        used[nums[i] + 10] = 0;   // 回溯：撤销对 nums[i] 的标记
        path.pop_back();          // 回溯：撤销对 path 的更改
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
    vector&lt;int&gt; used(21, 0);  // nums[i] 的取值范围为 [-10, 10]
    backTracking(nums, used);
    return result;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 <code>nums</code> 的长度</p><ul><li>一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span> 种全排列</li><li>每一种排列方案填入 <code>result</code> 数组都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间，递归的深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>这里用 <code>used[nums[i] + 10]</code> 来表示 <code>nums[i]</code> 是否被使用过，其实也可以直接用 <code>used[i]</code> 的值来表示 <code>nums</code> 数组的第 <code>i</code> 位是否被使用过</p><h1 id="leetcode-47-排列ii"><a class="anchor" href="#leetcode-47-排列ii">#</a> LeetCode 47. 排列 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMtaWkv">47. Permutations II</span></p><p>给定一个可<strong>包含重复数字</strong>的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有 <strong>不重复</strong> 的全排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,2]
输出：
[[1,1,2],
[1,2,1],
[2,1,1]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">\le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-6"><a class="anchor" href="#思路-6">#</a> 思路</h2><p>本题在 <a href="https://jiankychen.github.io/posts/1ba17777">46. 全排列</a> 的基础上，为 <code>nums</code> 数组引入了重复元素，要求返回所有不重复的全排列</p><p>因此，需要在每一层递归中，对 <code>for</code> 循环所遍历的元素进行去重</p><h2 id="method-回溯-排序"><a class="anchor" href="#method-回溯-排序">#</a> Method: 回溯 + 排序</h2><h2 id="算法思想"><a class="anchor" href="#算法思想">#</a> 算法思想</h2><ol><li><p>先对 <code>nums</code> 数组进行排序，使得重复元素在 <code>nums</code> 数组中连续</p></li><li><p>在递归函数中的去重操作：</p><ul><li>若 <code>nums[i]</code> 在上层递归中被选取过，本层不再选取 <code>nums[i]</code></li><li>若 <code>nums[i] == nums[i - 1]</code> （ <code>i &gt; 0</code> ），并且 <code>nums[i - 1]</code> 在上层递归中未被选取，则本层递归会选取 <code>nums[i - 1]</code> ，故而本层不再选取 <code>nums[i]</code></li></ul></li></ol><p>若使用 <code>used[i]</code> 值为 <code>1</code> 来表示 <code>nums[i]</code> 已经被上层递归选取，则元素去重的代码如下</p><pre><code class="language-cpp">for (int i = 0; i &lt; num.size(); i++) &#123;
    if (used[i] == 1) continue; // 情况一
    if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0) continue; // 情况二
    // 选取 nums[i] 的相关操作
&#125;
</code></pre><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; nums, vector&lt;int&gt; used) &#123;
    if (path.size() == nums.size()) &#123;
        result.push_back(path);
        return;
    &#125;
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        if (used[i] == 1) continue; // 上层递归已经选取过 nums[i]
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0)
            continue; // 上一层未选取 nums[i - 1] ，但是当前层会选取 nums[i - 1] ，故而无需选取 nums[i]
        path.push_back(nums[i]);    // 更新 path 数组
        used[i] = 1;                // 更新 used 数组
        backTracking(nums, used);   // 递归到下一层
        used[i] = 0;                // 回溯：撤销对 used 数组的更改
        path.pop_back();            // 回溯：撤销对 path 数组的更改
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt; &amp;nums) &#123;
    sort(nums.begin(), nums.end());  // 排序，以便去重
    vector&lt;int&gt; used(nums.size(), 0);
    backTracking(nums, used);
    return result;
&#125;
</code></pre><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNDcuJUU1JTg1JUE4JUU2JThFJTkyJUU1JTg4JTk3SUkuaHRtbCMlRTYlOEIlOTMlRTUlQjElOTU=">代码随想录：全排列 II</span> 上提到， <code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 1) continue</code> 也可以实现同一层递归中不选取重复元素，只不过效率相对较低</p></blockquote><p>事实上，这里用到的 <code>used</code> 数组也是哈希法的一种实现</p><h1 id="回溯-哈希"><a class="anchor" href="#回溯-哈希">#</a> 回溯 + 哈希</h1><h2 id="算法思想-2"><a class="anchor" href="#算法思想-2">#</a> 算法思想</h2><p>在每一层定义一个哈希表，用来记录 <code>for</code> 循环处理过的元素</p><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; nums, vector&lt;int&gt; used) &#123;
    if (path.size() == nums.size()) &#123;
        result.push_back(path);
        return;
    &#125;
    unordered_set&lt;int&gt; uset;        // 用于记录当前层 for 循环遍历情况
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        if (used[i] == 1) continue; // 上层递归已经选取过 nums[i]
        if (uset.find(nums[i]) != uset.end()) continue; // 本层递归已经处理过 nums[i] 的重复元素
        uset.insert(nums[i]);       // 记录元素
        path.push_back(nums[i]);
        used[i] = 1;
        backTracking(nums, used);
        used[i] = 0;
        path.pop_back();
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt; &amp;nums) &#123;
    vector&lt;int&gt; used(nums.size(), 0);
    backTracking(nums, used);
    return result;
&#125;
</code></pre><p>这里同时使用了 <code>used</code> 数组和哈希表 <code>unordered_set</code> ，前者用于实现不同层次递归间的去重，后者用于单次递归中 <code>for</code> 循环的去重</p><p>注：使用哈希 <code>unordered_set</code> 去重的效率较低（时间复杂度和空间复杂度都比较高）</p><h1 id="leetcode-491-递增子序列"><a class="anchor" href="#leetcode-491-递增子序列">#</a> LeetCode 491. 递增子序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ub24tZGVjcmVhc2luZy1zdWJzZXF1ZW5jZXMv">491. Increasing Subsequences</span></p><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [4,4,3,2,1]
输出：[[4,4]]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">\le 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-7"><a class="anchor" href="#思路-7">#</a> 思路</h2><p>本题属于子集问题，需要记录所有可行的子集。即，如果将该问题抽象成一棵树，则需要记录树上所有满足条件的节点</p><p>类似于 <a href="https://jiankychen.github.io/posts/a06c07a7">LeetCode 90. 子集 II</a> ，本题的 <code>nums</code> 数组也同样含有重复元素，因此，不能在同一层递归中取出重复元素（但可以分别在不同层次的递归中取出重复元素），即，需要对 <code>for</code> 循环的横向遍历进行去重</p><p>然而，不同于 <a href="https://jiankychen.github.io/posts/a06c07a7">LeetCode 90. 子集 II</a> ，本题需要的是子序列，元素之间的相对位置关系不能更改，因此不能对数组 <code>nums</code> 进行排序。故而不能再采用 <a href="https://jiankychen.github.io/posts/a06c07a7">LeetCode 90. 子集 II</a> 中的去重方式</p><p>对此，可以采用哈希法来去重</p><ul><li>由于需要对每一层递归的 <code>for</code> 循环遍历进行去重，每一层都需要定义一个数组来实现哈希表（本题的 <code>nums[i]</code> 取值范围较小，可直接用数组实现哈希法）</li><li>特别地，每一层递归中的哈希数组仅作用于当前层，不影响其他层，故而下一层可以使用上一层已经选择过的、数组 <code>nums</code> 中的重复元素</li></ul><p>此外，题目要求每个子序列都是递增的，因此，在把元素放入子集前，还需要比较该元素与子集中的最后一个元素进行比较</p><h2 id="method-回溯-哈希-2"><a class="anchor" href="#method-回溯-哈希-2">#</a> Method: 回溯 + 哈希</h2><p>算法思路：</p><ol><li><p>在使用数组 <code>used</code> 实现哈希表时，由于 <code>nums[i]</code> 的取值范围为 <code>[-100, 100]</code> ，我们可以将 <code>nums[i]</code> 映射到 <code>used</code> 数组中索引为 <code>nums[i] + 100</code> 的位置。即</p><ul><li>若 <code>used[nums[i] + 100] == 1</code> ，本层递归已经选过 <code>nums[i]</code> 这个数，不再重复选择</li><li>若 <code>used[nums[i] + 100] == 0</code> ，本层递归没有选过 <code>nums[i]</code> 这个数，可以考虑选择 <code>nums[i]</code> （因为还需要判断其是否能够构成新的递增序列）</li></ul></li><li><p>本题要求递增子序列长度至少为 2 ，因此，在将序列加入到结果集前需要检验序列的长度</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; nums, int index) &#123;
    if (path.size() &gt; 1) &#123;       // 需要记录所有的递增子序列（子序列中至少要有两个元素）
        result.push_back(path);
        // 注意，这里不能加 return ，因为要遍历树上所有节点
    &#125;
    vector&lt;int&gt; used(201, 0);    // 用于标记 nums[i] 这个数是否已经操作过
    for (int i = index; i &lt; nums.size(); i++) &#123;
        if (!path.empty() &amp;&amp; nums[i] &lt; path.back() || used[nums[i] + 100] == 1)
            continue;            // 非递增，或者，当前递归层已经操作过 nums[i] 这个数
        path.push_back(nums[i]);
        used[nums[i] + 100] = 1; // nums[i] 被选择，更新标记
        backTracking(nums, i + 1);
        path.pop_back();
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt; &amp;nums) &#123;
    backTracking(nums, 0);
    return result;
&#125;
</code></pre><p>注意，在定义 <code>used</code> 数组时，需要初始化：大小为 <code>201</code> ，每个元素值为 <code>0</code></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0OTEuJUU5JTgwJTkyJUU1JUEyJTlFJUU1JUFEJTkwJUU1JUJBJThGJUU1JTg4JTk3Lmh0bWw=">代码随想录：递增子序列</span></p><h1 id="leetcode-77-组合"><a class="anchor" href="#leetcode-77-组合">#</a> LeetCode 77. 组合</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMv">77. Combinations</span></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1, k = 1
输出：[[1]]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>k</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span></li></ul><h2 id="思路-8"><a class="anchor" href="#思路-8">#</a> 思路</h2><p>针对示例 <code>n = 4, k = 2</code> ，可通过以下代码来实现暴力搜索</p><pre><code class="language-cpp">int n = 4;
for (int i = 1; i &lt;= n; i++) &#123;
    for (int j = i + 1; j &lt;= n; j++) &#123;
        cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;
    &#125;
&#125;
</code></pre><p>但如果要解决 n 为 100 ，k 为 50 的情况，暴力搜索的写法需要嵌套 50 层 <code>for</code> 循环</p><p>此时，可以用递归来解决嵌套层数的问题，即，每一次的递归中嵌套一个 <code>for</code> 循环</p><p>这里可以把问题抽象为如下树形结构，回溯法的搜索过程就是这样一个树型结构的遍历过程， <code>for</code> 循环用来横向遍历，递归用来纵向遍历。其中，每搜索到一个叶节点，就是找到一个可行结果</p><p><img data-src="LeetCode77-%E7%BB%84%E5%90%88/1.png" alt="" height="200px"></p><p>可以发现， <code>n</code> 相当于树的宽度， <code>k</code> 相当于树的高度</p><h2 id="method-回溯-8"><a class="anchor" href="#method-回溯-8">#</a> Method: 回溯</h2><p>算法思路：</p><ol><li><p>确定回溯函数的参数与返回值</p><ul><li>参数：元素的取值范围 <code>n</code> ，选取元素的个数 <code>k</code> ，当前递归选择元素的起点 <code>startIndex</code><ul><li>每次从集合中选取元素，可选择的范围都会收缩， <code>startIndex</code> 就是用来记录选取元素的起始位置</li></ul></li><li>回溯算法一般不需要返回值，返回类型为 <code>void</code></li></ul></li><li><p>回溯函数的终止条件： <code>path</code> 数组大小等于 <code>k</code> ，说明已经找到 <code>k</code> 个数的组合，记录当前结果即可返回</p></li><li><p>回溯函数的单层搜索过程</p><ul><li><code>for</code> 循环每次从 <code>startIndex</code> 开始遍历<ul><li>记遍历的元素为 <code>i</code></li><li>处理节点：将 <code>i</code> 放入 <code>path</code> 数组中（记录递归的路径）</li><li>递归到树的下一层：为子集选择下一个元素（注意，下一层搜索要从 <code>i + 1</code> 开始）</li><li>回溯：因为需要遍历这一层的其他子树，故而将 <code>i</code> 从 <code>path</code> 从取出</li></ul></li></ul></li></ol><blockquote><p>这里定义了 <code>vector&lt;vector&lt;int&gt;&gt; result</code> 和 <code>vector&lt;int&gt; path</code> 两个全局变量，分别存放所有可行的搜索结果、当前的搜索结果（递归的路径）。事实上，可以把这两个变量定义到递归函数的参数里，这里定义为全局变量有两方面的考虑：1) 函数参数过多时会影响可读性；2) 定义成全局变量可显式地表现出回溯的过程</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result; // 存放所有符合条件的搜索结果
vector&lt;int&gt; path;           // 当前的搜索结果

void DFS(int n, int k, int startIndex) &#123;
    if (path.size() == k) &#123; // 子集的大小为 k ，符合条件
        result.push_back(path); // 将当前搜索结果存入 result 数组
        return;
    &#125;
    for (int i = startIndex; i &lt;= n; i++) &#123; // for 循环：控制树的横向遍历
        path.push_back(i); // 处理节点 
        DFS(n, k, i + 1);  // 递归：控制树的纵向遍历，注意下一层搜索要从 i + 1 开始
        path.pop_back();   // 回溯，撤销处理的节点
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
    DFS(n, k, 1);
    return result;
&#125;
</code></pre><h2 id="优化剪枝-3"><a class="anchor" href="#优化剪枝-3">#</a> 优化（剪枝）</h2><p>事实上，当 可选择的剩余元素个数 小于 仍需选择的元素个数 时，不再存在可行方案，不需要再进行后续的搜索</p><p>换而言之，只有 可选择的剩余元素个数 大于等于 仍需选择的元素个数 时，才需进行搜索</p><p>因此，可对回溯搜索进行剪枝操作：</p><ul><li>当前已选择的元素个数为 <code>path.size()</code> ，后续仍需选择 <code>k - path.size()</code> 个元素</li><li>在 <code>i</code> 被选择之前，区间 <code>[i, n]</code> 一共有 <code>n - i + 1</code> 个元素可供选择</li><li>因此， <code>for</code> 循环的循环控制条件应为 <code>n - i + 1 &gt;= k - path.size()</code> ，即： <code>i &lt;= n - (k - path.size()) + 1</code></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void DFS(int n, int k, int startIndex) &#123;
    if (path.size() == k) &#123;
        result.push_back(path);
        return;
    &#125;
    for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123; // 已剪枝
        path.push_back(i); // 处理节点
        DFS(n, k, i + 1);  // 递归：控制树的纵向遍历，注意下一层搜索要从 i + 1 开始
        path.pop_back();   // 回溯，撤销处理的节点
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
    DFS(n, k, 1);
    return result;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(C_n^k \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-2.4530000000000003em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.247em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-.247em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-2.4530000000000003em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.247em"><span></span></span></span></span></span></span></span></span></span> 种组合方案（从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个数中选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 个数），其中每一种组合方案填入 <code>result</code> 数组都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span> 的时间</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，考虑了递归需要的栈空间以及临时数组 <code>path</code> 所需空间（未考虑存储答案的数组 <code>result</code> ）</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNzcuJUU3JUJCJTg0JUU1JTkwJTg4Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMvc29sdXRpb24venUtaGUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解</span></li></ul><h1 id="leetcode-78-子集"><a class="anchor" href="#leetcode-78-子集">#</a> LeetCode 78. 子集</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLw==">LeetCode 78. Subsets</span></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]
输出：[[],[0]]
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h2 id="思路-9"><a class="anchor" href="#思路-9">#</a> 思路</h2><p>组合问题、分割问题、子集问题都可以抽象为一棵树，其中，<strong>组合问题和分割问题是在收集树的叶节点，子集问题是收集树的所有节点</strong></p><p>因此，可以用回溯搜索法（枚举法）遍历整棵树，并记录所有的节点（每个节点都是一个子集）</p><p><img data-src="LeetCode78-%E5%AD%90%E9%9B%86/example.png" alt="" height="200px"></p><p>注意，子集中的元素是无序的，即，子集 {1, 2} 和 子集 {2, 1} 是一样的，因此，每一层递归的 <code>for</code> 循环起始位置不能重复</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNzguJUU1JUFEJTkwJUU5JTlCJTg2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：子集</span></p><h2 id="method-回溯-9"><a class="anchor" href="#method-回溯-9">#</a> Method: 回溯</h2><p>算法思路：</p><ol><li><p>递归函数的参数</p><ul><li><code>vector&lt;int&gt; nums</code> ：原始数组</li><li><code>vector&lt;vector&lt;int&gt;&gt; &amp;result</code> ：存放所有的子集</li><li><code>vector&lt;int&gt; path</code> ：当前的子集</li><li><code>int index</code> ： <code>for</code> 循环遍历起点</li></ul></li><li><p>递归终止条件：剩余集合为空（即，到达叶节点， <code>index == nums.size()</code> ），递归结束</p></li><li><p>单层搜索的逻辑： <code>for</code> 循环遍历 <code>nums</code> 数组元素 <code>nums[i]</code> （从索引 <code>index</code> 开始遍历）：</p><ul><li>更新子集：将元素 <code>nums[i]</code> 添加到子集 <code>path</code> 中</li><li>存储结果：将子集 <code>path</code> 添加到结果数组 <code>result</code> 中</li><li>递归到下一层：继续扩充 <code>path</code> 这一子集（下一层递归的 <code>for</code> 循环从 <code>i + 1</code> 开始遍历）</li><li>回溯：撤销本次 <code>for</code> 循环对 <code>path</code> 的更改</li></ul></li></ol><p>特别地，由于空集也是数组 <code>nums</code> 的一个子集，需要将空集 <code>[]</code> 也添加到 <code>result</code> 当中</p><blockquote><p>建议将 <code>vector&lt;int&gt; nums</code> 和 <code>vector&lt;int&gt; path</code> 改为引用传递，即，采用 <code>vector&lt;int&gt; &amp;nums</code> 和 <code>vector&lt;int&gt; &amp;path</code> 形式作为递归函数的参数</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">void backTracking(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt; path, int index) &#123;
    if (index == nums.size()) return; // 递归终止条件，这里可以不加这个条件
    for (int i = index; i &lt; nums.size(); i++) &#123;
        path.push_back(nums[i]); // 更新当前子集
        result.push_back(path);  // 将当前子集添加到 result 数组
        backTracking(nums, result, path, i + 1); // 递归到下一层
        path.pop_back();         // 回溯
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    result.push_back(path); // 子集为空集的情况
    backTracking(nums, result, path, 0);
    return result;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 <code>nums</code> 的长度</p><ul><li>一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 个子集</li><li>构造每个子集的时间代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间，递归的最大深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>本题可以将 <code>result.push_back(path);</code> 放到递归函数体的第一行，即，每次递归时都会将子集 <code>path</code> 添加到目标数组 <code>result</code> 中。此时，不需要再单独将空集 <code>[]</code> 添加到目标数组</p></blockquote><h1 id="leetcode-79-单词搜索"><a class="anchor" href="#leetcode-79-单词搜索">#</a> LeetCode 79. 单词搜索</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC8=">79. Word Search</span></p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/Example1.jpg" alt="" height="150px"></p><pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;
输出：true
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/Example2.jpg" alt="" height="150px"></p><pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;
输出：true
</code></pre><p><strong>示例 3：</strong></p><p><img data-src="LeetCode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/Example3.jpg" alt="" height="150px"></p><pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;
输出：false
</code></pre><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><p><strong>进阶</strong>：你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p><h2 id="method-回溯-10"><a class="anchor" href="#method-回溯-10">#</a> Method: 回溯</h2><p>算法思路：</p><p>遍历 grid 中的每一个位置 (i, j)，判断从该位置出发能否搜索到 word 。特别地，只要找到一个可行的出发点，就说明网格中能够找到 word ，即可返回 true ，否则，说明不能找到，返回 false</p><p>为检查从某位置出发能否搜索到 word ，可以定义一个回溯函数：</p><ul><li><p>从 grid 的 (starti, startj) 位置出发，判断能否搜索到字符串 word 的子串 word [startk, word.size () - 1] ，若能够搜索到，则返回 true ，否则，返回 false</p></li><li><p>其中，每个位置可能向上、下、左、右四个方向移动，因此，在回溯函数体内，需要遍历这四个方向</p></li><li><p>并且，由于同一个单元格内的字母只允许使用一次，在回溯时需要维护一个 visited 数组，用于标记每个位置是否已经被访问过</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; // 四个方向

bool backTrcking(vector&lt;vector&lt;char&gt;&gt;&amp; board, int starti, int startj, string word, int startk, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) &#123;
    if (board[starti][startj] != word[startk]) return false; // 不匹配，返回 false
    if (startk == word.size() - 1) return true; // startk 已经是 word 的最后一个字符，返回 true
    visited[starti][startj] = true; // 标记 (starti, startj) 位置已访问
    for (auto &amp;dir : directions) &#123;  // 遍历 上 下 左 右 四个方向
        int newi = starti + dir[0]; // 下一个访问位置为 (newi, newj)
        int newj = startj + dir[1];
        if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size()) &#123; // 位置 (newi, newj) 未越界
            if (visited[newi][newj] == false) &#123; // 未被访问过
                bool flag = backTrcking(board, newi, newj, word, startk + 1, visited); // 递归到下一层
                if (flag) return true; // 从 (newi, newj) 位置出发，能够找到 word[startk + 1] 及其后续字符
            &#125;
        &#125;
    &#125;
    visited[starti][startj] = false;  // 未找到 word ，回溯，撤销对 (starti, startj) 位置的标记
    return false; // 返回 false
&#125;

bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
    vector&lt;vector&lt;bool&gt;&gt; visited(board.size(), vector&lt;bool&gt;(board[0].size(), false));
    for (int i = 0; i &lt; board.size(); i++) &#123;
        for (int j = 0; j &lt; board[0].size(); j++) &#123; // 遍历每一个起点 (i, j)，判断能否从该位置出发找到 word
            bool tag = backTrcking(board, i, j, word, 0, visited); // 回溯搜索
            if (tag) return true;
        &#125;
    &#125;
    return false;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo>×</mo><msup><mn>3</mn><mi>L</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N \times 3^L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-.25em"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 分别为网格 grid 的行数和列数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span> 是字符串 word 的长度</p><ul><li>在 <code>exist</code> 函数内，需要遍历每一个出发位置，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span></li><li>对于每一个出发位置 (i, j)，需要调用 <code>backTrackinig</code> 回溯函数进行搜索，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>3</mn><mi>L</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3^L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。这是因为，最多只有第一层递归中的 for 循环有 4 个方向可以搜索，其余每一层递归中的 for 循环最多只能向 3 个方向搜索（即，只能往新位置走，不能往回走）</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span></p><ul><li>visited 数组所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span></li><li>对于每一个出发位置 (i, j) ，递归所需的栈空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>M</mi><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(L, MN))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC9zb2x1dGlvbi9kYW4tY2ktc291LXN1by1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p><h1 id="leetcode-90-子集-ii"><a class="anchor" href="#leetcode-90-子集-ii">#</a> LeetCode 90. 子集 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLWlpLw==">90. Subsets II</span></p><p>给你一个整数数组 <code>nums</code> ，其中<strong>可能包含重复元素</strong>，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]
输出：[[],[0]]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-10"><a class="anchor" href="#思路-10">#</a> 思路</h2><p>与 <a href="https://jiankychen.github.io/posts/7ea8ca7d">LeetCode 78. 子集</a> 相比，本题的 <code>nums</code> 数组含有重复元素，因此，不能在同一层递归中取出重复元素（但可以分别在不同层次的递归中取出重复元素），即，需要对 <code>for</code> 循环的横向遍历进行去重</p><p>去重的思路可参考 <a href="https://jiankychen.github.io/posts/e3119804">LeetCode 40. 组合总和 II</a></p><h2 id="method-回溯-11"><a class="anchor" href="#method-回溯-11">#</a> Method: 回溯</h2><p>针对不同的去重方法，有以下两种实现</p><h2 id="排序-2"><a class="anchor" href="#排序-2">#</a> 排序</h2><p>采用 <a href="https://jiankychen.github.io/posts/e3119804">LeetCode 40. 组合总和 II</a> 中的去重方式</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt; &amp;nums, int index) &#123;
    result.push_back(path);
    for (int i = index; i &lt; nums.size(); i++) &#123;
        if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) continue; // 去重，避免在同一层递归中取出重复元素
        path.push_back(nums[i]);
        backTracking(nums, i + 1);
        path.pop_back();
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;
    sort(nums.begin(), nums.end()); // 排序，以便去重
    backTracking(nums, 0);
    return result;
&#125;
</code></pre><p>这里将 <code>vector&lt;vector&lt;int&gt;&gt; result;</code> 和 <code>vector&lt;int&gt; path;</code> 作为全局变量，实际上也可按照 <a href="https://jiankychen.github.io/posts/7ea8ca7d">LeetCode 78. 子集</a> 中的写法，将其作为递归函数的参数（建议采用引用传递的方式传入参数）</p><h2 id="哈希"><a class="anchor" href="#哈希">#</a> 哈希</h2><p>思想：在每一层定义一个哈希表，用来记录 <code>for</code> 循环处理过的元素</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;

void backTracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;
    result.push_back(path);
    unordered_set&lt;int&gt; uset; // 用于记录当前层的 for 循环遍历情况
    for (int i = startIndex; i &lt; nums.size(); i++) &#123;
        if (uset.find(nums[i]) != uset.end()) &#123; // 当前层已经处理过 nums[i]
            continue;
        &#125;
        uset.insert(nums[i]);
        path.push_back(nums[i]);
        backTracking(nums, i + 1);
        path.pop_back();
    &#125;
&#125;

vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;
    sort(nums.begin(), nums.end());
    backTracking(nums, 0);
    return result;
&#125;
</code></pre><p>注：使用哈希 <code>unordered_set</code> 去重的效率较低（时间复杂度和空间复杂度都比较高）</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNSU5QiU5RSVFNiVCQSVBRiVFNyVBRSU5NyVFNiVCMyU5NSVFNSU4RSVCQiVFOSU4NyU4RCVFOSU5NyVBRSVFOSVBMiU5OCVFNyU5QSU4NCVFNSU4RiVBNiVFNCVCOCU4MCVFNyVBNyU4RCVFNSU4NiU5OSVFNiVCMyU5NS5odG1sI185MC0lRTUlQUQlOTAlRTklOUIlODZpaQ==">代码随想录</span></p><h1 id="leetcode-93-复原-ip-地址"><a class="anchor" href="#leetcode-93-复原-ip-地址">#</a> LeetCode 93. 复原 IP 地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXN0b3JlLWlwLWFkZHJlc3Nlcy8=">93. Restore IP Addresses</span></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code> ），整数之间用 <code>'.'</code> 分隔。</p><ul><li>例如： <code>&quot;0.1.2.201&quot;</code> 和 <code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code> 、 <code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;25525511135&quot;
输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;0000&quot;
输出：[&quot;0.0.0.0&quot;]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;101023&quot;
输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><code>s</code> consists of digits only.</li></ul><h2 id="思路-11"><a class="anchor" href="#思路-11">#</a> 思路</h2><p>本题是一个分割问题（将字符串 <code>s</code> 分割成四个子串），需要列举出所有可行的分割方案</p><p>其中，以下情况无法形成有效的 IP 地址</p><ul><li>子串以 '0' 开头，且子串长度大于 1 （即，对应的整数有先导 0）</li><li>子串有非数字字符（本题的 <code>s</code> 只含有数字字符，无需考虑这一情况）</li><li>子串对应的整数大于 255</li></ul><p>解题思路类似于 <a href="https://jiankychen.github.io/posts/eeb65480">LeetCode 131. 分割回文串</a></p><h2 id="method-回溯-12"><a class="anchor" href="#method-回溯-12">#</a> Method: 回溯</h2><p>算法思路：</p><ol><li><p>递归函数的参数</p><ul><li><code>vector&lt;string&gt; &amp;result</code> ：存放所有可行的分割方案（即，所有有效的 IP 地址）</li><li><code>string path</code> ：当前的分割方案</li><li><code>int startIndex</code> ：当前递归层的分割起始位置</li><li><code>int pointNum</code> ：此前已添加的逗点数量</li></ul></li><li><p>递归终止条件：如果已经添加了 3 个逗点（即， <code>pointNum == 3</code> ），说明已经将字符串分成了四段，分割完成，递归结束</p><ul><li>结束递归前，需要判断当前分割方案是否合法（更准确地说，需要判断第四个整数是否合法，因为前面三个整数在之前的递归层中已经判断过），若当前分割方案合法，则需将其加入到结果集 <code>result</code> 之中</li></ul></li><li><p>单层搜索的逻辑：利用 <code>for</code> 循环遍历分割线的位置 <code>for (int i = startIndex; i &lt; s.size(); i++)</code></p><ul><li>截取 <code>[startIndex, i]</code> 这一索引区间内的字符子串，记作 <code>str</code></li><li>判断子串 <code>str</code> 是否合法，若不合法，跳过当前分割方案，若合法，继续下一步</li><li>递归到下一层，以分割后续字符。其中，传入下一层的 <code>path</code> 需在当前 <code>path</code> 的基础上加上 <code>str + '.'</code> ，下一层的分割起始位置 <code>startIndex</code> 需为 <code>i + 1</code> ，逗点数量 <code>pointNum</code> 需更新为 <code>pointNum + 1</code> ）</li><li>回溯：撤销对 <code>path</code> 和 <code>pointNum</code> 的更改，以便 <code>for</code> 循环继续遍历</li></ul></li></ol><p>特别地，针对上述算法可以做以下考虑：</p><ul><li>可以在分割字符串 <code>s</code> 前对 <code>s</code> 的长度进行判断，若长度小于 4 ，或者长度大于 12，说明 <code>s</code> 无法形成有效 IP 地址，直接返回空数组即可</li><li>子串对应的整数不能大于 255 ，因此，分割的子串长度不能超过 3 ， <code>for</code> 循环遍历分割线位置时无需考虑长度大于 3 的子串</li></ul><blockquote><p>这里将 <code>string path</code> 作为递归函数的参数传入，但采用的是值传递，调用函数时会申请额外的内存空间。为降低空间复杂度，建议采用引用传递，即，将 <code>string path</code> 修改为 <code>string &amp;path</code></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">bool isValid(string s, int left, int right) &#123; // 判断 s[left, right] 对应的整数是否有效
    if (s[left] == '0' &amp;&amp; right &gt; left) return false; // 整数有先导 0 ，无效
    string str = s.substr(left, right - left + 1);    // 取出索引为 [left, right] 的子串
    int num = 0;
    for (int i = left; i &lt;= right; i++) &#123;             // 将 str 转换为 int 型整数
        num = num * 10 + (s[i] - '0');
        if (num &gt; 255) return false;                  // 整数大于 255 ，无效
    &#125;
    return true;
&#125;

void backTracking(vector&lt;string&gt; &amp;result, string path, string s, int startIndex, int pointNum) &#123;
    if (pointNum == 3) &#123; // 已经添加 3 个逗点，分割结束
        if (startIndex &lt; s.size() &amp;&amp; isValid(s, startIndex, s.size() - 1)) &#123; // 判断最后一个整数是否有效
            path += s.substr(startIndex, s.size() - startIndex); // 将最后一个整数放入 path
            result.push_back(path);                              // 将 path 放入结果集
        &#125;
        return;
    &#125;
    for (int i = startIndex; i &lt; s.size() &amp;&amp; i &lt;= startIndex + 2; i++) &#123; // 遍历分割线位置，其中，每个整数最多三位
        if (isValid(s, startIndex, i)) &#123; // 判断 s[startIndex, i] 对应整数是否有效
            string str = s.substr(startIndex, i - startIndex + 1);
            backTracking(result, path + str + '.', s, i + 1, pointNum + 1); // 递归到下一层
        &#125;
    &#125;
&#125;

vector&lt;string&gt; restoreIpAddresses(string s) &#123;
    vector&lt;string&gt; result;
    if (s.size() &lt; 4 || s.size() &gt; 12) return result; // IP 地址至少 4 位，至多 12 位
    string path;
    backTracking(result, path, s, 0, 0);
    return result;
&#125;
</code></pre><p>其中， <code>backTracking(result, path + str + '.', s, i + 1, pointNum + 1);</code> 既实现了递归到一层时的参数更新，也实现了回溯到当前层时的参数回退</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwOTMuJUU1JUE0JThEJUU1JThFJTlGSVAlRTUlOUMlQjAlRTUlOUQlODAuaHRtbA==">代码随想录：复原 IP 地址</span></p><div class="tags"><a href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag"><i class="ic i-tag"></i> 回溯</a></div></div><footer><div class="meta"><span class="item"><time title="修改时间：2024-03-23 01:16:15" itemprop="dateModified" datetime="2024-03-23T01:16:15+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2024-03-23 </time></span><span id="posts/6012cc6b/" class="item leancloud_visitors" data-flag-title="LeetCode - 回溯专题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/6012cc6b/" title="LeetCode - 回溯专题">https://jiankychen.github.io/posts/6012cc6b/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/b754d2ea/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;42bab566f107b9a16542343e0368fb77.jpg" title="回溯"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Data Structure</span><h3>回溯</h3></a></div><div class="item right"><a href="/posts/f3b1f59f/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;99fb5ff897a82984470abf5e2a235d94.jpg" title="LeetCode - 贪心专题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 贪心专题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 131. 分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.2.</span> <span class="toc-text">Method: 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">LeetCode 17. 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-2"><span class="toc-number">2.2.</span> <span class="toc-text">Method: 回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">3.</span> <span class="toc-text">LeetCode 22. 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-3"><span class="toc-number">3.1.</span> <span class="toc-text">Method: 回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">4.</span> <span class="toc-text">LeetCode 301. 删除无效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-4"><span class="toc-number">4.1.</span> <span class="toc-text">Method: 回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">5.</span> <span class="toc-text">LeetCode 39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-5"><span class="toc-number">5.1.</span> <span class="toc-text">Method: 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%89%AA%E6%9E%9D"><span class="toc-number">5.2.</span> <span class="toc-text">优化（剪枝）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii"><span class="toc-number">6.</span> <span class="toc-text">LeetCode 40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-6"><span class="toc-number">6.2.</span> <span class="toc-text">Method: 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C-%E6%8E%92%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">哈希 + 排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iii"><span class="toc-number">7.</span> <span class="toc-text">LeetCode 216. 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-7"><span class="toc-number">7.2.</span> <span class="toc-text">Method: 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%89%AA%E6%9E%9D-2"><span class="toc-number">7.3.</span> <span class="toc-text">优化（剪枝）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">LeetCode 46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-%E5%93%88%E5%B8%8C"><span class="toc-number">8.2.</span> <span class="toc-text">Method: 回溯 + 哈希</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-47-%E6%8E%92%E5%88%97ii"><span class="toc-number">9.</span> <span class="toc-text">LeetCode 47. 排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.</span> <span class="toc-text">Method: 回溯 + 排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">9.3.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-%E5%93%88%E5%B8%8C"><span class="toc-number">10.</span> <span class="toc-text">回溯 + 哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2"><span class="toc-number">10.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">10.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.</span> <span class="toc-text">LeetCode 491. 递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">11.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-%E5%93%88%E5%B8%8C-2"><span class="toc-number">11.2.</span> <span class="toc-text">Method: 回溯 + 哈希</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-77-%E7%BB%84%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">LeetCode 77. 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">12.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-8"><span class="toc-number">12.2.</span> <span class="toc-text">Method: 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%89%AA%E6%9E%9D-3"><span class="toc-number">12.3.</span> <span class="toc-text">优化（剪枝）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-78-%E5%AD%90%E9%9B%86"><span class="toc-number">13.</span> <span class="toc-text">LeetCode 78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">13.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-9"><span class="toc-number">13.2.</span> <span class="toc-text">Method: 回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">14.</span> <span class="toc-text">LeetCode 79. 单词搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-10"><span class="toc-number">14.1.</span> <span class="toc-text">Method: 回溯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-90-%E5%AD%90%E9%9B%86-ii"><span class="toc-number">15.</span> <span class="toc-text">LeetCode 90. 子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">15.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-11"><span class="toc-number">15.2.</span> <span class="toc-text">Method: 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-2"><span class="toc-number">15.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">15.4.</span> <span class="toc-text">哈希</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-93-%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">16.</span> <span class="toc-text">LeetCode 93. 复原 IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-number">16.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%9B%9E%E6%BA%AF-12"><span class="toc-number">16.2.</span> <span class="toc-text">Method: 回溯</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/1b7ed9b4/" rel="bookmark" title="LeetCode Records">LeetCode Records</a></li><li><a href="/posts/32d5c1f6/" rel="bookmark" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></li><li><a href="/posts/2057f45/" rel="bookmark" title="LeetCode - 数组专题">LeetCode - 数组专题</a></li><li><a href="/posts/bc32ab1e/" rel="bookmark" title="LeetCode - 链表专题">LeetCode - 链表专题</a></li><li><a href="/posts/29abbd18/" rel="bookmark" title="LeetCode - 哈希表专题">LeetCode - 哈希表专题</a></li><li><a href="/posts/36947f98/" rel="bookmark" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></li><li><a href="/posts/51f34f0/" rel="bookmark" title="LeetCode - 栈与队列专题">LeetCode - 栈与队列专题</a></li><li><a href="/posts/ed3025a8/" rel="bookmark" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></li><li class="active"><a href="/posts/6012cc6b/" rel="bookmark" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></li><li><a href="/posts/f3b1f59f/" rel="bookmark" title="LeetCode - 贪心专题">LeetCode - 贪心专题</a></li><li><a href="/posts/5e11e767/" rel="bookmark" title="LeetCode - 动态规划专题">LeetCode - 动态规划专题</a></li><li><a href="/posts/611c1217/" rel="bookmark" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></li><li><a href="/posts/691b4be6/" rel="bookmark" title="LeetCode - 单调栈专题">LeetCode - 单调栈专题</a></li><li><a href="/posts/537e2e53/" rel="bookmark" title="LeetCode - 搜索专题">LeetCode - 搜索专题</a></li><li><a href="/posts/242193c5/" rel="bookmark" title="LeetCode - 排序专题">LeetCode - 排序专题</a></li><li><a href="/posts/f994a74a/" rel="bookmark" title="常见输入输出">常见输入输出</a></li><li><a href="/posts/def81c82/" rel="bookmark" title="LeetCode - 模拟专题">LeetCode - 模拟专题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">52</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/b754d2ea/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/f3b1f59f/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/36947f98/" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/b80c5159/" title="conda 常用命令">conda 常用命令</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/a444b428/" title="排序">排序</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tutorial/" title="分类于 Tutorial">Tutorial</a></div><span><a href="/posts/b84c37ec/" title="vscode 使用">vscode 使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/a21107fc/" title="优先级队列">优先级队列</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/242193c5/" title="LeetCode - 排序专题">LeetCode - 排序专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/def81c82/" title="LeetCode - 模拟专题">LeetCode - 模拟专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/cddca394/" title="C++ 字符串、向量和数组">C++ 字符串、向量和数组</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/51f34f0/" title="LeetCode - 栈与队列专题">LeetCode - 栈与队列专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/b754d2ea/" title="回溯">回溯</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">821k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:48</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/6012cc6b/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->