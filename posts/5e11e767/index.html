<!-- build time:Sat Mar 23 2024 01:17:14 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="动态规划"><link rel="canonical" href="https://jiankychen.github.io/posts/5e11e767/"><title>LeetCode - 动态规划专题 - Coding | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">LeetCode - 动态规划专题</h1><div class="meta"><span class="item" title="创建时间：2022-07-23 10:15:24"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-07-23T10:15:24+08:00">2022-07-23</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>89k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>2:29</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/2aabaeb8aca379b991071d1c41632741.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a1f3404a5032323ea4857ac5a6354d2f.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/8fe50780c15461b629c9aeab5a7f2acd.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/99fb5ff897a82984470abf5e2a235d94.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/e5221f7d85b0900837a45fb933fa34ec.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Coding/" itemprop="item" rel="index" title="分类于 Coding"><span itemprop="name">Coding</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/5e11e767/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="leetcode-10-正则表达式匹配"><a class="anchor" href="#leetcode-10-正则表达式匹配">#</a> LeetCode 10. 正则表达式匹配</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcv">10. Regular Expression Matching</span></p><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code> ，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><ul><li><code>'.'</code> 匹配任意单个字符</li><li><code>'*'</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;aa&quot;, p = &quot;a&quot;
输出：false
解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;aa&quot;, p = &quot;a*&quot;
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;ab&quot;, p = &quot;.*&quot;
输出：true
解释：&quot;.*&quot; 表示可匹配零个或多个（'*'）任意字符（'.'）。
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>p.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li><code>s</code> 只包含小写字母</li><li><code>p</code> 只包含小写字母，以及 <code>'.'</code> 和 <code>'*'</code></li><li>保证每次出现字符 <code>'*'</code> 时，前面都匹配到有效的字符</li></ul><h2 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组 ： <code>dp[i][j]</code> 表示 <code>s[0, i - 1]</code> 是否与 <code>p[0, j - 1]</code> 匹配</p><p>初始化 dp 数组： <code>dp[0][0] = true</code> ，其余全部初始化为 <code>false</code></p><blockquote><p>当字符串 <code>p</code> 以 <code>&quot;.*&quot;</code> 起始时，应有 <code>dp[0][2] = true</code> ，因为 <code>&quot;.*&quot;</code> 可以匹配零个（ <code>'*'</code> ）任意字符（ <code>'.'</code> ）</p></blockquote><p>推导 <code>dp[i][j]</code> 的状态转移过程：</p><ul><li>当 <code>p[j - 1] == '*'</code> 时，可以考虑将 <code>p[j - 2]</code> 与字符串 <code>s</code> 匹配任意次<ul><li>若 <code>p[j - 2] == s[i - 1] || p[j - 2] == '.'</code> ，则可以将 <code>p[j - 2]</code> 与 <code>s[i - 1]</code> 进行匹配。由于 <code>p[j - 2]</code> + <code>'*'</code> 这一组合可以匹配零次或多次，我们可以做以下考虑<ul><li>将其与 <code>s[i - 1]</code> 匹配、并考虑将其与 <code>s[i - 2]</code> 继续匹配（即，将 <code>s[i - 1]</code> 舍弃），此时， <code>dp[i][j] = dp[i - 1][j]</code></li><li>不与 <code>s[i - 1]</code> 匹配，将 <code>p[j - 2]</code> + <code>'*'</code> 这一组合直接舍弃，此时， <code>dp[i][j] = dp[i][j - 2]</code></li><li>综合两种情况可得， <code>dp[i][j] = dp[i - 1][j] || dp[i][j - 2]</code></li></ul></li><li>若 <code>p[j - 2] != s[i - 1] &amp;&amp; p[j - 2] != '.'</code> ，则无法将 <code>p[j - 2]</code> + <code>'*'</code> 这一组合与 <code>s[i - 1]</code> 匹配，应舍弃这一组合，即， <code>dp[i][j] = dp[i][j - 2]</code></li></ul></li><li>当 <code>p[j - 1] != '*'</code> 时，考虑将 <code>p[j - 1]</code> 与 <code>s[i - 1]</code> 匹配<ul><li>若 <code>p[j - 1] == '.' || s[i - 1] == p[j - 1]</code> ，则可以将 <code>p[j - 1]</code> 与 <code>s[i - 1]</code> 匹配，因此， <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>若 <code>p[j - 1] != '.' &amp;&amp; s[i - 1] != p[j - 1]</code> ，无法将 <code>p[j - 1]</code> 与 <code>s[i - 1]</code> 匹配，此时， <code>dp[i][j] = false</code></li></ul></li></ul><p>确定遍历顺序：由递推公式知， <code>dp[i][j]</code> 依赖于 <code>dp[i][j - 2]</code> 、 <code>dp[i - 1][j]</code> 以及 <code>dp[i - 1][j - 1]</code> ，因此，应按照从小到大的顺序遍历 <code>i</code> 、按照从小到大的顺序遍历 <code>j</code></p><p>特别地， <code>i</code> 应从 0 开始遍历，这是为了让 <code>s = &quot;&quot;</code> 与 <code>p = &quot;.*&quot;</code> 匹配，即，针对 示例 3 ，有 <code>dp[0][2] = true</code> （因为当 <code>i = 0</code> 、 <code>j = 2</code> 时，会执行 <code>dp[i][j] = dp[i][j - 2]</code> ），进一步地，才能推出 <code>dp[1][2] = true</code> 以及 <code>dp[2][2] = true</code> （因为会执行 <code>dp[i][j] = dp[i][j - 2] || dp[i - 1][j]</code> ）</p><p>代码实现：</p><pre><code class="language-cpp">bool isMatch(string s, string p) &#123;
    vector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector&lt;bool&gt;(p.size() + 1, false));
    dp[0][0] = true;
    for (int i = 0; i &lt;= s.size(); i++) &#123;
        for (int j = 1; j &lt;= p.size(); j++) &#123;
            if (p[j - 1] == '*') &#123;
                if (i &gt; 0 &amp;&amp; (p[j - 2] == '.' || s[i - 1] == p[j - 2]))
                    dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
                else
                    dp[i][j] = dp[i][j - 2];
            &#125; else &#123;
                if (i &gt; 0 &amp;&amp; (p[j - 1] == '.' || s[i - 1] == p[j - 1]))
                    dp[i][j] = dp[i - 1][j - 1];
            &#125;
        &#125;
    &#125;
    return dp[s.size()][p.size()];
&#125;
</code></pre><p>其中，对情况 <code>p[j - 1] == '*'</code> 的处理，即</p><pre><code>if (i &gt; 0 &amp;&amp; (p[j - 2] == '.' || s[i - 1] == p[j - 2]))
    dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
else
    dp[i][j] = dp[i][j - 2];
</code></pre><p>可改写为</p><pre><code>dp[i][j] = dp[i][j - 2];
if (i &gt; 0 &amp;&amp; (p[j - 2] == '.' || s[i - 1] == p[j - 2]))
    dp[i][j] = dp[i][j] || dp[i - 1][j];
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串 <code>s</code> 和 <code>p</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcvc29sdXRpb24vemhlbmctemUtYmlhby1kYS1zaGktcGktcGVpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解</span></p><h1 id="leetcode-1035-不相交的线"><a class="anchor" href="#leetcode-1035-不相交的线">#</a> LeetCode 1035. 不相交的线</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmNyb3NzZWQtbGluZXMv">1035. Uncrossed Lines</span></p><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/Example.png" alt="" height="200px"></p><pre><code>输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums1.length</code> , <code>nums2.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums1[i]</code> , <code>nums2[j]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">\le 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>本质是求两个数组的最长公共子序列的长度，即，与 <a href="https://jiankychen.github.io/posts/c261e90a">LeetCode 1143. 最长公共子序列</a> 完全一致</p><h2 id="method-动态规划-2"><a class="anchor" href="#method-动态规划-2">#</a> Method: 动态规划</h2><p>定义 <code>dp[i][j]</code> 表示 <code>nums1[0, i - 1]</code> 与子串 <code>nums2[0, j - 1]</code> 的最长公共子序列的长度，其中， <code>1 &lt;= i &lt;= nums1.size()</code> , <code>1 &lt;= j &lt;= nums2.size()</code></p><p>代码实现：</p><pre><code class="language-cpp">int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
    int m = nums1.size();
    int n = nums2.size();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (nums1[i - 1] == nums2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
        &#125;
    &#125;
    return dp[m][n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是数组 <code>nums1</code> 与数组 <code>nums2</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-1049-最后一块石头的重量ii"><a class="anchor" href="#leetcode-1049-最后一块石头的重量ii">#</a> LeetCode 1049. 最后一块石头的重量 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXN0LXN0b25lLXdlaWdodC1paS8=">1049. Last Stone Weight II</span></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 i 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code> ，且 <code>x &lt;= y</code> 。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code> ，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code> ，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code> 。</li></ul><p>最后，<strong>最多只会剩下一块石头</strong> 。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：stones = [2,7,4,1,8,1]
输出：1
解释：
    组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
    组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
    组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
    组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：stones = [31,26,33,21,40]
输出：5
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>stones.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>stones[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-2"><a class="anchor" href="#思路-2">#</a> 思路</h2><p>本题要求最后剩余的石头重量尽可能小，也就相当于，尽可能将石头分成重量相同的两堆，以使得相撞之后剩下的石头最小</p><p>因此，本题类似于 <a href="https://jiankychen.github.io/posts/31559997">LeetCode 416. 分割等和子集</a> ，可按照 0-1 背包问题来求解</p><p>即，物品 <code>i</code> 的重量为 <code>stones[i]</code> ，价值为 <code>stones[i]</code> ，对于最大容量为 <code>target</code> 的背包，选出若干物品，使背包中的物品总价值最大，其中， <code>target</code> 是 <code>stones</code> 数组元素和的一半</p><h2 id="method-动态规划-3"><a class="anchor" href="#method-动态规划-3">#</a> Method: 动态规划</h2><p>算法思路：</p><p>首先应计算整个数组的元素之和 <code>sum</code> ，并进一步计算背包的最大容量，即， <code>target = sum / 2</code></p><p>然后利用动态规划算法，得到容量为 <code>target</code> 的背包所能实现的最大重量</p><ol><li><p>定义 <code>dp</code> 数组：对于容量为 <code>j</code> 的背包，其物品最大价值为 <code>dp[j]</code> ，其中， <code>0 &lt;= j &lt; = target</code></p></li><li><p>确定递推公式：当 <code>stones[i] &lt;= j &lt;= target</code> 时， <code>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</code></p><ul><li>若 <code>j &lt; stones[i]</code> ，即，背包放不下物品 <code>i</code> ，此时， <code>i</code> 不可能被选取， <code>dp[j]</code> 保持不变</li><li>若 <code>stones[i] &lt;= j &lt;= target</code> ，可以选择物品 <code>i</code> （最大价值为 <code>dp[j - stones[i]] + stones[i]</code> ），也可以不选物品 <code>i</code> （最大价值为 <code>dp[j]</code> ），综合所得的最大价值为 <code>max(dp[j], dp[j - stones[i]] + stones[i])</code></li></ul></li><li><p>初始化 <code>dp</code> 数组：对任意 <code>j</code> ，初始的 <code>dp[j]</code> 均为 <code>0</code></p></li><li><p>确定遍历顺序：</p><ul><li>外层遍历物品 <code>i</code> ，内层遍历背包容量 <code>j</code></li><li><code>i</code> 按从小到大顺序遍历， <code>j</code> 按从大到小顺序遍历</li></ul></li><li><p>举例推导 <code>dp</code> 数组</p></li></ol><p>当遍历结束时， <code>dp[target]</code> 即为 最大容量为 <code>target</code> 的背包所能实现的最大重量</p><p>此时，一堆石头的重量为 <code>dp[target]</code> ，另一堆的重量为 <code>sum - dp[target]</code></p><p>由于 <code>target = sum / 2</code> 是向下取整，即， <code>dp[target] &lt;= target &lt;= sum / 2</code> ，故而 <code>dp[target] &lt;= sum - dp[target]</code></p><p>因此，相撞之后，剩余石头的最小重量为 <code>(sum - dp[target]) - dp[target]</code></p><p>代码实现：</p><pre><code class="language-cpp">int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;
    
    // 计算背包最大容量
    int n = stones.size();
    int sum = 0;
    for (int a : stones) sum += a;
    int target = sum / 2;
    
    // 0-1 背包
    vector&lt;int&gt; dp(target + 1, 0);
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = target; j &gt;= stones[i]; j--) &#123;
            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
        &#125;
    &#125;

    return (sum - dp[target]) - dp[target];

&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 是数组元素和的一半</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-1143-最长公共子序列"><a class="anchor" href="#leetcode-1143-最长公共子序列">#</a> LeetCode 1143. 最长公共子序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1zdWJzZXF1ZW5jZS8=">1143. Longest Common Subsequence</span></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code> ，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如， <code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 
输出：3  
解释：The longest common subsequence is &quot;ace&quot; and its length is 3.
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;
输出：3
解释：The longest common subsequence is &quot;abc&quot; and its length is 3.
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;
输出：0
解释：There is no such common subsequence, so the result is 0.
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>text1.length</code> , <code>text2.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成</li></ul><h2 id="method-动态规划-4"><a class="anchor" href="#method-动态规划-4">#</a> Method: 动态规划</h2><p>算法思路：</p><p>dp 数组： <code>dp[i][j]</code> 表示子串 <code>text1[0, i - 1]</code> 与子串 <code>text2[0, j - 1]</code> 的最长公共子序列的长度，其中， <code>1 &lt;= i &lt;= text1.size()</code> , <code>1 &lt;= j &lt;= text2.size()</code></p><p>递推公式：</p><ul><li>若 <code>text1[i - 1] == text2[j - 1]</code> ，则 <code>text1[0, i - 1]</code> 和 <code>text2[0, j - 1]</code> 的最长公共子序列长度 应比 <code>text1[0, i - 2]</code> 和 <code>text2[0, j - 2]</code> 的最长公共子序列长度大 1，即， <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>若 <code>text1[i - 1] != text2[j - 1]</code> ，则做以下考虑：<ul><li>确定 <code>text1[0, i - 2]</code> 和 <code>text2[0, j - 1]</code> 的最长公共子序列，即，计算 <code>dp[i - 1][j]</code></li><li>确定 <code>text1[0, i - 1]</code> 和 <code>text2[0, j - 2]</code> 的最长公共子序列，即，计算 <code>dp[i][j - 1]</code></li><li>综合两种情况，取最大值，即， <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li></ul></li></ul><p>初始化：根据递推公式知，应初始化 <code>dp[0][j]</code> 和 <code>dp[i][0]</code></p><ul><li><code>dp[0][j]</code> ：此时考虑的 <code>text1</code> 子串为空串，与 <code>text2</code> 的公共子序列长度为 0 ，即， <code>dp[0][j] = 0</code></li><li><code>dp[i][0]</code> ：此时考虑的 <code>text2</code> 子串为空串，与 <code>text1</code> 的公共子序列长度为 0 ，即， <code>dp[i][0] = 0</code></li></ul><p>遍历顺序：外层按从小到大顺序遍历 <code>i</code> ，内层按从小到大顺序遍历 <code>j</code></p><p>遍历结束后， <code>dp[text1.size()][text2.size()]</code> 即为字符串 <code>text1</code> 与字符串 <code>text2</code> 的最长公共子序列的长度</p><p>代码实现：</p><pre><code class="language-cpp">int longestCommonSubsequence(string text1, string text2) &#123;
    int m =text1.size();
    int n =text2.size();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (text1[i - 1] == text2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        &#125;
    &#125;
    return dp[m][n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串 <code>text1</code> 与字符串 <code>text2</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzExNDMuJUU2JTlDJTgwJUU5JTk1JUJGJUU1JTg1JUFDJUU1JTg1JUIxJUU1JUFEJTkwJUU1JUJBJThGJUU1JTg4JTk3Lmh0bWw=">代码随想录</span></p><h1 id="leetcode-115-不同的子序列"><a class="anchor" href="#leetcode-115-不同的子序列">#</a> LeetCode 115. 不同的子序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXN0aW5jdC1zdWJzZXF1ZW5jZXMv">115. Distinct Subsequences</span></p><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;
输出：3
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;
输出：5
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> , <code>t.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="method-动态规划-5"><a class="anchor" href="#method-动态规划-5">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示在 <code>s[0, i - 1]</code> 中出现 <code>t[0, j - 1]</code> 子序列的个数</p><p>初始化 <code>dp[0][j]</code> 和 <code>dp[i][0]</code> ：</p><ul><li>当 <code>j = 0</code> 时， <code>t[0, j - 1]</code> 为空字符串，由于空字符串是任何字符串的子序列，因此，对任意 <code>0 &lt;= i &lt;= s.size()</code> ，有 <code>dp[i][0] = 1</code></li><li>当 <code>i = 0</code> 时， <code>s[0, i - 1]</code> 为空字符串，由于非空字符串不是空字符串的子序列，因此，对任意 <code>1 &lt;= j &lt;= t.size()</code> ，有 <code>dp[0][j] = 0</code></li></ul><p>考虑 <code>dp[i][j]</code> 的状态转移过程：</p><ul><li>当 <code>s[i - 1] == t[j - 1]</code> 时<ul><li>如果把 <code>s[i - 1]</code> 与 <code>t[j - 1]</code> 匹配，则需考察 <code>s[0, i - 2]</code> 中出现 <code>t[0, j - 2]</code> 的个数，即， <code>dp[i - 1][j - 1]</code></li><li>如果不把 <code>s[i - 1]</code> 与 <code>t[j - 1]</code> 匹配，则需考察 <code>s[0, i - 2]</code> 中出现 <code>t[0, j - 1]</code> 的个数，即，子序列个数为 <code>dp[i - 1][j]</code></li><li>以上两种情况都是可行的，因此， <code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></li></ul></li><li>当 <code>s[i - 1] != t[j - 1]</code> 时<ul><li>无法将 <code>s[i - 1]</code> 与 <code>t[j - 1]</code> 匹配，故而应考察 <code>s[0, i - 2]</code> 中出现 <code>t[0, j - 1]</code> 的个数，即， <code>dp[i][j] = dp[i - 1][j]</code></li></ul></li></ul><p>例如，当 s = &quot;babgbag&quot; 、t = &quot;bag&quot; 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 都可以与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配</p><ul><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0] = t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[1][1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[1] \neq t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[2][1] = dp[1][1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2] = t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[3][1] = dp[2][0] + dp[2][1] = 1 + 1 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> ，即，可选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配，也可从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中选出字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配</li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[3] \neq t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[4][1] = dp[3][1] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span></li><li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[4] = t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">dp[4][1] = dp[3][0] + dp[3][1] = 1 + 2 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span> ，即，可选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配，也可从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0, 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span> 中选出字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 匹配</li></ul><p>遍历顺序：根据递推公式知， <code>dp[i][j]</code> 依赖于 <code>dp[i - 1][j - 1]</code> 和 <code>dp[i - 1][j]</code> ，因此， <code>i</code> 和 <code>j</code> 都应按从小到大的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int numDistinct(string s, string t) &#123;
    
    // dp 数组的定义及初始化
    vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size() + 1, vector&lt;uint64_t&gt;(t.size() + 1, 0));
    for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 1;
    
    // 遍历
    for (int i = 1; i &lt;= s.size(); i++) &#123;
        for (int j = 1; j &lt;= t.size(); j++) &#123;
            if (s[i - 1] == t[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            else
                dp[i][j] = dp[i - 1][j];
        &#125;
    &#125;

    // 返回结果
    return dp[s.size()][t.size()];
    
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串 <code>s</code> 和 <code>t</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-121-买卖股票的最佳时机"><a class="anchor" href="#leetcode-121-买卖股票的最佳时机">#</a> LeetCode 121. 买卖股票的最佳时机</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLw==">121. Best Time to Buy and Sell Stock</span></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-1-贪心"><a class="anchor" href="#method-1-贪心">#</a> Method 1: 贪心</h2><p>算法思路：</p><ul><li><p>利用 <code>priceBuy</code> 表示买入价，并维护获得的最大利润 <code>maxProfit</code></p></li><li><p>如果遇到更低的价格，则更新买入价 <code>priceBuy</code> ，后续按新的买入价计算所能得到的利润</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
    int priceBuy = prices[0]; // 买入价格
    int maxProfit = 0;        // 最大利润
    for (int i = 1; i &lt; prices.size(); i++) &#123;
        priceBuy = min(priceBuy, prices[i]);              
        maxProfit = max(maxProfit, prices[i] - priceBuy);
    &#125;
    return maxProfit;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中　<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-动态规划"><a class="anchor" href="#method-2-动态规划">#</a> Method 2: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2,0))</code></p><ul><li><code>dp[i][0]</code> 表示第 <code>i</code> 天持有股票时的最大利润</li><li><code>dp[i][1]</code> 表示第 <code>i</code> 天不持有股票时的最大利润</li></ul><p>确定递推公式：</p><ul><li>第 <code>i</code> 天持有股票，即， <code>dp[i][0]</code><ul><li>若第 <code>i - 1</code> 天持有股票，则最大利润为 <code>dp[i - 1][0]</code></li><li>若第 <code>i - 1</code> 天不持有股票，即，第 <code>i</code> 天买入股票，则最大利润为 <code>- prices[i]</code> （因为只能买入一次股票，第 <code>i - 1</code> 天不持有股票就说明此前并未买入过股票，因此第 <code>i - 1</code> 天的利润必定为 0 ）</li><li>综合两种情况得 <code>dp[i][0] = max(dp[i - 1][0], - prices[i]);</code></li></ul></li><li>第 <code>i</code> 天不持有股票，即， <code>dp[i][1]</code><ul><li>若第 <code>i - 1</code> 天持有股票，即，第 <code>i</code> 天卖出股票，则最大利润为 <code>dp[i - 1][0] + prices[i]</code></li><li>若第 <code>i - 1</code> 天不持有股票，则最大利润为 <code>dp[i - 1][1]</code></li><li>综合两种情况得 <code>dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1])</code></li></ul></li></ul><p>初始化 dp 数组：</p><ul><li>若第 0 天持有股票，当前利润应为 <code>- prices[0]</code> ，即 <code>dp[0][0] = - prices[0]</code></li><li>若第 0 天不持有股票，利润为 0 ，即 <code>dp[i][1] = 0</code></li></ul><p>遍历顺序：按 <code>i</code> 从小到大遍历</p><p>最后的 <code>dp[n - 1][1]</code> 即为所求（卖出股票可以获得收益，因此， <code>dp[n - 1][1]</code> 一定不小于 <code>dp[n - 1][0]</code> ）</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
    int n = prices.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2,0));
    dp[0][0] = - prices[0]; // 第 0 天持有股票时的最大利润
    dp[0][1] = 0;           // 第 0 天不持有股票时的最大利润
    for (int i = 1; i &lt; n; i++) &#123;
        dp[i][0] = max(dp[i - 1][0], - prices[i]);              // 第 i 天持有股票时的最大利润
        dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]); // 第 i 天不持有股票时的最大利润
    &#125;
    return dp[n - 1][1];    // 第 n - 1 天不持有股票时的最大利润
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中　<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMjEuJUU0JUI5JUIwJUU1JThEJTk2JUU4JTgyJUExJUU3JUE1JUE4JUU3JTlBJTg0JUU2JTlDJTgwJUU0JUJEJUIzJUU2JTk3JUI2JUU2JTlDJUJBLmh0bWw=">代码随想录</span></p><h1 id="leetcode-123-买卖股票的最佳时机-iii"><a class="anchor" href="#leetcode-123-买卖股票的最佳时机-iii">#</a> LeetCode 123. 买卖股票的最佳时机 III</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpaS8=">123. Best Time to Buy and Sell Stock III</span></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：prices = [7,6,4,3,1]
输出：0
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-动态规划-6"><a class="anchor" href="#method-动态规划-6">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示第 i 天状态为 j 时的最大利润</p><ul><li><code>dp[i][0]</code> ：第 i 天时，未曾买入过股票</li><li><code>dp[i][1]</code> ：第 i 天时，持有第一支股票（已买入、未卖出，可能第 i 天以前就已买入）</li><li><code>dp[i][2]</code> ：第 i 天时，不再持有第一支股票（可能是第 i 天以前就已经卖出）</li><li><code>dp[i][3]</code> ：第 i 天时，持有第二支股票（卖出第一支股票后再次买入，可能第 i 天以前就已买入）</li><li><code>dp[i][4]</code> ：第 i 天时，不再持有第二支股票（可能是第 i 天以前就已经卖出）</li></ul><p>推导递推公式：</p><ul><li><code>dp[i][0]</code> ：第 <code>i - 1</code> 天必然也不曾买入过股票，故而 <code>dp[i][0] = dp[i - 1][0]</code> （事实上，对任意 i 均有 <code>dp[i][0] = 0</code> ）</li><li><code>dp[i][1]</code> ：若第 <code>i - 1</code> 天不曾买入股票，即，第 <code>i</code> 天买入股票，此时利润为 <code>dp[i - 1][0] - prices[i]</code> ；若第 <code>i - 1</code> 天已持有股票，第 <code>i</code> 天时的利润为 <code>dp[i - 1][1]</code> 。综合两种情况，取最大利润，即， <code>dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])</code> （由于 <code>dp[i - 1][0] = 0</code> ， <code>dp[i][1]</code> 也可写为 <code>max( - prices[i], dp[i - 1][1])</code> ）</li><li><code>dp[i][2]</code> ：若第 <code>i - 1</code> 天不曾卖出股票，即，第 <code>i</code> 天卖出股票，此时利润为 <code>dp[i - 1][1] + prices[i]</code> ；若第 <code>i - 1</code> 天已卖出股票，第 <code>i</code> 天时的利润为 <code>dp[i - 1][2]</code> 。综合两种情况得， <code>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code></li><li><code>dp[i][3]</code> ：若第 <code>i - 1</code> 天不曾持有第二支股票，即，第 <code>i</code> 天买入第二支股票，此时利润为 <code>dp[i - 1][2] - prices[i]</code> ；若第 <code>i - 1</code> 天已持有第二支股票，第 <code>i</code> 天时的利润为 <code>dp[i - 1][3]</code> 。综合两种情况得， <code>dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3])</code></li><li><code>dp[i][4]</code> ：若第 <code>i - 1</code> 天持有第二支股票，即，第 <code>i</code> 天卖出第二支股票，此时利润为 <code>dp[i - 1][3] + prices[i]</code> ；若第 <code>i - 1</code> 天已不再持有第二支股票，第 <code>i</code> 天时的利润为 <code>dp[i - 1][4]</code> 。综合两种情况得， <code>dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4])</code></li></ul><p>初始化 dp 数组：</p><ul><li><code>dp[0][0] = 0</code> ，第 0 天不进行任何操作，利润为 0</li><li><code>dp[0][1] = - prices[0]</code> ，第 0 天买入股票，利润为 <code>- prices[0]</code></li><li><code>dp[0][2] = 0</code> ，当天买入股票并当天卖出，利润为 0</li><li><code>dp[0][3] = - prices[0]</code> ，买入股票，利润为 <code>- prices[0]</code></li><li><code>dp[0][4] = 0</code> ，当天买入股票并当天卖出，利润为 0</li></ul><p>遍历顺序：按 <code>i</code> 从小到大顺序遍历</p><p>最后的 <code>dp[prices.size() - 1][4]</code> 即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
    int n = prices.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(5, 0));
    dp[0][1] = - prices[0];
    dp[0][3] = - prices[0];
    for (int i = 1; i &lt; n; i++) &#123;
        dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
        dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
        dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3]);
        dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4]);
    &#125;
    return dp[n - 1][4];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以采用滚动数组优化空间复杂度</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMjMuJUU0JUI5JUIwJUU1JThEJTk2JUU4JTgyJUExJUU3JUE1JUE4JUU3JTlBJTg0JUU2JTlDJTgwJUU0JUJEJUIzJUU2JTk3JUI2JUU2JTlDJUJBSUlJLmh0bWw=">代码随想录</span></p><h1 id="leetcode-139-单词拆分"><a class="anchor" href="#leetcode-139-单词拆分">#</a> LeetCode 139. 单词拆分</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWJyZWFrLw==">139. Word Break</span></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p><strong>注意</strong>：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]
输出：true
解释：&quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]
输出：true
解释：&quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]
输出：false
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">\le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>wordDict.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>wordDict[i].length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 互不相同</li></ul><h2 id="method-动态规划-7"><a class="anchor" href="#method-动态规划-7">#</a> Method: 动态规划</h2><p>可以把字典 <code>wordDict</code> 中的单词看成物品，把字符串 <code>s</code> 看成背包，要判断 <code>wordDict</code> 中的单词是否能组成字符串 <code>s</code> ，也就是要判断物品是否能装满背包</p><p>算法思路：</p><ol><li><p>定义 dp 数组： <code>dp[j]</code> 表示字符串 <code>s</code> 前 <code>j</code> 个字符组成的子串是否能由字典 <code>wordDict</code> 中的单词拼接成，其中， <code>1 &lt;= j &lt;= s.size()</code></p></li><li><p>确定递推公式：对于任意 <code>j</code> ，需要枚举 <code>s[0, ..., j - 1]</code> 中的分割点 <code>i</code> ，看 <code>s[0, ..., i - 1]</code> 组成的字符串（默认 j = 0 时为空串）和 <code>s[i, ..., j - 1]</code> 组成的字符串是否都合法，如果两个字符串都合法，则组成的 <code>s[0, ..., j - 1]</code> 也合法。因此，递推公式为： <code>dp[j] = dp[i] &amp;&amp; check(s[i, ..., j - 1])</code> ，其中， <code>check(s[i, ..., j - 1])</code> 表示子串 <code>s[i, ..., j - 1]</code> 是否为字典中的单词</p></li><li><p>初始化 dp 数组：定义 <code>dp[0] = true</code> 表示空串是合法的，对任意 <code>j &gt; 0</code> 均有 <code>dp[j] = false</code></p></li><li><p>确定遍历顺序：由于字典 <code>wordDict</code> 中的单词可以重复出现（即，完全背包问题），并且单词出现的顺序并不确定，因此，应该外层 <code>for</code> 循环遍历背包，内层 <code>for</code> 循环遍历物品，其中，内循环须按从小到大顺序遍历</p></li></ol><p>其中，检查子串 <code>s[i, ..., j - 1]</code> 是否为字典中的单词可以通过哈希表实现</p><p>代码实现：</p><pre><code class="language-cpp">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;
    unordered_set&lt;string&gt; hash(wordDict.begin(), wordDict.end());
    vector&lt;bool&gt; dp(s.size() + 1, false); // dp[j] 表示 s[0, j - 1] 是否可由 wordDict 拼接得到
    dp[0] = true;
    for (int j = 1; j &lt;= s.size(); j++) &#123; // 遍历背包
        for (int i = 0; i &lt; j; i++) &#123;     // 遍历物品
            string word = s.substr(i, j - i);               // 截取 s[i, j - 1] 子串
            if (dp[i] &amp;&amp; (hash.find(word) != hash.end())) &#123; // s[0, i - 1] 可拼接，s[i, j - 1] 也可拼接
                dp[j] = true;                               // 故而 s[0, j - 1] 可拼接
                break;
            &#125;
        &#125;
    &#125;
    return dp[s.size()];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串 <code>s</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>也可以做一些简单的剪枝，枚举分割点的时候倒着枚举，如果分割点 <code>i</code> 到 <code>j</code> 的长度已经大于字典列表里最长的单词的长度，那么就结束枚举</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWJyZWFrL3NvbHV0aW9uL2Rhbi1jaS1jaGFpLWZlbi1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解</span></p><h1 id="leetcode-152-乘积最大子数组"><a class="anchor" href="#leetcode-152-乘积最大子数组">#</a> LeetCode 152. 乘积最大子数组</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkv">152. Maximum Product Subarray</span></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32 - 位</strong> 整数。</p><p><strong>子数组</strong> 是数组的连续子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,-2,4]
输出：6
解释：子数组 [2,3] 有最大乘积 6
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [-2,0,-1]
输出：0
解释：结果不能为 2, 因为 [-2,-1] 不是子数组
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 2 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li><code>nums</code> 的任何前缀或后缀的乘积都 保证 是一个 32 - 位 整数</li></ul><h2 id="method-动态规划-8"><a class="anchor" href="#method-动态规划-8">#</a> Method: 动态规划</h2><p>算法思路：</p><p>由于数组 nums 存在负数，子数组的乘积可能会出现 “最大的正数变成最小的负数”、“ 最小的负数变成最大的正数 ” 这两种情况</p><p>因此，我们可以分别定义 maxValue 数组和 minValue 数组</p><ul><li>maxValue [i] 表示以 nums [i] 结尾的乘积最大子数组的乘积</li><li>minValue [i] 表示以 nums [i] 结尾的乘积最小子数组的乘积</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxProduct(vector&lt;int&gt;&amp; nums) &#123;
    vector&lt;int&gt; maxValue(nums.size(), 0);
    vector&lt;int&gt; minValue(nums.size(), 0);
    int ans = nums[0];
    maxValue[0] = nums[0];
    minValue[0] = nums[0];
    for (int i = 1; i &lt; nums.size(); ++i) &#123;
        maxValue[i] = max(&#123;maxValue[i - 1] * nums[i], minValue[i - 1] * nums[i], nums[i]&#125;);
        minValue[i] = min(&#123;maxValue[i - 1] * nums[i], minValue[i - 1] * nums[i], nums[i]&#125;);
        ans = max(ans, maxValue[i]);
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以采用滚动数组的思想来优化空间复杂度</p></blockquote><h1 id="leetcode-188-买卖股票的最佳时机-iv"><a class="anchor" href="#leetcode-188-买卖股票的最佳时机-iv">#</a> LeetCode 188. 买卖股票的最佳时机 IV</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWl2Lw==">188. Best Time to Buy and Sell Stock IV</span></p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code>输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>k</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-动态规划-9"><a class="anchor" href="#method-动态规划-9">#</a> Method: 动态规划</h2><blockquote><p><a href="https://jiankychen.github.io/posts/">LeetCode 123. 买卖股票的最佳时机 III</a> 允许进行至多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 次交易，而本题允许进行至多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 次交易</p></blockquote><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示第 <code>i</code> 天状态为 <code>j</code> 时的最大利润，其中， <code>0 &lt;= i &lt;= prices.size() - 1</code> ， <code>0 &lt;= j &lt;= 2 * k</code></p><ul><li><code>dp[i][0]</code> ：没有任何操作</li><li><code>dp[i][1]</code> ：持有第 1 支股票</li><li><code>dp[i][2]</code> ：不再持有第 1 支股票</li><li>...</li><li><code>dp[i][2 * k - 1]</code> ：持有第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 支股票</li><li><code>dp[i][2 * k]</code> ：不再持有第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 支股票</li></ul><p>不难发现，对于 <code>dp[i][j]</code> 而言， <code>j</code> 为奇数时表示当前持有股票， <code>j</code> 为偶数（ <code>j &gt; 0</code> ）时表示当前并不持有股票</p><p>因此，递推公式为：</p><ul><li>当 <code>j</code> 为奇数时，有 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])</code></li><li>当 <code>j</code> 为偶数时，有 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i])</code></li></ul><p>并且，dp 数组的初始值应为：</p><ul><li>当 <code>j</code> 为奇数时， <code>dp[0][j] = - prices[0]</code></li><li>当 <code>j</code> 为偶数时， <code>dp[0][j] = 0</code></li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;
    if (prices.size() == 0) return 0;
    if (k == 0) return 0;
    vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2 * k + 1));
    for (int j = 1; j &lt; 2 * k; j += 2) &#123;
        dp[0][j] = - prices[0];
    &#125;
    for (int i = 1; i &lt; prices.size(); i++) &#123;
        for (int j = 0; j &lt; 2 * k - 1; j += 2) &#123;
            dp[i][j + 1] = max(dp[i - 1][j] - prices[i], dp[i - 1][j + 1]);
            dp[i][j + 2] = max(dp[i - 1][j + 1] + prices[i], dp[i - 1][j + 2]);
        &#125;
    &#125;
    return dp[prices.size() - 1][2 * k];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 <code>prices</code> 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 是允许的交易次数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxODguJUU0JUI5JUIwJUU1JThEJTk2JUU4JTgyJUExJUU3JUE1JUE4JUU3JTlBJTg0JUU2JTlDJTgwJUU0JUJEJUIzJUU2JTk3JUI2JUU2JTlDJUJBSVYuaHRtbA==">代码随想录</span></p><h1 id="leetcode-198-打家劫舍"><a class="anchor" href="#leetcode-198-打家劫舍">#</a> LeetCode 198. 打家劫舍</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXIv">198. House Robber</span></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>400</mn></mrow><annotation encoding="application/x-tex">\le 400</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-动态规划-10"><a class="anchor" href="#method-动态规划-10">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 间房屋（即，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ）能偷窃到的最高总金额</p><p>递推公式：当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.79549em;vertical-align:-.13597em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p><ul><li>偷窃第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 间房屋，能达到的最高总金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 2] + nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></li><li>不偷窃第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 间房屋，可考虑偷窃第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.74285em;vertical-align:-.08333em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 间房屋，能达到的最高总金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li><li>综合两种情况，取其中最大的，即，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li></ul><p>初始化 dp 数组：根据递推公式知，应初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><ul><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 时，能偷窃的最高金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，故而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[0] = nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 时，能偷窃的最高金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(nums[0], nums[1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> ，故而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[1] = max(nums[0], nums[1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li></ul><p>遍历顺序：按从小到大的顺序遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span></p><p>代码实现：</p><pre><code class="language-cpp">int rob(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    vector&lt;int&gt; dp(n, 0);
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);
    for (int i = 2; i &lt; n; i++) &#123;
        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
    &#125;
    return dp[n - 1];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-203-移除链表元素"><a class="anchor" href="#leetcode-203-移除链表元素">#</a> LeetCode 203. 移除链表元素</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWxpbmtlZC1saXN0LWVsZW1lbnRzLw==">LeetCode 203. Remove Linked List Elements</span></p><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/1.png" alt=""></p><pre><code>输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = [], val = 1
输出：[]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = [7,7,7,7], val = 7
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-3"><a class="anchor" href="#思路-3">#</a> 思路</h2><p>用 <code>cur</code> 表示当前节点：如果 <code>cur</code> 的下一个节点不为空 且 下一个节点的值等于给定的 <code>val</code> ，即， <code>cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val == val</code> ，则需要移除 <code>cur</code> 的下一个节点，即： <code>cur-&gt;next = cur-&gt;next-&gt;next</code></p><p><img data-src="LeetCode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/2.png" alt=""></p><p>但如果要移除的节点是头节点（它没有上个节点）怎么办？</p><ul><li>Method 1：直接将头节点向后移动</li><li>Method 2：在头节点前添加一个虚拟节点，使得原链表的所有节点均可按照常规的方式进行移除</li></ul><h2 id="method-1-直接使用原链表来进行删除操作"><a class="anchor" href="#method-1-直接使用原链表来进行删除操作">#</a> Method 1: 直接使用原链表来进行删除操作</h2><ol><li><p>若要移除头节点，只需将头节点向后移动一位</p><p><img data-src="LeetCode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/3.png" alt=""></p></li><li><p>考虑到新的头节点也可能是值为 <code>val</code> ，需要用循环来对头节点进行处理，直到头节点值不为 <code>val</code></p></li><li><p>对头节点以后的其他节点进行遍历，若需移除则按常规方式处理即可</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">struct ListNode &#123;
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) &#123;&#125;
    ListNode(int x) : val(x), next(nullptr) &#123;&#125;
    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
&#125;;

ListNode* removeElements(ListNode* head, int val) &#123;
    // 删除值为 val 的头节点
    while (head != nullptr &amp;&amp; head-&gt;val == val) &#123;
        ListNode* tmp = head;
        head = head-&gt;next;
        delete tmp;
    &#125;

    // 删除值为 val 的非头节点
    ListNode* cur = head;   // 遍历 cur 节点
    while(cur != nullptr &amp;&amp; cur-&gt;next != nullptr) &#123; // cur 非空且 cur 的下一个节点非空
        if (cur-&gt;next-&gt;val == val) &#123;    // 当 cur 的下一个节点的值为 val 时，删除 cur 的下一个节点
            ListNode* tmp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delete tmp;
        &#125;
        else
            cur = cur-&gt;next;  // cur 向后移动
    &#125;

    // 返回新的头节点
    return head;
&#125;
</code></pre><blockquote><p>注意要从内存中删除移除的节点，清理节点内存</p></blockquote><h2 id="method-2-设置虚拟头节点再进行删除操作"><a class="anchor" href="#method-2-设置虚拟头节点再进行删除操作">#</a> Method 2: 设置虚拟头节点再进行删除操作</h2><p>设置一个虚拟头结点，原链表的所有节点便都可按照统一的方式进行移除</p><p>例如，给链表添加一个虚拟头结点为新的头结点，若要移除这个旧的头结点元素 1 时，只需将虚拟头节点的 <code>next</code> 指向旧的头节点的下一个节点，然后从内存中删除旧的头节点即可：<br><img data-src="LeetCode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/4.png" alt=""></p><p>注意，在 <code>return</code> 头节点 时， <code>return</code> 的应该是虚拟头节点的下一个节点，即， <code>return dummyHead-&gt;next;</code></p><p>最后也需要将添加的虚拟头节点 <code>dummyHead</code> 从内存中删掉</p><p>代码实现：</p><pre><code class="language-cpp">struct ListNode &#123;
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) &#123;&#125;
    ListNode(int x) : val(x), next(nullptr) &#123;&#125;
    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
&#125;;

ListNode* removeElements(ListNode* head, int val) &#123;
    // 设置虚拟头节点
    ListNode* dummyHead = new ListNode(0);  // 创建虚拟头节点
    dummyHead-&gt;next = head;                 // 令虚拟头节点指向 head

    // 移除操作
    ListNode* cur = dummyHead;
    while (cur-&gt;next != nullptr) &#123;
        if (cur-&gt;next-&gt;val == val) &#123;
            ListNode* tmp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delete tmp;
        &#125;
        else
            cur = cur-&gt;next;
    &#125;

    // 返回虚拟头节点的下个节点，并删除虚拟头节点
    head = dummyHead-&gt;next;
    delete dummyHead;
    return head;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是链表的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-213-打家劫舍-ii"><a class="anchor" href="#leetcode-213-打家劫舍-ii">#</a> LeetCode 213. 打家劫舍 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXItaWkv">213. House Robber II</span></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,2]
输出：3
解释：只能偷窃 2 号房屋（金额 = 3）。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,2,3]
输出：3
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-4"><a class="anchor" href="#思路-4">#</a> 思路</h2><p>与 <a href="https://jiankychen.github.io/posts/be158ab">LeetCode 198. 打家劫舍</a> 有所不同，本题的房屋是首尾相连的，因此，第一间房屋和最后一间房屋不能在同一晚上偷窃</p><p>当只有一间房屋时，偷窃的最高金额就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></p><p>当房屋数量大于等于 2 时，考虑两种情况：</p><ul><li>可以偷窃第一间房屋、但不可以偷窃最后一间房屋，即，考虑偷窃 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, nums.size() - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 这一区间内的房屋</li><li>不可以偷窃第一间房屋、但可以偷窃最后一间房屋，即，考虑偷窃 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, nums.size() - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 这一区间内的房屋</li></ul><p>其中，每一种情况都可以按照 <a href="https://jiankychen.github.io/posts/be158ab">LeetCode 198. 打家劫舍</a> 中的方法求解</p><h2 id="method-动态规划-11"><a class="anchor" href="#method-动态规划-11">#</a> Method: 动态规划</h2><p>代码实现：</p><pre><code class="language-cpp">int robRange(vector&lt;int&gt;&amp; nums, int left, int right) &#123; // 打家劫舍，区间 nums[left, right]
    if (left == right) return nums[left];
    vector&lt;int&gt; dp(nums.size(), 0);
    dp[left] = nums[left];
    dp[left + 1] = max(nums[left], nums[left + 1]);
    for (int i = left + 2; i &lt;= right; i++)
        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
    return dp[right];
&#125;

int rob(vector&lt;int&gt;&amp; nums) &#123;
    if (nums.size() == 1) return nums[0];
    int result1 = robRange(nums, 0, nums.size() - 2); // 不考虑尾元素
    int result2 = robRange(nums, 1, nums.size() - 1); // 不考虑首元素
    return max(result1, result2);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-221-最大正方形"><a class="anchor" href="#leetcode-221-最大正方形">#</a> LeetCode 221. 最大正方形</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXNxdWFyZS8=">221. Maximal Square</span></p><p>在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/Example1.jpg" alt=""></p><pre><code>输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]
输出：4
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/Example2.jpg" alt=""></p><pre><code>输入：matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]
输出：1
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：matrix = [[&quot;0&quot;]]
输出：0
</code></pre><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li></ul><h2 id="method-动态规划-12"><a class="anchor" href="#method-动态规划-12">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组：dp [i][j] 表示以 (i, j) 为右下角、只包含 '1' 的正方形的最大边长</p><p>确定递推公式：</p><ul><li>如果位置 (i, j) 的值是 '0' ，则 dp [i][j] = 0</li><li>如果位置 (i, j) 的值是 '1' ，则 dp [i][j] 依赖于其上方、左方和左上方这三个相邻位置的 dp 值，dp [i][j] = min ({dp [i - 1][j - 1], dp [i - 1][j], dp [i][j - 1]}) + 1</li></ul><blockquote><p>需结合具体实例来理解递推公式，其详细证明可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1zcXVhcmUtc3VibWF0cmljZXMtd2l0aC1hbGwtb25lcy9zb2x1dGlvbi90b25nLWppLXF1YW4td2VpLTEtZGUtemhlbmctZmFuZy14aW5nLXppLWp1LXpoZW4tMi8=">力扣官方题解：统计全为 1 的正方形子矩阵</span></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;
    int m = matrix.size();
    int n = matrix[0].size();
    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
    int sideLength = 0; // 最大边长
    for (int i = 0; i &lt; m; ++i) &#123;
        for (int j = 0; j &lt; n; ++j) &#123;
            if (matrix[i][j] == '1') &#123;
                if (i == 0 || j == 0)
                    dp[i][j] = 1;
                else
                    dp[i][j] = min(&#123;dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]&#125;) + 1;
                sideLength = max(sideLength, dp[i][j]);
            &#125;
        &#125;
    &#125;
    int ans = sideLength * sideLength; // 面积
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是矩阵的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXNxdWFyZS9zb2x1dGlvbi96dWktZGEtemhlbmctZmFuZy14aW5nLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">leetcode-solution</span></p><h1 id="leetcode-27-移除元素"><a class="anchor" href="#leetcode-27-移除元素">#</a> LeetCode 27. 移除元素</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC8=">LeetCode 27. Remove Element</span></p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code> ，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><blockquote><p>由于在某些语言中无法改变数组的长度，必须让结果放在数组 <code>nums</code> 的最前面。因此，如果在去除重复元素后还有 k 个元素，那么应该将结果放在 <code>nums</code> 的前 k 个位置，并返回 k 。</p></blockquote><p>不要使用额外的数组空间，你必须仅使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 额外空间并 <strong>原地</strong> 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以「<strong>引用</strong>」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code class="language-cpp">int[] nums = [...]; // Input array
int val = ...;      // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k);           // Sort the first k elements of nums
for (int i = 0; i &lt; actualLength; i++) &#123;
    assert nums[i] == expectedNums[i];
&#125;
</code></pre><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
</code></pre><p></p><p><strong>限制</strong>:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-双指针"><a class="anchor" href="#method-1-双指针">#</a> Method 1: 双指针</h2><p><code>slow</code> 对应 将要被覆盖的位置， <code>fast</code> 对应 当前搜索位置，均初始化为 <code>0</code></p><p><code>fast</code> 右移，并进行如下操作，直到 <code>fast == nums.size() - 1</code> ：</p><ul><li><p>如果 <code>nums[fast] == val</code> ，跳过该元素</p></li><li><p>如果 <code>nums[fast] != val</code> ，令 <code>nums[slow] = nums[fast]</code> ，并让 <code>l</code> 右移一位</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
    int n = nums.size();
    int slow = 0;
    for (int fast = 0; fast &lt; n; fast++)
        if (nums[fast] != val) // 对值不为 val 的元素进行移位，值为 val 则跳过
            nums[slow++] = nums[fast];
    return slow;               // slow 即为 新数组的长度
&#125;
</code></pre><p>时间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为数组的长度</p><p>空间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-双指针优化"><a class="anchor" href="#method-2-双指针优化">#</a> Method 2: 双指针优化</h2><p>如果要移除的元素恰好在数组的开头，方法一需要把每一个元素都左移一位</p><p>可以定义两个指针，初始时分别指向数组的首尾，向中间移动遍历该序列（题目允许改变元素的顺序）</p><p>算法流程：</p><p>执行以下循环，直到 <code>left</code> 与 <code>right</code> 重合</p><ul><li>判断 <code>left</code> 的元素是否等于 <code>val</code><ul><li>若是，将 <code>right</code> 指向的元素复制到 <code>left</code> 的位置，然后 <code>right</code> 左移一位</li><li>若否， <code>left</code> 右移一位</li></ul></li></ul><blockquote><p>注意这里的 <code>right</code> 指向的元素也有可能是 <code>val</code> ，此时：</p><ul><li>可以选择将 <code>val</code> 赋值给 <code>left</code> ，然后 <code>right</code> 左移（在这种情况下，赋值后 <code>left</code> 位置的元素仍为 <code>val</code> ， <code>left</code> 不会移动）</li><li>也可以选择跳过该元素，即， <code>right</code> 直接左移</li></ul></blockquote><p>代码实现：</p><pre><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
    int left = 0, right = nums.size() - 1;
    while (left &lt; right) &#123;
        if (nums[left] == val)
            nums[left] = nums[right--];
        else
            left++;
    &#125;
    return left;
&#125;
</code></pre><p>时间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>与 Method 1 相比，Method 2 避免了值不为 <code>val</code> 元素的重复赋值操作</p><h1 id="leetcode-279-完全平方数"><a class="anchor" href="#leetcode-279-完全平方数">#</a> LeetCode 279. 完全平方数</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJmZWN0LXNxdWFyZXMv">279. Perfect Squares</span></p><p>给你一个整数 <code>n</code> ，返回 和为 <code>n</code> 的完全平方数的最少数量 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 12
输出：3
解释：12 = 4 + 4 + 4
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 13
输出：2
解释：13 = 4 + 9
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路-5"><a class="anchor" href="#思路-5">#</a> 思路</h2><p>可以将完全平方数视为背包问题中的物品，所需凑成的整数 n 即为背包最大容量，求解装满背包所需物品的最小数量</p><p>其中，物品可以重复选取，因此，本题是一个完全背包问题</p><h2 id="method-动态规划-13"><a class="anchor" href="#method-动态规划-13">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[j]</code> 表示凑成 <code>j</code> 所需完全平方数的最少数量，其中 <code>0 &lt;= j &lt;= n</code></p><p>递推公式：当 <code>j &gt;= i * i</code> 时，可选取 <code>i * i</code> ，也可不选取 <code>i * i</code> ，因此 <code>dp[j] = min(dp[j], 1 + dp[j - i * i])</code></p><p>初始化 dp 数组：如果和为 0 ，最少需要 0 个完全平方数，即 <code>dp[0] = 0</code> ，为确保递推公式的更新，应将任意 <code>j &gt; 0</code> 的 <code>dp[j]</code> 初始化为一个比较大的数值，例如 <code>INT_MAX</code></p><p>遍历顺序：完全平方数的选取顺序不影响最终结果，可以采用外层遍历物品、内层遍历背包容量，其中，物品、背包容量均需按照从小到大的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int numSquares(int n) &#123;
    vector&lt;int&gt; dp(n + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 1; i * i &lt;= n; i++) &#123; // 遍历物品
        for (int j = 1; j &lt;= n; j++) &#123; // 遍历背包容量
            if (j &gt;= i * i)
                dp[j] = min(dp[j], 1 + dp[j - i * i]);
        &#125;
    &#125;
    return dp[n];
&#125;
</code></pre><p>或者</p><pre><code class="language-cpp">int numSquares(int n) &#123;
    vector&lt;int&gt; dp(n + 1, INT_MAX);
    dp[0] = 0;
    for (int j = 1; j &lt;= n; j++) &#123;         // 遍历背包容量
        for (int i = 1; i * i &lt;= j; i++) &#123; // 遍历物品
            dp[j] = min(dp[j], 1 + dp[j - i * i]);
        &#125;
    &#125;
    return dp[n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times \sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-.25em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8002800000000001em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord" style="padding-left:.833em"><span class="mord mathnormal">n</span></span></span><span style="top:-2.76028em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.23972em"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-300-最长递增子序列"><a class="anchor" href="#leetcode-300-最长递增子序列">#</a> LeetCode 300. 最长递增子序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2Uv">300. Longest Increasing Subsequence</span></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如， <code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,0,3,2,3]
输出：4
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [7,7,7,7,7,7,7]
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2500</mn></mrow><annotation encoding="application/x-tex">\le 2500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：你能将算法的时间复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 吗？</p><h2 id="method-动态规划-14"><a class="anchor" href="#method-动态规划-14">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i]</code> 表示在 <code>[0, i]</code> 区间内，以 <code>nums[i]</code> 结尾的最长递增子序列的长度</p><p>确定递推公式：</p><ul><li><p>对任意一个满足条件 <code>0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code> 的 <code>nums[j]</code> 而言，可以在 以 <code>nums[j]</code> 结尾的最长递增子序列 之后再添加一个 <code>nums[i]</code> ，形成更长的递增子序列，其中，新的序列长度即为 <code>dp[j] + 1</code></p></li><li><p>因此，要想得到以 <code>nums[i]</code> 结尾的最长递增子序列，应将 <code>nums[i]</code> 添加在 满足 <code>0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code> 条件、且具有最大 <code>dp[j]</code> 的 <code>nums[j]</code> 之后，即， <code>dp[i] = max(dp[j]) + 1</code> ，其中 <code>0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code></p></li></ul><p>初始化 dp 数组：对于任意 <code>i</code> 而言， <code>nums[i]</code> 自身就是一个长度为 1 的递增子序列，因此，任意的 <code>dp[i]</code> 都应初始化为 1</p><p>确定遍历顺序：按 <code>i</code> 从小到大的顺序遍历</p><p>最后，从所有的 <code>dp[i]</code> 中找出最大值，即为最长递增子序列的长度</p><p>代码实现：</p><pre><code class="language-cpp">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    vector&lt;int&gt; dp(n, 1); // dp[i] 表示以 nums[i] 结尾的最长严格递增子序列的长度
    for (int i = 1; i &lt; n; i++) &#123;
        for (int j = 0; j &lt; i; j++) &#123;
            if (nums[i] &gt; nums[j]) // nums[i] 可以接在 nums[j] 之后，形成新的递增子序列
                dp[i] = max(dp[i], dp[j] + 1);
        &#125;
    &#125;
    int ans = 0; // 最长递增子序列的长度
    for (int i = 0; i &lt; n; i++) &#123;
        ans = max(ans, dp[i]);
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-贪心-二分查找"><a class="anchor" href="#method-2-贪心-二分查找">#</a> Method 2: 贪心 + 二分查找</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2Uvc29sdXRpb24venVpLWNoYW5nLXNoYW5nLXNoZW5nLXppLXh1LWxpZS1ieS1sZWV0Y29kZS1zb2x1dGkv">力扣官方题解</span></p><h1 id="leetcode-309-最佳买卖股票时机含冷冻期"><a class="anchor" href="#leetcode-309-最佳买卖股票时机含冷冻期">#</a> LeetCode 309. 最佳买卖股票时机含冷冻期</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtY29vbGRvd24v">309. Best Time to Buy and Sell Stock with Cooldown</span></p><p>给定一个整数数组 <code>prices</code> ，其中第 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [1,2,3,0,2]
输出：3
解释：对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1]
输出：0
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>prices[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-动态规划-15"><a class="anchor" href="#method-动态规划-15">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2,0))</code></p><ul><li><code>dp[i][0]</code> 表示第 <code>i</code> 天结束时不持有股票的最大利润</li><li><code>dp[i][1]</code> 表示第 <code>i</code> 天结束时持有股票的最大利润</li></ul><p>确定递推公式：</p><ul><li>第 <code>i</code> 天结束时不持有股票，即， <code>dp[i][0]</code><ul><li>若第 <code>i - 1</code> 天不持有股票，此时的利润为 <code>dp[i - 1][0]</code></li><li>若第 <code>i - 1</code> 天持有股票、第 <code>i</code> 天卖出股票，此时的利润为 <code>dp[i - 1][1] + prices[i]</code></li><li>综合两种情况得 <code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code></li></ul></li><li>第 <code>i</code> 天结束时持有股票，即， <code>dp[i][1]</code><ul><li>若第 <code>i - 2</code> 天不持有股票、第 <code>i</code> 天买入股票，此时的利润为 <code>dp[i - 2][0] - prices[i]</code> （购买股票具有 1 天的冷冻期，<strong>第 <code>i</code> 天买入股票要求第 <code>i - 2</code> 天已经卖出股票</strong>）</li><li>若第 <code>i - 1</code> 天持有股票，此时利润为 <code>dp[i - 1][1]</code></li><li>综合两种情况得 <code>dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i])</code></li></ul></li></ul><p>初始化 dp 数组：根据递推公式知，应初始化 <code>dp[0][]</code> 和 <code>dp[1][]</code></p><ul><li>第 0 天不持有股票：利润为 0 ，即 <code>dp[i][0] = 0</code></li><li>第 0 天持有股票：当前利润为 <code>- prices[0]</code> ，即 <code>dp[0][1] = - prices[0]</code></li><li>第 1 天不持有股票：若第 0 天不持有股票，则利润为 <code>0</code> ；若第 0 天持有股票、第 1 天卖出股票，则利润为 <code>prices[1] - prices[0]</code> 。因此， <code>dp[1][0] = max(0, prices[1] - prices[0])</code></li><li>第 1 天持有股票：若第 0 天买入股票，则利润为 <code>dp[0][1]</code> ；若第 1 天买入股票，则利润为 <code>- prices[1]</code> 。因此， <code>dp[1][1] = max(dp[0][1], - prices[1])</code></li></ul><p>遍历顺序：按 <code>i</code> 从小到大遍历</p><p>最后的 <code>dp[n - 1][0]</code> 即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
    int n = prices.size();
    if (n &lt;= 1) return 0;
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));
    dp[0][0] = 0;           // 第 0 天不持有股票时的最大利润
    dp[0][1] = - prices[0]; // 第 0 天持有股票时的最大利润
    dp[1][0] = max(dp[0][1] + prices[1], dp[0][0]);
    dp[1][1] = max(dp[0][0] - prices[1], dp[0][1]);
    for (int i = 2; i &lt; n; i++) &#123;
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i]); // 具有冷冻期
    &#125;
    return dp[n - 1][0];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 <code>prices</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-312-戳气球"><a class="anchor" href="#leetcode-312-戳气球">#</a> LeetCode 312. 戳气球</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy8=">312. Burst Balloons</span></p><p>有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums [i - 1] * nums [i] * nums [i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,5]
输出：10
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 300</li><li>0 &lt;= nums[i] &lt;= 100</li></ul><h2 id="method-1-记忆化搜索"><a class="anchor" href="#method-1-记忆化搜索">#</a> Method 1: 记忆化搜索</h2><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy9zb2x1dGlvbi9jaHVvLXFpLXFpdS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">leetcode-solution</span></p><h2 id="method-2-动态规划-2"><a class="anchor" href="#method-2-动态规划-2">#</a> Method 2: 动态规划</h2><p>算法思路：</p><p>题目告知 “i - 1 或者 i + 1 超出数组边界时相当于一个数字为 1 的气球”，因此，可以为数组的首尾分别添加元素 1，以便处理边界问题（定义辅助数组 <code>vector&lt;int&gt; val(nums.size() + 2)</code> ）</p><p>定义 dp 数组：<strong>dp [i][j] 表示戳破区间 (i, j) 内所有气球所能获得的最高分数</strong></p><p>初始化 dp 数组：当 i &gt;= j 时，开区间 (i, j) 内没有气球，dp [i][j] = 0</p><p>递推公式：</p><ul><li>假设 <strong>区间 (i, j) 内最后一个被戳破的气球</strong> 为 k<ul><li>在戳破气球 k 前，区间 (i, k) 内的所有气球均已被戳破，其获得的分数为 dp [i][k] ，区间 (k, j) 内的所有气球也均已被戳破，其获得的分数为 dp [k][j]</li><li>气球 k 左侧为气球 i ，气球 k 右侧为气球 j ，即：戳破 k 获得的分数为 val [i] * val [k] * val [j]</li><li>此时，区间 (i, j) 能获得的总分数为 dp [i][k] + val [i] * val [k] * val [j] + dp [k][j]</li></ul></li><li>由于区间 (i, j) 具有多个可选的最后一个气球 k ，需要枚举 k 并选择总分数最高的，因此，递推公式为： <code>dp[i][j] = max(dp[i][j], dp[i][k] + val[i] * val[k] * val[j] + dp[k][j])</code> ，其中， <code>i + 1 &lt;= k &lt;= j - 1</code></li></ul><p>遍历顺序：由递推公式可知，dp [i][j] 依赖于 dp [i][k] 和 dp [k][j] ，其中，i &lt; k 且 k &lt; j，因此，i 应按照从大到小的顺序遍历（为了获得 dp [k][j] ），j 应按照从小到大的顺序遍历（为了获得 dp [i][k] ）</p><blockquote><p>或者，也可以按照对角线从左到右的顺序斜着遍历 dp 数组</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int maxCoins(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    vector&lt;int&gt; val(n + 2, 0); // 创建一个辅助数组（在首尾各添 1），处理边界情况
    val[0] = val[n + 1] = 1;
    for (int i = 1; i &lt;= n; ++i)
        val[i] = nums[i - 1];
    vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0));
    for (int i = n; i &gt;= 0; --i) &#123; // 区间的左端点（开区间）
        for (int j = i + 1; j &lt; n + 2; ++j) &#123; // 区间的右端点（开区间）
            for (int k = i + 1; k &lt; j; ++k) &#123; // 区间内最后戳破的气球
                int tmp = dp[i][k] + val[i] * val[k] * val[j] + dp[k][j];
                dp[i][j] = max(dp[i][j], tmp); // 择优做选择
            &#125;
        &#125;
    &#125;
    return dp[0][n + 1];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度</p><ul><li>状态数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li><li>状态转移的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy9zb2x1dGlvbi90dS1qaWUtZG9uZy10YWktZ3VpLWh1YS1qaWUtanVlLWNodW8tcWktY3gxOGgv">angela：图解：动态规划解决戳气球问题，思路清晰简明，注释详细</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy9zb2x1dGlvbi96aGUtZ2UtY2FpLXB1LXppLWppLXphaS1qaWEteWUtbmVuZy16dW8tZ3Vhbi1qaWFuLS8=">xiao-yan-gou：关键思路解释</span></li></ul><h1 id="leetcode-32-最长有效括号"><a class="anchor" href="#leetcode-32-最长有效括号">#</a> LeetCode 32. 最长有效括号</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzLw==">32. Longest Valid Parentheses</span></p><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;(()&quot;
输出：2
解释：最长有效括号子串是 &quot;()&quot;
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;)()())&quot;
输出：4
解释：最长有效括号子串是 &quot;()()&quot;
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;&quot;
输出：0
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 3 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li></ul><h2 id="method-动态规划-16"><a class="anchor" href="#method-动态规划-16">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp [i] 表示以 s [i] 结尾的最长有效括号的长度</p><p>初始化 dp [i] ：全都初始化为 0</p><p>推导 dp [i] 的状态转移过程：</p><ul><li>若 s [i] == '(' ，无法形成以 s [i] 结尾的有效括号，则 dp [i] = 0</li><li>若 s [i] == ')' ，需要进一步分析前面的字符<ul><li>若 s [i - 1] == '(' ，则 s [i - 1] 可以与 s [i] 组成一对有效括号，因此：<ul><li>若 i - 2 &lt;0 ，即 s [0, i] = &quot;()&quot; ，有 dp [i] = 2</li><li>若 i - 2 &gt;= 0 ，以 s [i] 结尾的最长有效括号的长度为 dp [i - 2] + 2</li></ul></li><li>若 s [i - 1] == ')' ，以 s [i] 结尾的最长有效括号只能是形如 “((...))” 的括号对，此时需要找到与 s [i] 配对的位置，即，i - dp [i - 1] - 1<ul><li>若 i - dp [i - 1] - 1 &gt;= 0 且 s [i - dp [i - 1] - 1] == '(' ，则 s [i - dp [i - 1] - 1] 可以与 s [i] 组成有效括号，即，以 s [i] 结尾的最长有效括号的长度至少为 dp [i - 1] + 2<ul><li>需注意的是：可能存在以 s [i - dp [i - 1] - 2] 结尾的有效括号，即，可以将 “以 s [i - dp [i - 1] - 2] 结尾的有效括号” 与 “以 s [i - dp [i - 1] - 1] 起始的、以 s [i] 结尾的有效括号” 拼接</li><li>因此，如果 i - dp [i - 1] - 2 &gt;= 0 ，则以 s [i] 结尾的最长有效括号的长度为 dp [i - dp [i - 1] - 2] + dp [i - 1] + 2</li></ul></li></ul></li></ul></li></ul><p>确定遍历顺序：根据递推公式知，dp [i] 依赖于 dp [i - 1] 、dp [i - 2] 、dp [i - dp [i - 1] - 2] ，因此，应按照 i 从小到大的顺序遍历</p><p>遍历结束后，找出值最大的 dp [i] ，即为最长有效括号的长度</p><p>代码实现：</p><pre><code class="language-cpp">int longestValidParentheses(string s) &#123;
    vector&lt;int&gt; dp(s.size(), 0);
    int ans = 0;
    for (int i = 1; i &lt; s.size(); i++) &#123;
        if (s[i] == ')') &#123;
            if (s[i - 1] == '(') &#123;
                if (i &gt;= 2) dp[i] = dp[i - 2] + 2;
                else dp[i] = 2;
            &#125; else if (i - dp[i - 1] - 1 &gt;= 0 &amp;&amp; s[i - dp[i - 1] - 1] == '(') &#123;
                dp[i] = dp[i - 1] + 2;
                if (i - dp[i - 1] - 2 &gt;= 0) &#123;
                    dp[i] = dp[i] + dp[i - dp[i - 1] - 2];
                &#125;
            &#125;
            ans = max(ans, dp[i]);
        &#125;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是 <code>s</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzL3NvbHV0aW9uL3p1aS1jaGFuZy15b3UteGlhby1ndWEtaGFvLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解</span></p><h1 id="leetcode-322-零钱兑换"><a class="anchor" href="#leetcode-322-零钱兑换">#</a> LeetCode 322. 零钱兑换</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS8=">322. Coin Change</span></p><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><pre><code>输入：coins = [1,2,5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：coins = [2], amount = 3
输出：-1
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：coins = [1], amount = 0
输出：0
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>coins.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">\le 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">2</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>coins[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>amount</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路-6"><a class="anchor" href="#思路-6">#</a> 思路</h2><p>每种面额的硬币可以重复选取，因此，本题属于完全背包问题，可以采用动态规划方法求解</p><p>其中，选取硬币的顺序并不影响结果，因此，外层遍历物品、内层遍历背包容量，或者，外层遍历背包容量、内层遍历物品，这两种遍历方案都可以</p><h2 id="method-动态规划-17"><a class="anchor" href="#method-动态规划-17">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[j]</code> 表示凑成金额 <code>j</code> 所需的最少硬币个数，其中 <code>0 &lt;= j &lt;= amount</code></p><p>递推公式：当 <code>coins[i] &lt;= j &lt;= amount</code> 时，若 <code>dp[j - coins[i]] != INT_MAX</code> ， <code>dp[j] = min(dp[j], 1 + dp[j - coins[i]])</code></p><ul><li>当 <code>j &lt; coins[i]</code> 时，不能选取 <code>coins[i]</code> ， <code>dp[j]</code> 保持不变</li><li>当 <code>coins[i] &lt;= j &lt;= amount</code> 时，若选取 <code>coins[i]</code> ，所需的最少硬币数为 <code>1 + dp[j - coins[i]]</code> （注意，此时要求金额 <code>j - coins[i]</code> 是可以被凑出来的，即， <code>dp[j - coins[i]]</code> 不等于初始值），若不选取 <code>coins[i]</code> ，所需的最少硬币数为 <code>dp[j]</code> ，综合可得， <code>dp[j] = min(dp[j], 1 + dp[j - coins[i]])</code></li></ul><p>初始化 dp 数组：凑成金额 0 的硬币个数一定为 0 ，即， <code>dp[0] = 0</code> 。考虑到递推公式的特性， <code>dp[j]</code> 必须初始化为一个比较大的数值，以便在执行 <code>dp[j] = min(dp[j], 1 + dp[j - coins[i]])</code> 时能够更新 dp 数组，因此，对任意 <code>j &gt; 0</code> 均有 <code>dp[j] = INT_MAX</code></p><p>遍历顺序：硬币的选取顺序不影响所需的最少硬币个数，可以采用外层遍历硬币面额（物品）、内层遍历金额之和（背包容量）</p><p>遍历结束后，若 <code>dp[amount]</code> 等于初始值 <code>INT_MAX</code> ，则说明任何一种硬币组合都无法组成金额 <code>amount</code> ，故而返回 <code>-1</code> ，否则， <code>dp[amount]</code> 表示的就是所需的最少硬币个数</p><p>代码实现：</p><pre><code class="language-cpp">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;
    vector&lt;int&gt; dp(amount + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 0; i &lt; coins.size(); i++) &#123;
        for (int j = coins[i]; j &lt;= amount; j++) &#123;
            if (dp[j - coins[i]] != INT_MAX) // 方案可行
                dp[j] = min(dp[j], 1 + dp[j - coins[i]]);
        &#125;
    &#125;
    if (dp[amount] == INT_MAX) return -1;    // 不存在可行的方案
    return dp[amount];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzMjIuJUU5JTlCJUI2JUU5JTkyJUIxJUU1JTg1JTkxJUU2JThEJUEyLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p><h1 id="leetcode-337-打家劫舍-iii"><a class="anchor" href="#leetcode-337-打家劫舍-iii">#</a> LeetCode 337. 打家劫舍 III</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXItaWlpLw==">337. House Robber III</span></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个 “父 “房子与之相连。一番侦察之后，聪明的小偷意识到 “这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回 <strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p><p><strong>示例 1：</strong></p><pre><code>输入：root = [3,2,3,null,3,null,1]
输出：7
解释：小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [3,4,5,1,3,null,1]
输出：9
解释：小偷一晚能够盗取的最高金额 4 + 5 = 9
</code></pre><p><strong>提示：</strong></p><ul><li>树的节点数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 范围内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-递归-动态规划"><a class="anchor" href="#method-递归-动态规划">#</a> Method: 递归 + 动态规划</h2><p>确定递归函数的参数和返回值：</p><ul><li>传入参数： <code>TreeNode* root</code></li><li>返回值： <code>vector&lt;int&gt;&#123;val1, val2&#125;</code><ul><li><code>val1</code> 表示不偷窃 <code>root</code> 节点时，从 <code>root</code> 的子树上偷窃所得的最大金额</li><li><code>val2</code> 表示偷窃 <code>root</code> 节点时，从 <code>root</code> 及其子树上偷窃所得的最大金额</li></ul></li></ul><p>确定递归的终止条件：遇到空节点，无论是否偷窃，所得金额均为 0 ，故而返回 <code>vector&lt;int&gt;(2, 0)</code></p><p>确定遍历顺序：采用后序遍历，因为需要根据子节点的返回值来处理当前节点</p><p>单层递归的逻辑：</p><ul><li>递归左子树，计算偷窃左子节点、不偷窃左子节点所能达到的金额，分别记为 <code>left[0]</code> , <code>left[1]</code></li><li>递归右子树，计算偷窃右子节点、不偷窃右子节点所能达到的金额，分别记为 <code>right[0]</code> , <code>right[1]</code></li><li>处理当前节点<ul><li>如果不偷窃当前节点，则可以考虑偷窃子节点（并不一定要偷窃子节点），从左子树上所能得到的最大金额为 <code>max(left[0], left[1])</code> ，从右子树上所能得到的最大金额为 <code>max(right[0], right[1])</code> ，因此，总金额为 <code>val1 = max(left[0], left[1]) + max(right[0], right[1])</code></li><li>如果偷窃当前节点，则不能偷窃子节点，从左子树上得到的最大金额为 <code>left[0]</code> ，从右子树上得到的最大金额为 <code>right[0]</code> ，因此，总金额为 <code>val2 = root-&gt;val + left[0] + right[0]</code></li></ul></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; dfs(TreeNode* root) &#123;
    if (root == nullptr) return vector&lt;int&gt;&#123;0, 0&#125;;
    vector&lt;int&gt; left = dfs(root-&gt;left);
    vector&lt;int&gt; right = dfs(root-&gt;right);
    int val1 = max(left[0], left[1]) + max(right[0], right[1]); // 偷窃 root 节点
    int val2 = root-&gt;val + left[0] + right[0];                  // 不偷窃 root 节点
    return vector&lt;int&gt;&#123;val1, val2&#125;;
&#125;

int rob(TreeNode* root) &#123;
    vector&lt;int&gt; result = dfs(root);
    int ans = max(result[0], result[1]); // 处理根节点
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p><h1 id="leetcode-343-整数拆分"><a class="anchor" href="#leetcode-343-整数拆分">#</a> LeetCode 343. 整数拆分</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlZ2VyLWJyZWFrLw==">343. Integer Break</span></p><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 正整数 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p><p>返回 可以获得的最大乘积 。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2
输出：1
解释：2 = 1 + 1, 1 × 1 = 1.
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 10
输出：36
解释：10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>58</mn></mrow><annotation encoding="application/x-tex">\le 58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">8</span></span></span></span></li></ul><h2 id="method-动态规划-18"><a class="anchor" href="#method-动态规划-18">#</a> Method: 动态规划</h2><p>算法思路：</p><ol><li><p>确定 <code>dp</code> 数组及其含义： <code>dp[i]</code> 表示将正整数 <code>i</code> 拆分后所能得到的最大乘积</p></li><li><p>确定递推公式：</p><ul><li>假设拆分 <code>i</code> （ <code>i &gt;= 2</code> ）所得的第一个数为 <code>j</code> （ <code>1 &lt;= j &lt; i</code> ），还剩 <code>i - j</code> ，做以下考虑<ul><li>不再拆分 <code>i - j</code> ，此时的乘积为 <code>j * (i - j)</code></li><li>继续将 <code>i - j</code> 拆成多个整数的和，此时的最大乘积为 <code>j * dp[i - j]</code></li><li>因此，对给定的 <code>j</code> ，最大乘积为 <code>max(j * (i - j), j * dp[i - j])</code></li></ul></li><li>由于 <code>j</code> 可取 <code>[1, i - 1]</code> 区间内任意值，应遍历 <code>j</code> 才能得到 <code>dp[i]</code> ，即， <code>dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</code></li></ul></li><li><p>初始化 <code>dp</code> 数组：可拆分的最小正整数为 2，而拆分 2 所得的最大乘积为 1 ，故而应初始化 <code>dp[2] = 1</code></p></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code> 依赖于 <code>dp[i - j]</code> ，故而应按 <code>i</code> 从小到大的顺序遍历；至于 <code>j</code> ，按从小到大顺序或从大到小顺序遍历均可</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int integerBreak(int n) &#123;
    vector&lt;int&gt; dp(n + 1, 0);
    dp[2] = 1;
    for (int i = 3; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt; i; j++) &#123;
            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
        &#125;
    &#125;
    return dp[n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAzNDMuJUU2JTk1JUI0JUU2JTk1JUIwJUU2JThCJTg2JUU1JTg4JTg2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p><h1 id="leetcode-377-组合总和-iv"><a class="anchor" href="#leetcode-377-组合总和-iv">#</a> LeetCode 377. 组合总和 IV</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taXYv">377. Combination Sum IV</span></p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [9], target = 3
输出：0
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>nums</code> 中的所有元素 互不相同</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>target</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶：</strong> 如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><h2 id="思路-7"><a class="anchor" href="#思路-7">#</a> 思路</h2><p><code>nums</code> 的每个元素可以选取多次，且需要考虑选取元素的顺序，因此本题计算的是选取元素的 <strong>排列</strong> 数</p><p>可以通过动态规划方法求解</p><p>其中，遍历顺序应为：外层 for 循环遍历背包容量，内层 for 循环遍历物品</p><h2 id="method-动态规划-19"><a class="anchor" href="#method-动态规划-19">#</a> Method: 动态规划</h2><p>算法思路</p><p>定义 dp 数组： <code>dp[j]</code> 表示选取元素之和等于 <code>j</code> 的硬币组合数，其中， <code>0 &lt;= j &lt;= target</code></p><p>递推公式： <code>dp[j] += dp[j - nums[i]], nums[i] &lt;= j &lt;= target</code></p><ul><li>若 <code>j &lt; nums[i]</code> ，不能选取 <code>nums[i]</code> ，因此， <code>dp[j]</code> 保持不变</li><li>若 <code>j &gt;= nums[i]</code> ，如果选取 <code>nums[i]</code> ，方案数应为 <code>dp[j - nums[i]]</code> ，如果不选取 <code>nums[i]</code> ，方案数应为 <code>dp[j]</code> ，综合两种情况，总的方案数为 <code>dp[j] = dp[j] + dp[j - nums[i]]</code></li></ul><p>初始化 dp 数组：不选取任何元素，元素之和才为 0 ，即， <code>dp[0] = 1</code></p><p>遍历顺序：<strong>由于所求的是排列数，外层 for 循环应遍历元素之和（背包容量），内层 for 循环应遍历数组元素（物品），并且，均按照从小到大的顺序遍历</strong></p><p>C++ 测试用例有两个数相加超过 <code>int</code> 的数据，因此需要加上 <code>dp[j] + dp[j - nums[i]] &lt; INT_MAX</code> 这一限制</p><p>代码实现：</p><pre><code class="language-cpp">int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;
    vector&lt;int&gt; dp(target + 1, 0);
    dp[0] = 1;
    for (int j = 0; j &lt;= target; j++) &#123;
        for (int i = 0; i &lt; nums.size(); i++) &#123;
            if (j &gt;= nums[i] &amp;&amp; dp[j] + dp[j - nums[i]] &lt; INT_MAX)
                dp[j] += dp[j - nums[i]];
        &#125;
    &#125;
    return dp[target];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><h1 id="进阶"><a class="anchor" href="#进阶">#</a> 进阶</h1><p>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p>如果给定的数组中含有负数，则会导致出现无限长度的排列</p><p>例如，假设数组中含有正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span> 和负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>−</mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">−b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.77777em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord mathnormal">b</span></span></span></span>（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.73354em;vertical-align:-.0391em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> ），则对于任意一个元素之和等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 的排列，都可以在该排列的后面添加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">b</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>−</mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">−b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.77777em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord mathnormal">b</span></span></span></span> ，使得新排列的元素之和依然等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 。换而言之，只要存在一种符合条件的排列，就能构造出无限长度的排列</p><p>因此，必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taXYvc29sdXRpb24venUtaGUtem9uZy1oZS1pdi1ieS1sZWV0Y29kZS1zb2x1dGlvbi1xOHp2Lw==">力扣官方题解</span></p><h1 id="leetcode-392-判断子序列"><a class="anchor" href="#leetcode-392-判断子序列">#</a> LeetCode 392. 判断子序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pcy1zdWJzZXF1ZW5jZS8=">392. Is Subsequence</span></p><p>给定字符串 <code>s</code> 和 <code>t</code> ，判断 <code>s</code> 是否为 <code>t</code> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot; 是 &quot;abcde&quot; 的一个子序列，而 &quot;aec&quot; 不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S<sub>1</sub>, S<sub>2</sub>, ... , S<sub>k</sub> ，其中 k <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≥</span></span></span></span> 10<sup>9</sup>，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;
输出：true
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;
输出：false
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>t.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><code>s</code> 和 <code>t</code> 都只由小写字符组成</li></ul><h2 id="method-1-双指针-2"><a class="anchor" href="#method-1-双指针-2">#</a> Method 1: 双指针</h2><p>算法思路：如果能够在字符串 <code>t</code> 中依次找到字符串 <code>s</code> 的每个字符，则说明 <code>s</code> 是 <code>t</code> 的子序列</p><p>算法流程：</p><p>定义指针 <code>i</code> 指向字符串 <code>s</code> ，指针 <code>j</code> 指向字符串 <code>t</code></p><p>遍历 <code>i</code> 与 <code>j</code> ：</p><ul><li>若 <code>s[i] == t[j]</code> ，说明在字符串 <code>t</code> 中找到了字符 <code>s[i]</code> ，可以继续寻找下一个字符，因此，同时移动 <code>i</code> 和 <code>j</code> ，</li><li>若 <code>s[i] != t[j]</code> ，则需继续在字符串 <code>t</code> 中寻找 <code>s[i]</code> ，因此，移动 <code>j</code></li></ul><p>遍历结束时，若 <code>i</code> 指向 <code>s</code> 的尾后，则说明 <code>s</code> 的所有字符都已在字符串 <code>t</code> 中找到，即，字符串 <code>s</code> 是字符串 <code>t</code> 的子序列</p><p>代码实现：</p><pre><code class="language-cpp">bool isSubsequence(string s, string t) &#123;
    int i = 0;
    int j = 0;
    while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;
        if (s[i] == t[j]) i++;      // 字符串 t 中包含字符 s[i]
        j++;
    &#125;
    if (i == s.size()) return true; // 字符串 t 中包含 s 的所有字符
    return false;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串 <code>s</code> 和字符串 <code>t</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-动态规划-3"><a class="anchor" href="#method-2-动态规划-3">#</a> Method 2: 动态规划</h2><p>算法思路：可以通过计算字符串 <code>s</code> 与字符串 <code>t</code> 的最长公共子序列长度来判断：若最长公共子序列长度等于字符串 <code>s</code> 的长度，则字符串 <code>s</code> 是字符串 <code>t</code> 的子序列；否则， <code>s</code> 不是 <code>t</code> 的子序列</p><p>可参考 <a href="https://jiankychen.github.io/posts/c261e90a">LeetCode 1143. 最长公共子序列</a></p><p>算法流程：</p><p>定义 <code>dp[i][j]</code> 表示子串 <code>s[0, i -1]</code> 与子串 <code>t[0, j - 1]</code> 的最长公共子序列的长度</p><p>若 <code>s[i - 1] == t[j - 1]</code> ，则在 <code>s[0, i - 2]</code> 与 <code>t[0, j - 2]</code> 的基础上又找到了一个相同字符，因此， <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p><p>若 <code>s[i - 1] != t[j - 1]</code> ，则 <code>s[0, i - 1]</code> 与 <code>t[0, j - 2]</code> 的最长公共子序列就是 <code>s[0, i - 1]</code> 与 <code>t[0, j - 1]</code> 的最长公共子序列，因此， <code>dp[i][j] = dp[i][j - 1]</code></p><p>代码实现：</p><pre><code class="language-cpp">bool isSubsequence(string s, string t) &#123;
    vector&lt;vector&lt;int&gt;&gt; dp(s.size() + 1, vector&lt;int&gt;(t.size() + 1, 0)); // dp[i][j] 表示 s[0, i - 1] 与 t[0, j - 1] 的最长公共子序列的长度
    for (int i = 1; i &lt;= s.size(); i++) &#123;
        for (int j = 1; j &lt;= t.size(); j++) &#123;
            if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = dp[i][j - 1];
        &#125;
    &#125;
    return dp[s.size()][t.size()] == s.size();
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是字符串 <code>s</code> 和字符串 <code>t</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="进阶-2"><a class="anchor" href="#进阶-2">#</a> 进阶</h2><p>在前面的双指针法中，有大量的时间用于在 <code>t</code> 中找到下一个匹配字符</p><p>因此，可对字符串 <code>t</code> 进行预处理，计算出 “字符串 <code>t</code> 中任意位置到某字符下次出现时的距离” ，例如， <code>i</code> 位置 与 <code>i</code> 右侧第一次出现字符 <code>j</code> 位置的距离</p><p>为此，可将 dp 数组定义为： <code>dp[i][j]</code> 表示在字符串 <code>t</code> 中的位置 <code>i</code> 以右（包含 <code>i</code> ），字符 <code>j + 'a'</code> 第一次出现的位置</p><p>此时，对字符串 <code>t</code> 的预处理是与字符串 <code>s</code> 无关的，并且，在预处理完成后，可以利用 dp 数组信息计算出任意一个字符串 <code>s</code> 是否为 <code>t</code> 的子串，由此可解决 进阶 中的问题</p><p>具体可参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pcy1zdWJzZXF1ZW5jZS9zb2x1dGlvbi9wYW4tZHVhbi16aS14dS1saWUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解</span></p><h1 id="leetcode-416-分割等和子集"><a class="anchor" href="#leetcode-416-分割等和子集">#</a> LeetCode 416. 分割等和子集</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tZXF1YWwtc3Vic2V0LXN1bS8=">416. Partition Equal Subset Sum</span></p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-动态规划-20"><a class="anchor" href="#method-动态规划-20">#</a> Method: 动态规划</h2><p>传统的 0-1 背包问题要求选取的物品的重量之和不超过背包的总容量，本题则要求选取的数字的和恰好等于数组元素和的一半（记作 <code>target</code> ）</p><h2 id="思路一"><a class="anchor" href="#思路一">#</a> 思路一</h2><p>首先判断数组是否可拆分：</p><ul><li>若数组长度小于 2，不可能将将数组分成元素和相等的两个子集</li><li>若数组元素和为奇数，不可能将数组分成符合条件的两个子集</li><li>若 数组最大元素 超过 <code>target</code> ，也不可能将数组分成符合条件的两个子集</li></ul><p>定义 <code>dp</code> 数组： <code>dp[i][j]</code> 表示 是否能从下标 <code>[0, i]</code> 的数组元素中选取若干正整数，使得被选取的元素之和等于 <code>j</code> ，其中， <code>0 &lt;= 0 &lt;= nums.size() - 1</code> ， <code>0 &lt;= j &lt;= target</code></p><p>确定递推公式：</p><ul><li>若 <code>j &gt;= nums[i]</code> ，做以下考虑<ul><li>选取 <code>nums[i]</code> ，则 <code>dp[i][j] = dp[i - 1][j - nums[i]]</code></li><li>不选取 <code>nums[i]</code> ，则 <code>dp[i][j] = dp[i - 1][j]</code></li><li>两种情况只要有一个为 <code>true</code> 就会有 <code>dp[i][j]</code> 为 <code>true</code> ，因此， <code>dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]</code></li></ul></li><li>若 <code>j &lt; nums[i]</code> ，则 <code>nums[i]</code> 必不可能选取，因此有 <code>dp[i][j] = dp[i - 1][j]</code></li></ul><p>初始化 <code>dp</code> 数组：</p><ul><li>当 <code>i</code> 为 0 时，只有 <code>nums[0]</code> 可被选取，故而 <code>dp[0][nums[0]] = true</code> 且 <code>dp[0][0] = true</code> （这一步要求 <code>nums[0]</code> 不大于 <code>target</code> ，而我们此前判断了数组最大元素是否超过 <code>target</code> ）</li><li>当 <code>j</code> 为 0 时，对任意 <code>i</code> 均有 <code>dp[i][0] = true</code> ，即，不选取任何数</li></ul><p>代码实现：</p><pre><code class="language-cpp">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    
    // 判断数组是否可拆分
    if (n &lt; 2) return false;
    int sum = 0;
    int maxValue = 0;
    for (auto a : nums) &#123;
        sum += a;
        maxValue = max(maxValue, a);
    &#125;
    if (sum % 2 == 1) return false; // sum 为奇数，不可分割
    int target = sum / 2;
    if (maxValue &gt; target) return false;

    // 定义 dp 数组及其初始化
    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(target + 1, false));
    for (int i = 0; i &lt; n; i++)
        dp[i][0] = true;
    dp[0][nums[0]] = true;

    // 遍历
    for (int i = 1; i &lt; n; i++) &#123;
        for (int j = 1; j &lt;= target; j++) &#123;
            if (j &lt; nums[i])
                dp[i][j] = dp[i - 1][j];
            else
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
        &#125;
    &#125;

    return dp[n - 1][target];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 是数组元素和的一半</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>可采用一维 <code>dp</code> 数组实现，以优化算法空间复杂度</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tZXF1YWwtc3Vic2V0LXN1bS9zb2x1dGlvbi9mZW4tZ2UtZGVuZy1oZS16aS1qaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解</span></p><h2 id="思路二"><a class="anchor" href="#思路二">#</a> 思路二</h2><p>本题可以将 <code>target</code> 当成背包的最大容量，并将 <code>nums[i]</code> 同时当成物品的重量和物品的价值。当背包内物品的总价值恰好等于 <code>target</code> 时，说明可以将 <code>nums</code> 数组分割成元素和相等的两个子集</p><p>首先判断数组是否可拆分：</p><ul><li>若数组长度小于 2，不可能将将数组分成元素和相等的两个子集</li><li>若数组元素和为奇数，不可能将数组分成符合条件的两个子集</li></ul><p>定义 <code>dp</code> 数组：在 <code>[0, i]</code> 范围内选择物品，放进容量为 <code>j</code> 的背包内，其最大价值为 <code>dp[i][j]</code> ，其中， <code>0 &lt;= 0 &lt;= nums.size() - 1</code> ， <code>0 &lt;= j &lt;= target</code></p><p>确定递推公式：当 <code>j &gt;= nums[i]</code> 时， <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i])</code></p><ul><li>若 <code>j &gt;= nums[i]</code> ，做以下考虑<ul><li>选取 <code>nums[i]</code> ，此时，背包最大价值为 <code>dp[i - 1][j - nums[i]] + nums[i]</code></li><li>不选取 <code>nums[i]</code> ，此时，背包最大价值为 <code>dp[i - 1][j]</code></li><li>综合两种情况，应选择价值最大的，即 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i])</code></li></ul></li><li>若 <code>j &lt; nums[i]</code> ，则 <code>nums[i]</code> 必不可能选取，因此有 <code>dp[i][j] = dp[i - 1][j]</code></li></ul><p>初始化 <code>dp</code> 数组：</p><ul><li>当 <code>i = 0</code> 时，若 <code>j &lt; nums[0]</code> ，背包放不下物品 0 ，则 <code>dp[0][j] = 0</code> ，若 <code>j &gt;= nums[0]</code> ，应选取物品 0 使得背包价值最大，即 <code>dp[0][j] = nums[0]</code></li><li>当背包容量为 0 时， <code>dp[i][0] = 0</code></li></ul><p>其代码实现类似于思路一，这里不再给出具体代码</p><p>鉴于空间复杂度较高，下面给出一维 <code>dp</code> 数组的代码实现：</p><pre><code class="language-cpp">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    if (n &lt; 2) return false;
    int sum = 0;
    for (int i = 0; i &lt; n; i++)
        sum += nums[i];
    if (sum % 2) return false;
    int target = sum / 2;

    // 0-1 背包
    vector&lt;int&gt; dp(target + 1, 0);
    for (int i = 0; i &lt; n; i++)
        for (int j = target; j &gt;= nums[i]; j--)
            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

    return dp[target] == target ? true : false; // 判断背包最大价值是否恰好为 target
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 是数组元素和的一半</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0MTYuJUU1JTg4JTg2JUU1JTg5JUIyJUU3JUFEJTg5JUU1JTkyJThDJUU1JUFEJTkwJUU5JTlCJTg2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p><h1 id="leetcode-474-一和零"><a class="anchor" href="#leetcode-474-一和零">#</a> LeetCode 474. 一和零</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vbmVzLWFuZC16ZXJvZXMv">474. Ones and Zeroes</span></p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：strs = [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：strs = [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m = 1, n = 1
输出：2
解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>strs.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>600</mn></mrow><annotation encoding="application/x-tex">\le 600</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>strs[i].length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>strs[i]</code> 仅由 <code>'0'</code> 和 <code>'1'</code> 组成</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>m</code> , <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-8"><a class="anchor" href="#思路-8">#</a> 思路</h2><p>本题和 0-1 背包问题非常相似，但是本题的背包有两种容量，即选取的字符串子集中的 0 和 1 的数量上限</p><p>因此，动态规划需要遍历三个维度：字符串、0 的容量、1 的容量</p><h2 id="method-动态规划-21"><a class="anchor" href="#method-动态规划-21">#</a> Method: 动态规划</h2><p>算法思路：</p><ol><li><p><code>dp</code> 数组</p><ul><li><code>dp[i][j][k]</code> ：在确保 0 的个数不超过 <code>i</code> 、1 的个数不超过 <code>j</code> 的情况下，从索引 <code>[0, i]</code> 范围内选出字符串，所能达到的最大子集的长度</li><li>其中， <code>0 &lt;= i &lt;= strs.size() - 1</code> ， <code>0 &lt;= j &lt;= m</code> ， <code>0 &lt;= k &lt;= n</code></li></ul></li><li><p>递推公式：当 <code>1 &lt;= i &lt; strs.size()</code> 时，计算 <code>strs[i]</code> 中 0 和 1 的个数，分别记作 <code>num0</code> 和 <code>num1</code></p><ul><li>若 <code>j &lt; num0</code> 或 <code>k &lt; num1</code> ：不能选取 <code>strs[i]</code> 这一字符串，此时， <code>dp[i][j][k] = dp[i - 1][j][k]</code></li><li>若 <code>j &gt;= num0</code> 且 <code>k &gt;= num1</code> ：如果选取 <code>strs[i]</code> ，最大子集的长度为 <code>1 + dp[i - 1][j - num0][k - num1]</code> ，如果不选取 <code>strs[i]</code> ，最大子集的长度为 <code>dp[i - 1][j][k]</code> ，因此， <code>dp[i][j][k] = max(1 + dp[i - 1][j - num0][k - num1], dp[i - 1][j][k])</code></li></ul></li><li><p>初始化 <code>dp</code> 数组：当 <code>i = 0</code> 时，对满足 <code>j &gt;= num0 &amp;&amp; k &gt;= num1</code> 的任意 <code>j</code> 和 <code>k</code> ，都应选取 <code>strs[0]</code> 这一字符串，即， <code>dp[0][j][k] = 1</code></p></li><li><p>遍历顺序</p><ul><li>最外层遍历 <code>i</code> ，按从小到大顺序遍历</li><li>中层遍历 <code>j</code> ，按从小到大顺序遍历</li><li>内层遍历 <code>k</code> ，按从小到大顺序遍历</li></ul></li></ol><blockquote><p>也可以中层遍历 <code>k</code> ，内层遍历 <code>j</code></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int numberOfZero(string s) &#123; // 统计字符串 s 中的 0 的个数
    int count = 0;
    for (auto c : s)
        if (c == '0') count++;
    return count;
&#125;

int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;
    
    // 定义 dp 数组
    int size = strs.size();
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(size, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(n + 1, 0)));
    
    // 初始化
    int num0 = numberOfZero(strs[0]);
    int num1 = strs[0].size() - num0;
    for (int j = num0; j &lt;= m; j++) &#123;
        for (int k = num1; k &lt;= n; k++) &#123;
            dp[0][j][k] = 1;
        &#125;
    &#125;

    // 遍历
    for (int i = 1; i &lt; size; i++) &#123;
        num0 = numberOfZero(strs[i]);
        num1 = strs[i].size() - num0;
        for (int j = 0; j &lt;= m; j++) &#123;
            for (int k = 0; k &lt;= n; k++) &#123;
                if (num0 &lt;= j &amp;&amp; num1 &lt;= k)
                    dp[i][j][k] = max(dp[i - 1][j][k], 1 + dp[i - 1][j - num0][k - num1]);
                else
                    dp[i][j][k] = dp[i - 1][j][k];
            &#125;
        &#125;
    &#125;

    // 返回目标值
    return dp[size - 1][m][n];
    
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n + L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> 是数组 <code>strs</code> 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span> 是数组 <code>strs</code> 中所有字符串的长度之和</p><ul><li>动态规划需要分别遍历 <code>i</code> 、 <code>j</code> 、 <code>k</code> ，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>需要计算 <code>strs</code> 中每个字符串的 0 和 1 的数量，因此需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 的时间来遍历所有的字符串</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，三维 <code>dp</code> 数组所需空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vbmVzLWFuZC16ZXJvZXMvc29sdXRpb24veWktaGUtbGluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi11MnoyLw==">力扣官方题解</span></p><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>可定义二维 <code>dp</code> 数组，降低空间复杂度</p><p>其中， <code>dp[j][k]</code> ：最多 <code>j</code> 个 0 、 <code>k</code> 个 1 时，所能达到的最大子集的长度</p><p>此时， <code>j</code> 和 <code>k</code> 都要按从大到小的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int numberOfZero(string s) &#123; // 统计字符串 s 中的 0 的个数
    int count = 0;
    for (auto c : s)
        if (c == '0') count++;
    return count;
&#125;

int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;
    // 定义 dp 数组
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    // 遍历
    for (int i = 0; i &lt; strs.size(); i++) &#123;
        int num0 = numberOfZero(strs[i]);
        int num1 = strs[i].size() - num0;
        for (int j = m; j &gt;= num0; j--) &#123;
            for (int k = n; k &gt;= num1; k--) &#123;
                dp[j][k] = max(dp[j][k], 1 + dp[j - num0][k - num1]);
            &#125;
        &#125;
    &#125;
    // 返回目标值
    return dp[m][n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>n</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l m n + L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> 是数组 <code>strs</code> 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span> 是数组 <code>strs</code> 中所有字符串的长度之和</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，二维 <code>dp</code> 数组所需空间</p><h1 id="leetcode-494-目标和"><a class="anchor" href="#leetcode-494-目标和">#</a> LeetCode 494. 目标和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXJnZXQtc3VtLw==">494. Target Sum</span></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如， <code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1], target = 1
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>sum(nums[i])</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>target</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-深度优先搜索"><a class="anchor" href="#method-1-深度优先搜索">#</a> Method 1: 深度优先搜索</h2><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>遍历所有的表达式，即，为每个数字分别添加符号 <code>+</code> 或 <code>-</code> ，判断表达式的结果是否等于 target</p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">int ans = 0;

void DFS(vector&lt;int&gt;&amp; nums, int start, int sum, int target) &#123;
    if (start == nums.size()) &#123;
        if (sum == target) ++ans;
        return;
    &#125;
    DFS(nums, start + 1, sum + nums[start], target);
    DFS(nums, start + 1, sum - nums[start], target);
&#125;

int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;
    DFS(nums, 0, 0, target);
    return ans;
&#125;
</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度，一共需要遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.664392em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种表达式</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p><h2 id="method-2-动态规划-4"><a class="anchor" href="#method-2-动态规划-4">#</a> Method 2: 动态规划</h2><h2 id="算法思路-2"><a class="anchor" href="#算法思路-2">#</a> 算法思路</h2><p>记数组的元素和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> ，添加 <code>-</code> 的元素之和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span></span></span></span> ，添加 <code>+</code> 的元素之和则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mtext>−</mtext><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">sum − neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7777700000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord">−</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span></span></span></span></p><p>所得的表达式为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false">)</mo><mo>−</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>2</mn><mo>×</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(sum - neg) - neg = sum - 2 \times neg = target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>由此可得</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi><mo>=</mo><mfrac><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">neg = \frac{sum - target}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.9780799999999998em;vertical-align:-.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.29208em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由于 <code>nums</code> 数组中的元素均为非负整数，其组成的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span></span></span></span> 也必定为非负整数，因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sum - target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 应为 非负偶数。否则， <code>nums</code> 数组元素无法组成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span></span></span></span> ，也无法得到值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 的表达式，直接返回 0</p><p>若上式成立，问题转化为：从数组 <code>nums</code> 中选取若干元素，使得这些元素之和等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span></span></span></span> ，计算选取元素的方案数</p><p>即，0-1 背包问题，可采用动态规划方法求解，类似于 <a href="https://jiankychen.github.io/posts/31559997">LeetCode 416. 分割等和子集</a> 和 <a href="https://jiankychen.github.io/posts/51a8dea1">LeetCode 1049. 最后一块石头的重量 II</a></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXJnZXQtc3VtL3NvbHV0aW9uL211LWJpYW8taGUtYnktbGVldGNvZGUtc29sdXRpb24tbzBjcC8=">力扣官方题解</span></p><h2 id="算法流程"><a class="anchor" href="#算法流程">#</a> 算法流程</h2><p>定义 <code>dp</code> 数组： <code>dp[j]</code> 表示元素和为 <code>j</code> 的方案数，其中， <code>0 &lt;= j &lt;= neg</code></p><p>确定递推公式： <code>dp[j] = dp[j] + dp[j - nums[j]], nums[i] &lt;= j &lt;= neg</code></p><ul><li>当 <code>j &lt; nums[i]</code> 时，不能选择 <code>nums[i]</code> ， <code>dp[j]</code> 应保持不变</li><li>当 <code>j &gt;= nums[i]</code> 时，若选取 <code>nums[i]</code> ，则元素和等于 <code>j</code> 的方案数为 <code>dp[j - nums[j]]</code> ，若不选取 <code>nums[j]</code> ，则方案数为 <code>dp[j]</code> ，综合两种情况可得 <code>dp[j] = dp[j] + dp[j - nums[j]]</code></li></ul><p>初始化 <code>dp</code> 数组： <code>dp[0] = 1</code></p><ul><li>当 <code>j</code> 为 <code>0</code> 时，任意 <code>nums[i]</code> 均不可被选择，对应的方案数为 1，即 <code>dp[0] = 1</code></li></ul><p>确定遍历顺序：</p><ul><li>外层遍历 <code>i</code> ，内层遍历 <code>j</code></li><li><code>i</code> 按从小到大顺序遍历， <code>j</code> 按从大到小顺序遍历</li></ul><p>最终得到 <code>dp[neg]</code> 即为所求</p><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;
    int n = nums.size();
    int sum = 0;
    for (int a : nums)
        sum += a;
    
    int diff = sum - target;
    if (diff &lt; 0 || diff % 2) return 0;
    int neg = diff / 2;

    vector&lt;int&gt; dp(neg + 1, 0);
    dp[0] = 1;
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = neg; j &gt;= nums[i]; j--) &#123;
            dp[j] += dp[j - nums[i]];
        &#125;
    &#125;

    return dp[neg];
&#125;
</code></pre><h2 id="复杂度分析-2"><a class="anchor" href="#复杂度分析-2">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times neg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组 nums 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span></span></span></span> 为添加 <code>-</code> 的元素之和</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(neg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mclose">)</span></span></span></span>，dp 数组所需空间</p><h1 id="leetcode-5-最长回文子串"><a class="anchor" href="#leetcode-5-最长回文子串">#</a> LeetCode 5. 最长回文子串</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy8=">5. Longest Palindromic Substring</span></p><p>给你一个字符串 <code>s</code> ，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;babad&quot;
输出：&quot;bab&quot;
解释：&quot;aba&quot; 同样是符合题意的答案。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;cbbd&quot;
输出：&quot;bb&quot;
</code></pre><p><strong>提示：</strong></p><ul><li>1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span></span></span></span> 1000</li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h2 id="method-动态规划-22"><a class="anchor" href="#method-动态规划-22">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示 <code>[i, j]</code> 区间范围内的子串是否为回文子串，其中， <code>0 &lt;= i &lt;= s.size() - 1</code> ， <code>i &lt;= j &lt;= s.size() - 1</code></p><p>初始化 dp 数组：全都初始化为 <code>false</code></p><p>推导状态转移过程：当 <code>s[i] == s[j]</code> 时，考虑以下情况：</p><ul><li><code>j - i == 0</code> ：即，只有一个字符，此时一定为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i == 1</code> ：即，只有 <code>s[i]</code> 和 <code>s[j]</code> 这两个相同的字符，此时也为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i &gt; 1</code> ：此时， <code>s[i, j]</code> 多于两个字符，若 <code>s[i + 1, j - 1]</code> 是回文子串，则 <code>s[i, j]</code> 也是回文子串，因此， <code>dp[i][j] = dp[i + 1][j - 1]</code></li></ul><p>确定遍历顺序：根据递推公式知， <code>dp[i][j]</code> 依赖于 <code>dp[i + 1][j - 1]</code> ，因此，应按照从大到小的顺序遍历 <code>i</code> ，按照从小到大的顺序遍历 <code>j</code></p><p>由于本题要求的是最长回文子串，因此，在遍历 dp 数组时，还需要维护最长回文子串的起点和长度</p><p>代码实现：</p><pre><code class="language-cpp">string longestPalindrome(string s) &#123;
    vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));
    int len = 0;    // 最长回文子串的长度
    int start = 0;  // 最长回文子串的起点
    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;
        for (int j = i; j &lt; s.size(); j++) &#123;
            if (s[i] == s[j] &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123;
                dp[i][j] = true;
                if (j - i + 1 &gt; len) &#123; // 更新最长回文子串
                    len = j - i + 1;
                    start = i;
                &#125;
            &#125;
        &#125;
    &#125;
    return s.substr(start, len); // 以 start 为起点的、长为 len 的回文子串
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串 <code>s</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-509-斐波那契数"><a class="anchor" href="#leetcode-509-斐波那契数">#</a> LeetCode 509. 斐波那契数</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maWJvbmFjY2ktbnVtYmVyLw==">LeetCode 509. Fibonacci Number</span></p><p><strong>斐波那契数</strong>（通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre><code>F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n &gt; 1.
</code></pre><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-动态规划-23"><a class="anchor" href="#method-动态规划-23">#</a> Method: 动态规划</h2><p>算法思路：</p><ol><li><p>确定 <code>dp</code> 数组及其含义： <code>dp[i]</code> 表示第 <code>i</code> 个斐波那契数，即， <code>F(i)</code></p></li><li><p>确定递推公式：当 <code>i &gt;= 2</code> 时， <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p></li><li><p>初始化 <code>dp</code> 数组： <code>dp[0] = 0</code> ， <code>dp[1] = 1</code></p></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code> 依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> ，因此，应按 <code>i</code> 从小到大遍历</p></li><li><p>举例推导 <code>dp</code> 数组</p></li></ol><p>最后的 <code>dp[n]</code> 就是所求的斐波那契数</p><p>代码实现：</p><pre><code class="language-cpp">int fib(int n) &#123;
    if (n == 0) return 0;
    if (n == 1) return 1;
    vector&lt;int&gt; dp(n + 1, 0);
    dp[1] = 1;
    for (int i = 2; i &lt;= n; i++) &#123;
        dp[i] = dp[i - 2] + dp[i - 1];
    &#125;
    return dp[n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="优化-2"><a class="anchor" href="#优化-2">#</a> 优化</h2><p>由于 <code>dp[i]</code> 仅依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> ，也可以只维护 <code>dp[0]</code> 和 <code>dp[1]</code> ，而不需要记录整个 <code>dp</code> 数组</p><ul><li>当 <code>i</code> 是奇数时，斐波那契数 <code>F(i)</code> 存放在 <code>dp[1]</code> 中</li><li>当 <code>i</code> 是偶数时，斐波那契数 <code>F(i)</code> 存放在 <code>dp[0]</code> 中</li></ul><p>最后的 <code>dp[n &amp; 1]</code> 就是所求的斐波那契数</p><p>代码实现：</p><pre><code class="language-cpp">int fib(int n) &#123;
    if (n &lt;= 1) return n;
    vector&lt;int&gt; dp = &#123;0, 1&#125;;
    for (int i = 2; i &lt;= n; i++) &#123;
        dp[i &amp; 1] = dp[(i - 2) &amp; 1] + dp[(i - 1) &amp; 1];
    &#125;
    return dp[n &amp; 1];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-516-最长回文子序列"><a class="anchor" href="#leetcode-516-最长回文子序列">#</a> LeetCode 516. 最长回文子序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnNlcXVlbmNlLw==">516. Longest Palindromic Subsequence</span></p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;bbbab&quot;
输出：4
解释：One possible longest palindromic subsequence is &quot;bbbb&quot;.
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;cbbd&quot;
输出：2
解释：One possible longest palindromic subsequence is &quot;bb&quot;.
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="method-动态规划-24"><a class="anchor" href="#method-动态规划-24">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示 <code>[i, j]</code> 区间范围内的最长回文子序列的长度，其中， <code>0 &lt;= i &lt;= s.size() - 1</code> ， <code>i &lt;= j &lt;= s.size() - 1</code></p><p>初始化 dp 数组：任何一个长为 1 的子序列都是回文子序列，因此， <code>dp[i][i] == 1</code></p><p>推导 <code>dp[i][j]</code> 的状态转移过程：</p><ul><li>当 <code>s[i] == s[j]</code> 时，针对 <code>[i + 1, j - 1]</code> 区间内的最长回文子序列，可在其首端和尾端分别添加 <code>s[i]</code> 和 <code>s[j]</code> ，以形成更长的回文子序列，因此，最大长度为 <code>dp[i][j] = dp[i + 1][j - 1] + 2</code></li><li>当 <code>s[i] != s[j]</code> 时，则 <code>s[i]</code> 和 <code>s[j]</code> 不能同时作为某一个回文子序列的首尾，因此：<ul><li>考虑 <code>[i, j - 1]</code> 区间内的最长回文子序列，最大长度为 <code>dp[i][j - 1]</code></li><li>考虑 <code>[i + 1, j]</code> 区间内的最长回文子序列，最大长度为 <code>dp[i + 1][j]</code></li><li>综合两种情况，取最大值，即， <code>dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])</code></li></ul></li></ul><p>确定遍历顺序：根据递推公式知， <code>dp[i][j]</code> 依赖于 <code>dp[i + 1][j - 1]</code> ，因此，应按照从大到小的顺序遍历 <code>i</code> ，按照从小到大的顺序遍历 <code>j</code></p><p>遍历结束后， <code>dp[0][s.size() - 1]</code> 即为字符串 <code>s</code> 的最长回文子序列的长度</p><p>代码实现：</p><pre><code class="language-cpp">int longestPalindromeSubseq(string s) &#123;
    vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));
    for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1;
    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;
        for (int j = i + 1; j &lt; s.size(); j++) &#123;
            if (s[i] == s[j])
                dp[i][j] = dp[i + 1][j - 1] + 2;
            else
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        &#125;
    &#125;
    return dp[0][s.size() - 1];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串 <code>s</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-518-零钱兑换-ii"><a class="anchor" href="#leetcode-518-零钱兑换-ii">#</a> LeetCode 518. 零钱兑换 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS1paS8=">518. Coin Change 2</span></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><pre><code>输入：amount = 5, coins = [1,2,5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：amount = 10, coins = [10]
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>coins.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">\le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>coins[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>amount</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-9"><a class="anchor" href="#思路-9">#</a> 思路</h2><p><code>coins</code> 的每个元素可以选取多次，且不考虑选取元素的顺序，因此本题计算的是选取硬币的 <strong>组合</strong> 数</p><p>本题是一个完全背包问题，可以通过动态规划方法求解</p><p>完全背包问题的遍历顺序：</p><ul><li>如果求的是组合数，外层 for 遍历物品，内层 for 遍历背包</li><li>如果求的是排列数，外层 for 遍历背包，内层 for 遍历物品</li></ul><h2 id="method-动态规划-25"><a class="anchor" href="#method-动态规划-25">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[j]</code> 表示凑成金额 <code>j</code> 的硬币组合数，其中， <code>0 &lt;= j &lt;= amount</code></p><p>递推公式： <code>dp[j] += dp[j - coins[i]], coins[i] &lt;= j &lt;= amount</code></p><ul><li>若 <code>j &lt; coins[i]</code> ，不能选取 <code>coins[i]</code> ，因此， <code>dp[j]</code> 保持不变</li><li>若 <code>j &gt;= coins[i]</code> ，如果选取 <code>coins[i]</code> ，凑成金额 <code>j</code> 的方案数应为 <code>dp[j - coins[i]]</code> ，如果不选取 <code>coins[i]</code> ，凑成 <code>j</code> 的方案数应为 <code>dp[j]</code> ，综合两种情况，总的方案数为 <code>dp[j] = dp[j] + dp[j - coins[i]]</code></li></ul><p>初始化 dp 数组：只有不选取任何硬币时，金额之和才为 0 ，即，金额 0 只对应 1 种硬币组合，因此， <code>dp[0] = 1</code></p><p>遍历顺序：<strong>外层遍历硬币面额，内层遍历金额总和，并且，均按照从小到大的顺序遍历</strong></p><ul><li>不同于 <a href="https://jiankychen.github.io/posts/a80d0031">动态规划</a> 中的纯完全背包问题（要求的是能否凑成某个金额、凑成的最大金额是多少），纯完全背包可以改变两个 for 循环的嵌套方式，本题（要求的是凑成某金额的方案个数）只能外层遍历物品（硬币面额），内层遍历背包容量（金额总和）</li><li>外层遍历硬币面额，内层遍历金额总和：只可能出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext></mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i],\ coins[i + 1]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> 这种情况，而不会出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext></mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i + 1],\ coins[i]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> 的情况，即，硬币面额的出现顺序是确定的，因此，只会计算组合数，而不会计算排列数</li><li>外层遍历金额总和，内层遍历硬币面额：可能会既出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext></mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i],\ coins[i + 1]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> ，又出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext></mtext><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{coins[i + 1],\ coins[i]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span> ，即，硬币面额的出现顺序并不确定，因此，这里会计算排列数</li></ul><p>例如 <code>coins = [1,2]</code> ，对于 <code>dp[3]</code> 的计算，一定是先遍历硬币面额 1 然后才遍历硬币面额 2，故而只会统计 <code>3 = 1 + 1 + 1</code> 和 <code>3 = 1 + 2</code> 这两种情况。硬币面额 2 不可能出现在硬币面额 1 之前，即，不会重复计算 <code>3 = 2 + 1</code> 的情况</p><blockquote><p>建议把这两种方案的 dp 数组打印出来，对比一下</p></blockquote><p>最后的 <code>dp[amount]</code> 即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int change(int amount, vector&lt;int&gt;&amp; coins) &#123;
    vector&lt;int&gt; dp(amount + 1, 0);
    dp[0] = 1;
    for (int i = 0; i &lt; coins.size(); i++) &#123;
        for (int j = coins[i]; j &lt;= amount; j++) &#123;
            dp[j] += dp[j - coins[i]];
        &#125;
    &#125;
    return dp[amount];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">amount</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span> 是总金额</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(amount)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MTguJUU5JTlCJUI2JUU5JTkyJUIxJUU1JTg1JTkxJUU2JThEJUEySUkuaHRtbA==">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS0yL3NvbHV0aW9uL2xpbmctcWlhbi1kdWktaHVhbi1paS1ieS1sZWV0Y29kZS1zb2x1dGktZjd1aC8=">力扣官方题解</span></li></ul><h1 id="leetcode-583-两个字符串的删除操作"><a class="anchor" href="#leetcode-583-两个字符串的删除操作">#</a> LeetCode 583. 两个字符串的删除操作</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtb3BlcmF0aW9uLWZvci10d28tc3RyaW5ncy8=">583. Delete Operation for Two Strings</span></p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> 相同所需的最小步数。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><pre><code>输入：word1 = &quot;sea&quot;, word2 = &quot;eat&quot;
输出：2
解释：第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;
输出：4
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>word1.length</code> , <code>word2.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li></ul><h2 id="method-1-最长公共子序列"><a class="anchor" href="#method-1-最长公共子序列">#</a> Method 1: 最长公共子序列</h2><p>要通过删除字符使得 word1 与 word2 相同，也就是要得到 word1 与 word2 的公共子序列</p><p>因此，本题可以通过 word1 与 word2 的最长公共子序列的长度来计算：</p><ul><li>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 表示 word1 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 表示 word2 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 表示 word1 与 word2 的最长公共子序列的长度</li><li>要使 word1 与 word2 相同，则应删除最长公共子序列以外的所有字符。即，word1 需要删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 个字符，word2 需要删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 个字符</li><li>因此，所需的最少步数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">m + n - 2 k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span></li></ul><p>其中，最长公共子序列长度的计算可参考 <a href="https://jiankychen.github.io/posts/c261e90a">LeetCode 1143. 最长公共子序列</a></p><p>代码实现：</p><pre><code class="language-cpp">int minDistance(string word1, string word2) &#123;
    int m = word1.size();
    int n = word2.size();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (word1[i - 1] == word2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        &#125;
    &#125;
    int ans = m + n - (2 * dp[m][n]);
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是 <code>word1</code> 和 <code>word2</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-动态规划-5"><a class="anchor" href="#method-2-动态规划-5">#</a> Method 2: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示使得 <code>word1[0, i - 1]</code> 与 <code>word2[0, j - 1]</code> 相同所需的最少删除次数，其中， <code>1 &lt;= i &lt;= word1.size()</code> , <code>1 &lt;= j &lt;= word2.size()</code></p><p>初始化 <code>dp[i][0]</code> 与 <code>dp[0][j]</code> ：</p><ul><li><code>[dp][i][0]</code> ：此时， <code>word2[0, j - 1]</code> 为空字符串，要使得 <code>word1[0, i - 1]</code> 与空字符串相等，应将 <code>word1[0, i - 1]</code> 中的全部字符都删除，即， <code>dp[i][0] = i</code></li><li><code>[dp][0][j]</code> ：此时， <code>word1[0, i - 1]</code> 为空字符串，要使得 <code>word2[0, j - 1]</code> 与空字符串相等，应将 <code>word2[0, j - 1]</code> 中的全部字符都删除，即， <code>dp[i][0] = j</code></li></ul><p>推导 <code>dp[i][j]</code> 的状态转移过程：</p><ul><li>当 <code>word1[i - 1] == word2[j - 1]</code> 时，无需删除 <code>word1[i - 1]</code> 与 <code>word2[j - 1]</code> ，计算使 <code>word1[0, i - 2]</code> 与 <code>word2[0, j - 2]</code> 相同所需的最少删除次数即可，即， <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>当 <code>word1[i - 1] != word2[j - 1]</code> 时，做以下考虑<ul><li>若删除 <code>word1[i - 1]</code> ，则应使 <code>word1[0, i - 2]</code> 与 <code>word2[j - 1]</code> 相同，此时，所需的最少删除次数为 <code>1 + dp[i - 1][j]</code></li><li>若删除 <code>word2[j - 1]</code> ，则应使 <code>word1[0, i - 1]</code> 与 <code>word2[0, j - 2]</code> 相同，此时，所需的最少删除次数为 <code>1 + dp[i][j - 1]</code></li><li>综合两种情况，取最小值，即， <code>dp[i][j] = min(1 + dp[i - 1][j], 1 + dp[i][j - 1])</code></li></ul></li></ul><p>确定遍历顺序：根据状态转移方程知， <code>dp[i][j]</code> 依赖于 <code>dp[i - 1][j - 1]</code> ， <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> ，因此，应按照从小到大的顺序遍历 <code>i</code> 和 <code>j</code></p><p>遍历结束后， <code>dp[word1.size()][word2.size()]</code> 即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int minDistance(string word1, string word2) &#123;
    int m = word1.size();
    int n = word2.size();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    for (int i = 0; i &lt;= m; i++) dp[i][0] = i;
    for (int j = 0; j &lt;= n; j++) dp[0][j] = j;
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (word1[i - 1] == word2[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;
        &#125;
    &#125;
    return dp[m][n];

&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是 <code>word1</code> 和 <code>word2</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtb3BlcmF0aW9uLWZvci10d28tc3RyaW5ncy9zb2x1dGlvbi9saWFuZy1nZS16aS1mdS1jaHVhbi1kZS1zaGFuLWNodS1jYW8tenVvLTE0dXcv">力扣官方题解</span></p><h1 id="leetcode-62-不同路径"><a class="anchor" href="#leetcode-62-不同路径">#</a> LeetCode 62. 不同路径</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMv">62. Unique Paths</span></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/example.png" alt=""></p><pre><code>输入：m = 3, n = 7
输出：28
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：m = 3, n = 2
输出：3
解释：从左上角开始，总共有 3 条路径可以到达右下角。
  1. 向右 -&gt; 向下 -&gt; 向下
  2. 向下 -&gt; 向下 -&gt; 向右
  3. 向下 -&gt; 向右 -&gt; 向下
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：m = 3, n = 3
输出：6
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>m</code> , <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li>题目数据保证答案小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-动态规划-26"><a class="anchor" href="#method-动态规划-26">#</a> Method: 动态规划</h2><p>算法思路：</p><ol><li><p>确定 <code>dp</code> 数组及其含义： <code>dp[i][j]</code> 表示从 <code>(0, 0)</code> 到达 <code>(i, j)</code> 位置的路径条数，其中， <code>0 &lt;= i &lt;= m - 1</code> ， <code>0 &lt;= j &lt;= n - 1</code></p></li><li><p>确定递推公式</p><ul><li><code>(0, j)</code> 只能由 <code>(0, j - 1)</code> 向右移动一步到达，故而 <code>dp[0][j] = 1</code></li><li><code>(i, 0)</code> 只能由 <code>(i - 1, 0)</code> 向下移动一步到达，故而 <code>dp[i][0] = 1</code></li><li>对任意 <code>i &gt; 0</code> 且 <code>j &gt; 0</code> ， <code>(i, j)</code> 可由 <code>(i - 1, j)</code> 向下移动到达，也可由 <code>(i, j - 1)</code> 向右移动到达，故而 <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></li></ul></li><li><p>初始化 <code>dp</code> 数组： <code>dp[0][j] = 1</code> ， <code>dp[i][0] = 1</code></p></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i][j]</code> 依赖于 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> ，因此，应按 <code>i</code> 从小到大、 <code>j</code> 从小到大顺序遍历</p></li><li><p>举例推导 <code>dp</code> 数组</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int uniquePaths(int m, int n) &#123;
    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); // 从 (0, 0) 到 (i, j) 的路径条数
    for (int i = 0; i &lt; m; i++) dp[i][0] = 1;
    for (int j = 1; j &lt; n; j++) dp[0][j] = 1;
    for (int i = 1; i &lt; m; i++) &#123;
        for (int j = 1; j &lt; n; j++) &#123;
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        &#125;
    &#125;
    return dp[m - 1][n - 1];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-63-不同路径-ii"><a class="anchor" href="#leetcode-63-不同路径-ii">#</a> LeetCode 63. 不同路径 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMtaWkv">63. Unique Paths II</span></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/example1.jpg" alt=""></p><pre><code>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：
  1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
  2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/example2.jpg" alt=""></p><pre><code>输入：obstacleGrid = [[0,1],[0,0]]
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>m</code> , <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="method-动态规划-27"><a class="anchor" href="#method-动态规划-27">#</a> Method: 动态规划</h2><p>算法思路：</p><ol><li><p>确定 <code>dp</code> 数组及其含义： <code>dp[i][j]</code> 表示从 <code>(0, 0)</code> 到达 <code>(i, j)</code> 位置的路径条数，其中， <code>0 &lt;= i &lt;= m - 1</code> ， <code>0 &lt;= j &lt;= n - 1</code></p></li><li><p>确定递推公式</p><ul><li>对任意 <code>(i, j)</code> ，若 <code>(i, j)</code> 有障碍物，则无法到达 <code>(i, j)</code> ，即， <code>dp[i][j] = 0</code></li><li>否则， <code>(i, j)</code> 可由 <code>(i - 1, j)</code> 向下移动到达，也可由 <code>(i, j - 1)</code> 向右移动到达，即， <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></li></ul></li><li><p>初始化 <code>dp</code> 数组：</p><ul><li>到达 <code>(i, 0)</code> 的路径只有一条，即 <code>dp[i][0] = 1</code> ，但如果某个 <code>(i0, 0)</code> 存在障碍物，则对任意 <code>i &gt;= i0</code> 均有 <code>dp[i][0] = 0</code></li><li>到达 <code>(0, j)</code> 的路径只有一条，即 <code>dp[0][j] = 1</code> ，但如果某个 <code>(0, j0)</code> 存在障碍物，则对任意 <code>j &gt;= j0</code> 均有 <code>dp[0][j] = 0</code></li></ul><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) // 遇到障碍物则停止赋 1
    dp[i][0] = 1;
for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) // 遇到障碍物则停止赋 1
    dp[0][j] = 1;
</code></pre></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i][j]</code> 依赖于 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> ，因此，应按 <code>i</code> 从小到大、 <code>j</code> 从小到大顺序遍历</p></li><li><p>举例推导 <code>dp</code> 数组</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
    int m = obstacleGrid.size();
    int n = obstacleGrid[0].size();
    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
    for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) // 注意这里要从 i = 0 开始，因为 (0, 0) 可能有障碍物
        dp[i][0] = 1;
    for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) // 注意这里要从 j = 0 开始，因为 (0, 0) 可能有障碍物
        dp[0][j] = 1;
    for (int i = 1; i &lt; m; i++) &#123;
        for (int j = 1; j &lt; n; j++) &#123;
            if (obstacleGrid[i][j] == 1) continue; // (i,j) 处有障碍物，无法到达
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        &#125;
    &#125;
    return dp[m - 1][n - 1];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNjMuJUU0JUI4JThEJUU1JTkwJThDJUU4JUI3JUFGJUU1JUJFJTg0SUkuaHRtbCMlRTYlODAlOUQlRTglQjclQUY=">代码随想录</span></p><h1 id="leetcode-64-最小路径和"><a class="anchor" href="#leetcode-64-最小路径和">#</a> LeetCode 64. 最小路径和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXBhdGgtc3VtLw==">64. Minimum Path Sum</span></p><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明</strong>：每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/Example1.jpg" alt=""></p><pre><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[1,2,3],[4,5,6]]
输出：12
</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>m</code> , <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">\le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>grid[i][j]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-动态规划-28"><a class="anchor" href="#method-动态规划-28">#</a> Method: 动态规划</h2><p>代码实现：</p><pre><code class="language-cpp">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
    
    // 定义 dp 数组
    int m = grid.size();
    int n = grid[0].size();
    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); // dp[i][j] 表示从左上角到达 (i, j) 位置的最小路径和
    
    // 初始化
    dp[0][0] = grid[0][0];
    for (int i = 1; i &lt; m; i++)
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    for (int j = 1; j &lt; n; j++)
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    
    // 更新 dp 数组
    for (int i = 1; i &lt; m; i++) &#123;
        for (int j = 1; j &lt; n; j++) &#123;
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        &#125;
    &#125;
    
    // 目标值
    return dp[m - 1][n - 1];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是网格的行数和列数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>可以使用滚动数组来降低空间复杂度</p></blockquote><h1 id="leetcode-647-回文子串"><a class="anchor" href="#leetcode-647-回文子串">#</a> LeetCode 647. 回文子串</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21pYy1zdWJzdHJpbmdzLw==">647. Palindromic Substrings</span></p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abc&quot;
输出：3
解释：3 个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;aaa&quot;
输出：6
解释：6 个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>s.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>s</code> 由小写英文字母组成</li></ul><h2 id="method-动态规划-29"><a class="anchor" href="#method-动态规划-29">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示 <code>[i, j]</code> 区间范围内的子串是否为回文子串，其中， <code>0 &lt;= i &lt;= s.size() - 1</code> ， <code>i &lt;= j &lt;= s.size() - 1</code></p><p>初始化 dp 数组：全都初始化为 <code>false</code></p><p>推导状态转移过程：</p><ul><li>当 <code>s[i] != s[j]</code> 时， <code>s[i, j]</code> 不可能是回文子串， <code>dp[i][j] = false</code></li><li>当 <code>s[i] == s[j]</code> 时，考虑以下情况：<ul><li><code>j - i == 0</code> ：即，只有一个字符，此时一定为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i == 1</code> ：即，只有 <code>s[i]</code> 和 <code>s[j]</code> 这两个相同的字符，此时也为回文子串，即， <code>dp[i][j] = true</code></li><li><code>j - i &gt; 1</code> ：即， <code>s[i, j]</code> 多于两个字符，此时，还需判断 <code>s[i + 1, j - 1]</code> 是否为回文子串。若 <code>s[i + 1, j - 1]</code> 是回文子串，则 <code>s[i, j]</code> 也是回文子串，否则， <code>s[i, j]</code> 不是回文子串。即， <code>dp[i][j] = dp[i + 1][j - 1]</code></li></ul></li></ul><p>确定遍历顺序：根据递推公式知， <code>dp[i][j]</code> 依赖于 <code>dp[i + 1][j - 1]</code> ，因此，应按照从大到小的顺序遍历 <code>i</code> ，按照从小到大的顺序遍历 <code>j</code></p><p>遍历结束后，dp 数组值为 <code>true</code> 的元素个数，即为字符串 <code>s</code> 的回文子串个数</p><p>代码实现：</p><pre><code class="language-cpp">int countSubstrings(string s) &#123;
    vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));
    int ans = 0;
    for (int i = s.size() - 1; i &gt;= 0; i--) &#123;
        for (int j = i; j &lt; s.size(); j++) &#123;
            if (s[i] == s[j]) &#123;
                if (j - i &lt;= 1 || dp[i + 1][j - 1]) &#123;
                    dp[i][j] = true;
                    ans++;
                &#125;
            &#125;
        &#125;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串 <code>s</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-674-最长连续递增序列"><a class="anchor" href="#leetcode-674-最长连续递增序列">#</a> LeetCode 674. 最长连续递增序列</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnRpbnVvdXMtaW5jcmVhc2luZy1zdWJzZXF1ZW5jZS8=">674. Longest Continuous Increasing Subsequence</span></p><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong> ，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code> （ <code>l &lt; r</code> ）确定，如果对于每个 <code>l &lt;= i &lt; r</code> ，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p></p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5] , 长度为 3
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2] , 长度为 1
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-1-动态规划"><a class="anchor" href="#method-1-动态规划">#</a> Method 1: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i]</code> 表示在 <code>nums[0, i]</code> 区间内，以 <code>nums[i]</code> 结尾的最长连续递增序列的长度</p><p>本题要求递增序列连续，因此，维护 <code>dp[i]</code> 只需比较 <code>nums[i]</code> 与 <code>nums[i - 1]</code> 即可，递归公式为： <code>dp[i] = max(dp[i], dp[i - 1] + 1), i &gt;= 1 &amp;&amp; nums[i] &gt; nums[i - 1]</code></p><p>遍历结束后，dp 数组的最大元素即为所求</p><p>代码实现：</p><pre><code class="language-cpp">int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    vector&lt;int&gt; dp(n, 1); // dp[i] 表示以 nums[i] 结尾的最长连续递增序列的长度
    for (int i = 1; i &lt; n; i++) &#123;
        if (nums[i] &gt; nums[i - 1]) // 连续递增
            dp[i] = max(dp[i], dp[i - 1] + 1);
    &#125;
    int ans = 0;
    for (int i = 0; i &lt; n; i++)
        ans = max(ans, dp[i]);
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-贪心"><a class="anchor" href="#method-2-贪心">#</a> Method 2: 贪心</h2><p>代码实现：</p><pre><code class="language-cpp">int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    int ans = 0;
    int count = 1;
    for (int i = 1; i &lt; n; i++) &#123;
        if (nums[i] &gt; nums[i - 1]) count++;
        else &#123;
            ans = max(ans, count);
            count = 1;
        &#125;
    &#125;
    ans = max(ans, count); // 处理 nums[n - 1] &gt; nums[n - 2] 的情况
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-70-爬楼梯"><a class="anchor" href="#leetcode-70-爬楼梯">#</a> LeetCode 70. 爬楼梯</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMv">LeetCode 70. Climbing Stairs</span></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
      1. 1 阶 + 1 阶
      2. 2 阶
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
      1. 1 阶 + 1 阶 + 1 阶
      2. 1 阶 + 2 阶
      3. 2 阶 + 1 阶
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>n</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>45</mn></mrow><annotation encoding="application/x-tex">\le 45</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span><span class="mord">5</span></span></span></span></li></ul><h2 id="method-1-动态规划-2"><a class="anchor" href="#method-1-动态规划-2">#</a> Method 1: 动态规划</h2><p>算法思路：</p><ol><li><p>确定 <code>dp</code> 数组及其含义： <code>dp[i]</code> 表示爬到第 <code>i</code> 阶的方案数</p></li><li><p>确定递推公式：当 <code>i &gt;= 2</code> 时， <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p><ul><li>可以从第 <code>i - 1</code> 阶爬 1 个台阶，到达第 <code>i</code> 阶，方案数为 <code>dp[i - 1]</code></li><li>也可以从第 <code>i - 2</code> 阶爬 2 个台阶，到达第 <code>i</code> 阶，方案数为 <code>dp[i - 2]</code></li></ul></li><li><p>初始化 <code>dp</code> 数组： <code>dp[1] = 1</code> ， <code>dp[2] = 2</code></p><ul><li>爬到第 1 阶只有一种方案，因此， <code>dp[1] = 1</code></li><li>爬到第 2 阶有两种方案，因此， <code>dp[2] = 2</code></li></ul></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code> 依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> ，因此，应按 <code>i</code> 从小到大遍历</p></li><li><p>举例推导 <code>dp</code> 数组</p></li></ol><blockquote><p>这里不考虑 <code>dp[0]</code> 的初始化，因为 <code>dp[0]</code> 并不具有实际含义</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int climbStairs(int n) &#123;
    if (n &lt;= 1) return n;
    vector&lt;int&gt; dp(n + 1, 0);
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i &lt;= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>类似地，也可以利用滚动数组法来优化空间复杂度</p></blockquote><h2 id="method-2-完全背包"><a class="anchor" href="#method-2-完全背包">#</a> Method 2: 完全背包</h2><p>算法思路：</p><p>每一步爬一个台阶，或者，每一步爬两个台阶，可以视为背包问题中的物品；楼梯的台阶数，可以视为背包问题中的背包容量</p><p>因此，问题可改写为：从 <code>nums = &#123;1, 2&#125;</code> 中选取若干个元素（每个元素可以重复选择），使得元素之和为 <code>n</code> ，一共有多少种方案？</p><p>即，问题是一个完全背包问题，并且，所要求的是选取元素的 <strong>排列</strong> 数</p><p>采用动态规划方法求解，其中，外层 for 循环遍历元素之和（背包容量），内层 for 循环遍历元素（物品），并且均按照从小到大的顺序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int climbStairs(int n) &#123;
    vector&lt;int&gt; nums = &#123;1, 2&#125;;
    vector&lt;int&gt; dp(n + 1, 0);
    dp[0] = 1;
    for (int j = 1; j &lt;= n; j++) &#123;
        for (int num : nums) &#123;
            if (j &gt;= num)
                dp[j] += dp[j - num];
        &#125;
    &#125;
    return dp[n];
&#125;
</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwNzAuJUU3JTg4JUFDJUU2JUE1JUJDJUU2JUEyJUFGJUU1JUFFJThDJUU1JTg1JUE4JUU4JTgzJThDJUU1JThDJTg1JUU3JTg5JTg4JUU2JTlDJUFDLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p><h1 id="leetcode-718-最长重复子数组"><a class="anchor" href="#leetcode-718-最长重复子数组">#</a> LeetCode 718. 最长重复子数组</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWxlbmd0aC1vZi1yZXBlYXRlZC1zdWJhcnJheS8=">718. Maximum Length of Repeated Subarray</span></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums1.length</code> , <code>nums2.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums1[i]</code> , <code>nums2[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-动态规划-3"><a class="anchor" href="#method-1-动态规划-3">#</a> Method 1: 动态规划</h2><h2 id="实现一"><a class="anchor" href="#实现一">#</a> 实现一</h2><p>定义 dp 数组： <code>dp[i][j]</code> 表示以 <code>nums1[i]</code> 与 <code>nums2[j]</code> 为结尾的最长重复子数组的长度，其中， <code>0 &lt;= i &lt; nums1.size()</code> , <code>0 &lt;= j &lt; nums2.size()</code></p><ul><li>若 <code>nums1[i] != nums2[j]</code> ，则 <code>nums1[i]</code> 与 <code>nums2[j]</code> 不可能作为重复子数组的末尾，即， <code>dp[i][j] = 0</code></li><li>若 <code>nums1[i] == nums2[j]</code> ，则 <code>nums1[i]</code> 与 <code>nums2[j]</code> 可以作为重复子数组的末尾，即， <code>dp[i][j] &gt; 0</code></li></ul><p>确定递推公式：若 <code>num1[i] == nums2[j]</code> ，则 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p><p>初始化：根据递推公式知，应初始化 <code>dp[i][0]</code> 与 <code>dp[0][j]</code></p><ul><li><code>dp[i][0]</code> ：若 <code>nums1[i] == nums2[0]</code> ，则 <code>nums1[i]</code> 可以与 <code>nums2[0]</code> 作为重复子数组，即， <code>dp[i][0] = 1</code> ；否则， <code>dp[i][0] = 0</code></li><li><code>dp[0][j]</code> ：若 <code>nums1[0] == nums2[j]</code> ，则 <code>nums1[0]</code> 可以与 <code>nums2[j]</code> 作为重复子数组，即， <code>dp[0][j] = 1</code> ；否则， <code>dp[0][j] = 0</code></li></ul><p>遍历顺序：外层遍历 <code>i</code> 、内层遍历 <code>j</code> （可以交换）； <code>i</code> 与 <code>j</code> 均按照从小到大的顺序遍历</p><p>最后，从 dp 数组中找到最大值，即为最长重复子数组的长度</p><p>代码实现：</p><pre><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
    int m = nums1.size();
    int n = nums2.size();

    // 定义 dp 数组
    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));

    // 初始化 dp 数组
    for (int i = 0; i &lt; m; i++) &#123;
        if (nums1[i] == nums2[0]) dp[i][0] = 1;
    &#125;
    for (int j = 0; j &lt; n; j++) &#123;
        if (nums1[0] == nums2[j]) dp[0][j] = 1;
    &#125;

    // 遍历
    for (int i = 1; i &lt; m; i++) &#123;
        for (int j = 1; j &lt; n; j++) &#123;
            if (nums1[i] == nums2[j])
                dp[i][j] = dp[i - 1][j - 1] + 1;
        &#125;
    &#125;

    // 寻找 dp 数组的最大元素
    int ans = 0;
    for (int i = 0; i &lt; m; i++) &#123;
        for (int j = 0; j &lt; n; j++) &#123;
            if (dp[i][j] &gt; ans)
                ans = dp[i][j];
        &#125;
    &#125;

    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是数组 <code>nums1</code> 、 <code>nums2</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="实现二"><a class="anchor" href="#实现二">#</a> 实现二</h2><p>可以将 dp 数组定义为： <code>dp[i][j]</code> 表示以 <code>nums1[i - 1]</code> 与 <code>nums2[j - 1]</code> 为结尾的最长重复子数组的长度，其中， <code>0 &lt;= i &lt;= nums1.size()</code> , <code>0 &lt;= j &lt;= nums2.size()</code></p><p>dp 数组的元素全部初始化为 <code>0</code> 即可</p><p>递推公式为：若 <code>nums1[i - 1] == nums2[j - 1]</code> ，则 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p><p>遍历顺序：与上一种实现相同， <code>i</code> 从 1 遍历至 <code>nums1.size()</code> ， <code>j</code> 从 1 遍历至 <code>nums2.size()</code></p><p>代码实现：</p><pre><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
    int m = nums1.size();
    int n = nums2.size();
    int ans = 0;

    // 定义 dp 数组及其初始化
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));

    // 遍历
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (nums1[i - 1] == nums2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            if (dp[i][j] &gt; ans)
                ans = dp[i][j];
        &#125;
    &#125;

    return ans;
&#125;
</code></pre><h2 id="优化-3"><a class="anchor" href="#优化-3">#</a> 优化</h2><p>可以利用滚动数组的思想，将二维 dp 数组换成一维 dp 数组，即，一维数组的 <code>dp[j]</code> 对应上述二维数组的 <code>dp[i][j]</code> （实现二）</p><p>代码实现：</p><pre><code class="language-cpp">int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
    int m = nums1.size();
    int n = nums2.size();
    int ans = 0;
    vector&lt;int&gt; dp(n + 1, 0);
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = n; j &gt;= 1; j--) &#123;
            if (nums1[i - 1] == nums2[j - 1]) dp[j] = dp[j - 1] + 1;
            else dp[j] = 0;           // nums1[i - 1] != nums2[j - 1] 时，dp[j] = 0
            ans = max(ans, dp[j]);
        &#125;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是数组 <code>nums1</code> 、 <code>nums2</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MTguJUU2JTlDJTgwJUU5JTk1JUJGJUU5JTg3JThEJUU1JUE0JThEJUU1JUFEJTkwJUU2JTk1JUIwJUU3JUJCJTg0Lmh0bWw=">代码随想录</span></p><h1 id="leetcode-72-编辑距离"><a class="anchor" href="#leetcode-72-编辑距离">#</a> LeetCode 72. 编辑距离</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLw==">72. Edit Distance</span></p><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出：3
解释：
    horse -&gt; rorse (将 'h' 替换为 'r')
    rorse -&gt; rose (删除 'r')
    rose -&gt; ros (删除 'e')
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
输出：5
解释：
    intention -&gt; inention (删除 't')
    inention -&gt; enention (将 'i' 替换为 'e')
    enention -&gt; exention (将 'n' 替换为 'x')
    exention -&gt; exection (将 'n' 替换为 'c')
    exection -&gt; execution (插入 'u')
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>word1.length</code> , <code>word2.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h2 id="method-动态规划-30"><a class="anchor" href="#method-动态规划-30">#</a> Method: 动态规划</h2><p>算法思路：</p><p>定义 dp 数组： <code>dp[i][j]</code> 表示将 <code>word1[0, i - 1]</code> 转换成 <code>word2[0, j - 1]</code> 所需的最少操作数</p><p>初始化 <code>dp[i][0]</code> 与 <code>dp[0][j]</code> ：</p><ul><li><code>[dp][i][0]</code> ：此时， <code>word2[0, j - 1]</code> 为空字符串，要将 <code>word1[0, i - 1]</code> 转换成空字符串，应将 <code>word1[0, i - 1]</code> 的全部字符都删除，即， <code>dp[i][0] = i</code></li><li><code>[dp][0][j]</code> ：此时， <code>word1[0, i - 1]</code> 为空字符串，要将空字符串转换成 <code>word2[0, j - 1]</code> ，应将 <code>word2[0, j - 1]</code> 的全部字符都插入到 <code>word1</code> ，即， <code>dp[i][0] = j</code></li></ul><p>推导 <code>dp[i][j]</code> 的状态转移过程：<strong>（要注意围绕 <code>dp[i][j]</code> 的定义进行思考）</strong></p><ul><li>当 <code>word1[i - 1] == word2[j - 1]</code> 时，无需操作 <code>word1[i - 1]</code> ，只需将 <code>word1[0, i - 2]</code> 转换成 <code>word2[0, j - 2]</code> ，因此， <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>当 <code>word1[i - 1] != word2[j - 1]</code> 时，可针对 <code>word1[0, i - 1]</code> 进行 插入、删除、替换 三种操作：<ul><li><strong>插入字符</strong>：在 <code>word1[i - 2]</code> 与 <code>word1[i - 1]</code> 之间插入一个字符，使之与 <code>word2[j - 1]</code> 相同。该操作 <strong>等价于 删除 <code>word2[j - 1]</code> </strong>，因为插入字符和删除 <code>word2[j - 1]</code> 都能将 <code>word1</code> 变成 <code>word2</code> 。因此，所需的操作数为 <code>1 + dp[i][j - 1]</code> ，其中， <code>1</code> 表示删除 <code>word2[j - 1]</code> 所需的操作数， <code>dp[i][j - 1]</code> 表示将 <code>word1[0, i - 1]</code> 转换成 <code>word2[0, j - 2]</code> 所需的最少操作数</li><li><strong>删除字符</strong>：删除 <code>word1[i - 1]</code> ，然后将 <code>word1[0, i - 2]</code> 转换成 <code>word2[0, j - 1]</code> 。所需的操作数为 <code>1 + dp[i - 1][j]</code></li><li><strong>替换字符</strong>：将 <code>word1[i - 1]</code> 替换成与 <code>word2[j - 1]</code> 相同的字符，然后将 <code>word1[0, i - 2]</code> 转换成 <code>word2[0, j - 2]</code> 。所需的操作数为 <code>1 + dp[i - 1][j - 1]</code></li><li>综合以上三种情况，应取最小的操作数，即， <code>dp[i][j] = min(&#123;1 + dp[i][j - 1], 1 + dp[i - 1][j], 1 + dp[i - 1][j - 1]&#125;)</code></li></ul></li></ul><p>遍历顺序：根据递推公式知， <code>dp[i][j]</code> 依赖于 <code>dp[i - 1][j - 1]</code> 、 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> ，因此，应按照从左到右、从上到下的顺序维护 dp 数组，即，按照从小到大的顺序分别遍历 <code>i</code> 和 <code>j</code></p><p>代码实现：</p><pre><code class="language-cpp">int minDistance(string word1, string word2) &#123;
    int m = word1.size();
    int n = word2.size();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    for (int i = 0; i &lt;= m; i++) dp[i][0] = i;
    for (int j = 0; j &lt;= n; j++) dp[0][j] = j;
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (word1[i - 1] == word2[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = min(&#123;dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]&#125;) + 1;
        &#125;
    &#125;
    return dp[m][n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是 <code>word1</code> 和 <code>word2</code> 的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-746-使用最小花费爬楼梯"><a class="anchor" href="#leetcode-746-使用最小花费爬楼梯">#</a> LeetCode 746. 使用最小花费爬楼梯</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tY29zdC1jbGltYmluZy1zdGFpcnMv">LeetCode 746. Min Cost Climbing Stairs</span></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><pre><code>输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
      - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
      总花费为 15 。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
      - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
      - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
      - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
      - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
      - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
      - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
      总花费为 6 。
</code></pre><p><strong>提示：</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">2 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>cost.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>cost[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>999</mn></mrow><annotation encoding="application/x-tex">\le 999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span></p><h2 id="method-动态规划-31"><a class="anchor" href="#method-动态规划-31">#</a> Method: 动态规划</h2><p>注意，楼梯顶部对应的是第 <code>cost.size()</code> 个台阶</p><p>算法思路：</p><ol><li><p>确定 <code>dp</code> 数组及其含义： <code>vector&lt;int&gt; dp(cost.size() + 1, 0)</code> ，其中， <code>dp[i]</code> 表示到达第 <code>i</code> 个台阶的最低费用</p></li><li><p>确定递推公式： <code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></p><ul><li>可以从第 <code>i - 1</code> 阶爬 1 个台阶到达第 <code>i</code> 阶，费用为 <code>dp[i - 1] + cost[i - 1]</code></li><li>也可以从第 <code>i - 2</code> 阶爬 2 个台阶到达第 <code>i</code> 阶，费用为 <code>dp[i - 2] + cost[i - 2]</code></li><li>综合两种情况，从中选择费用最低的，即， <code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></li></ul></li><li><p>初始化 <code>dp</code> 数组： <code>dp[0] = 0</code> ， <code>dp[1] = 0</code></p><ul><li>第 0 个台阶和第 1 个台阶可以作为起点，因此，到达第 0 个台阶和第 1 个台阶的费用均为 0 ，即 <code>dp[0] = dp[1] = 0</code></li></ul></li><li><p>确定遍历顺序：根据递推公式可知， <code>dp[i]</code> 依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> ，因此，应按 <code>i</code> 从小到大遍历</p></li><li><p>举例推导 <code>dp</code> 数组</p></li></ol><p>最后， <code>dp[cost.size()]</code> 就是到达楼梯顶部的最低费用</p><p>代码实现：</p><pre><code class="language-cpp">int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;
    int n = cost.size();
    vector&lt;int&gt; dp(n + 1, 0); // dp[i] 表示到达下标 i 的最低费用
    for (int i = 2; i &lt;= n; i++) &#123;
        dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    &#125;
    return dp[n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><div class="tags"><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"><i class="ic i-tag"></i> 动态规划</a></div></div><footer><div class="meta"><span class="item"><time title="修改时间：2024-03-23 01:16:15" itemprop="dateModified" datetime="2024-03-23T01:16:15+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2024-03-23 </time></span><span id="posts/5e11e767/" class="item leancloud_visitors" data-flag-title="LeetCode - 动态规划专题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/5e11e767/" title="LeetCode - 动态规划专题">https://jiankychen.github.io/posts/5e11e767/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/f3b1f59f/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;99fb5ff897a82984470abf5e2a235d94.jpg" title="LeetCode - 贪心专题"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 贪心专题</h3></a></div><div class="item right"><a href="/posts/611c1217/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;470d00578173666b5183f4631e51a421.jpg" title="LeetCode - 双指针专题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 双指针专题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 10. 正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-number">2.</span> <span class="toc-text">LeetCode 1035. 不相交的线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-number">2.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii"><span class="toc-number">3.</span> <span class="toc-text">LeetCode 1049. 最后一块石头的重量 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-number">3.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">LeetCode 1143. 最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-number">4.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">LeetCode 115. 不同的子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="toc-number">5.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">LeetCode 121. 买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E8%B4%AA%E5%BF%83"><span class="toc-number">6.1.</span> <span class="toc-text">Method 1: 贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.2.</span> <span class="toc-text">Method 2: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iii"><span class="toc-number">7.</span> <span class="toc-text">LeetCode 123. 买卖股票的最佳时机 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-6"><span class="toc-number">7.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">8.</span> <span class="toc-text">LeetCode 139. 单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-7"><span class="toc-number">8.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">9.</span> <span class="toc-text">LeetCode 152. 乘积最大子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-8"><span class="toc-number">9.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iv"><span class="toc-number">10.</span> <span class="toc-text">LeetCode 188. 买卖股票的最佳时机 IV</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-9"><span class="toc-number">10.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">11.</span> <span class="toc-text">LeetCode 198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-10"><span class="toc-number">11.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">12.</span> <span class="toc-text">LeetCode 203. 移除链表元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">12.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%8E%9F%E9%93%BE%E8%A1%A8%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">12.2.</span> <span class="toc-text">Method 1: 直接使用原链表来进行删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9%E5%86%8D%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">12.3.</span> <span class="toc-text">Method 2: 设置虚拟头节点再进行删除操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii"><span class="toc-number">13.</span> <span class="toc-text">LeetCode 213. 打家劫舍 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">13.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-11"><span class="toc-number">13.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">14.</span> <span class="toc-text">LeetCode 221. 最大正方形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-12"><span class="toc-number">14.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">15.</span> <span class="toc-text">LeetCode 27. 移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">15.1.</span> <span class="toc-text">Method 1: 双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96"><span class="toc-number">15.2.</span> <span class="toc-text">Method 2: 双指针优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">LeetCode 279. 完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">16.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-13"><span class="toc-number">16.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">17.</span> <span class="toc-text">LeetCode 300. 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-14"><span class="toc-number">17.1.</span> <span class="toc-text">Method: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">17.2.</span> <span class="toc-text">Method 2: 贪心 + 二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number">18.</span> <span class="toc-text">LeetCode 309. 最佳买卖股票时机含冷冻期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-15"><span class="toc-number">18.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-312-%E6%88%B3%E6%B0%94%E7%90%83"><span class="toc-number">19.</span> <span class="toc-text">LeetCode 312. 戳气球</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">19.1.</span> <span class="toc-text">Method 1: 记忆化搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-number">19.2.</span> <span class="toc-text">Method 2: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">20.</span> <span class="toc-text">LeetCode 32. 最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-16"><span class="toc-number">20.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">21.</span> <span class="toc-text">LeetCode 322. 零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">21.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-17"><span class="toc-number">21.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii"><span class="toc-number">22.</span> <span class="toc-text">LeetCode 337. 打家劫舍 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">22.1.</span> <span class="toc-text">Method: 递归 + 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">23.</span> <span class="toc-text">LeetCode 343. 整数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-18"><span class="toc-number">23.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iv"><span class="toc-number">24.</span> <span class="toc-text">LeetCode 377. 组合总和 IV</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">24.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-19"><span class="toc-number">24.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">25.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">26.</span> <span class="toc-text">LeetCode 392. 判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-number">26.1.</span> <span class="toc-text">Method 1: 双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-number">26.2.</span> <span class="toc-text">Method 2: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-2"><span class="toc-number">26.3.</span> <span class="toc-text">进阶</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">27.</span> <span class="toc-text">LeetCode 416. 分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-20"><span class="toc-number">27.1.</span> <span class="toc-text">Method: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">27.2.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">27.3.</span> <span class="toc-text">思路二</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-474-%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">28.</span> <span class="toc-text">LeetCode 474. 一和零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">28.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-21"><span class="toc-number">28.2.</span> <span class="toc-text">Method: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">28.3.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">29.</span> <span class="toc-text">LeetCode 494. 目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">29.1.</span> <span class="toc-text">Method 1: 深度优先搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">29.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">29.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">29.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-number">29.5.</span> <span class="toc-text">Method 2: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-2"><span class="toc-number">29.6.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">29.7.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">29.8.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">29.9.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">30.</span> <span class="toc-text">LeetCode 5. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-22"><span class="toc-number">30.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">31.</span> <span class="toc-text">LeetCode 509. 斐波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-23"><span class="toc-number">31.1.</span> <span class="toc-text">Method: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-2"><span class="toc-number">31.2.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">32.</span> <span class="toc-text">LeetCode 516. 最长回文子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-24"><span class="toc-number">32.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii"><span class="toc-number">33.</span> <span class="toc-text">LeetCode 518. 零钱兑换 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">33.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-25"><span class="toc-number">33.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">34.</span> <span class="toc-text">LeetCode 583. 两个字符串的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">34.1.</span> <span class="toc-text">Method 1: 最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="toc-number">34.2.</span> <span class="toc-text">Method 2: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">35.</span> <span class="toc-text">LeetCode 62. 不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-26"><span class="toc-number">35.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii"><span class="toc-number">36.</span> <span class="toc-text">LeetCode 63. 不同路径 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-27"><span class="toc-number">36.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">37.</span> <span class="toc-text">LeetCode 64. 最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-28"><span class="toc-number">37.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">38.</span> <span class="toc-text">LeetCode 647. 回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-29"><span class="toc-number">38.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-number">39.</span> <span class="toc-text">LeetCode 674. 最长连续递增序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">39.1.</span> <span class="toc-text">Method 1: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%B4%AA%E5%BF%83"><span class="toc-number">39.2.</span> <span class="toc-text">Method 2: 贪心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">40.</span> <span class="toc-text">LeetCode 70. 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-number">40.1.</span> <span class="toc-text">Method 1: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">40.2.</span> <span class="toc-text">Method 2: 完全背包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">41.</span> <span class="toc-text">LeetCode 718. 最长重复子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-number">41.1.</span> <span class="toc-text">Method 1: 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80"><span class="toc-number">41.2.</span> <span class="toc-text">实现一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%8C"><span class="toc-number">41.3.</span> <span class="toc-text">实现二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-3"><span class="toc-number">41.4.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">42.</span> <span class="toc-text">LeetCode 72. 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-30"><span class="toc-number">42.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">43.</span> <span class="toc-text">LeetCode 746. 使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-31"><span class="toc-number">43.1.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/1b7ed9b4/" rel="bookmark" title="LeetCode Records">LeetCode Records</a></li><li><a href="/posts/32d5c1f6/" rel="bookmark" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></li><li><a href="/posts/2057f45/" rel="bookmark" title="LeetCode - 数组专题">LeetCode - 数组专题</a></li><li><a href="/posts/bc32ab1e/" rel="bookmark" title="LeetCode - 链表专题">LeetCode - 链表专题</a></li><li><a href="/posts/29abbd18/" rel="bookmark" title="LeetCode - 哈希表专题">LeetCode - 哈希表专题</a></li><li><a href="/posts/36947f98/" rel="bookmark" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></li><li><a href="/posts/51f34f0/" rel="bookmark" title="LeetCode - 栈与队列专题">LeetCode - 栈与队列专题</a></li><li><a href="/posts/ed3025a8/" rel="bookmark" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></li><li><a href="/posts/6012cc6b/" rel="bookmark" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></li><li><a href="/posts/f3b1f59f/" rel="bookmark" title="LeetCode - 贪心专题">LeetCode - 贪心专题</a></li><li class="active"><a href="/posts/5e11e767/" rel="bookmark" title="LeetCode - 动态规划专题">LeetCode - 动态规划专题</a></li><li><a href="/posts/611c1217/" rel="bookmark" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></li><li><a href="/posts/691b4be6/" rel="bookmark" title="LeetCode - 单调栈专题">LeetCode - 单调栈专题</a></li><li><a href="/posts/537e2e53/" rel="bookmark" title="LeetCode - 搜索专题">LeetCode - 搜索专题</a></li><li><a href="/posts/242193c5/" rel="bookmark" title="LeetCode - 排序专题">LeetCode - 排序专题</a></li><li><a href="/posts/f994a74a/" rel="bookmark" title="常见输入输出">常见输入输出</a></li><li><a href="/posts/def81c82/" rel="bookmark" title="LeetCode - 模拟专题">LeetCode - 模拟专题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">52</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/f3b1f59f/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/611c1217/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/6012cc6b/" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/36947f98/" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/b80c5159/" title="conda 常用命令">conda 常用命令</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/SQL/" title="分类于 SQL">SQL</a></div><span><a href="/posts/f416b295/" title="SQL 基础">SQL 基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/9e07c79c/" title="C++ 类">C++ 类</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/691b4be6/" title="LeetCode - 单调栈专题">LeetCode - 单调栈专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/2057f45/" title="LeetCode - 数组专题">LeetCode - 数组专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/b8928e0e/" title="数据结构简介">数据结构简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/afade57b/" title="递推与递归">递推与递归</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/72c3df1c/" title="Dijkstra">Dijkstra</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">821k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:48</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/5e11e767/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->