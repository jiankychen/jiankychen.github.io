<!-- build time:Sat Mar 23 2024 01:17:15 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="2x-AZKhVa94zRjcvqeVJ3rz6zaOo8YoY6KED0ROdfCY"><meta name="msvalidate.01" content="83838B7BA6376B5BD60C2E20978C1356"><meta name="baidu-site-verification" content="codeva-kq4MKFD3xG"><link rel="alternate" type="application/rss+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Jiankychen's Blog" href="https://jiankychen.github.io/atom.xml"><link rel="alternate" type="application/json" title="Jiankychen's Blog" href="https://jiankychen.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="二叉树"><link rel="canonical" href="https://jiankychen.github.io/posts/ed3025a8/"><title>LeetCode - 二叉树专题 - Coding | Jiankychen's Blog</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="container"><div class="loader"><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--dot"></div><div class="loader--text"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">LeetCode - 二叉树专题</h1><div class="meta"><span class="item" title="创建时间：2022-06-09 20:31:59"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-09T20:31:59+08:00">2022-06-09</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>109k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>3:02</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiankychen</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/65d0bfef68566882ce0560cab2e87921.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/9b626c5ba21d7cb4dbcba2b507688bbb.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1135e8eb0ca0a462aa1c2f6ecb6a5ae2.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/99fb5ff897a82984470abf5e2a235d94.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a1f3404a5032323ea4857ac5a6354d2f.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/e5221f7d85b0900837a45fb933fa34ec.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Coding/" itemprop="item" rel="index" title="分类于 Coding"><span itemprop="name">Coding</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jiankychen.github.io/posts/ed3025a8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://www.helloimg.com/image/oTb9AX"><meta itemprop="name" content="Jiankychen"><meta itemprop="description" content="Never put off till tomorrow what you can do today, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jiankychen's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="leetcode-100-相同二叉树"><a class="anchor" href="#leetcode-100-相同二叉树">#</a> LeetCode 100. 相同二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYW1lLXRyZWUv">100. Same Tree</span></p><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode100-%E7%9B%B8%E5%90%8C%E4%BA%8C%E5%8F%89%E6%A0%91/ex1.jpg" alt=""></p><pre><code>输入：p = [1,2,3], q = [1,2,3]
输出：true
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode100-%E7%9B%B8%E5%90%8C%E4%BA%8C%E5%8F%89%E6%A0%91/ex2.jpg" alt=""></p><pre><code>输入：p = [1,2], q = [1,null,2]
输出：false
</code></pre><p><strong>示例 3：</strong></p><p><img data-src="LeetCode100-%E7%9B%B8%E5%90%8C%E4%BA%8C%E5%8F%89%E6%A0%91/ex3.jpg" alt=""></p><pre><code>输入：p = [1,2,1], q = [1,1,2]
输出：false
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路"><a class="anchor" href="#思路">#</a> 思路</h2><p>如果两棵树的所有节点都相同，则这两棵二叉树相同</p><p>因此，判断两棵二叉树是否相同的步骤可分为：</p><ul><li>判断根节点的值是否相等</li><li>判断左子树是否相同</li><li>判断右子树是否相同</li></ul><p>解法类似于 <a href="https://jiankychen.github.io/posts/3c1e41f">LeetCode 101. 对称二叉树</a></p><h2 id="method-1-递归"><a class="anchor" href="#method-1-递归">#</a> Method 1: 递归</h2><p>算法思路：</p><ol><li><p>定义递归函数：检查以 <code>p</code> 、 <code>q</code> 为根节点的两棵是否相同</p></li><li><p>递归函数的内部，做以下判断：</p><ul><li>若 <code>p</code> 与 <code>q</code> 同时为空，则两树相同</li><li>若 <code>p</code> 与 <code>q</code> 不同时为空，则两树不同</li><li>若 <code>p</code> 与 <code>q</code> 的值不相等，则两树相同</li><li>若 <code>p</code> 的左子树 与 <code>q</code> 的左子树不相同，则两树不同</li><li>若 <code>p</code> 的右子树 与 <code>q</code> 的右子树不相同，则两树不同</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;
    if (!p &amp;&amp; !q) return true;
    if (!p || !q) return false;
    if (p-&gt;val != q-&gt;val) return false;
    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是两棵二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><ul><li>递归调用的层数不会超过较小的二叉树的最大高度</li><li>最坏情况下，二叉树的高度等于节点数</li></ul><h2 id="method-2-迭代"><a class="anchor" href="#method-2-迭代">#</a> Method 2: 迭代</h2><p>本题也可以使用迭代法来显式地维护 Method 1 中调用的栈</p><p>这里利用 栈 来存放待访问的节点（也可以使用队列，区别仅在于节点的访问顺序）</p><h3 id="写法一"><a class="anchor" href="#写法一">#</a> 写法一</h3><p>类似于 <a href="https://jiankychen.github.io/posts/3c1e41f">LeetCode 101. 对称二叉树</a> 的 Method 2</p><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;
    stack&lt;TreeNode*&gt; stk;
    stk.push(q);
    stk.push(p);
    TreeNode *u = nullptr, *v = nullptr;
    while (!stk.empty()) &#123;
        u = stk.top();
        stk.pop();
        v = stk.top();
        stk.pop();
        if ((u == nullptr) &amp;&amp; (v == nullptr)) continue;
        if ((u == nullptr) || (v == nullptr)) return false;
        if (u-&gt;val != v-&gt;val) return false;
        stk.push(v-&gt;right);
        stk.push(u-&gt;right);
        stk.push(v-&gt;left);
        stk.push(u-&gt;left);
    &#125;
    return true;
&#125;
</code></pre><p>若采用 队列 来实现迭代法，将上述代码中的 栈（及其成员函数）替换为 队列（及其成员函数）即可</p><h3 id="写法二"><a class="anchor" href="#写法二">#</a> 写法二</h3><p>为降低算法复杂度，可以仅将非空节点入栈</p><p>因此，在将两棵树的子节点入栈前，须对两棵树的结构进行判断</p><p>算法思路：</p><ol><li>定义一个栈，若 <code>p</code> 与 <code>q</code> 非空，将其入栈</li><li>执行循环，直到栈为空：<ul><li>从栈中取出两个节点，记作 <code>u</code> 和 <code>v</code></li><li>判断 <code>u</code> 和 <code>v</code> 的值是否相等</li><li>判断 <code>u</code> 的右子节点 和 <code>v</code> 的右子节点 是否为空<ul><li>如果有且仅有一个为空，则说明 <code>u</code> 和 <code>v</code> 的右子树结构不同，返回 <code>false</code></li><li>如果均不为空，则将其入栈，以进一步判断右子树是否相同</li></ul></li><li>判断 <code>u</code> 和 <code>v</code> 的左子节点是否为空，类似于上一步</li></ul></li><li>循环结束时，栈为空，且不存在不相同的节点，返回 <code>true</code></li></ol><p>其中，当 <code>u</code> 和 <code>v</code> 的右子节点均为空时，对应的右子树相同，无需再将其入栈，类似地，当 <code>u</code> 和 <code>v</code> 的左子节点均为空时，也无需将其入栈</p><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;
    if (!p &amp;&amp; !q) return true;
    if (!p || !q) return false;
    stack&lt;TreeNode*&gt; stk;
    stk.push(q);
    stk.push(p);
    TreeNode *u = nullptr, *v = nullptr;
    while (!stk.empty()) &#123;
        u = stk.top();
        stk.pop();
        v = stk.top();
        stk.pop();
        if (u-&gt;val != v-&gt;val) return false;
        if ((u-&gt;right == nullptr) ^ (v-&gt;right == nullptr)) // u 或 v 不存在右子节点
            return false;
        if ((u-&gt;left == nullptr) ^ (v-&gt;left == nullptr))   // u 或 v 不存在左子节点
            return false;
        if (v-&gt;right) stk.push(v-&gt;right); // 将非空的右子节点入栈
        if (u-&gt;right) stk.push(u-&gt;right);
        if (v-&gt;left) stk.push(v-&gt;left);   // 将非空的左子节点入栈
        if (u-&gt;left) stk.push(u-&gt;left);
    &#125;
    return true;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是两棵二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYW1lLXRyZWUvc29sdXRpb24veGlhbmctdG9uZy1kZS1zaHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：相同的树</span></p><h1 id="leetcode-101-对称二叉树"><a class="anchor" href="#leetcode-101-对称二叉树">#</a> LeetCode 101. 对称二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">LeetCode 101. Symmetric Tree</span></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/symtree1.jpg" alt=""></p><pre><code>输入：root = [1,2,2,3,4,4,3]
输出：true
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/symtree2.jpg" alt=""></p><pre><code>输入：root = [1,2,2,null,3,null,3]
输出：false
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：你可以运用递归和迭代两种方法解决这个问题吗？</p><h2 id="思路-2"><a class="anchor" href="#思路-2">#</a> 思路</h2><p>如果一棵树的左子树与右子树对称，那么这棵树就是对称的</p><p>进一步地分析，子树 A1 与子树 A2 对称，需要满足以下条件：</p><ul><li>A1 的根节点值 等于 A2 的根节点值</li><li>A1 的左子树 与 A2 的右子树 对称</li><li>A1 的右子树 与 A2 的左子树 对称</li></ul><p>如下图所示，检查二叉树对称性的步骤可分为：</p><ul><li>检查 B 与 C 的值是否相等</li><li>检查 D 与 G 的值是否相等</li><li>检查 E 与 F 的值是否相等</li></ul><p><img data-src="LeetCode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/example.png" alt=""></p><h2 id="method-1-递归-2"><a class="anchor" href="#method-1-递归-2">#</a> Method 1: 递归</h2><p>算法思路：</p><ol><li><p>定义一个递归函数，函数传入两个参数：</p><ul><li>指针 <code>l</code> ：指向左侧的子树 A1</li><li>指针 <code>r</code> ：指向右侧的子树 A2</li></ul></li><li><p>递归函数的作用：检查子树 A1 与 A2 是否对称</p></li><li><p>递归函数的内部，做以下判断：</p><ul><li>若 <code>l</code> 与 <code>r</code> 同时为空，则 A1 与 A2 对称</li><li>若 <code>l</code> 与 <code>r</code> 不同时为空，则 A1 与 A2 不对称</li><li>若 <code>l</code> 与 <code>r</code> 的值不相等，则 A1 与 A2 不对称</li><li>若 <code>l</code> 的左子树 与 <code>r</code> 的右子树不对称，则 A1 与 A2 不对称</li><li>若 <code>l</code> 的右子树 与 <code>r</code> 的左子树不对称，则 A1 与 A2 不对称</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool check(TreeNode* l, TreeNode* r) &#123;  // 检查 l 与 r 及其子树是否对称
    if (l == nullptr &amp;&amp; r == nullptr) return true;  // l 与 r 均为空
    if (l == nullptr || r == nullptr) return false; // l 为空，或，r 为空
    if (l-&gt;val != r-&gt;val) return false; // 检查 l 与 r 是否对称
    return check(l-&gt;left, r-&gt;right) &amp;&amp; check(l-&gt;right, r-&gt;left); // 检查 l 与 r 的子树是否对称
&#125;

bool isSymmetric(TreeNode* root) &#123;
    if (root == nullptr) return true;
    return check(root-&gt;left, root-&gt;right);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><h2 id="method-2-迭代-2"><a class="anchor" href="#method-2-迭代-2">#</a> Method 2: 迭代</h2><p>对于二叉树的前序、中序、后序遍历，我们可以使用迭代法来显式地维护递归调用的栈</p><p>类似地，本题可以定义一个 队列 来显式地维护 Method 1 中递归调用的栈，以检查两棵子树的对称性</p><blockquote><p>这里为了能够逐层遍历，采用的是 队列 来实现迭代法，事实上，也可以使用 栈 来实现</p></blockquote><p>算法流程：</p><ol><li>定义一个队列，并将根节点 <code>root</code> 的两个子节点入队</li><li>执行循环，直到队列为空：<ul><li>从队列中取出两个节点，记作 <code>u</code> 和 <code>v</code> （类似于 Method 1 中的 指针 <code>l</code> 和 <code>r</code> ，分别指向子树 A1 和 A2）</li><li>若 <code>u</code> 和 <code>v</code> 均为空，则跳过本次循环</li><li>若 <code>u</code> 和 <code>v</code> 中有且仅有一个为空，则子树不对称，返回 <code>false</code></li><li>若 <code>u</code> 和 <code>v</code> 均不为空，判断 <code>u</code> 与 <code>v</code> 的值是否相等，若不相等，则返回 <code>false</code></li><li>将 <code>u</code> 的左子节点、 <code>v</code> 的右子节点依次入队</li><li>将 <code>u</code> 的右子节点、 <code>v</code> 的左子节点依次入队</li></ul></li><li>循环结束时，队列为空，不存在不对称的子树，返回 <code>true</code></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool isSymmetric(TreeNode* root) &#123;
    if (root == nullptr) return true;
    queue&lt;TreeNode*&gt; que;
    que.push(root-&gt;left);
    que.push(root-&gt;right);
    TreeNode *u = new TreeNode(0), *v = new TreeNode(0);
    while (!que.empty()) &#123;
        u = que.front();    // 指向子树 A1
        que.pop();
        v = que.front();    // 指向子树 A2
        que.pop();
        if (!u &amp;&amp; !v) continue;             // A1 与 A2 同时为空
        if (!u || !v) return false;         // A1 与 A2 不同时为空
        if (u-&gt;val != v-&gt;val) return false; // A1 与 A2 的根节点值不相等
        que.push(u-&gt;left);  // A1 的左子树
        que.push(v-&gt;right); // A2 的右子树
        que.push(u-&gt;right); // A1 的右子树
        que.push(v-&gt;left);  // A2 的左子树
    &#125;
    return true;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-102-二叉树的层序遍历"><a class="anchor" href="#leetcode-102-二叉树的层序遍历">#</a> LeetCode 102. 二叉树的层序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">LeetCode 102. Binary Tree Level Order Traversal</span></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/1.jpg" alt=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]
输出：[[1]]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-3"><a class="anchor" href="#思路-3">#</a> 思路</h2><p>逐层遍历二叉树，其中，每层按从左到右顺序遍历</p><p>由于队列具有先进先出特性，本题可利用队列来存放 待访问的节点，即，按从左到右的顺序将待访问的节点依次加入到队列中</p><p>注意本题要求输出一个二维数组，其中，二维数组中的每一个一维数组，表示 二叉树每一层上所有节点的值。因此，一维数组的长度 即为 对应层上的二叉树节点数，亦为 上一层访问结束后的队列长度</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="二叉树的层序遍历" height="400px"></p><h2 id="method-广度优先搜索"><a class="anchor" href="#method-广度优先搜索">#</a> Method: 广度优先搜索</h2><p>算法思路：</p><ol><li><p>将根节点入队</p></li><li><p>当队列不为空，执行以下循环：</p><ul><li>求当前队列的长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></li><li>依次从队列中取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 个元素：<ul><li>读取其值，将值临时存放到一维数组 <code>tmp</code> 中</li><li>将非空的左、右子节点依次入队</li></ul></li><li>将一维数组 <code>tmp</code> 添加到目标数组 <code>res</code></li></ul></li></ol><blockquote><p>普通的广度优先搜索每次只取 1 个元素拓展，而这里每次取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 个元素，即，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 次迭代就得到了二叉树的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 层的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 个元素</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
    vector&lt;vector&lt;int&gt;&gt; res;
    queue&lt;TreeNode*&gt; que; // 队列存放的是待展开的二叉树节点
    if (root != nullptr) que.push(root);
    while (!que.empty()) &#123;
        vector&lt;int&gt; tmp;
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            TreeNode* node = que.front();
            que.pop();
            tmp.push_back(node-&gt;val);
            if (node-&gt;left != nullptr) que.push(node-&gt;left);
            if (node-&gt;right != nullptr) que.push(node-&gt;right);
        &#125;
        res.push_back(tmp);
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每个点入队出队各一次，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为树的所有节点的个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，队列中元素的个数不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDIuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU1JUIxJTgyJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2Lmh0bWw=">代码随想录：二叉树的层序遍历</span></p><h1 id="leetcode-104-二叉树的最大深度"><a class="anchor" href="#leetcode-104-二叉树的最大深度">#</a> LeetCode 104. 二叉树的最大深度</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">LeetCode 104. Maximum Depth of Binary Tree</span></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明</strong>：叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/tmp-tree.jpg" alt="" height="150px"></p><pre><code>输入：root = [3,9,20,null,null,15,7]
输出：3
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,null,2]
输出：2
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-4"><a class="anchor" href="#思路-4">#</a> 思路</h2><p>二叉树的深度是从上往下数，而高度是从下往上数</p><p>即，按前序遍历顺序求的是二叉树的深度，按后序遍历顺序求的是二叉树的高度。具体可参考 <a href="https://jiankychen.github.io/posts/cd137cbe/">LeetCode 110. 平衡二叉树</a> 中的概念辨析</p><h2 id="method-1-递归-3"><a class="anchor" href="#method-1-递归-3">#</a> Method 1: 递归</h2><p>本题可通过后序遍历来计算根节点的高度，从而得到二叉树的最大深度（根节点的高度，即为二叉树的最大深度）</p><p>算法思路：</p><ul><li (l,="" r)=""><p>若已知左子树和右子树的高度分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span> ，则二叉树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>max</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">1 + \max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mop">max</span></span></span></span></p></li><li><p>左子树与右子树的高度可通过同样方式获得，即，递归</p></li><li><p>递归的终止条件为：节点为空</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(TreeNode* root) &#123;
    if (root == nullptr) return 0; // 当 root 为空时，深度为 0
    int l = maxDepth(root-&gt;left);  // 左子树的高度
    int r = maxDepth(root-&gt;right); // 右子树的高度
    int ans = 1 + max(l, r);
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span></span></span></span> 为二叉树的最大深度（这里考虑了递归所需的栈空间）</p><blockquote><p>本题也可以使用前序遍历计算节点的深度，节点深度的最大值即为二叉树的最大深度。具体可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDQuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU1JUE0JUE3JUU2JUI3JUIxJUU1JUJBJUE2Lmh0bWwjJUU5JTgwJTkyJUU1JUJEJTkyJUU2JUIzJTk1">代码随想录：二叉树的最大深度</span></p></blockquote><h2 id="method-2-层序遍历"><a class="anchor" href="#method-2-层序遍历">#</a> Method 2: 层序遍历</h2><p>算法思路：</p><ul><li>利用队列存储待访问的节点，与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似</li><li>逐层遍历，遍历的层数就是二叉树的最大深度（即，从根节点到最底层节点所经历的层数）</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(TreeNode* root) &#123;
    int ans = 0; // 二叉树的深度
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            TreeNode* tmp = que.front();
            que.pop();
            if (tmp-&gt;left) que.push(tmp-&gt;left);
            if (tmp-&gt;right) que.push(tmp-&gt;right);
        &#125;
        ans++;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL3NvbHV0aW9uL2VyLWNoYS1zaHUtZGUtenVpLWRhLXNoZW4tZHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：二叉树的最大深度</span></p><h1 id="leetcode-559-n-叉树的最大深度"><a class="anchor" href="#leetcode-559-n-叉树的最大深度">#</a> LeetCode 559. N 叉树的最大深度</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLW4tYXJ5LXRyZWUv">LeetCode 559. Maximum Depth of N-ary Tree</span></p><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/narytreeexample1.png" alt=""></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]
输出：3
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/narytreeexample2.png" alt=""></p><pre><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树的深度不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>树的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li></ul><h2 id="method-1-递归-4"><a class="anchor" href="#method-1-递归-4">#</a> Method 1: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(Node* root) &#123;
    if (!root) return 0;
    int depth = 0;
    for (int i = 0; i &lt; root-&gt;children.size(); i++) &#123;
        int temp = maxDepth(root-&gt;children[i]); // 第 i 棵子树的最大深度
        depth = max(depth, temp); // 所有子树的最大深度
    &#125;
    return 1 + depth;             // 以 root 为根节点的树的最大深度
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为 N 叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span></span></span></span> 为 N 叉树的最大深度（这里考虑了递归所需的栈空间）</p><h2 id="method-2-层序遍历-2"><a class="anchor" href="#method-2-层序遍历-2">#</a> Method 2: 层序遍历</h2><p>代码实现：</p><pre><code class="language-cpp">int maxDepth(Node* root) &#123;
    int depth = 0;
    queue&lt;Node*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        depth++;
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            Node* tmp = que.front();
            que.pop();
            for (int j = 0; j &lt; tmp-&gt;children.size(); j++)
                if (tmp-&gt;children[j]) que.push(tmp-&gt;children[j]);
        &#125;
    &#125;
    return depth;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为 N 叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-105-从前序与中序遍历序列构造二叉树"><a class="anchor" href="#leetcode-105-从前序与中序遍历序列构造二叉树">#</a> LeetCode 105. 从前序与中序遍历序列构造二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwv">105. Construct Binary Tree from Preorder and Inorder Traversal</span></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的先序遍历， <code>inorder</code> 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/tree.jpg" alt=""></p><pre><code>输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出：[3,9,20,null,null,15,7]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：preorder = [-1], inorder = [-1]
输出：[-1]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>preorder.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>inorder.length == preorder.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>3000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-3000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>preorder[i]</code> , <code>inorder[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>preorder</code> 和 <code>inorder</code> 均无重复元素</li><li><code>inorder</code> 的每个元素均出现在 <code>preorder</code></li><li><code>preorder</code> 保证为二叉树的前序遍历序列</li><li><code>inorder</code> 保证为二叉树的中序遍历序列</li></ul><h2 id="思路-5"><a class="anchor" href="#思路-5">#</a> 思路</h2><p>根据前序遍历数组的第一个元素来确定根节点</p><p>在中序遍历数组中找到根节点，根节点左侧、右侧分别为左子树、右子树的中序遍历序列</p><p>根据左子树的中序遍历序列长度，确定左子树、右子树的前序遍历序列</p><ul><li>树的中序遍历序列长度等于前序遍历序列长度，并且同一棵树的节点在遍历数组中连续</li></ul><p>依此类推，最终可确定每个节点的左、右子节点</p><h2 id="method-递归"><a class="anchor" href="#method-递归">#</a> Method: 递归</h2><p>算法思路：类似于 <a href="https://jiankychen.github.io/posts/65174f2a">LeetCode 106. 从中序与后序遍历序列构造二叉树</a></p><blockquote><p>分割数组时，坚持区间不变量原则，左闭右开，或者左闭右闭</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preorderBegin, int preorderEnd, int inorderBegin, int inorderEnd) &#123;
    if (preorderBegin == preorderEnd) return nullptr;
    
    // 根节点
    int rootValue = preorder[preorderBegin];
    TreeNode *root = new TreeNode(rootValue);
    
    // 中序遍历分界线
    int delimiterIndex = inorderBegin;
    for (; delimiterIndex &lt; inorderEnd; delimiterIndex++)
        if (inorder[delimiterIndex] == rootValue) break;
    
    // 左子树的节点数
    int leftSize = delimiterIndex - inorderBegin;

    // 左子树的前序区间：[preorderBegin + 1, preorderBegin + 1 + leftSize) 
    // 左子树的中序区间：[inorderBegin, delimiterIndex)
    root-&gt;left = traversal(preorder, inorder, preorderBegin + 1, preorderBegin + 1 + leftSize, inorderBegin, delimiterIndex);

    // 右子树的前序区间：[preorderBegin + 1 + leftSize, preorderEnd)
    // 右子树的中序区间：[delimiterIndex + 1, inorderEnd)
    root-&gt;right = traversal(preorder, inorder, preorderBegin + 1 + leftSize, preorderEnd, delimiterIndex + 1, inorderEnd);

    return root;
&#125;

TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
    return traversal(preorder, inorder, 0, preorder.size(), 0, inorder.size());
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>每个节点都将调用一次 <code>traversal</code> 函数，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次调用 <code>traversal</code> 函数时，需要找到根节点在中序遍历数组中的位置<ul><li>平均情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><h2 id="优化"><a class="anchor" href="#优化">#</a> 优化</h2><p>可以考虑使用哈希表来快速定位根节点在中序遍历数组中的位置</p><ul><li><code>key</code> 表示一个元素（节点的值）， <code>value</code> 表示其在中序遍历序列中的出现位置</li></ul><p>具体实现：</p><ol><li><p>定义全局变量</p><pre><code class="language-cpp">unordered_map&lt;int, int&gt; index;
</code></pre></li><li><p>在 <code>buildTree</code> 函数中，构造哈希映射</p><pre><code class="language-cpp">for (int i = 0; i &lt; n; ++i) &#123;
    index[inorder[i]] = i;
&#125;
</code></pre></li><li><p>在递归函数 <code>traversal</code> 中，使用哈希表查询根节点</p><pre><code class="language-cpp">int delimiterIndex = index[preorder[preorderBegin]]; // preorder 首元素为根节点的值
</code></pre></li></ol><p>优化后的算法时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwvc29sdXRpb24vY29uZy1xaWFuLXh1LXl1LXpob25nLXh1LWJpYW4tbGkteHUtbGllLWdvdS16YW8tOS8=">力扣官方题解：从前序与中序遍历序列构造二叉树</span></p><h1 id="leetcode-106-从中序与后序遍历序列构造二叉树"><a class="anchor" href="#leetcode-106-从中序与后序遍历序列构造二叉树">#</a> LeetCode 106. 从中序与后序遍历序列构造二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1pbm9yZGVyLWFuZC1wb3N0b3JkZXItdHJhdmVyc2FsLw==">106. Construct Binary Tree from Inorder and Postorder Traversal</span></p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/tree.jpg" alt=""></p><pre><code>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：inorder = [-1], postorder = [-1]
输出：[-1]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>inorder.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>postorder.length == inorder.length</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>3000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-3000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>inorder[i]</code> , <code>postorder[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>inorder</code> 和 <code>postorder</code> 均无重复元素</li><li><code>postorder</code> 的每个元素均出现在 <code>inorder</code></li><li><code>inorder</code> 保证为二叉树的中序遍历序列</li><li><code>postorder</code> 保证为二叉树的后序遍历序列</li></ul><h2 id="思路-6"><a class="anchor" href="#思路-6">#</a> 思路</h2><p>根据后序遍历的最后一个元素来确定根节点</p><p>在中序遍历中找到根节点，得到左子树的中序遍历、右子树的中序遍历</p><ul><li>依据：在中序遍历的数组中，根节点左侧为左子树，右侧为右子树</li></ul><p>在后序遍历中分别找到左子树所有节点、右子树所有节点，即可得到左子树、右子树的后序遍历</p><ul><li>依据：后序遍历的数组大小等于中序的数组大小，同一棵树的节点在遍历数组中连续</li></ul><p>依此类推，最终可确定每个节点的左、右子节点</p><h2 id="method-递归-2"><a class="anchor" href="#method-递归-2">#</a> Method: 递归</h2><p>算法流程：</p><ul><li><p>若二叉树的中序遍历数组为空，当前树为空</p></li><li><p>若不为空，取后序数组的最后一个元素作为根节点</p></li><li><p>找到根节点在中序数组的位置，作为切割点</p></li><li><p>切割中序数组，分成中序左数组、中序右数组</p></li><li><p>根据中序左数组、中序右数组的大小来切割后序数组，将其分成后序左数组、后序右数组</p></li><li><p>递归处理左子树和右子树</p></li></ul><blockquote><p>分割数组时，坚持区间不变量原则，左闭右开，或者左闭右闭</p></blockquote><p>为降低时空间复杂度，通过使用左子树、右子树节点在数组 <code>inorder</code> 和 <code>postorder</code> 的下标索引，表示左子树、右子树的中序、后序遍历的结果数组</p><p>代码实现：</p><pre><code class="language-cpp">// 根据中序区间和后序区间确定根节点及左右子树
// 中序区间 [inorderBegin, inorderEnd)，后序区间 [postorderBegin, postorderEnd)
TreeNode* traversal(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd) &#123;
    if (inorderBegin == inorderEnd) return nullptr;  // 空数组，二叉树为空
    int rootValue = postorder[postorderEnd - 1];     // 后序遍历的最后一个元素为根节点
    TreeNode *root = new TreeNode(rootValue);        // 根节点
    if (inorder.size() == 1) return root;

    // 找到根节点在中序遍历数组中的位置，即，左、右子树的分界线
    int delimiterIndex;
    for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd ; delimiterIndex++) &#123;
        if (inorder[delimiterIndex] == rootValue) break;
    &#125;

    // 切割中序数组
    // 左子树的中序遍历数组，对应在 inorder 中的索引为 [leftInorderBegin, leftInorderEnd)
    int leftInorderBegin = inorderBegin;
    int leftInorderEnd = delimiterIndex;
    // 右子树的中序遍历数组，对应在 inorder 中的索引为 [rightInorderBegin, rightInorderEnd)
    int rightInorderBegin = delimiterIndex + 1; // 需排除根节点
    int rightInorderEnd = inorderEnd;

    // 切割后序数组
    // 左子树的后序遍历数组，对应在 postorder 中的索引为 [leftPostorderBegin, leftPostorderEnd)
    int leftPostorderBegin = postorderBegin;
    int leftPostorderEnd = postorderBegin + (leftInorderEnd - leftInorderBegin);
    // 右子树的后序遍历数组，对应在 postorder 中的索引为 [rightPostorderBegin, rightPostorderEnd)
    int rightPostorderBegin = postorderBegin + (leftInorderEnd - leftInorderBegin);
    int rightPostorderEnd = postorderEnd - 1; // 需排除根节点

    // 递归到左子树（确定 root 的左子节点指针）
    root-&gt;left = traversal(inorder, postorder, leftInorderBegin, leftInorderEnd, leftPostorderBegin, leftPostorderEnd);
    // 递归到右子树（确定 root 的右子节点指针）
    root-&gt;right = traversal(inorder, postorder, rightInorderBegin, rightInorderEnd, rightPostorderBegin, rightPostorderEnd);

    return root;
&#125;

TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
    if (inorder.size() == 0) return nullptr;
    return traversal(inorder, postorder, 0, inorder.size(), 0, postorder.size());
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>每个节点都将调用一次 <code>traversal</code> 函数，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次调用 <code>traversal</code> 函数时，需要找到根节点在中序遍历数组中的位置<ul><li>平均情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDYuJUU0JUJCJThFJUU0JUI4JUFEJUU1JUJBJThGJUU0JUI4JThFJUU1JTkwJThFJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2JUU1JUJBJThGJUU1JTg4JTk3JUU2JTlFJTg0JUU5JTgwJUEwJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjYy0lRTQlQkMlOTglRTUlOEMlOTYlRTclODklODglRTYlOUMlQUM=">代码随想录：从中序与后序遍历序列构造二叉树</span></p><p>简化版：</p><pre><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd) &#123;
    if (inorderBegin == inorderEnd) return nullptr;  // 空数组，二叉树为空
    int rootValue = postorder[postorderEnd - 1];     // 后序遍历的最后一个元素为根节点
    TreeNode *root = new TreeNode(rootValue);        // 根节点
    if (inorder.size() == 1) return root;

    // 找到根节点在中序遍历数组中的位置
    int delimiterIndex;
    for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd ; delimiterIndex++)
        if (inorder[delimiterIndex] == rootValue) break;
    // 左子树节点数
    int leftSize = delimiterIndex - inorderBegin;

    // 递归到左子树
    root-&gt;left = traversal(inorder, postorder, inorderBegin, delimiterIndex, postorderBegin, postorderBegin + leftSize);
    // 递归到右子树
    root-&gt;right = traversal(inorder, postorder, delimiterIndex + 1, inorderEnd, postorderBegin + leftSize, postorderEnd - 1);

    return root;
&#125;

TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
    if (inorder.size() == 0) return nullptr;
    return traversal(inorder, postorder, 0, inorder.size(), 0, postorder.size());
&#125;
</code></pre><h2 id="优化-2"><a class="anchor" href="#优化-2">#</a> 优化</h2><p>另外，可以考虑使用哈希表来快速定位根节点</p><ul><li><code>key</code> 表示一个元素（节点的值）， <code>value</code> 表示其在中序遍历序列中的出现位置</li><li>在调用递归函数前，先对中序遍历序列进行一遍扫描，构造出哈希表</li><li>以后只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间就可以对中序遍历中的根节点进行定位</li></ul><p>具体实现：</p><ol><li><p>定义全局变量</p><pre><code class="language-cpp">unordered_map&lt;int, int&gt; index;
</code></pre></li><li><p>在 <code>buildTree</code> 函数中构造哈希映射</p><pre><code class="language-cpp">for (int i = 0; i &lt; n; ++i) &#123;
    index[inorder[i]] = i;
&#125;
</code></pre></li><li><p>在递归函数 <code>traversal</code> 中使用哈希表查询根节点</p><pre><code class="language-cpp">int delimiterIndex = index[postorder[postorderEnd]]; // postorder 最后元素为根节点的值
</code></pre></li></ol><p>优化后的算法时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1pbm9yZGVyLWFuZC1wb3N0b3JkZXItdHJhdmVyc2FsL3NvbHV0aW9uL2NvbmctemhvbmcteHUteXUtaG91LXh1LWJpYW4tbGkteHUtbGllLWdvdS16YW8tMTQv">力扣官方题解：从中序与后序遍历序列构造二叉树</span></p><h1 id="leetcode-107-二叉树的层序遍历-ii"><a class="anchor" href="#leetcode-107-二叉树的层序遍历-ii">#</a> LeetCode 107. 二叉树的层序遍历 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwtaWkv">LeetCode 107. Binary Tree Level Order Traversal II</span></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II/tree1.jpg" alt=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]
输出：[[1]]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-7"><a class="anchor" href="#思路-7">#</a> 思路</h2><p>与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 不同，本题的遍历是从二叉树底层向上遍历</p><h2 id="method-广度优先搜索-2"><a class="anchor" href="#method-广度优先搜索-2">#</a> Method: 广度优先搜索</h2><p>算法流程：</p><ol><li><p>按照 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 算法自上而下遍历二叉树</p></li><li><p>反转目标数组</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;
    vector&lt;vector&lt;int&gt;&gt; res;
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        int size = que.size();
        vector&lt;int&gt; tmp;
        for (int i = 0; i &lt; size; i++) &#123;
            TreeNode* node = que.front();
            que.pop();
            tmp.push_back(node-&gt;val);
            if (node-&gt;left) que.push(node-&gt;left);
            if (node-&gt;right) que.push(node-&gt;right);
        &#125;
        res.push_back(tmp);
    &#125;
    reverse(res.begin(), res.end()); // 反转二维数组
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-108-将有序数组转换为二叉搜索树"><a class="anchor" href="#leetcode-108-将有序数组转换为二叉搜索树">#</a> LeetCode 108. 将有序数组转换为二叉搜索树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUv">108. Convert Sorted Array to Binary Search Tree</span></p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/btree1.jpg" alt=""></p><pre><code>输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案
</code></pre><p><img data-src="LeetCode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/btree2.jpg" alt=""></p><p><strong>示例 2：</strong></p><p><img data-src="LeetCode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/btree.jpg" alt=""></p><pre><code>输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>104</mn></mrow><annotation encoding="application/x-tex">\le 104</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>104</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-104 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>104</mn></mrow><annotation encoding="application/x-tex">\le 104</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span></span></span></span></li><li><code>nums</code> 按 严格递增 顺序排列</li></ul><h2 id="思路-8"><a class="anchor" href="#思路-8">#</a> 思路</h2><p>注意本题的数组 <code>nums</code> 为严格递增的有序序列</p><p>取数组最中间元素 <code>mid</code> 作为二叉树的根节点， <code>mid</code> 左侧所有元素作为左子树， <code>mid</code> 右侧所有元素作为右子树</p><p>于是，左子树所有节点值小于根节点，右子树所有节点值大于根节点，即，满足二叉搜索树的要求</p><p>并且，左子树、右子树的最大高度差不超过 1 （当数组元素为偶数时，高度差最大，值为 1），即，满足平衡二叉树的要求</p><ul><li>若取 <code>mid = left + (right - left) / 2;</code> ，左侧元素个数比右侧少 1</li><li>若取 <code>mid = left + (right - left + 1) / 2;</code> ，左侧元素个数比右侧多 1</li></ul><blockquote><p>注意：在分割数组时需要坚持不变量原则，即，预先定义有效区间为 左闭右闭 <code>[left, right]</code> （或者 左闭右开 <code>[left, right)</code> ）</p></blockquote><p>由于选择根节点的方式不同，构造出的二叉搜索树也就不同，因此，本题存在多解</p><h2 id="method-递归-3"><a class="anchor" href="#method-递归-3">#</a> Method: 递归</h2><p>算法思路：总是选择中间位置左边的数字作为根节点，即，取 <code>mid = left + (right - left) / 2;</code></p><p>这里采用 左闭右闭 原则：从 <code>nums</code> 数组中取出索引为 <code>[left, right]</code> 的所有元素，将其构建为一棵平衡二叉搜索树</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* buildTree(vector&lt;int&gt; &amp;nums, int left, int right) &#123; // 将数组索引为 [left, right] 的元素建成一棵二叉搜索树
    if (left &gt; right) return nullptr;    // 没有节点需要建立
    int mid = left + (right - left) / 2; // 取 [left, right] 区间中点对应元素值作为根节点值
    TreeNode *node = new TreeNode(nums[mid]);      // 根节点
    node-&gt;left = buildTree(nums, left, mid - 1);   // 左子树
    node-&gt;right = buildTree(nums, mid + 1, right); // 右子树
    return node;
&#125;

TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
    return buildTree(nums, 0, nums.size() - 1);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，递归的最大深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-110-平衡二叉树"><a class="anchor" href="#leetcode-110-平衡二叉树">#</a> LeetCode 110. 平衡二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWxhbmNlZC1iaW5hcnktdHJlZS8=">110. Balanced Binary Tree</span></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1 。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/balance_1.jpg" alt=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]
输出：true
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/balance_2.jpg" alt=""></p><pre><code>输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []
输出：true
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h1 id="概念辨析"><a class="anchor" href="#概念辨析">#</a> 概念辨析</h1><h2 id="节点的深度与高度"><a class="anchor" href="#节点的深度与高度">#</a> 节点的深度与高度</h2><p>深度是从上往下数，而高度是从下往上数</p><ol><li><p>维基百科</p><ul><li>节点的深度：从根节点到该节点路径上的边的条数</li><li>结点的高度：从该节点到叶节点路径上的边的条数</li></ul></li><li><p>Leetcode</p><ul><li>节点的深度：从根节点到该节点路径上的节点个数</li><li>结点的高度：从该节点到叶节点路径上的节点个数</li></ul></li></ol><p>按照维基百科的定义，根节点的深度为 0 ；按照 Leetcode 的定义，根节点的深度为 1</p><p>这里以 Leetcode 定义为准</p><p><img data-src="https://img-blog.csdnimg.cn/20210203155515650.png" alt="节点的深度与高度" height="150px"></p><blockquote><p>对于具有相同深度的节点，它们的高度不一定相同，这取决于它们下面的叶结点的深度</p></blockquote><p>计算节点的深度，按照从上往下的顺序去遍历子节点，需要采用前序遍历</p><p>计算节点的高度，按照从下往上的顺序去遍历，需要采用后序遍历</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMTAuJUU1JUI5JUIzJUU4JUExJUExJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU5JUEyJTk4JUU1JUE0JTk2JUU4JUFGJTlE">代码随想录：二叉树节点的深度与高度</span></p><h2 id="树的深度与高度"><a class="anchor" href="#树的深度与高度">#</a> 树的深度与高度</h2><p>二叉树的深度：所有节点中最深节点的深度，即，二叉树最底层节点的深度</p><p>二叉树的高度：根节点的高度</p><p>二叉树的 深度 与 高度 在数值上相等</p><p>因此，计算二叉树的深度（高度），可按照从上往下的顺序（前序遍历、层序遍历）计算最底层节点的深度，也可按照从下往上的顺序（后序遍历）计算根节点的高度</p><h2 id="思路-9"><a class="anchor" href="#思路-9">#</a> 思路</h2><p>按照本题的提示 “若每个节点的左子树与右子树的高度差不超过 1 ，该二叉树为平衡二叉树” ，可以通过计算每个节点左右子树的高度差来判断是否为平衡二叉树</p><p>一棵二叉树为平衡二叉树，当且仅当其所有子树都是平衡二叉树</p><p>因此，可以使用递归来判断。其中，递归可以按照 自顶向下 的顺序，也可以按照 自底向上 的顺序</p><h2 id="method-1-自顶向下"><a class="anchor" href="#method-1-自顶向下">#</a> Method 1: 自顶向下</h2><p>算法思路：</p><ol><li>定义一个递归函数 <code>height</code> ，用于计算节点 <code>root</code> 的高度</li><li>从根节点开始遍历节点<ul><li>分别调用 <code>height</code> 函数计算左、右子树的高度</li><li>若左右子树的高度差的绝对值大于 1，二叉树不是平衡二叉树，返回 <code>false</code></li><li>若左右子树的高度差的绝对值不超过 1，分别递归到左、右子节点（分别判断以左子节点为根节点、以右子节点为根节点的二叉树是否为平衡二叉树）</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">int height(TreeNode* root) &#123; // 计算 root 节点的高度
    if (root == nullptr) return 0;
    return 1 + max(height(root-&gt;left), height(root-&gt;right));
&#125;

bool isBalanced(TreeNode* root) &#123; // 判断以 root 为根节点的树是否为平衡二叉树
    if (!root) return true;
    if (abs(height(root-&gt;left) - height(root-&gt;right)) &gt; 1) // root 左右子树的高度差大于 1
        return false;
    return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); // 递归到左右子节点
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li>最坏情况下，二叉树为满二叉树，需要遍历满二叉树的所有节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>对于任意节点 <code>p</code> ，如果它的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">d</span></span></span></span> ，则 <code>height(p)</code> 最多会被调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">d</span></span></span></span> 次（被 <code>p</code> 及其祖先节点调用），因此节点 <code>p</code> 的计算时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>≤</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">d \le h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83041em;vertical-align:-.13597em"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span></span></span></span> 是二叉树的最大高度<ul><li>平均情况下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h) = O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，此时，总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，二叉树呈链状，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，此时，总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归调用栈</p><h2 id="method-2-自底向上"><a class="anchor" href="#method-2-自底向上">#</a> Method 2: 自底向上</h2><p>注意，在上述方法中，对于每个节点， <code>height</code> 函数会被调用多次，故而时间复杂度较高</p><p>可以采用自底向上的顺序，对于每个节点， <code>height</code> 函数仅被调用 1 次</p><p>算法思路：</p><ol><li><p>定义 <code>height</code> 函数，输入参数为 <code>root</code> ，返回参数为 <code>int</code> 型的数</p><ul><li>分别递归到左子树、右子树（即，调用 <code>height(root-&gt;left)</code> 和 <code>height(root-&gt;right)</code> ），并记录其返回值</li><li>判断左子树、右子树是否平衡<ul><li>若否，返回 <code>-1</code></li></ul></li><li>判断以当前 <code>root</code> 节点为根节点的树是否平衡<ul><li>若是，返回 <code>root</code> 的高度</li><li>否则，返回 <code>-1</code></li></ul></li></ul></li><li><p>若 <code>height</code> 函数返回值为 <code>-1</code> ，二叉树不是平衡二叉树， <code>isBalanced</code> 函数返回 <code>false</code></p></li></ol><p>代码实现：</p><pre><code class="language-cpp">int height(TreeNode* root) &#123; // 若二叉树为平衡二叉树，返回 root 的高度；否则，返回 -1
    if (!root) return 0;
    int leftHight = height(root-&gt;left);
    int rightHight = height(root-&gt;right);
    if (leftHight == -1 || rightHight == -1 || abs(leftHight - rightHight) &gt; 1) // 非平衡
        return -1; // 返回 -1
    return 1 + max(leftHight, rightHight); // 平衡，返回高度
&#125;

bool isBalanced(TreeNode* root) &#123;
    if (height(root) == -1) return false;
    return true;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>最坏情况下，需要遍历二叉树的所有节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每个节点仅计算一次高度，只进行一次 是否平衡 的判断，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归调用栈</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWxhbmNlZC1iaW5hcnktdHJlZS9zb2x1dGlvbi9waW5nLWhlbmctZXItY2hhLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：平衡二叉树</span></p><h1 id="leetcode-111-二叉树的最小深度"><a class="anchor" href="#leetcode-111-二叉树的最小深度">#</a> LeetCode 111. 二叉树的最小深度</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">LeetCode 111. Minimum Depth of Binary Tree</span></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明</strong>：叶子节点是指没有子节点的节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/tmp-tree.jpg" alt="" height="150px"></p><pre><code>输入：root = [3,9,20,null,null,15,7]
输出：2
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-10"><a class="anchor" href="#思路-10">#</a> 思路</h2><p>最小深度：从根节点到最近叶节点的最短路径上的节点数量</p><p>注意：<strong>叶节点是指左右子节点均为空的节点</strong></p><p><img data-src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="" height="200px"></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMTEuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU1JUIwJThGJUU2JUI3JUIxJUU1JUJBJUE2Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：二叉树的最小深度</span></p><h2 id="method-1-递归-5"><a class="anchor" href="#method-1-递归-5">#</a> Method 1: 递归</h2><p>递归函数：</p><ul><li>输入参数： <code>root</code></li><li>函数返回值：以 <code>root</code> 为根节点的树的最小深度</li></ul><h3 id="写法一-2"><a class="anchor" href="#写法一-2">#</a> 写法一</h3><p>递归终止条件：</p><ul><li><p>若左子树与右子树均不为空，返回 <code>1 + min (左子树最小深度、右子树最小深度)</code></p></li><li><p>若左子树为空、右子树不为空，返回 <code>1 + 右子树的最小深度</code></p></li><li><p>若左子树不为空、右子树为空，返回 <code>1 + 左子树的最小深度</code></p></li><li><p>若右子树与右子树均为空，节点为叶节点，返回 <code>1</code></p></li></ul><p>其中，第四种情况可与第二种（或，第三种）情况合并</p><p>代码实现：</p><pre><code class="language-cpp">int minDepth(TreeNode* root) &#123;
    if (!root) return 0;
    if (!root-&gt;left) return 1 + minDepth(root-&gt;right);           // 左子树为空（包括左右子树均为空的情形）
    if (!root-&gt;right) return 1 + minDepth(root-&gt;left);           // 右子树为空
    return 1 + min(minDepth(root-&gt;right), minDepth(root-&gt;left)); // 左右子树均不为空
&#125;
</code></pre><h3 id="写法二-2"><a class="anchor" href="#写法二-2">#</a> 写法二</h3><p>代码实现：</p><pre><code class="language-cpp">int minDepth(TreeNode* root) &#123; // 返回 root 到叶节点的最小深度
    if (root == nullptr) return 0;
    int left = minDepth(root-&gt;left);   // 左子树最小深度
    int right = minDepth(root-&gt;right); // 右子树最小深度
    if (!left || !right)               // 左子树为空，或，右子树为空，最小深度为 1 + left + right
        return 1 + left + right;
    return 1 + min(left, right);       // 左子树与右子树非空，最小深度为 1 + min(left, right)
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span></span></span></span> 为二叉树的最大深度（这里考虑了递归时栈空间的开销）</p><ul><li>最坏情况下，树呈现链状，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span></li><li>平均情况下，树的高度与节点数的对数正相关，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span></span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL3NvbHV0aW9uL2xpLWppZS16aGUtZGFvLXRpLWRlLWppZS1zaHUtdGlhby1qaWFuLWJ5LXVzZXI3MjA4Lw==">reals：二叉树的最小深度 - 理解递归结束条件</span></p><h2 id="method-2-层序遍历-3"><a class="anchor" href="#method-2-层序遍历-3">#</a> Method 2: 层序遍历</h2><p>算法思路：</p><ul><li>逐层遍历，每层按从左到右顺序遍历</li><li>若遇到叶节点（即，左右子节点均为空），则返回当前遍历到的层数</li></ul><p>代码实现：</p><pre><code class="language-cpp">int minDepth(TreeNode* root) &#123;
    int ans = 0;
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        ans++;
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            TreeNode* tmp = que.front();
            que.pop();
            if (tmp-&gt;left == nullptr &amp;&amp; tmp-&gt;right == nullptr) return ans; // tmp 为叶节点
            if (tmp-&gt;left) que.push(tmp-&gt;left);
            if (tmp-&gt;right) que.push(tmp-&gt;right);
        &#125;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-112-路径总和"><a class="anchor" href="#leetcode-112-路径总和">#</a> LeetCode 112. 路径总和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS8=">112. Path Sum</span></p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/pathsum1.jpg" alt=""></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,2,3], targetSum = 5
输出：false
解释：不存在 sum = 5 的根节点到叶子节点的路径。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>targetSum</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-递归-6"><a class="anchor" href="#method-1-递归-6">#</a> Method 1: 递归</h2><p><code>hasPathSum</code> 函数的功能：判断是否存在从当前节点 <code>root</code> 到叶节点的路径，使得路径和为 <code>targetSum</code></p><p>假定从根节点到当前节点的路径和为 <code>val</code> ，则问题可以转换为：判断是否存在一条从当前节点的子节点到叶节点的路径，满足其路径和为 <code>targetSum - val</code></p><p>因此，可以利用递归来实现这一系列问题的求解</p><p>算法思路：</p><ol><li><p>确定递归的参数和返回值：</p><ul><li>参数：根节点 <code>root</code> ，期望的 <code>root-to-leaf</code> 路径和 <code>sum</code></li><li>返回值： <code>bool</code> 类型，表示是否找到可行路径（设定返回值是为了在遇到可行路径时就返回，不再继续递归）</li></ul></li><li><p>递归终止条件：遇到叶节点，当前递归结束</p></li><li><p>单层递归的逻辑：</p><ul><li>若 <code>root</code> 是叶节点，判断当前路径是否满足条件</li><li>若不是叶节点，分别递归到左、右子树（注意，传入的第二个参数为 <code>sum - root-&gt;val</code> ）</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">bool hasPathSum(TreeNode* root, int sum) &#123;
    if (!root) return false;        // 空节点，递归返回
    if (!root-&gt;left &amp;&amp; !root-&gt;right)
        return  root-&gt;val == sum;   // 若当前叶节点的值等于sum，路径符合条件，返回 true
    return hasPathSum(root-&gt;left, sum - root-&gt;val) ||
            hasPathSum(root-&gt;right, sum - root-&gt;val); // 判断是否存在从子节点到叶节点路径和为 sum - root-&gt;val 的路径
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><blockquote><p>本题也可以累加路径和，在遇到叶节点时，判断路径和是否与目标值相等，但那样比较麻烦，例如：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9zdWJtaXNzaW9ucy9kZXRhaWwvMzI1OTQ0NDQ0Lw==">LeetCode 提交记录</span></p></blockquote><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMTIuJUU4JUI3JUFGJUU1JUJFJTg0JUU2JTgwJUJCJUU1JTkyJThDLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录：路径总和</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS9zb2x1dGlvbi9sdS1qaW5nLXpvbmctaGUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：路径总和</span></li></ul><h1 id="leetcode-113-路径总和-ii"><a class="anchor" href="#leetcode-113-路径总和-ii">#</a> LeetCode 113. 路径总和 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paS8=">113. Path Sum II</span></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/pathsum1.jpg" alt=""></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/pathsum2.jpg" alt=""></p><pre><code>输入：root = [1,2,3], targetSum = 5
输出：[]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,2], targetSum = 0
输出：[]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>targetSum</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-递归-7"><a class="anchor" href="#method-1-递归-7">#</a> Method 1: 递归</h2><p>算法思路：综合 <a href="https://jiankychen.github.io/posts/30d556a7">LeetCode 257. 二叉树的所有路径</a> 和 <a href="https://jiankychen.github.io/posts/ee978a9e">LeetCode 112. 路径总和</a> 这两题的思想</p><p>递归函数的参数：</p><ul><li><code>TreeNode *root</code> ：当前节点</li><li><code>vector&lt;int&gt; path</code> ：记录从二叉树根节点到当前节点的路径（注意，参数传递方式为值传递）</li><li><code>int sum</code> ：从当前节点到叶节点应满足的路径和（注意，参数传递方式为值传递）</li></ul><p>为避免 <code>getPaths</code> 函数需要传入太多参数，特将 <code>vector&lt;vector&lt;int&gt;&gt; ans</code> 设置为全局变量（记录所有可行路径）</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ans;
void getPaths(TreeNode *root, vector&lt;int&gt; path, int sum) &#123;
    if (!root) return;                 // 空节点，递归终止
    path.push_back(root-&gt;val);         // 更新路径
    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // root 为叶节点
        if (root-&gt;val == sum)          // 若当前值等于 sum ，路径符合要求，将其添加到 ans
            ans.push_back(path);
        return;
    &#125;
    getPaths(root-&gt;left, path, sum - root-&gt;val);  // 递归到左子树（传入 sum - root-&gt;val）
    getPaths(root-&gt;right, path, sum - root-&gt;val); // 递归到右子树（传入 sum - root-&gt;val）
&#125;

vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;
    vector&lt;int&gt; path;
    getPaths(root, path, targetSum);
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li>在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶节点的路径都符合要求</li><li>此时，路径数目为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，每一条路径的节点个数也为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，因此总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈空间的开销</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paS9zb2x1dGlvbi9sdS1qaW5nLXpvbmctaGUtaWktYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：路径总和 II</span></p><h1 id="leetcode-114-二叉树展开为链表"><a class="anchor" href="#leetcode-114-二叉树展开为链表">#</a> LeetCode 114. 二叉树展开为链表</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGF0dGVuLWJpbmFyeS10cmVlLXRvLWxpbmtlZC1saXN0Lw==">114. Flatten Binary Tree to Linked List</span></p><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="LeetCode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/Example1.jpg" alt="" height="150px"></p><pre><code>输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [0]
输出：[0]
</code></pre><p><strong>提示：</strong></p><ul><li>The number of nodes in the tree is in the range [0, 2000].</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><p><strong>进阶</strong>：Can you flatten the tree with <code>O(1)</code> extra space?</p><h2 id="method-1-暴力法"><a class="anchor" href="#method-1-暴力法">#</a> Method 1: 暴力法</h2><p>算法思路：</p><p>首先按照前序遍历顺序将二叉树节点依次存入队列中</p><p>队首到队尾的元素对应于所需构建的二叉树链表的首端和尾端（因为展开后的单链表与二叉树前序遍历顺序相同）</p><p>于是，依据队列中的元素重构二叉树即可：对于队列中的任意元素（记作 node ），其 left 指针应为空指针，right 指针应指向其在队列中的下一个元素</p><pre><code class="language-cpp">queue&lt;TreeNode*&gt; que; // 存放先序遍历结果

void traverse(TreeNode* root) &#123; // 先序遍历
    que.push(root);
    if (root-&gt;left) traverse(root-&gt;left);
    if (root-&gt;right) traverse(root-&gt;right);
&#125;

void flatten(TreeNode* root) &#123;
    if (root == nullptr)return; // 二叉树为空
    traverse(root);             // 获取先序遍历序列
    root = que.front();
    que.pop();
    while (!que.empty()) &#123;      // 构造链表
        root-&gt;left = nullptr;   // 注意这里需要将 left 指针置为空指针
        root-&gt;right = que.front();
        que.pop();
        root = root-&gt;right;
    &#125;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了存放二叉树前序遍历结果所需空间，不考虑递归所需栈空间</p><h2 id="method-2-递归"><a class="anchor" href="#method-2-递归">#</a> Method 2: 递归</h2><p>算法思路：</p><p>定义一个递归函数，用于将以 root 为根节点的二叉树展开成链表</p><p>单层递归的具体逻辑为：</p><ul><li>将左子树展开成链表（为便于表述，记作 左子树链表）</li><li>将右子树展开成链表（为便于表述，记作 右子树链表）</li><li>拼接左子树链表与右子树链表</li><li>将拼接结果作为新的右子树，并将左子树置为空</li></ul><p>其中，题目要求展开所得的单链表与二叉树前序遍历顺序相同（即，根 - 左 - 右），因此，需要将右子树链表拼接在左子树链表的后面。即，需要找到左子树链表的尾端，令其 right 指针指向右子树链表的首端</p><p>代码实现：</p><pre><code class="language-cpp">void flatten(TreeNode* root) &#123;
    if (root == nullptr) return;
    flatten(root-&gt;left);         // 将左子树展开成链表
    flatten(root-&gt;right);        // 将右子树展开成链表
    TreeNode* tmp = root-&gt;right; // 备份右子树的根节点
    root-&gt;right = root-&gt;left;    // 将 root 的左子树修改为 root 的右子树
    root-&gt;left = nullptr;        // root 的左子节点置为空指针
    TreeNode* node = root;       // root 左子树与 root 右子树的拼接点（即，左子树链表的尾端）
    while (node-&gt;right != nullptr) &#123;
        node = node-&gt;right;
    &#125;
    node-&gt;right = tmp;           // 将 root 右子树链表拼接在 root 左子树链表上
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归所需栈空间</p><h1 id="leetcode-116-填充每个节点的下一个右侧节点指针"><a class="anchor" href="#leetcode-116-填充每个节点的下一个右侧节点指针">#</a> LeetCode 116. 填充每个节点的下一个右侧节点指针</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcG9wdWxhdGluZy1uZXh0LXJpZ2h0LXBvaW50ZXJzLWluLWVhY2gtbm9kZS8=">LeetCode 116. Populating Next Right Pointers in Each Node</span></p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code>// Definition for a Node.
class Node &#123;
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;
&#125;;
</code></pre><p>填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code> 。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/1.png" alt=""></p><pre><code>输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数量在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>12</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2^{12} - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">- 1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h2 id="method-1-层序遍历"><a class="anchor" href="#method-1-层序遍历">#</a> Method 1: 层序遍历</h2><p>类似于 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a></p><p>算法思路：</p><ul><li>逐层遍历、每层按从左到右顺序遍历，利用队列存放待访问的节点</li><li>在遍历过程中，将 节点的 <code>next</code> 指针 指向 同一层的后一个节点（即，指向 队列的下一个元素）</li></ul><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;
    queue&lt;Node*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            Node* cur = que.front();
            que.pop();
            if (i &lt; size - 1) cur-&gt;next = que.front(); // 除最右侧节点外，每个节点的 next 指针均指向右侧节点
            if (cur-&gt;left) que.push(cur-&gt;left);
            if (cur-&gt;right) que.push(cur-&gt;right);
        &#125;
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-使用已建立的-next-指针"><a class="anchor" href="#method-2-使用已建立的-next-指针">#</a> Method 2: 使用已建立的 next 指针</h2><p>算法思路：</p><p>本题的二叉树为满二叉树，每一层的节点都是满的。针对满二叉树而言， <code>next</code> 指针的连接方式有两种类型：</p><ul><li><p>所连接的两个节点具有共同的父节点</p><p><img data-src="LeetCode116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/connection1.jpg" alt="Connection 1" height="200px"></p></li><li><p>所连接的两个节点具有不同的父节点，但他们的父节点通过 <code>next</code> 指针连接</p><p><img data-src="LeetCode116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/connection2.jpg" alt="Connection 2" height="200px"></p></li></ul><p>算法流程：</p><ol><li><p>定义 <code>pre</code> 指向根节点，即，令 <code>pre = root</code></p></li><li><p>遍历二叉树的每一层，即，执行以下循环，循环条件是 <code>pre-&gt;left</code> 不为空：</p><ul><li>定义 <code>cur</code> 指向 <code>pre</code> 所在层的节点，初始时指向 <code>pre</code></li><li>遍历 <code>cur</code> ，建立 <code>cur</code> 下一层节点的 <code>next</code> 指针：<ul><li>若 <code>cur</code> 的左子节点不为空，则右子节点必不为空，通过 <code>cur-&gt;left-&gt;next = cur-&gt;right</code> 连接 <code>cur</code> 的两个子节点</li><li>若 <code>cur</code> 的左子节点不为空 且 <code>cur</code> 的 <code>next</code> 指针不为空，通过 <code>cur-&gt;right-&gt;next = cur-&gt;next-&gt;left</code> 连接 <code>cur</code> 的右子节点与 <code>cur-&gt;next</code> 的左子节点</li><li><code>cur</code> 向右移动，即，更新 <code>cur = cur-&gt;next</code></li></ul></li><li>完成当前层的连接后，进入下一层重复操作，即 <code>pre</code> 向下移动（更新 <code>pre = pre-&gt;left</code> ）</li></ul></li></ol><p><img data-src="https://pic.leetcode-cn.com/eef065800417742831e8702ef7b45ccb082afa3782470af81491d2b4b6046f40-5.gif" alt="示意图" height="200px"></p><blockquote><p>需要注意：</p><ul><li><code>pre</code> 表示的是 <code>pre</code> 所在层的最左侧节点</li><li>遍历 <code>cur</code> 时， <code>cur</code> 所在层节点的 <code>next</code> 指针均已建立完成，此时建立的是下一层节点的 <code>next</code> 指针</li></ul></blockquote><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;
    if (root == nullptr) return root;
    Node* pre = root;
    while (pre-&gt;left != nullptr) &#123; // 遍历二叉树的每一层
        Node* cur = pre;
        while (cur != nullptr) &#123; // 遍历 pre 所在层的节点，建立下一层节点的 next 指针
                                 // 注意，外层的 while 循环已确保 cur 的下一层不为空
            cur-&gt;left-&gt;next = cur-&gt;right;           // 连接同一个父节点的两个子节点
            if (cur-&gt;next != nullptr)
                cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; // 连接不同父节点之间子节点
            cur = cur-&gt;next;     // 向右移动
        &#125;
        pre = pre-&gt;left;         // 向下一层移动
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每个节点只访问一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不需要额外空间用于存储</p><blockquote><p>以上算法可改写成递归算法（即，深度优先搜索）</p></blockquote><p>递归法的代码实现：</p><pre><code class="language-cpp">void DFS(Node* root) &#123; // 更新 root 左右子节点的 next 指针
    if (root == nullptr || root-&gt;left == nullptr) return;
    root-&gt;left-&gt;next = root-&gt;right;
    if (root-&gt;next != nullptr)
        root-&gt;right-&gt;next = root-&gt;next-&gt;left;
    DFS(root-&gt;left);
    DFS(root-&gt;right);
&#125;

Node* connect(Node* root) &#123;
    DFS(root);
    return root;
&#125;
</code></pre><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAxMDIuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU1JUIxJTgyJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2Lmh0bWwjXzExNi0lRTUlQTElQUIlRTUlODUlODUlRTYlQUYlOEYlRTQlQjglQUElRTglOEElODIlRTclODIlQjklRTclOUElODQlRTQlQjglOEIlRTQlQjglODAlRTQlQjglQUElRTUlOEYlQjMlRTQlQkUlQTclRTglOEElODIlRTclODIlQjklRTYlOEMlODclRTklOTIlODg=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlL3NvbHV0aW9uL3RpYW4tY2hvbmctbWVpLWdlLWppZS1kaWFuLWRlLXhpYS15aS1nZS15b3UtY2UtMi00Lw==">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktc2FuLWNob25nLXNoaS14aWFuLTExNi10aWFuLWNob25nLw==">wang_ni_ma：动画演示 + 三种实现</span></li></ul><h1 id="leetcode-117-填充每个节点的下一个右侧节点指针-ii"><a class="anchor" href="#leetcode-117-填充每个节点的下一个右侧节点指针-ii">#</a> LeetCode 117. 填充每个节点的下一个右侧节点指针 II</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLWlpLw==">LeetCode 117. Populating Next Right Pointers in Each Node II</span></p><p>给定一个二叉树：</p><pre><code>struct Node &#123;
    int val;
    Node *left;
    Node *right;
    Node *next;
&#125;
</code></pre><p>填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code> 。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/example.png" alt="" height="200px"></p><pre><code>输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>6000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 6000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。</li></ul><h2 id="思路-11"><a class="anchor" href="#思路-11">#</a> 思路</h2><p>与 <a href="">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 不同，本题并未限定二叉树为满二叉树</p><p>因此，针对每个节点，都需在其右侧寻找距离其最近的节点</p><h2 id="method-1-层序遍历-2"><a class="anchor" href="#method-1-层序遍历-2">#</a> Method 1: 层序遍历</h2><p>算法思路：与 <a href="https://jiankychen.github.io/33b5a27e">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 的 Method 1 相同，利用队列存放待访问的节点，在二叉树每一层的访问完成之前，队列下一个元素即为当前元素 <code>next</code> 指针应指向的对象</p><blockquote><p>该算法与 二叉树是否为满二叉树 无关</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;
    queue&lt;Node*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            Node* cur = que.front();
            que.pop();
            if (i &lt; size - 1) cur-&gt;next = que.front();
            if (cur-&gt;left) que.push(cur-&gt;left);
            if (cur-&gt;right) que.push(cur-&gt;right);
        &#125;
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-使用已建立的-next-指针-2"><a class="anchor" href="#method-2-使用已建立的-next-指针-2">#</a> Method 2: 使用已建立的 next 指针</h2><p>算法思路：</p><ul><li><p>与 <a href="https://jiankychen.github.io/33b5a27e">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 的 Method 2 类似，可以利用已经建立了的 <code>next</code> 指针：即，在遍历 <code>cur</code> 的过程中，与 <code>cur</code> 处于同一层的各个节点的 <code>next</code> 指针均已建立完成，需要建立的是 <code>cur</code> 下一层节点的 <code>next</code> 指针</p></li><li><p>不同的是，由于二叉树不一定为满二叉树， <code>cur</code> 不一定存在左、右子节点，如果存在的话， <code>cur-&gt;left</code> 、 <code>cur-&gt;right</code> 应分别指向 <code>cur-&gt;left</code> 右侧的第一个节点、 <code>cur-&gt;right</code> 右侧的第一个节点，如 示例 1 所示</p></li><li><p>由于 <code>pre</code> 不一定具有左子节点，在更新 <code>pre</code> 时，不能简单地令 <code>pre = pre-&gt;left</code> ，需要对 <code>pre</code> 下一层的节点情况进行判断，更准确地说，需要找到 <code>pre</code> 下一层的最左侧节点，将其作为新的 <code>pre</code></p></li></ul><p>因此，本题在 <a href="https://jiankychen.github.io/33b5a27e">LeetCode 116. 填充每个节点的下一个右侧节点指针</a> 的基础上，作出以下改变：</p><ul><li><p>定义 <code>leftmost</code> 指向 <code>pre</code> 下一层的最左侧节点</p></li><li><p>定义一个 <code>handle</code> 函数，在 <code>root</code> 右侧找到第一个非叶节点，返回其左子节点（不存在左子节点时，则返回右子节点）</p><ul><li>该函数用于确定 <code>cur-&gt;left</code> （不存在 <code>cur-&gt;right</code> 时）、 <code>cur-&gt;right</code> 的 <code>next</code> 指针的方向，也用于 <code>leftmost</code> 的更新</li></ul></li></ul><p>代码实现：</p><pre><code class="language-cpp">Node* handle(Node* root) &#123; // 寻找 root 右侧第一个非叶节点的子节点（靠左侧的子节点）
    Node* cur = root-&gt;next;
    while (cur != nullptr) &#123;
        if (cur-&gt;left) return cur-&gt;left;
        if (cur-&gt;right) return cur-&gt;right;
        cur = cur-&gt;next;
    &#125;
    return nullptr;
&#125;

Node* connect(Node* root) &#123;
    if (root == nullptr) return root;
    Node* pre = root;
    Node* leftmost = pre-&gt;left ? pre-&gt;left : pre-&gt;right; // pre 下一层的最左侧节点
    while (leftmost != nullptr) &#123;  // 当 pre 不是叶节点时执行循环
        Node* cur = pre;
        while (cur != nullptr) &#123;
            if (cur-&gt;left)   // 当 cur 存在左子节点时，其 next 指针指向 cur-&gt;left 右侧第一个节点
                cur-&gt;left-&gt;next = cur-&gt;right ? cur-&gt;right : handle(cur);
            if (cur-&gt;right)  // 当 cur 存在右子节点时，其 next 指针指向 cur-&gt;right 右侧第一个节点
                cur-&gt;right-&gt;next = handle(cur);
            cur = cur-&gt;next; // cur 向右移动
        &#125;
        pre = leftmost;      // pre 向下移动：更新 pre 为 leftmost
        if (pre-&gt;left)       // 更新 leftmost
            leftmost = pre-&gt;left;
        else if (pre-&gt;right)
            leftmost = pre-&gt;right;
        else
            leftmost = handle(pre);
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数，每个节点至多被访问 3 次</p><ul><li>确定 <code>cur-&gt;left</code> 和 <code>cur-&gt;right</code> 的 <code>next</code> 指针时，至多访问 <code>cur</code> 右侧各个节点 1 次</li><li>遍历 <code>cur</code> 时，访问各节点 1 次</li><li>更新 <code>leftmost</code> 时，至多访问 <code>pre</code> 下一层的各个节点 1 次</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p>注意，本题的样例并不一定为满二叉树，不能将该算法改写成递归法（深度优先搜索）。因为在调用 <code>handle</code> 时，与 <code>root</code> 同一层节点的 <code>next</code> 指针可能并未更新完成，这将导致 <code>handle</code> 函数返回错误结果</p></blockquote><p>与 Method 1 相比，Method 2 的时间复杂度相对较高，空间复杂度相对较低</p><h2 id="method-3-链表"><a class="anchor" href="#method-3-链表">#</a> Method 3: 链表</h2><p>可以将二叉树的每一层都看成一个链表</p><p>算法流程：</p><ol><li><p>定义：指针 <code>dummyHead</code> 指向虚拟头节点，指针 <code>cur</code> 指向当前遍历到的二叉树节点，指针 <code>LinkedNode</code> 指向链表的当前节点</p></li><li><p>当 <code>cur</code> 不为空时，执行循环：</p><ul><li>令 <code>LinkedNode = dummyHead</code></li><li>在同一层上遍历 <code>cur</code> ：<ul><li>若 <code>cur</code> 的左子节点不为空，将左子节点串进链表，并更新 <code>LinkedNode</code></li><li>若 <code>cur</code> 的右子节点不为空，将右子节点串进链表，并更新 <code>LinkedNode</code></li><li>继续访问这一层的下一个节点</li></ul></li><li>更新 <code>cur</code> 为下一层的最左侧节点，即， <code>cur = dummyHead-&gt;next</code></li><li>重置哑结点 <code>dummyHead</code> 的 <code>next</code> 指针，即， <code>dummyHead-&gt;next = nullptr</code></li></ul></li></ol><blockquote><p>在内层的循环中，遍历的是 <code>cur</code> 所在层的节点，串联的是 <code>cur</code> 下一层的节点</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">Node* connect(Node* root) &#123;
    if (root == nullptr) return root;
    Node* cur = root;              // 当前节点
    Node* dummyHead = new Node();  // 链表的哑结点（定义在最外层，确保空间复杂度为 O(1)）
    Node* LinkedNode = nullptr;    // 链表的当前节点
    while (cur != nullptr) &#123;
        LinkedNode = dummyHead;
        while (cur != nullptr) &#123; // 遍历 cur ，将 cur 下一层的节点串联成链表
            if (cur-&gt;left) &#123;
                LinkedNode-&gt;next = cur-&gt;left;  // 将 cur 左子节点串进链表
                LinkedNode = LinkedNode-&gt;next; // LinkedNode 右移
            &#125;
            if (cur-&gt;right) &#123;
                LinkedNode-&gt;next = cur-&gt;right; // 将 cur 右子节点串进链表
                LinkedNode = LinkedNode-&gt;next; // LinkedNode 右移
            &#125;
            cur = cur-&gt;next;   // cur 向右移动
        &#125;
        cur = dummyHead-&gt;next; // cur 向下移动
        dummyHead-&gt;next = nullptr; // 重置 dummyHead 的 next 指针
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLWlpL3NvbHV0aW9uL2Jmc2ppZS1qdWUtenVpLWhhby1kZS1qaS1iYWktbGlhby0xMDBkZS15b25nLWh1LWJ5Lw==">sdwwld：BFS 解决</span></p><h1 id="leetcode-124-二叉树中的最大路径和"><a class="anchor" href="#leetcode-124-二叉树中的最大路径和">#</a> LeetCode 124. 二叉树中的最大路径和</h1><h1 id="二叉树的最大路径和"><a class="anchor" href="#二叉树的最大路径和">#</a> 二叉树的最大路径和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtLw==">124. Binary Tree Maximum Path Sum</span></p><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 3 \times 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-递归-4"><a class="anchor" href="#method-递归-4">#</a> Method: 递归</h2><p>算法思路：</p><p>定义一个递归函数 <code>int maxGain(TreeNode* root)</code> ，用于计算 root 节点的最大贡献值，即：在以 root 为根节点的二叉树中，计算以 root 为起点的路径的最大和</p><p>定义一个全局变量 <code>maxSum</code> ，用于存储二叉树的最大路径和</p><p>递归终止条件：遇到空节点，当前递归结束</p><p>单层递归的逻辑：</p><ul><li>递归到左子节点，在左子树中计算以左子节点为起点的最大路径和，记作 leftGain ，即 leftGain = maxGain (root-&gt;left)</li><li>递归到右子节点，在右子树中计算以右子节点为起点的最大路径和，记作 rightGain ，即 rightGain = maxGain (root-&gt;right)</li><li>在以 root 为根节点的二叉树中，包含 root 节点的路径的最大和为：sum = root-&gt;val + max (leftGain, 0) + max (rightGain, 0)<ul><li>这里实际计算的是 “左子树 - root - 右子树” 路径的最大和</li><li>当左子节点和右子节点的贡献值为负数时，不能将左子节点和右子节点计入 root 节点所对应的、具有最大和的路径（因为加上一个负数会使得和变小），所以，我们累加的是 max (leftGain, 0) 和 max (rightGain, 0)</li></ul></li><li>在以 root 为根节点的二叉树中，以 root 为起点的路径的最大和为：gain = max (root-&gt;val + max (leftGain, 0), root-&gt;val + max (rightGain, 0))<ul><li>root-&gt;val + max (leftGain, 0) 为 root 节点到左子树的最大路径和</li><li>root-&gt;val + max (rightGain, 0) 为 root 节点到右子树的最大路径和</li></ul></li><li>更新二叉树的最大路径和：maxSum = max (maxSum, sum)<ul><li>注意，sum 始终大于或等于 gain ，因此，这里需根据 sum 来更新 maxSum （可结合 示例 1 和 示例 2 进行理解）</li></ul></li><li>返回 root 节点的贡献值 gain</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxSum = INT_MIN; // 二叉树的最大路径和

int maxPathSum(TreeNode* root) &#123;
    maxGain(root);
    return maxSum;
&#125;

int maxGain(TreeNode* root) &#123;
    if (root == nullptr) return 0;
    int leftGain = max(maxGain(root-&gt;left), 0);
    int rightGain = max(maxGain(root-&gt;right), 0);
    maxSum = max(maxSum, root-&gt;val + leftGain + rightGain);
    return root-&gt;val + max(leftGain, rightGain);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtL3NvbHV0aW9uL2VyLWNoYS1zaHUtemhvbmctZGUtenVpLWRhLWx1LWppbmctaGUtYnktbGVldGNvZGUtLw==">leetcode-solution</span></p><h1 id="三叉树中的最大路径和"><a class="anchor" href="#三叉树中的最大路径和">#</a> 三叉树中的最大路径和</h1><p>华为 2022.10.12 第二道笔试题</p><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;

using namespace std;

struct TreeNode &#123;
    int val;
    TreeNode* left;
    TreeNode* mid;
    TreeNode* right;
    TreeNode (int _val) : val(_val), left(nullptr), mid(nullptr), right(nullptr) &#123;&#125;
    // TreeNode () : val(0), left(nullptr), mid(nullptr), right(nullptr) &#123;&#125;
    // TreeNode (int _val, TreeNode* _left, TreeNode* _mid, TreeNode* _right) : val(_val), left(_left), mid(_mid), right(_right) &#123;&#125;
&#125;;

TreeNode* buildTree(vector&lt;int&gt;&amp; nums) &#123; // 利用层序遍历数组 nums 构建三叉树
    TreeNode* root = new TreeNode(nums[0]);
    queue&lt;TreeNode*&gt; que;
    que.push(root);
    int idx = 1;
    while (!que.empty() &amp;&amp; idx &lt; nums.size()) &#123;
        int size = que.size();
        for (int i = 0; i &lt; size; ++i) &#123;
            TreeNode* node = que.front();
            que.pop();
            
            if (idx &lt; nums.size() &amp;&amp; nums[idx] != -1) &#123; // left 子节点
                node-&gt;left = new TreeNode(nums[idx]);
                que.push(node-&gt;left);
                // cout &lt;&lt; node-&gt;left-&gt;val &lt;&lt; endl;
            &#125;
            else node-&gt;left = nullptr;
            ++idx;

            if (idx &lt; nums.size() &amp;&amp; nums[idx] != -1) &#123; // mid 子节点
                node-&gt;mid = new TreeNode(nums[idx]);
                que.push(node-&gt;mid);
                // cout &lt;&lt; node-&gt;mid-&gt;val &lt;&lt; endl;
            &#125;
            else node-&gt;mid = nullptr;
            ++idx;
            
            if (idx &lt; nums.size() &amp;&amp; nums[idx] != -1) &#123; // right 子节点
                node-&gt;right = new TreeNode(nums[idx]);
                que.push(node-&gt;right);
                // cout &lt;&lt; node-&gt;right-&gt;val &lt;&lt; endl;
            &#125;
            else node-&gt;right = nullptr;
            ++idx;

        &#125;
    &#125;

    return root;
&#125;

vector&lt;int&gt; order;

void traversal(TreeNode* root) &#123; // 层序遍历三叉树
    if (root == nullptr) return;
    queue&lt;TreeNode*&gt; que;
    que.push(root);
    while (!que.empty()) &#123;
        int size = que.size();
        for (int i = 0; i &lt; size; ++i) &#123;
            TreeNode* node = que.front();
            que.pop();
            order.push_back(node-&gt;val);
            if (node-&gt;left) que.push(node-&gt;left);
            if (node-&gt;mid) que.push(node-&gt;mid);
            if (node-&gt;right) que.push(node-&gt;right);
        &#125;
    &#125;
&#125;

int ans = INT_MIN; // 最大路径和

int gain(TreeNode* root) &#123; // 计算 以 root 为起点、向下延申的最大路径和
    if (root == nullptr) return 0;
    int left = gain(root-&gt;left);   // left 子树最大路径和
    left = max(left, 0);
    int mid = gain(root-&gt;mid);     // mid 子树最大路径和
    mid = max(mid, 0);
    int right = gain(root-&gt;right); // right 子树最大路径和
    right = max(right, 0);
    int maxgain = root-&gt;val + max(&#123;left + mid, left + right, mid + right&#125;); // 找出三条路径中的最大路径和：从 left 经 root 到 mid 、从 left 经 root 到 right 、从 mid 经 root 到 right
    ans = max(ans, maxgain);       // 更新最大路径和
    return root-&gt;val + max(&#123;left, mid, right&#125;); // 以 root 为起点、向下延申的最大路径和
&#125;

int main() &#123;
    // 读取输入
    int n = 0;
    cin &gt;&gt; n;
    vector&lt;int&gt; nums(n, 0); // 三叉树的层序遍历数组（其中，-1 表示空节点）
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; nums[i];
    // int n = 19;
    // vector&lt;int&gt; nums = &#123;20, 12, 30, 15, -1, -1, -1, -1, -1, -1, 15, 5, 25, -1, -1, -1, 16, -1, 22&#125;;
    
    // 构建三叉树
    TreeNode* root = buildTree(nums);
    
    // // 遍历三叉树，检查三叉树构建是否正确
    // traversal(root);
    // for (int i = 0; i &lt; order.size(); ++i) cout &lt;&lt; order[i] &lt;&lt; &quot; &quot;;
    // cout &lt;&lt; endl;
    
    // 计算最大路径和
    gain(root);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
&#125;
</code></pre><h1 id="leetcode-144-二叉树的前序遍历"><a class="anchor" href="#leetcode-144-二叉树的前序遍历">#</a> LeetCode 144. 二叉树的前序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==">LeetCode 144. Binary Tree Preorder Traversal</span></p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 前序 遍历。</p><p><strong>示例 1：</strong><br><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/1.jpg" alt=""></p><pre><code>输入：root = [1,null,2,3]
输出：[1,2,3]
</code></pre><p><strong>示例 2：</strong><br><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/2.jpg" alt=""></p><pre><code>输入：root = [1,2]
输出：[1,2]
</code></pre><p><strong>示例 3：</strong><br><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/3.jpg" alt=""></p><pre><code>输入：root = [1,null,2]
输出：[1,2]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路-12"><a class="anchor" href="#思路-12">#</a> 思路</h2><p>按照访问根节点 —— 左子树 —— 右子树的方式遍历这棵树，左子树或者右子树按照同样的方式遍历</p><p>注意二叉树节点的定义：</p><pre><code class="language-cpp">struct TreeNode &#123;
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
&#125;;
</code></pre><h2 id="method-1-递归-8"><a class="anchor" href="#method-1-递归-8">#</a> Method 1: 递归</h2><p>算法流程：</p><p>定义递归函数 <code>preorder(root, res)</code> ，将遍历到的 <code>root</code> 节点的结果添加到目标数组 <code>res</code> ：</p><ul><li>按照定义，首先将 <code>root</code> 节点的值加入数组</li><li>递归调用 <code>preorder(root.left)</code> 来遍历 <code>root</code> 节点的左子树</li><li>递归调用 <code>preorder(root.right)</code> 来遍历 <code>root</code> 节点的右子树</li></ul><p>递归终止的条件为碰到空节点</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; res;
    preorder(root,res);         // 前序遍历，调用递归函数
    return res;
&#125;

void preorder(TreeNode* root, vector&lt;int&gt; &amp;res) &#123;
    if (root == nullptr) return;
    res.push_back(root-&gt;val);    // 当前节点
    preorder(root-&gt;left, res);   // 左子树
    preorder(root-&gt;right, res);  // 右子树
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数，每一个节点恰好被遍历一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，为递归过程中栈的开销，这里忽略了目标数组所需空间</p><ul><li>平均情况下，栈所需空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下树呈现链状，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="method-2-迭代-3"><a class="anchor" href="#method-2-迭代-3">#</a> Method 2: 迭代</h2><blockquote><p>递归的实现：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，递归返回时再从栈顶弹出上一次递归的各项参数，故而递归可以返回到上一层</p></blockquote><p>不同于递归法，迭代法 显式地 维护一个栈，以实现遍历</p><p>由于栈的后进先出特性，要想先访问左子树、后访问右子树，需要先将右子树入栈、后将左子树入栈</p><p>算法思路：</p><ol><li><p>设计一个栈，用于存放将访问的树的根节点（只放入非空节点）</p></li><li><p>将根节点入栈，然后重复以下过程，直到栈为空</p><ul><li>从栈中取出一个节点，记录节点的值</li><li>将右子节点放入栈</li><li>将左子节点放入栈</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; res;
    if(root == nullptr) return res;
    stack&lt;TreeNode*&gt; stk;          // 栈存放二叉树节点的指针
    stk.push(root);                // 根节点入栈
    while (!stk.empty()) &#123;         // 栈不为空，节点未遍历完
        TreeNode* cur = stk.top(); // 栈顶元素（根节点）
        stk.pop();                 // 出栈
        res.push_back(cur-&gt;val);             // 将节点的值加入到目标数组
        if(cur-&gt;right) stk.push(cur-&gt;right); // 将右子节点压入栈
        if(cur-&gt;left) stk.push(cur-&gt;left);   // 将左子节点压入栈
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈的开销，这里忽略了目标数组所需空间</p><p>事实上，迭代法也可以如下实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; ans;
    stack&lt;TreeNode*&gt; st;
    TreeNode* node = root;
    while (!st.empty() || node != nullptr) &#123;
        while (node != nullptr) &#123;     // 遍历 node ，直到到达最底部
            ans.push_back(node-&gt;val); // 将 node 的值添加到目标数组
            st.push(node);            // 之后还需访问 node 右子节点，故而将 node 放入栈
            node = node-&gt;left;        // 更新 node 为左子节点，继续遍历
        &#125;
        node = st.top();              // 循环结束时，栈顶指向最底层节点
        st.pop();
        node = node-&gt;right;           // 遍历右子节点
    &#125;
    return ans;
&#125;
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwvc29sdXRpb24vZXItY2hhLXNodS1kZS1xaWFuLXh1LWJpYW4tbGktYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：二叉树的前序遍历</span></p><h1 id="leetcode-145-二叉树的后序遍历"><a class="anchor" href="#leetcode-145-二叉树的后序遍历">#</a> LeetCode 145. 二叉树的后序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">LeetCode 145. Binary Tree Postorder Traversal</span></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 后序遍历 。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/1.jpg" alt=""></p><pre><code>输入：root = [1,null,2,3]
输出：[3,2,1]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1]
输出：[1]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路-13"><a class="anchor" href="#思路-13">#</a> 思路</h2><p>按照左子树 —— 右子树 —— 根节点的顺序，对二叉树的每个节点进行遍历</p><h2 id="method-1-递归-9"><a class="anchor" href="#method-1-递归-9">#</a> Method 1: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; res;
    postorder(root, res);         // 中序遍历
    return res;
&#125;

void postorder(TreeNode* root, vector&lt;int&gt; &amp;res) &#123;
    if (root == nullptr) return;
    postorder(root-&gt;left, res);   // 左子树
    postorder(root-&gt;right, res);  // 右子树
    res.push_back(root-&gt;val);     // 根节点
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-迭代-4"><a class="anchor" href="#method-2-迭代-4">#</a> Method 2: 迭代</h2><h3 id="方案一"><a class="anchor" href="#方案一">#</a> 方案一</h3><p>算法流程：</p><ol><li><p>按照 “根 - 右 - 左” 的顺序访问节点，并依次将节点值添加到目标数组（类似于 <a href="https://jiankychen.github.io/posts/1e967892">LeetCode 144. 二叉树的前序遍历</a> ，仅仅是访问 左子节点 和 右子节点 的先后顺序不同而已）</p></li><li><p>将目标数组反转，即可得按 “左 - 右 - 根” 顺序访问的结果</p></li></ol><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; res;
    if (root == nullptr) return res;
    stack&lt;TreeNode*&gt; stk;
    stk.push(root);
    while (!stk.empty()) &#123;           // 按照 根-右-左 的顺序遍历
        TreeNode* cur = stk.top();
        stk.pop();
        res.push_back(cur-&gt;val);     // 访问根节点，并将其出栈
        if (cur-&gt;left) stk.push(cur-&gt;left);   // 左子节点先入栈，后访问
        if (cur-&gt;right) stk.push(cur-&gt;right); // 右子节点后入栈，先访问
    &#125;
    reverse(res.begin(), res.end()); // 将数组反转，可得 左-右-根 遍历顺序的结果
    return res;
&#125;
</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSVFNyU5QSU4NCVFOCVCRiVBRCVFNCVCQiVBMyVFOSU4MSU4RCVFNSU4RSU4Ni5odG1sIyVFNSU5MCU4RSVFNSVCQSU4RiVFOSU4MSU4RCVFNSU4RSU4Ni0lRTglQkYlQUQlRTQlQkIlQTMlRTYlQjMlOTU=">代码随想录：二叉树的后序遍历（迭代法）</span></p><h3 id="方案二"><a class="anchor" href="#方案二">#</a> 方案二</h3><p>可以采取类似 <a href="https://jiankychen.github.io/posts/803071b8">LeetCode 94. 二叉树的中序遍历</a> 的迭代法</p><p>不过，这里有些许不同：</p><ul><li>对于中序遍历，从栈中弹出节点时，其左子树已访问完，可以直接访问该节点，然后访问右子树</li><li>对于后序遍历，从栈中弹出节点时，只能确定其左子树已访问完，无法确定右子树是否被访问过</li></ul><p>于是，引入一个指针 <code>prev</code> 来记录子树的访问情况：</p><ul><li>当一个节点及其左右子树均已访问过，令 <code>prev</code> 指向该节点</li><li>回溯到父节点后，可以根据其右子节点指针是否等于 <code>prev</code> ，来判断右子节点是否被访问过</li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;
    vector&lt;int&gt; res;
    stack&lt;TreeNode*&gt; stk;
    TreeNode *node = root;     // 当前遍历节点
    TreeNode *prev = nullptr;  // 已访问过的子节点
    while (!stk.empty() || node != nullptr) &#123; // 节点未遍历完
        while (node != nullptr) &#123;     // 遍历至 node 左子树的最底部
            stk.push(node);
            node = node-&gt;left;
        &#125;
        node = stk.top();       // 左子树最底部的节点
        stk.pop();
        if (node-&gt;right == nullptr || node-&gt;right == prev) &#123; // 右子树为空 或 右子树已访问过
            res.push_back(node-&gt;val); // 将当前节点的值添加到目标数组
            prev = node;              // 用 prev 标记当前节点及其子节点已访问
            node = nullptr;           // 左子树已访问过，下次循环无需再次访问
        &#125; else &#123;                // 未访问过右子树
            stk.push(node);     // node 重新入栈，待右子树访问结束后才访问 node 
            node = node-&gt;right; // 访问 node 的右子树
        &#125;
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcG9zdG9yZGVyLXRyYXZlcnNhbC9zb2x1dGlvbi9lci1jaGEtc2h1LWRlLWhvdS14dS1iaWFuLWxpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：二叉树的后序遍历（迭代法）</span></p><blockquote><p>针对前、中、后序三种遍历方式，也可以采用 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSVFNyU5QSU4NCVFNyVCQiU5RiVFNCVCOCU4MCVFOCVCRiVBRCVFNCVCQiVBMyVFNiVCMyU5NS5odG1s">代码随想录：二叉树的统一迭代法</span> 思路：</p><ul><li>对于 已经遍历过、但并未把其值添加到目标数组 的节点（根节点），将其放入栈，并紧接着放入一个空指针作为标记；对于未曾遍历过的节点（左右子节点），直接放入栈，无需添加空指针标记</li><li>于是，在后续操作过程中，若栈顶为空指针，将其弹出后，所得的新栈顶元素则为 已经遍历过、但未把值添加到目标数组的节点</li></ul></blockquote><h1 id="leetcode-199-二叉树的右视图"><a class="anchor" href="#leetcode-199-二叉树的右视图">#</a> LeetCode 199. 二叉树的右视图</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">LeetCode 199. Binary Tree Right Side View</span></p><p>给定一个二叉树的根节点 <code>root</code> ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/tree.jpg" alt=""></p><pre><code>输入：root = [1,2,3,null,5,null,4]
输出：[1,3,4]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,null,3]
输出：[1,3]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-14"><a class="anchor" href="#思路-14">#</a> 思路</h2><p>逐层、从左到右遍历，利用队列存放待访问的节点</p><p>在遍历过程中，只需将 每层最右侧节点的值 添加到目标数组</p><h2 id="method-广度优先搜索-3"><a class="anchor" href="#method-广度优先搜索-3">#</a> Method: 广度优先搜索</h2><p>算法流程：与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似，区别在于，只需记录每一层最右侧节点的值</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; rightSideView(TreeNode* root) &#123;
    vector&lt;int&gt; res;
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        int size = que.size();
        TreeNode* node = nullptr;        // 当前遍历节点的指针
        for (int i = 0; i &lt; size; i++) &#123; // for 循环结束时，node 指向该层最右侧节点
            node = que.front();
            que.pop();
            if (node-&gt;left) que.push(node-&gt;left);
            if (node-&gt;right) que.push(node-&gt;right);
        &#125;
        res.push_back(node-&gt;val);    // 仅记录每一层最右侧节点的值
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-深度优先搜索"><a class="anchor" href="#method-深度优先搜索">#</a> Method: 深度优先搜索</h2><p>可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcvc29sdXRpb24vZXItY2hhLXNodS1kZS15b3Utc2hpLXR1LWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">力扣官方题解：二叉树的右视图</span> 的方法一</p><h1 id="leetcode-222-完全二叉树的节点个数"><a class="anchor" href="#leetcode-222-完全二叉树的节点个数">#</a> LeetCode 222. 完全二叉树的节点个数</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1jb21wbGV0ZS10cmVlLW5vZGVzLw==">LeetCode 222. Count Complete Tree Nodes</span></p><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><strong>完全二叉树</strong> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 1~ 2<sup>h</sup> 个节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/complete.jpg" alt=""></p><pre><code>输入：root = [1,2,3,4,5,6]
输出：6
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []
输出：0
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1]
输出：1
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 5 \times 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><p><strong>进阶：</strong> 遍历树来统计节点是一种时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的简单解决方案。你可以设计一个更快的算法吗？</p><h2 id="method-1-遍历"><a class="anchor" href="#method-1-遍历">#</a> Method 1: 遍历</h2><p>算法思路：遍历二叉树的所有节点，逐个计数</p><p>代码实现：</p><pre><code class="language-cpp">int countNodes(TreeNode* root) &#123;
    if (!root) return 0;
    int left = countNodes(root-&gt;left);   // 左子树节点数
    int right = countNodes(root-&gt;right); // 右子树节点数
    return 1 + left + right;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，未考虑递归调用栈</p><blockquote><p>这里采用的是递归法实现遍历（后序遍历），也可以采用迭代法实现</p></blockquote><h2 id="method-2-寻找满二叉树"><a class="anchor" href="#method-2-寻找满二叉树">#</a> Method 2: 寻找满二叉树</h2><p>完全二叉树有两种情况：</p><ul><li>最底层的叶节点是满的，即，二叉树为满二叉树。此时，二叉树的节点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.932438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span></span></span></span> 是树的深度</li><li>最底层的叶节点没有满。此时，从根节点开始，分别递归左子树、右子树，递归到一定深度时就会出现满二叉树，然后按照第一种情况计算节点数量即可</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20201124092634138.png" alt="代码随想录：完全二叉树中的满二叉树示意图" height="150px"></p><p>注意：若根节点的最左侧深度等于最右侧深度，则该二叉树为满二叉树</p><p>代码实现：</p><pre><code class="language-cpp">int countNodes(TreeNode* root) &#123;
    if (!root) return 0;
    int leftDepth = 1, rightDepth = 1;
    TreeNode* leftNode = root-&gt;left;
    TreeNode* rightNode = root-&gt;right;
    while (leftNode) &#123;  // 左子树的深度（最左侧的深度）
        leftDepth++;
        leftNode = leftNode-&gt;left;
    &#125;
    while (rightNode) &#123; // 右子树的深度（最右侧的深度）
        rightDepth++;
        rightNode = rightNode-&gt;right;
    &#125;
    if (leftDepth == rightDepth) // 以 root 为根节点的二叉树为满二叉树
        return (1 &lt;&lt; leftDepth) - 1; // 利用位左移计算 2^leftDepth
    int leftCount = countNodes(root-&gt;left);   // 递归左子树
    int rightCount = countNodes(root-&gt;right); // 递归右子树
    return 1 + leftCount + rightCount;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n} \times \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为节点数</p><ul><li>对于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 层的节点（$ 1 \le i \le \log {n}$），需要计算左右子树的深度，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n} - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></li><li>总的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow></msub><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{1 \le i \le \log{n}} O(\log{n} - i) = O(\log{n} \times \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-.43581800000000004em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.18639799999999984em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:.01389em">g</span></span><span class="mspace mtight" style="margin-right:.19516666666666668em"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.43581800000000004em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑递归调用栈</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMjIuJUU1JUFFJThDJUU1JTg1JUE4JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU4JThBJTgyJUU3JTgyJUI5JUU0JUI4JUFBJUU2JTk1JUIwLmh0bWwjJUU1JUFFJThDJUU1JTg1JUE4JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkx">代码随想录：完全二叉树的节点个数</span></p><h2 id="method-3-二分查找-位运算"><a class="anchor" href="#method-3-二分查找-位运算">#</a> Method 3: 二分查找 + 位运算</h2><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1jb21wbGV0ZS10cmVlLW5vZGVzL3NvbHV0aW9uL3dhbi1xdWFuLWVyLWNoYS1zaHUtZGUtamllLWRpYW4tZ2Utc2h1LWJ5LWxlZXRjby0yLw==">力扣官方题解：完全二叉树的节点个数</span></p><h1 id="leetcode-226-翻转二叉树"><a class="anchor" href="#leetcode-226-翻转二叉树">#</a> LeetCode 226. 翻转二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">LeetCode 226. Invert Binary Tree</span></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/invert1-tree.jpg" alt="" height="150px"></p><pre><code>输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/invert2-tree.jpg" alt="" height="150px"></p><pre><code>输入：root = [2,1,3]
输出：[2,3,1]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-15"><a class="anchor" href="#思路-15">#</a> 思路</h2><p>翻转二叉树的本质是：交换每个节点的左右子节点</p><p>因此，本题需遍历二叉树，并翻转每个节点的左右子节点</p><p>本题采用前序、中序、后序、层序遍历都可以</p><blockquote><p>若采用中序遍历，即，按照 “翻转左子树、交换左右子节点、翻转右子树” 这一原理进行操作时，须注意，在交换左右子节点以后，原本的右子树将变成左子树，因此， “翻转右子树” 须通过 翻转左子树 实现。可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMjYuJUU3JUJGJUJCJUU4JUJEJUFDJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU2JThCJTkzJUU1JUIxJTk1">代码随想录：翻转二叉树</span></p></blockquote><h2 id="method-1-前序遍历递归"><a class="anchor" href="#method-1-前序遍历递归">#</a> Method 1: 前序遍历（递归）</h2><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;
    if (root == nullptr) return root;
    swap(root-&gt;left, root-&gt;right); // 交换左、右子节点
    invertTree(root-&gt;right);       // 将最初的左子树（新的右子树）翻转
    invertTree(root-&gt;left);        // 将最初的右子树（新的左子树）翻转
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-前序遍历迭代"><a class="anchor" href="#method-2-前序遍历迭代">#</a> Method 2: 前序遍历（迭代）</h2><h2 id="写法一-3"><a class="anchor" href="#写法一-3">#</a> 写法一</h2><p>类似于 <a href="https://jiankychen.github.io/posts/1e967892">144. 二叉树的前序遍历</a></p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;
    stack&lt;TreeNode*&gt; stk;
    if (root) stk.push(root);
    TreeNode* tmp = new TreeNode();
    while (!stk.empty()) &#123;
        tmp = stk.top();
        stk.pop();
        swap(tmp-&gt;left, tmp-&gt;right);          // 交换左右子节点
        if (tmp-&gt;left) stk.push(tmp-&gt;left);   // 将最初的右子节点（新的左子节点）入栈
        if (tmp-&gt;right) stk.push(tmp-&gt;right); // 将最初的左子节点（新的右子节点）入栈
    &#125;
    return root;
&#125;
</code></pre><h2 id="写法二-3"><a class="anchor" href="#写法二-3">#</a> 写法二</h2><p>类似于 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVyY2FybC5jb20vJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU3JUJCJTlGJUU0JUI4JTgwJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1Lmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1JUU1JTg5JThEJUU1JUJBJThGJUU5JTgxJThEJUU1JThFJTg2">二叉树深度优先搜索的统一迭代法</span> ，在第一次访问到某个节点时，不对该节点进行处理，反而将其重新放入栈，并紧接着放入一个空指针</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;
    stack&lt;TreeNode*&gt; stk;
    if (root) stk.push(root);
    while (!stk.empty()) &#123;
        TreeNode* node = stk.top();
        stk.pop();
        if (node == NULL) &#123; // 遇到空指针，意味着第二次访问到根节点
            node = stk.top();
            stk.pop();
            swap(node-&gt;left, node-&gt;right); // 将左右子节点进行交换
        &#125; else &#123;  // 非空指针，意味着第一次访问到根节点
            if (node-&gt;right) stk.push(node-&gt;right); // 将右子节点入栈（此前并未交换过左右子节点）
            if (node-&gt;left) stk.push(node-&gt;left);   // 将左子节点入栈
            stk.push(node); // 访问过 node 节点，但并未处理，将其重新放入栈
            stk.push(NULL); // 加入空指针作为标记
        &#125;
    &#125;
    return root;
&#125;
</code></pre><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMjYuJUU3JUJGJUJCJUU4JUJEJUFDJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU2JUI3JUIxJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU5JTgxJThEJUU1JThFJTg2">代码随想录：翻转二叉树之深度优先遍历</span></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-3-层序遍历"><a class="anchor" href="#method-3-层序遍历">#</a> Method 3: 层序遍历</h2><p>Method 1 与 Method 2 均为深度优先搜索，本题也还可以采用广度优先搜索，即，层序遍历</p><p>与 <a href="https://jiankychen.github.io/posts/c7ba20f5">102. 二叉树的层序遍历</a> 不同，本题无需按层输出结果，故而，在交换左右字节数时，不需要每次从队列中取出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 个元素（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 为当前所在层数），只需逐个取出元素即可</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    TreeNode* tmp = new TreeNode();
    while (!que.empty()) &#123;
        tmp = que.front();
        que.pop();
        swap(tmp-&gt;left, tmp-&gt;right);          // 交换左右子节点
        if (tmp-&gt;right) que.push(tmp-&gt;right); // 将最初的左子节点（新的右子节点）入队
        if (tmp-&gt;left) que.push(tmp-&gt;left);   // 将最初的右子节点（新的左子节点）入队
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-235-二叉搜索树的最近公共祖先"><a class="anchor" href="#leetcode-235-二叉搜索树的最近公共祖先">#</a> LeetCode 235. 二叉搜索树的最近公共祖先</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">235. Lowest Common Ancestor of a Binary Search Tree</span></p><p>给定一个二叉搜索树，找到该树中两个指定节点的 <strong>最近公共祖先</strong> 。</p><p>最近公共祖先 的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img data-src="LeetCode235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/tree.png" alt=""></p><p><strong>示例 1：</strong></p><pre><code>输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出：6
解释：节点 2 和节点 8 的最近公共祖先是 6。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出：2
解释：节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [2,1], p = 2, q = 1
输出：2
</code></pre><p><strong>提示：</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="思路-16"><a class="anchor" href="#思路-16">#</a> 思路</h2><p>本题可采用 <a href="https://jiankychen.github.io/posts/8d6a58cf">LeetCode 236. 二叉树的最近公共祖先</a> 中的方法求解</p><p>但由于本题的二叉树为二叉搜索树，可在 <a href="https://jiankychen.github.io/posts/8d6a58cf">LeetCode 236. 二叉树的最近公共祖先</a> 的基础上简化求解</p><h2 id="method-1-确定路径"><a class="anchor" href="#method-1-确定路径">#</a> Method 1: 确定路径</h2><p>算法思路：根据二叉搜索树的特性，分别找出从 <code>root</code> 到 <code>p</code> 的路径、从 <code>root</code> 到 <code>q</code> 的路径，然后从两个路径中找到最后一个公共节点，即为最近公共祖先</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;TreeNode*&gt; getPath(TreeNode *root, TreeNode * target) &#123; // 记录从 root 到 target 的路径
    vector&lt;TreeNode*&gt; path;
    while (root != target) &#123;
        path.push_back(root);
        if (root-&gt;val &gt; target-&gt;val) root = root-&gt;left;
        else root = root-&gt;right; // 注意这里是 else 语句，与前面的 if 互斥
    &#125;
    path.push_back(root);
    return path;
&#125;

TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
    vector&lt;TreeNode*&gt; pathP = getPath(root, p); // 获取 root 到 p 的路径
    vector&lt;TreeNode*&gt; pathQ = getPath(root, q); // 获取 root 到 q 的路径
    TreeNode *ans = NULL; // 公共祖先
    for (int i = 0; i &lt; pathP.size() &amp;&amp; i &lt; pathQ.size(); i++) &#123; // 找到深度最大的公共祖先
        if (pathP[i] == pathQ[i]) ans = pathP[i];
        else break;
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑存放路径的数组空间</p><h2 id="method-2-迭代-5"><a class="anchor" href="#method-2-迭代-5">#</a> Method 2: 迭代</h2><p>算法思路：</p><ul><li><p>如果当前节点的值大于 <code>p</code> 和 <code>q</code> 的值，说明 <code>p</code> 和 <code>q</code> 在当前节点的左子树，因此，将当前节点移动到左子节点</p></li><li><p>如果当前节点的值小于 <code>p</code> 和 <code>q</code> 的值，说明 <code>p</code> 和 <code>q</code> 在当前节点的右子树，因此，将当前节点移动到右子节点</p></li><li><p>如果当前节点值不满足以上两种情况，则当前节点就是 <code>p</code> 和 <code>q</code> 的最近公共祖先</p></li></ul><p>换而言之， <code>p</code> 和 <code>q</code> 的最近公共祖先节点的值一定落在 <code>[p-&gt;val, q-&gt;val]</code> 或者 <code>[q-&gt;val, p-&gt;val]</code> 区间内</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
    while (true) &#123;
        if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;
            root = root-&gt;left;
        &#125; else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;
            root = root-&gt;right;
        &#125; else &#123;
            break;
        &#125;
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlL3NvbHV0aW9uL2VyLWNoYS1zb3Utc3VvLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLTI2Lw==">力扣官方题解</span></p><h2 id="method-3-递归"><a class="anchor" href="#method-3-递归">#</a> Method 3: 递归</h2><p>算法思路：判断 <code>root</code> 的值是否落在 <code>[p-&gt;val, q-&gt;val]</code> 或者 <code>[q-&gt;val, p-&gt;val]</code> 区间内</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* helper(TreeNode *root, TreeNode* p, TreeNode* q) &#123;
    if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)
        return helper(root-&gt;right, p, q);
    else if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)
        return helper(root-&gt;left, p, q);
    else return root;
&#125;

TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
    return helper(root, p, q);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMzUuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4Lmh0bWw=">代码随想录</span></p><h1 id="leetcode-236-二叉树的最近公共祖先"><a class="anchor" href="#leetcode-236-二叉树的最近公共祖先">#</a> LeetCode 236. 二叉树的最近公共祖先</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">236. Lowest Common Ancestor of a Binary Tree</span></p><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/tree.png" alt=""></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,2], p = 1, q = 2
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2, 10^5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h2 id="思路-17"><a class="anchor" href="#思路-17">#</a> 思路</h2><p>若 <code>x</code> 满足以下任意一种情况， <code>x</code> 是 <code>p</code> 和 <code>q</code> 的最近公共祖先</p><ul><li><code>x</code> 的左子树包含 <code>p</code> 节点，并且 <code>x</code> 的右子树包含 <code>q</code> 节点（或者， <code>x</code> 的左子树包含 <code>q</code> 节点 且 <code>x</code> 的右子树包含 <code>p</code> 节点）</li><li><code>x</code> 恰好是 <code>p</code> 节点，并且 <code>x</code> 的其中一个子树包含 <code>q</code> 节点（或者， <code>x</code> 恰好是 <code>q</code> 节点，并且 <code>x</code> 的其中一个子树包含 <code>p</code> 节点）</li></ul><p>若按照后序遍历顺序来遍历二叉树（即，自底向上遍历二叉树），在所有满足条件的公共祖先中，一定是深度最大的祖先最先被访问到。因此，可以找到最近公共祖先</p><h2 id="method-1"><a class="anchor" href="#method-1">#</a> Method 1</h2><p>代码实现：</p><pre><code class="language-cpp">TreeNode *ans = nullptr; // 最近公共祖先
bool helper(TreeNode *root, TreeNode *p, TreeNode *q) &#123; // 判断以 root 为根节点的树是否含有 p 节点或 q 节点
    if (!root) return false;
    bool left = helper(root-&gt;left, p, q);   // 递归到左子树
    bool right = helper(root-&gt;right, p, q); // 递归到右子树
    if (left &amp;&amp; right) ans = root;          // 情形一
    if (root == p || root == q) &#123;
        if (left || right)                  // 情形二
            ans = root;
    &#125;
    return (left || right) || (root == p || root == q); // 返回值：是否含有 p 节点或 q 节点
&#125;

TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
    helper(root, p, q);
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUvc29sdXRpb24vZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWJ5LWxlZXRjLTIv">力扣官方题解</span></p><h2 id="method-2"><a class="anchor" href="#method-2">#</a> Method 2</h2><p>算法思路：</p><p>针对情形二，在找到一个节点是 <code>p</code> 或者 <code>q</code> 的时候，直接返回当前节点即可，无需继续递归子树。在接下来的遍历中，如果找到了后继节点满足情形一，则修改返回值为后继节点，否则，继续返回已找到的节点即可</p><p>示意图：<br><img data-src="LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/method2.png" alt="" height="200px"></p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
    if (root == p || root == q || root == NULL) return root;
    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
    TreeNode* right = lowestCommonAncestor(root-&gt;right, p ,q);
    if (left &amp;&amp; right) return root; // 左、右子树分别包含 p 、q 节点
    if (left || right) return left ? left : right; // 左子树或者右子树包含 p 或 q 节点
    return NULL;                    // 不包含 p 和 q 节点
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyMzYuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4Lmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></p><blockquote><p>本题也可以用哈希表存储所有节点的父节点，然后分别从 <code>p</code> 、 <code>q</code> 节点开始向上访问父节点以及祖先节点，遇到的第一个公共祖先节点即为所求，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUvc29sdXRpb24vZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWJ5LWxlZXRjLTIv">力扣官方题解 - 方法二</span></p></blockquote><h1 id="leetcode-257-二叉树的所有路径"><a class="anchor" href="#leetcode-257-二叉树的所有路径">#</a> LeetCode 257. 二叉树的所有路径</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy8=">257. Binary Tree Paths</span></p><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/paths-tree.jpg" alt="" height="200px"></p><pre><code>输入：root = [1,2,3,null,5]
输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]
输出：[&quot;1&quot;]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-前序遍历"><a class="anchor" href="#method-1-前序遍历">#</a> Method 1: 前序遍历</h2><p>算法思路：</p><ol><li><p>定义一个递归函数 <code>getPaths</code> ，用于获取从 <code>root</code> 到叶节点的路径，具有以下输入参数：</p><ul><li><code>TreeNode* root</code> ：路径的起点</li><li><code>string path</code> ：记录当前查找路径。注意，这里不能使用引用 <code>&amp;</code> ：因为在探寻到叶节点后，需要回溯到它的父节点（以及祖先节点），回溯后的 <code>path</code> 不能包含已经遍历过的叶节点。因此，在每次调用时，都是采用复制赋值的方法传入 <code>path</code> 参数</li><li><code>vector&lt;string&gt; &amp;res</code> ：存放所有查找到的 <code>root-to-leaf</code> 路径</li></ul></li><li><p>递归函数 <code>getPaths</code> 的实现：</p><ul><li>若 <code>root</code> 为空，当前的递归结束，否则，执行后续操作</li><li>将 <code>root</code> 的值（需转换成 <code>string</code> 类型）添加到 <code>path</code> 中，以记录路径</li><li>若 <code>root</code> 是叶节点，记录到的路径 <code>path</code> 即为一条从根节点到叶节点的路径，将 <code>path</code> 添加到答案数组 <code>res</code> ，当前递归结束</li><li>若 <code>root</code> 不是叶节点，将路径的间隔符 <code>&quot;-&gt;&quot;</code> 添加到 <code>path</code> 中，并分别递归到左子节点、右子节点</li></ul></li></ol><blockquote><p><code>to_string</code> 函数：将变量转换成 <code>string</code> 类型，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdHJpbmcvdG9fc3RyaW5nLz9rdz10b19zdHJpbmc=">std::to_string</span></p></blockquote><p>代码实现：</p><pre><code class="language-cpp">void getPaths(TreeNode* root, string path, vector&lt;string&gt; &amp;res) &#123;
    if (!root) return;
    path += to_string(root-&gt;val);      // 将节点值转换成 string 并添加到路径
    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // 叶节点
        res.push_back(path);           // 将路径添加到目标数组
        return;
    &#125;
    path += &quot;-&gt;&quot;; // 当前节点不是叶节点，继续递归遍历子节点
    getPaths(root-&gt;left, path, res);
    getPaths(root-&gt;right, path, res);
&#125;

vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
    vector&lt;string&gt; res;
    getPaths(root, &quot;&quot;, res);
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：这里不考虑存放 <code>res</code> 的空间，但考虑 <code>path</code> 变量所需空间：</p><ul><li>对于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 层，存放 <code>path</code> 变量所需的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 小于等于二叉树的高度</li><li>平均情况下，二叉树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>，此时，总的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n} \times \log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下，二叉树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，此时，总的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy9zb2x1dGlvbi9lci1jaGEtc2h1LWRlLXN1by15b3UtbHUtamluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：二叉树的所有路径</span></p><p>本题也可以采用迭代法来实现前序遍历，除了需要一个栈来模拟递归之外，还需要一个栈来存放对应的遍历路径，可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAyNTcuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTg5JTgwJUU2JTlDJTg5JUU4JUI3JUFGJUU1JUJFJTg0Lmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1">代码随想录：二叉树的所有路径 - 迭代法</span></p><p>此外，也可以使用层序遍历解题，具体可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy9zb2x1dGlvbi9lci1jaGEtc2h1LWRlLXN1by15b3UtbHUtamluZy1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：二叉树的所有路径 - 方法二</span></p><h1 id="leetcode-297-二叉树的序列化与反序列化"><a class="anchor" href="#leetcode-297-二叉树的序列化与反序列化">#</a> LeetCode 297. 二叉树的序列化与反序列化</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXJpYWxpemUtYW5kLWRlc2VyaWFsaXplLWJpbmFyeS10cmVlLw==">297. Serialize and Deserialize Binary Tree</span></p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9mYXEvI2JpbmFyeS10cmVl">LeetCode 序列化二叉树的格式</span> 。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E7%A4%BA%E4%BE%8B.jpg" alt=""></p><pre><code>输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-前序遍历"><a class="anchor" href="#method-前序遍历">#</a> Method: 前序遍历</h2><p>算法思路：</p><p>序列化：按照前序遍历的顺序遍历二叉树，并将每个节点的数值转换成字符串记录下来。特别地，用 ',' 分隔每个节点的值，用 &quot;1001&quot; 标记空节点</p><p>反序列化：从字符串中提取出用 ',' 分隔的每一个数值，并按照前序遍历的顺序构造二叉树。特别地，如果遇到 &quot;1001&quot; ，则说明当前节点为空节点，无需继续构造其子树；如果遇到的不是 &quot;1001&quot; ，构造当前节点后还需递归构造其子树</p><p>代码实现：</p><pre><code class="language-cpp">class Codec &#123;
public:

    string serialize(TreeNode* root) &#123; // 序列化
        string res = &quot;&quot;;
        if (root == nullptr) &#123;
            res += to_string(1001);
            res.push_back(',');
            return res;
        &#125;
        res += to_string(root-&gt;val);
        res.push_back(',');
        res += serialize(root-&gt;left);
        res += serialize(root-&gt;right);
        return res;
    &#125;

    TreeNode* deserialize(string data) &#123; // 反序列化
        int start = 0;
        return helper(data, start);
    &#125;

    TreeNode* helper(string&amp; data, int&amp; start) &#123; // 从 data 的第 start 位开始构造二叉树
        TreeNode* root = nullptr;
        int i = start;
        while (i != data.size() &amp;&amp; data[i] != ',') ++i;
        string str(data.begin() + start, data.begin() + i); // 获取 ',' 之间的字符
        start = i + 1; // 更新起点
        if (str != &quot;1001&quot;) &#123; // 非空节点
            int num = stoi(str);
            root = new TreeNode(num);
            root-&gt;left = helper(data, start);
            root-&gt;right = helper(data, start);
        &#125;
        return root;
    &#125;
&#125;;

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p><h1 id="leetcode-404-左叶子之和"><a class="anchor" href="#leetcode-404-左叶子之和">#</a> LeetCode 404. 左叶子之和</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tb2YtbGVmdC1sZWF2ZXMv">404. Sum of Left Leaves</span></p><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/leftsum-tree.jpg" alt=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]
输出：24
解释：在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]
输出：0
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>节点数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 范围内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="思路-18"><a class="anchor" href="#思路-18">#</a> 思路</h2><p>注意，本题计算的是 <strong>左叶节点</strong> 的和，而不是 左子节点 的和</p><p><strong>若节点 <code>node</code> 是叶节点（即，不存在左右子节点），并且， <code>node</code> 是其父节点的左子节点，则节点 <code>node</code> 是左叶节点</strong></p><p>例如，在 示例 1 中，值为 9 的节点和值为 15 的节点都是左叶节点</p><p>对于节点 <code>node</code> 而言，容易判断 <code>node</code> 是否为叶节点，但是，要想判断 <code>node</code> 是否为其父节点的左子节点，则并不容易</p><p>对此，我们可以退而求其次：判断每个 <code>node</code> 节点的左子节点（即， <code>node-&gt;left</code> ）是否为叶节点</p><ul><li>若是，则 <code>node-&gt;left</code> 是左叶节点</li><li>若否，则 <code>node-&gt;left</code> 不是左叶节点</li></ul><h2 id="method-1-后序遍历"><a class="anchor" href="#method-1-后序遍历">#</a> Method 1: 后序遍历</h2><p>采用递归法，实现后序遍历（处理节点的顺序为：左 - 右 - 根）</p><p>算法思路：</p><ol><li><p>递归函数的参数和返回值：</p><ul><li>传入参数为树的根节点 <code>root</code></li><li>返回值为左叶节点的数值和，数据类型为 <code>int</code></li></ul></li><li><p>递归的终止条件：遇到空节点 <code>root</code> ，递归结束</p></li><li><p>单层递归的逻辑：</p><ul><li>判断 <code>root-&gt;left</code> 是否为叶节点<ul><li>若是，记录其数值</li><li>若否，分别递归到 <code>root</code> 的左、右子树，计算左、右子树上的左叶节点数值和</li></ul></li><li>计算以 <code>root</code> 为根的所有左叶节点数值之和</li></ul></li></ol><blockquote><p>注意， <code>node</code> 的右子树也可能含有左子节点，例如 示例 1 中值为 15 的节点</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">int sumOfLeftLeaves(TreeNode* root) &#123;
    if (!root) return 0;
    int midValue = 0;
    if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) // root-&gt;left 为左叶节点
        midValue = root-&gt;left-&gt;val;
    return midValue + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间，最坏情况下，树呈链状，深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-前序遍历"><a class="anchor" href="#method-2-前序遍历">#</a> Method 2: 前序遍历</h2><p>采用迭代法，实现前序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int sumOfLeftLeaves(TreeNode* root) &#123;
    int ans = 0;
    stack&lt;TreeNode*&gt; stk;
    if (root) stk.push(root);
    while (!stk.empty()) &#123;
        TreeNode* node = stk.top();
        stk.pop();
        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)
            ans += node-&gt;left-&gt;val;
        if (node-&gt;right) stk.push(node-&gt;right); // 右
        if (node-&gt;left) stk.push(node-&gt;left);   // 左
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-3-层序遍历-2"><a class="anchor" href="#method-3-层序遍历-2">#</a> Method 3: 层序遍历</h2><p>特别地，本题只需计算左叶节点的数值和，层序遍历时不必区分节点的层次。故而，只需将 Method 2 中的栈换成队列，即可实现层序遍历</p><p>代码实现：</p><pre><code class="language-cpp">int sumOfLeftLeaves(TreeNode* root) &#123;
    int ans = 0;
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        TreeNode* node = que.front();
        que.pop();
        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)
            ans += node-&gt;left-&gt;val;
        if (node-&gt;left) que.push(node-&gt;left);   // 左
        if (node-&gt;right) que.push(node-&gt;right); // 右
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-429-n-叉树的层序遍历"><a class="anchor" href="#leetcode-429-n-叉树的层序遍历">#</a> LeetCode 429. N 叉树的层序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLWxldmVsLW9yZGVyLXRyYXZlcnNhbC8=">LeetCode 429. N-ary Tree Level Order Traversal</span></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/narytreeexample1.png" alt="" height="200px"></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/narytreeexample2.png" alt="" height="200px"></p><pre><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树的高度不会超过 1000</li><li>树的节点总数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 之间</li></ul><h2 id="思路-19"><a class="anchor" href="#思路-19">#</a> 思路</h2><p>从上到下、逐层遍历二叉树，每层按从左到右顺序遍历</p><p>对于 <strong>N 叉树</strong> 而言，每个节点可能有多个子节点，不失一般性地，指向子节点的指针存放在数组中</p><p>即，N 叉树的每个元素都有两个成员变量：节点的值 <code>val</code> 、存放子节点指针的数组 <code>children</code></p><pre><code class="language-cpp">// N 叉树节点的定义
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val = _val;
    &#125;

    Node(int _val, vector&lt;Node*&gt; _children) &#123;
        val = _val;
        children = _children;
    &#125;
&#125;;
</code></pre><h2 id="method-广度优先搜索-4"><a class="anchor" href="#method-广度优先搜索-4">#</a> Method: 广度优先搜索</h2><p>算法思路：</p><ul><li>与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似，利用队列存放待访问的节点</li><li>不同点在于：在 将子节点指针入队 的过程中，需要遍历子节点指针数组 <code>children</code></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;
    vector&lt;vector&lt;int&gt;&gt; res;
    queue&lt;Node*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        vector&lt;int&gt; tmp;
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            Node* cur = que.front();
            que.pop();
            tmp.push_back(cur-&gt;val);
            for (Node* child : cur-&gt;children) &#123; // 子节点
                if (child) que.push(child);
            &#125;
        &#125;
        res.push_back(tmp);
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-437-路径总和-iii"><a class="anchor" href="#leetcode-437-路径总和-iii">#</a> LeetCode 437. 路径总和 III</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkv">437. Path Sum III</span></p><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/Example.jpg" alt="" height="200px"></p><pre><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
</code></pre><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 [0, 1000]</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^9 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-1000 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>targetSum</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-1-深度优先搜索"><a class="anchor" href="#method-1-深度优先搜索">#</a> Method 1: 深度优先搜索</h2><p>算法思路：</p><p>访问每一个节点 node，检测以 node 为起始节点且和为 targetSum 的路径数目，即：</p><ul><li>定义 rootSum (root, sum) 表示以节点 root 为起点且满足路径总和为 val 的路径数目</li><li>递归遍历二叉树的每个节点 root，对每个节点 root 求 rootSum (root, sum)，累加每个节点所求值</li></ul><p>其中，rootSum (root, sum) 也是通过递归实现：</p><ul><li>假设当前节点 root 的值为 val，初始化返回值 res 为 0</li><li>检查 val 是否等于 sum，若等于，则已经存在一条路径（节点 root 单独作为一条路径），即，res = res + 1</li><li>递归到左子树，计算以 root-&gt;left 为起点且满足路径和为 sum - val 的路径数，记作 leftRes</li><li>递归到右子树，计算以 root-&gt;left 为起点且满足路径和为 sum - val 的路径数，记作 rightRes</li><li>计算以 root 为起点且满足路径和为 sum 的路径总数，即：res = res + leftRes + rightRes</li></ul><p>代码实现：</p><pre><code class="language-cpp">// 以 root 为起点的、和为 sum 的路径数
int rootSum(TreeNode* root, long sum) &#123; // 注意这里是 long sum （因为有特殊样例）
    if (root == nullptr) return 0;
    int res = 0;
    if (root-&gt;val == sum) ++res;
    res += rootSum(root-&gt;left, sum - root-&gt;val);
    res += rootSum(root-&gt;right, sum - root-&gt;val);
    return res;
&#125;

// 在以 root 为根节点的二叉树中，计算和为 sum 的路径数
int pathSum(TreeNode* root, int sum) &#123;
    if (root == nullptr) return 0;
    int ans = rootSum(root, sum);          // 以 root 为起点的、和为 sum 的路径数
    int left = pathSum(root-&gt;left, sum);   // 递归到左子树，计算和为 sum 的路径数
    int right = pathSum(root-&gt;right, sum); // 递归到右子树，计算和为 sum 的路径数
    ans += left + right;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数</p><ul><li>遍历二叉树的每个节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每个节点都要计算以该节点为起点的路径数目，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p><h2 id="method-2-前缀和"><a class="anchor" href="#method-2-前缀和">#</a> Method 2: 前缀和</h2><p>算法思路：</p><p>定义节点的前缀和：从根节点到当前节点的路径上所有节点的和（不包含当前节点），并利用哈希表 <code>unordered_map&lt;long long, int&gt; prefix</code> 记录每一个前缀和的出现次数</p><p>定义递归函数 helper () ：在以 node 为根节点的二叉树中，计算 “ 以每个节点为路径终点、并且满足路径和为 targetSum” 的路径数，返回路径数总和</p><p>递归函数的参数：</p><ul><li><code>TreeNode* node</code> ：当前节点</li><li><code>int targetSum</code> ：目标和</li><li><code>long long curSum</code> ：根节点到当前节点路径上所有节点之和（不包含当前节点）</li><li>返回值：路径和为 targetSum 的路径条数</li></ul><p>递归终止条件：node 为空节点，当前递归结束，返回 0</p><p>单层递归的逻辑：</p><ul><li>将当前节点值计入路径和 curSum</li><li>计算以 node 为路径终点且满足路径和为 targetSum 的路径数：prefix [curSum - targetSum]<ul><li>若存在节点 p<sub>i</sub> 使得根节点 root 到 p<sub>i</sub> 的路径和为 curSum - targetSum ，则节点 p<sub>i+1</sub> 到 node 的路径和一定为 targetSum</li><li>换言之，如果存在值为 curSum - targetSum 的前缀和，则一定存在 以 node 为终点且路径和为 targetSum 的路径，并且，前缀和的出现次数即为路径条数</li></ul></li><li>将当前路径和 curSum 作为前缀和计入哈希表（以 curSum 为 key ，将对应的 value 加 1），以便递归到子树时使用</li><li>递归到左子树，计算以 node-&gt;left 为路径终点且满足路径和为 targetSum 的路径数</li><li>递归到左子树，计算以 node-&gt;right 为路径终点且满足路径和为 targetSum 的路径数</li><li>回溯：将当前路径和 curSum 从哈希表中删除（以 curSum 为 key ，将对应的 value 减 1）</li><li>计算路径总数，并返回结果</li></ul><p>代码实现：</p><pre><code class="language-cpp">unordered_map&lt;long long, int&gt; prefix;

int helper(TreeNode* node, int targetSum, long long curSum) &#123;
    if (node == nullptr) return 0;
    int ans = 0;
    curSum += node-&gt;val;
    ans += prefix[curSum - targetSum];
    ++prefix[curSum];
    ans += helper(node-&gt;left, targetSum, curSum);
    ans += helper(node-&gt;right, targetSum, curSum);
    --prefix[curSum]; // 回溯
    return ans;
&#125;

int pathSum(TreeNode* root, int targetSum) &#123;
    prefix[0] = 1;
    return helper(root, targetSum, 0);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数。利用前缀和只需遍历一次二叉树</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间以及哈希表所需储存空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkvc29sdXRpb24vbHUtamluZy16b25nLWhlLWlpaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi16OXRkLw==">leetcode-solution</span></p><h1 id="leetcode-450-删除二叉搜索树中的节点"><a class="anchor" href="#leetcode-450-删除二叉搜索树中的节点">#</a> LeetCode 450. 删除二叉搜索树中的节点</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=">450. Delete Node in a BST</span></p><p>给定一个二叉搜索树的根节点 <code>root</code> 和一个值 <code>key</code> ，删除二叉搜索树中的 <code>key</code> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ul><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="LeetCode450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/example.jpg" alt=""></p><pre><code>输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如图所示。另一个正确答案是 [5,2,6,null,4,null,7]。
</code></pre><p><img data-src="LeetCode450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/result.jpg" alt=""></p><p><strong>示例 2：</strong></p><pre><code>输入：root = [5,3,6,2,4,null,7], key = 0
输出：[5,3,6,2,4,null,7]
解释：二叉树不包含值为 0 的节点
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [], key = 0
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li>节点数的范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>key</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：要求算法时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span></span></span></span> 为树的高度。</p><h2 id="思路-20"><a class="anchor" href="#思路-20">#</a> 思路</h2><p><strong>建议先画示意图，结合图来分析</strong></p><p>本题可能有以下情况：</p><ol><li><p>二叉树中不存在值为 <code>key</code> 的节点</p></li><li><p>二叉树中存在值为 <code>key</code> 的节点，不妨记作 <code>node</code></p><ul><li><code>node</code> 的左、右子节点均为空，即， <code>node</code> 是叶节点，直接删除 <code>node</code> 即可</li><li><code>node</code> 的左子节点为空、右子节点不为空，在删除 <code>node</code> 时需要将其右子节点作为新的 <code>node</code></li><li><code>node</code> 的左子节点为空、右子节点为空，在删除 <code>node</code> 时需要将其左子节点作为新的 <code>node</code></li><li><code>node</code> 的左、右子节点均不为空，需要找到一个节点来承接 <code>node</code> 的左、右子节点</li></ul></li></ol><p>其中，针对 <code>node</code> 的左、右子节点均不为空 的情况：由于 <code>node</code> 左子树上所有节点值均小于 <code>node</code> ，而 <code>node</code> 右子树上所有节点值均大于 <code>node</code> ，可确定新的 <code>node</code> 节点为（二者选其一）</p><ul><li>左子树上的最大节点（左子树的最右侧节点）</li><li>右子树上的最小节点（右子树的最左侧节点）</li></ul><p>不妨取右子树上的最小节点，将其记作 <code>successor</code> ，在利用 <code>successor</code> 替换 <code>node</code> 的过程中需做以下考虑： <code>successor</code> 的右子树不一定为空，在从 <code>successor</code> 原本的位置上移除 <code>successor</code> 时，需妥善处理其右子树</p><ul><li>如果 <code>successor</code> 是 <code>node</code> 的右子节点（即， <code>node-&gt;right</code> 就是 <code>node</code> 右子树上的最小节点），可以直接将 <code>successor</code> 的右子树作为 <code>node</code> 的右子树</li><li>否则，需要记录 <code>successor</code> 的父节点（记作 <code>parent</code> ），将 <code>successor</code> 的右子树作为 <code>parent</code> 的左子树</li></ul><blockquote><p>除了上述方式外，也可以直接调用函数 <code>deleteNode(root-&gt;right, successor-&gt;val)</code> ，从以 <code>root-&gt;right</code> 为根的树上删除值为 <code>successor-&gt;val</code> 的节点</p></blockquote><h2 id="method-1-递归-10"><a class="anchor" href="#method-1-递归-10">#</a> Method 1: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">TreeNode* deleteNode(TreeNode* root, int key) &#123;
    if (!root) return nullptr; // 未找到 key
    if (root-&gt;val &gt; key)       // 递归到左子树寻找 key
        root-&gt;left = deleteNode(root-&gt;left, key);
    if (root-&gt;val &lt; key)       // 递归到右子树寻找 key
        root-&gt;right = deleteNode(root-&gt;right, key);
    if (root-&gt;val == key) &#123;    // root 就是应删除的节点
        if (!root-&gt;left &amp;&amp; !root-&gt;right) // root 为叶节点，直接删除
            return nullptr;
        if (root-&gt;left &amp;&amp; !root-&gt;right)  // 用 root-&gt;left 替代 root
            return root-&gt;left;
        if (!root-&gt;left &amp;&amp; root-&gt;right)  // 用 root-&gt;right 替代 root
            return root-&gt;right;
        if (root-&gt;left &amp;&amp; root-&gt;right) &#123; // 从左、右子树中选出一个新的 root
            TreeNode *successor = root-&gt;right; // 新的 root（初始化）
            while (successor-&gt;left)      // 取 root 右子树的最左侧节点
                successor = successor-&gt;left;
            root-&gt;right = deleteNode(root-&gt;right, successor-&gt;val); // 删除 successor 原本的位置
            successor-&gt;left = root-&gt;left;   // 将 root 左子树移动到 successor 上
            successor-&gt;right = root-&gt;right; // 将 root 右子树移动到 successor 上
            return successor;
        &#125;
    &#125;
    return root;
&#125;
</code></pre><p>其中</p><pre><code class="language-cpp">TreeNode *successor = root-&gt;right; // 新的 root
while (successor-&gt;left)      // 将 root 右子树的最左侧节点作为新的 root
    successor = successor-&gt;left;
root-&gt;right = deleteNode(root-&gt;right, successor-&gt;val); // 删除 successor 原本的位置
</code></pre><p>可替换为</p><pre><code class="language-cpp">TreeNode *successor = root-&gt;right; // 新的 root （初始化）
TreeNode *parent = root;  // successor 的父节点
while (successor-&gt;left) &#123; // 将 root 右子树的最左侧节点作为新的 root
    parent = successor;
    successor = successor-&gt;left;
&#125;
if (parent == root) // successor 就是 root-&gt;right 
    parent-&gt;right = successor-&gt;right; // 将 successor 右子树作为 root 右子树
else // successor 是 root-&gt;right 的左子树上节点
    parent-&gt;left = successor-&gt;right;  // 将 successor 右子树作为 parent 左子树
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC9zb2x1dGlvbi9zaGFuLWNodS1lci1jaGEtc291LXN1by1zaHUtemhvbmctZGUtamllLW42dm8v">力扣官方题解：删除二叉树中的节点</span></p><blockquote><p>附注：在 <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA0NTAuJUU1JTg4JUEwJUU5JTk5JUE0JUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU4JThBJTgyJUU3JTgyJUI5Lmh0bWw=">代码随想录</span> 中，针对 <code>node</code> 的左、右子节点均不为空 的情况，其直接将 <code>node</code> 的左子树作为 <code>successor</code> 的左子树</p></blockquote><h1 id="leetcode-501-二叉搜索树中的众数"><a class="anchor" href="#leetcode-501-二叉搜索树中的众数">#</a> LeetCode 501. 二叉搜索树中的众数</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1vZGUtaW4tYmluYXJ5LXNlYXJjaC10cmVlLw==">501. Find Mode in Binary Search Tree</span></p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <strong>众数</strong>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 小于等于 当前节点的值</li><li>结点右子树中所含节点的值 大于等于 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><p><img data-src="LeetCode501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/mode-tree.jpg" alt=""></p><pre><code>输入：root = [1,null,2,2]
输出：[2]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [0]
输出：[0]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^5 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>进阶</strong>：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h2 id="思路-21"><a class="anchor" href="#思路-21">#</a> 思路</h2><p>在二叉搜索树中，中序遍历可以得到有序序列</p><p>重复数字在中序遍历序列中必定是连续出现的</p><p>因此，可以先获得这棵树的中序遍历，然后扫描中序遍历序列，统计每个数字出现的个数，这样就可以找到出现次数最多的数字</p><h2 id="method-1-中序遍历额外数组"><a class="anchor" href="#method-1-中序遍历额外数组">#</a> Method 1: 中序遍历（额外数组）</h2><p>算法思路：</p><ol><li><p>中序遍历二叉树，得到非递减的有序序列 <code>nums</code></p></li><li><p>定义 <code>curCount</code> 记录当前数字的出现次数， <code>maxCount</code> 表示当前统计到的最大出现次数，数组 <code>res</code> 记录出现的众数</p></li><li><p>遍历数组 <code>nums</code> 的元素</p><ul><li>更新 <code>curCount</code><ul><li>如果该元素是第 0 位元素，或者，该元素与上一位元素相等， <code>curCount</code> 自增 1</li><li>否则，意味着出现新数字， <code>curCount</code> 置为 1</li></ul></li><li>更新 <code>maxCount</code><ul><li>若 <code>curCount == maxCount</code> ，当前数字的出现次数等于统计到的最大出现次数，将当前数字加入 <code>res</code></li><li>若 <code>curCount &gt; maxCount</code> ，当前数字的出现次数大于统计到的最大出现次数，需将 <code>maxCount</code> 更新为 <code>curCount</code> ，清空 <code>res</code> 数组后再将当前元素加入 <code>res</code> 数组</li></ul></li></ul></li></ol><blockquote><p>注：该算法在条件 <code>curCount &gt; maxCount</code> 或条件 <code>curCount == maxCount</code> 满足时就会更新 <code>res</code> 数组，而不只是在 <code>nums[i] != nums[i - 1]</code> 时更新 <code>res</code> 数组</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">void traversal(TreeNode *root, vector&lt;int&gt; &amp;nums) &#123; // 中序遍历
    if (!root) return;
    traversal(root-&gt;left, nums);
    nums.push_back(root-&gt;val);
    traversal(root-&gt;right, nums);
&#125;

vector&lt;int&gt; findMode(TreeNode* root) &#123;
    vector&lt;int&gt; nums;
    traversal(root, nums); // 中序遍历序列
    int maxCount = 0;      // 最大出现频率
    int curCount = 0;      // 当前出现频率
    vector&lt;int&gt; res;       // 目标数组
    for (int i = 0; i &lt; nums.size(); i++) &#123;
        if (i == 0 || nums[i] == nums[i - 1]) curCount++; // 连续相同数字
        else curCount = 1;          // 不相同数字，重新统计频率
        if (curCount &gt; maxCount) &#123;  // 遇到出现频率更高的数字
            maxCount = curCount;    // 更新最大出现频率
            res = &#123;nums[i]&#125;;        // 清空此前记录的众数，并放入新的众数
        &#125; else if (curCount == maxCount) &#123; // 多个众数
            res.push_back(nums[i]);
        &#125;
    &#125;
    return res;
&#125;
</code></pre><p>其中， <code>res = &#123;nums[i]&#125;;</code> 等价于</p><pre><code class="language-cpp">res.clear();
res.push_back(nums[i]);
</code></pre><p>算法的时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li>遍历二叉树、遍历数组 <code>nums</code> 的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>算法的空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里考虑了递归需要的栈空间、存放中序遍历结果的所需的空间</p><h2 id="method-2-中序遍历无额外数组"><a class="anchor" href="#method-2-中序遍历无额外数组">#</a> Method 2: 中序遍历（无额外数组）</h2><p>Method 1 先将二叉树节点值存放到中序遍历序列，然后再统计各数字的出现次数，这一过程使用了额外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的空间</p><p>实际上，也可以不存储中序遍历序列，直接在中序遍历二叉树的过程中操作</p><p>代码实现：</p><pre><code class="language-cpp">int curCount = 0; // 当前出现次数
int maxCount = 0; // 最大出现次数
TreeNode *pre = nullptr; // 前一个节点
vector&lt;int&gt; res;  // 存放众数

void update(TreeNode *root) &#123; // 更新 curCount , maxCount 和 res
    if (pre == nullptr || root-&gt;val == pre-&gt;val) curCount++;
    else curCount = 1;
    if (curCount &gt; maxCount) &#123;
        maxCount = curCount;
        res = &#123;root-&gt;val&#125;;
    &#125; else if (curCount == maxCount) &#123;
        res.push_back(root-&gt;val);
    &#125;
    pre = root;
&#125;

void traversal(TreeNode *root) &#123; // 中序遍历
    if (!root) return;
    traversal(root-&gt;left);
    update(root);
    traversal(root-&gt;right);
&#125;

vector&lt;int&gt; findMode(TreeNode* root) &#123;
    traversal(root);
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这里仅需考虑递归需要的栈空间</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MDEuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU0JUJDJTk3JUU2JTk1JUIwLmh0bWw=">代码随想录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1vZGUtaW4tYmluYXJ5LXNlYXJjaC10cmVlL3NvbHV0aW9uL2VyLWNoYS1zb3Utc3VvLXNodS16aG9uZy1kZS16aG9uZy1zaHUtYnktbGVldGNvZGUtLw==">力扣官方题解</span></li></ul><h1 id="leetcode-513-找树左下角的值"><a class="anchor" href="#leetcode-513-找树左下角的值">#</a> LeetCode 513. 找树左下角的值</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWJvdHRvbS1sZWZ0LXRyZWUtdmFsdWUv">513. Find Bottom Left Tree Value</span></p><p>给定一个二叉树的 根节点 <code>root</code> ，请找出该二叉树的 <strong>最底层</strong> <strong>最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/tree1.jpg" alt=""></p><pre><code>输入：root = [2,1,3]
输出：1
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/tree2.jpg" alt=""></p><pre><code>输入：root = [1,2,3,4,null,5,6,null,null,7]
输出：7
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="思路-22"><a class="anchor" href="#思路-22">#</a> 思路</h2><p>找出最后一行的最左侧节点的值：首先要是最后一行，然后是最左侧节点</p><h2 id="method-1-层序遍历-3"><a class="anchor" href="#method-1-层序遍历-3">#</a> Method 1: 层序遍历</h2><p>算法思路：逐层遍历，记录每层最左侧的节点（用下一层的记录覆盖上一层），遍历结束时，即得到最后一层的最左侧节点</p><p>代码实现：</p><pre><code class="language-cpp">int findBottomLeftValue(TreeNode* root) &#123;
    TreeNode* leftMost = new TreeNode(0); // 最左侧节点
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        leftMost = que.front();
        int size = que.size();
        for (int i = 0; i &lt; size; i++) &#123;
            TreeNode* tmp = que.front();
            que.pop();
            if (tmp-&gt;left) que.push(tmp-&gt;left);
            if (tmp-&gt;right) que.push(tmp-&gt;right);
        &#125;
    &#125;
    return leftMost-&gt;val;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>在遍历每一层时，可以按照 从右到左 的遍历顺序，于是，广度优先搜索所遍历的最后一个节点就是最底层最左边节点</p></blockquote><h2 id="method-2-前序遍历-2"><a class="anchor" href="#method-2-前序遍历-2">#</a> Method 2: 前序遍历</h2><p>利用递归法计算二叉树的最大深度，并记录访问到的第一个具有最大深度的叶节点</p><p>算法思路：</p><ol><li><p>递归函数 <code>getValue</code> 的参数和返回值</p><ul><li>传入参数为根节点 <code>root</code> 及其深度 <code>depth</code></li><li>无返回值，返回值类型为 <code>void</code></li></ul></li><li><p>递归的终止条件：遇到叶节点，当前递归结束</p></li><li><p>单层递归的逻辑：</p><ul><li>若当前节点是叶节点<ul><li>若当前节点深度大于此前所有节点的深度，则更新二叉树最大深度为当前节点的深度，并记录当前叶节点的值</li><li>当前递归结束，返回上一层递归</li></ul></li><li>若当前节点不是叶节点，分别递归到左、右子节点</li></ul></li></ol><p>注意：</p><ul><li>最大深度 <code>maxDepth</code> 和 最左侧节点值 <code>value</code> 是全局变量</li><li>递归函数的参数 <code>depth</code> 采用拷贝赋值的方式传递，而不是以引用方式传递，这是为了递归的回溯</li></ul><p>代码实现：</p><pre><code class="language-cpp">int maxDepth = INT_MIN; // 最大深度
int value = 0;          // 最大深度最左侧节点值
void getValue(TreeNode* root, int depth) &#123; // 查找以 root 为根的树底层最左侧节点
    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // root 为叶节点
        if (depth &gt; maxDepth) &#123; // 遍历到更大深度，更新 maxDepth 以及 value
            maxDepth = depth;
            value = root-&gt;val;
        &#125;
        return;         // root 为叶节点，不再向下遍历
    &#125;
    if (root-&gt;left) getValue(root-&gt;left, depth + 1);   // 递归到左子树
    if (root-&gt;right) getValue(root-&gt;right, depth + 1); // 递归到右子树
    return;
&#125;

int findBottomLeftValue(TreeNode* root) &#123;
    getValue(root, 1);
    return value;
&#125;
</code></pre><p>补充说明：具有最大深度的节点一定是在最底层，这一点容易理解。但是，为什么可以找到最左侧的节点呢？</p><ul><li>对于具有相同深度的两个节点，左侧节点的访问 / 处理一定先于右侧节点（无论是采用何种深度优先遍历方式）</li><li>在访问到第一个具有最大深度的节点（即，最底层的最左侧节点）时， <code>maxDepth</code> 和 <code>value</code> 均被更新。此后，访问到最底层的其余节点时， <code>depth &gt; maxDepth</code> 这一条件并不满足， <code>value</code> 也就不会被更新。故而， <code>value</code> 是最底层最左侧节点的值</li></ul><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MTMuJUU2JTg5JUJFJUU2JUEwJTkxJUU1JUI3JUE2JUU0JUI4JThCJUU4JUE3JTkyJUU3JTlBJTg0JUU1JTgwJUJDLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录：找树左下角的值</span></p><h1 id="leetcode-515-在每个树行中找最大值"><a class="anchor" href="#leetcode-515-在每个树行中找最大值">#</a> LeetCode 515. 在每个树行中找最大值</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWxhcmdlc3QtdmFsdWUtaW4tZWFjaC10cmVlLXJvdy8=">LeetCode 515. Find Largest Value in Each Tree Row</span></p><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/example1.jpg" alt="" height="200px"></p><pre><code>输入：root = [1,3,2,5,3,null,9]
输出：[1,3,9]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,2,3]
输出：[1,3]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="思路-23"><a class="anchor" href="#思路-23">#</a> 思路</h2><p>与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似</p><p>逐层、从左到右遍历，利用队列存放待访问的节点</p><p>在遍历过程中，只需将 每一层节点值的最大值 添加到目标数组</p><h2 id="method-广度优先搜索-5"><a class="anchor" href="#method-广度优先搜索-5">#</a> Method: 广度优先搜索</h2><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; largestValues(TreeNode* root) &#123;
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    vector&lt;int&gt; ans;
    while (!que.empty()) &#123;
        int size = que.size();
        int value = que.front()-&gt;val; // 每一行的最大值
        for (int i = 0; i &lt; size; i++) &#123;
            TreeNode* node = que.front();
            que.pop();
            if (node-&gt;val &gt; value) value = node-&gt;val; // 查找最大值
            if (node-&gt;left) que.push(node-&gt;left);
            if (node-&gt;right) que.push(node-&gt;right);
        &#125;
        ans.push_back(value); // 将最大值添加到目标数组
    &#125;
    return ans;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-530-二叉搜索树的最小绝对差"><a class="anchor" href="#leetcode-530-二叉搜索树的最小绝对差">#</a> LeetCode 530. 二叉搜索树的最小绝对差</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWFic29sdXRlLWRpZmZlcmVuY2UtaW4tYnN0Lw==">530. Minimum Absolute Difference in BST</span></p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/bst1.jpg" alt=""></p><pre><code>输入：root = [4,2,6,1,3]
输出：1
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/bst2.jpg" alt=""></p><pre><code>输入：root = [1,0,48,null,null,12,49]
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><strong>说明</strong>：本题与 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1kaXN0YW5jZS1iZXR3ZWVuLWJzdC1ub2Rlcy8=">LeetCode 783</span> 相同</p><h2 id="思路-24"><a class="anchor" href="#思路-24">#</a> 思路</h2><p>本题类似于 <a href="https://jiankychen.github.io/posts/282d26b5">LeetCode 98. 验证二叉搜索树</a></p><p>只需在中序遍历过程中计算前一个节点值和后一个节点值之差即可</p><h2 id="method-中序遍历"><a class="anchor" href="#method-中序遍历">#</a> Method: 中序遍历</h2><p>代码实现：</p><pre><code class="language-cpp">void helper(TreeNode *root, int &amp;minDif, int &amp;preValue) &#123; // 计算 root 与前一个节点值的绝对差，并更新最小绝对差
    if (!root) return;
    helper(root-&gt;left, minDif, preValue);            // 左
    minDif = min(abs(root-&gt;val - preValue), minDif); // 根
    preValue = root-&gt;val;
    helper(root-&gt;right, minDif, preValue);           // 右
&#125;

int getMinimumDifference(TreeNode* root) &#123;
    int minDif = INT_MAX;   // 最小差值
    int preValue = INT_MAX; // 前一个节点的值
    helper(root, minDif, preValue);
    return minDif;
&#125;
</code></pre><p>也可以写成：</p><pre><code class="language-cpp">int minDif = INT_MAX;    // 最小绝对差
TreeNode *pre = nullptr; // 前一个节点

void helper(TreeNode *root) &#123;
    if (!root) return;
    helper(root-&gt;left);  // 左
    if (pre != nullptr)
        minDif = min(abs(root-&gt;val - pre-&gt;val), minDif); // 根
    pre = root;
    helper(root-&gt;right); // 右
&#125;

int getMinimumDifference(TreeNode* root) &#123;
    helper(root);
    return minDif;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p><h1 id="leetcode-538-把二叉搜索树转换为累加树"><a class="anchor" href="#leetcode-538-把二叉搜索树转换为累加树">#</a> LeetCode 538. 把二叉搜索树转换为累加树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUv">538. Convert BST to Greater Tree</span></p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 小于 节点键的节点。</li><li>节点的右子树仅包含键 大于 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="LeetCode538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/tree.png" alt="" height="200px"></p><pre><code>输入：root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [0,null,1]
输出：[1,null,1]
</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>树中的所有值 互不相同</li><li>给定的树为二叉搜索树</li></ul><p><strong>说明：</strong> 本题与 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC10cmVlLXRvLWdyZWF0ZXItc3VtLXRyZWUv">LeetCode 1038</span> 相同</p><h2 id="method-递归-5"><a class="anchor" href="#method-递归-5">#</a> Method: 递归</h2><h2 id="算法思路"><a class="anchor" href="#算法思路">#</a> 算法思路</h2><p>二叉搜索树的中序遍历是一个单调递增的有序序列</p><p>若按照 右 - 根 - 左 的顺序遍历，则会得到一个单调递减的有序序列</p><p>本题要求将 每个节点的值 修改为 原来的节点值加上所有大于它的节点值之和 ，<strong>可以按照 右 - 根 - 左 的顺序遍历二叉树，记录过程中的节点值之和，并不断更新遍历到的节点值</strong></p><h2 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h2><pre><code class="language-cpp">void traversal(TreeNode *root, int &amp;sum) &#123; // 按 右-根-左 顺序遍历
    if (!root) return;
    traversal(root-&gt;right, sum); // 先递归右子树，统计 所有 值大于 root-&gt;val 的节点 之和
    sum += root-&gt;val; // 统计所有 值大于等于 root-&gt;val 的节点 之和
    root-&gt;val = sum;  // 将 root-&gt;val 更新为 sum
    traversal(root-&gt;left, sum);  // 递归到左子树
&#125;

TreeNode* convertBST(TreeNode* root) &#123;
    int sum = 0; // 累加和
    traversal(root, sum);
    return root;
&#125;
</code></pre><h2 id="复杂度分析"><a class="anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用的栈空间</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUvc29sdXRpb24vYmEtZXItY2hhLXNvdS1zdW8tc2h1LXpodWFuLWh1YW4td2VpLWxlaS1qaWEtc2gtMTQv">力扣官方题解：把二叉搜索树转换为累加树</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA1MzguJUU2JThBJThBJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU4JUJEJUFDJUU2JThEJUEyJUU0JUI4JUJBJUU3JUI0JUFGJUU1JThBJUEwJUU2JUEwJTkxLmh0bWw=">代码随想录：把二叉搜索树转换为累加树</span></li></ul><h1 id="leetcode-543-二叉树的直径"><a class="anchor" href="#leetcode-543-二叉树的直径">#</a> LeetCode 543. 二叉树的直径</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaWFtZXRlci1vZi1iaW5hcnktdHJlZS8=">543. Diameter of Binary Tree</span></p><p>给定一棵二叉树，你需要计算它的直径长度。</p><p>一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>注意：</strong> 两结点之间的路径长度是以它们之间边的数目表示</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/Example.jpg" alt=""></p><pre><code>输入：root = [1,2,3,4,5]
输出：3
解释：路径 [4,2,1,3] 或者 [5,2,1,3]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,2]
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li>节点数的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><h2 id="method-递归-6"><a class="anchor" href="#method-递归-6">#</a> Method: 递归</h2><h2 id="算法思路-2"><a class="anchor" href="#算法思路-2">#</a> 算法思路</h2><p>定义一个递归函数 <code>int helper(TreeNode* root)</code> ，用于计算 以 root 为起点、向下延伸的路径的最大长度（即，最大边数，因为两节点之间的路径长度是以它们之间边的数目表示的），即，以 root 为根的二叉树的最大深度减 1</p><p>任意节点 node 都有一条从其左子树到右子树的最长路径（记作 route ），其路径长度（边数）为左子树最大深度 + 右子树最大深度 - 2 ，即， <code>helper(node-&gt;left)</code> + <code>helper(node-&gt;right)</code></p><p>因此，遍历二叉树每一个节点并比较其对应的路径 route 的长度，即可得到整个二叉树中最长路径的长度</p><h2 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h2><pre><code class="language-cpp">int ans = 0; // 路径的最大长度

int helper(TreeNode* root) &#123;
    if (root == nullptr) return 0;
    int leftEdges = helper(root-&gt;left);     // 以左子节点为起点向下延伸的最长路径的长度（边数）
    int rightEdges = helper(root-&gt;right);   // 以右子节点为起点向下延伸的最长路径的长度（边数）
    ans = max(ans, leftEdges + rightEdges); // 从左子树深度最大的节点到右子树深度最大的节点
    return max(leftEdges, rightEdges) + 1;  // 以 root 为起点向下延伸的最长路径的长度（边数）
&#125;

int diameterOfBinaryTree(TreeNode* root) &#123;
    helper(root);
    return ans;
&#125;
</code></pre><h2 id="复杂度分析-2"><a class="anchor" href="#复杂度分析-2">#</a> 复杂度分析</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点数。每个节点均遍历一次</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归所需栈空间</p><h1 id="leetcode-572-另一棵树的子树"><a class="anchor" href="#leetcode-572-另一棵树的子树">#</a> LeetCode 572. 另一棵树的子树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJ0cmVlLW9mLWFub3RoZXItdHJlZS8=">572. Subtree of Another Tree</span></p><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。 <code>tree</code> 也可以看做它自身的一棵子树。</p><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/subtree1-tree.jpg" alt=""></p><pre><code>输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/subtree2-tree.jpg" alt=""></p><pre><code>输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><code>root</code> 树上的节点数量范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><code>subRoot</code> 树上的节点数量范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>root.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>subRoot.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-1-深度优先遍历-暴力匹配"><a class="anchor" href="#method-1-深度优先遍历-暴力匹配">#</a> Method 1: 深度优先遍历 + 暴力匹配</h2><p>算法思路：按照前序遍历的顺序枚举树 <code>root</code> 中的每一个节点，判断以这个节点为根的树是否和树 <code>subRoot</code> 相同，其中，判断两树是否相同可参考 <a href="https://jiankychen.github.io/posts/b45c53f3">LeetCode 100. 相同二叉树</a></p><p>代码实现：</p><pre><code class="language-cpp">bool isSameTree(TreeNode *root1, TreeNode *root2) &#123; // 判断以 root1 为根的树是否相同于以 root2 为根的树
    if (!root1 &amp;&amp; !root2) return true;
    if (!root1 || !root2) return false;
    if (root1-&gt;val != root2-&gt;val) return false;
    return isSameTree(root1-&gt;left, root2-&gt;left) &amp;&amp; isSameTree(root1-&gt;right, root2-&gt;right);
&#125;

bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;
    if (!root) return false; // root 为空，subRoot 不是 root 的子树
    if (isSameTree(root, subRoot)) return true; // 以 root 为根的树 相同于 以 subRoot 为根的树
    return isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot); // root 递归到左、右子节点
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是树 <code>root</code> 和树 <code>subRoot</code> 的节点个数</p><ul><li>最坏情况下，需要遍历树 <code>root</code> 中每个节点，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li><li>判断两树是否相同 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\max(d_r, d_s))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">d_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">d_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 分别是树 <code>root</code> 和树 <code>subRoot</code> 的深度。这里考虑了递归调用栈，任意时刻下栈使用的最大空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\max(d_r, d_s))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJ0cmVlLW9mLWFub3RoZXItdHJlZS9zb2x1dGlvbi9saW5nLXlpLWdlLXNodS1kZS16aS1zaHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：另一棵树的子树</span></p><h2 id="method-2-深度优先遍历-kmp-匹配"><a class="anchor" href="#method-2-深度优先遍历-kmp-匹配">#</a> Method 2: 深度优先遍历 + KMP 匹配</h2><p>先验知识：一棵子树上的节点在深度优先搜索序列（前序遍历）中是连续的</p><p>因此，可以利用前序遍历得到树 <code>root</code> 和树 <code>subRoot</code> 的节点序列，分别记作 <code>s</code> 和 <code>t</code> ，然后判断 <code>t</code> 是否为 <code>s</code> 的子串</p><ul><li><p>但需注意，仅仅是前序遍历无法唯一确定一棵二叉树</p></li><li><p>例如， <code>root</code> 由两个点组成：1 是根，2 是 1 的左子节点； <code>subRoot</code> 也由两个点组成：1 是根，2 是 1 的右子节点，此时，树 <code>root</code> 和 <code>subRoot</code> 的前序遍历序列相同，但 <code>subRoot</code> 并不是 <code>root</code> 的某一棵子树</p></li><li><p>由此可见：“ <code>t</code> 是 <code>s</code> 的子串 ” 是 “ <code>subRoot</code> 是 <code>root</code> 的子树 ” 的必要不充分条件</p></li><li><p>对此，可以引入两个空值 <code>lNull</code> 和 <code>rNull</code> ，当前序遍历遇到空的左子节点、空的右子节点时，分别在节点序列中放入 <code>lNull</code> 和 <code>rNull</code> 值，由此，可以唯一确定一棵二叉树</p></li></ul><p>判断 <code>t</code> 是否为 <code>s</code> 的子串，可以采用暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法</p><p>可参考 <a href="https://jiankychen.github.io/posts/36b55f59">KMP 算法</a> 和 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJ0cmVlLW9mLWFub3RoZXItdHJlZS9zb2x1dGlvbi9saW5nLXlpLWdlLXNodS1kZS16aS1zaHUtYnktbGVldGNvZGUtc29sdXRpb24v">力扣官方题解：另一棵树的子树 - 方法二</span></p><h1 id="leetcode-589-n-叉树的前序遍历"><a class="anchor" href="#leetcode-589-n-叉树的前序遍历">#</a> LeetCode 589. N 叉树的前序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXByZW9yZGVyLXRyYXZlcnNhbC8=">589. N-ary Tree Preorder Traversal</span></p><p>给定一个 n 叉树的根节点 <code>root</code> ，返回 其节点值的 <strong>前序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/example1.png" alt=""></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]
输出：[1,3,5,6,2,4]
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/example2.png" alt=""></p><pre><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]
</code></pre><p><strong>提示：</strong></p><ul><li>节点总数在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>n 叉树的高度小于或等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归法很简单，你可以使用迭代法完成此题吗？</p><h2 id="思路-25"><a class="anchor" href="#思路-25">#</a> 思路</h2><p>类似于 <a href="https://jiankychen.github.io/posts/1e967892">144. 二叉树的前序遍历</a></p><h2 id="method-1-递归-11"><a class="anchor" href="#method-1-递归-11">#</a> Method 1: 递归</h2><p>算法思路：按照 根 - 左 - 右 的顺序访问节点，并将节点的值添加到目标数组</p><p>代码实现：</p><pre><code class="language-cpp">void DFS(Node* root, vector&lt;int&gt; &amp;res) &#123;
    if (root == nullptr) return;
    res.push_back(root-&gt;val);        // 将 root 的值添加到数组 res
    for (auto node : root-&gt;children) // 访问子节点
        DFS(node, res);
&#125;

vector&lt;int&gt; preorder(Node* root) &#123;
    vector&lt;int&gt; res;
    DFS(root, res);
    return res;
&#125;
</code></pre><h2 id="method-2-迭代-6"><a class="anchor" href="#method-2-迭代-6">#</a> Method 2: 迭代</h2><p>算法思路：子节点须按从右到左的顺序依次放入栈中，以使得子节点按从左到右顺序出栈，以实现 根 - 左 - 右 顺序访问</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; preorder(Node* root) &#123;
    vector&lt;int&gt; res;
    stack&lt;Node*&gt; stk;
    if (root) stk.push(root);
    Node* tmp = new Node(0);
    while (!stk.empty()) &#123;
        tmp = stk.top();
        stk.pop();
        res.push_back(tmp-&gt;val);
        int size = tmp-&gt;children.size();
        for (int i = size - 1; i &gt;= 0; i--) &#123; // 逆序入栈，顺序出栈
            if (tmp-&gt;children[i]) stk.push(tmp-&gt;children[i]);
        &#125;
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-590-n-叉树的后序遍历"><a class="anchor" href="#leetcode-590-n-叉树的后序遍历">#</a> LeetCode 590. N 叉树的后序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXBvc3RvcmRlci10cmF2ZXJzYWwv">LeetCode 590. N-ary Tree Postorder Traversal</span></p><p>Given the <code>root</code> of an n-ary tree, return <em>the postorder traversal of its nodes' values</em>.</p><h2 id="思路-26"><a class="anchor" href="#思路-26">#</a> 思路</h2><p>类似于 <a href="https://jiankychen.github.io/posts/4e96229e">145. 二叉树的后序遍历</a></p><h2 id="method-1-递归-12"><a class="anchor" href="#method-1-递归-12">#</a> Method 1: 递归</h2><p>算法思路：按照 左 - 右 - 根 的顺序访问节点，并将节点的值添加到目标数组</p><p>代码实现：</p><pre><code class="language-cpp">void DFS(Node* root, vector&lt;int&gt; &amp;res) &#123; // 左-右-根
    if (root == nullptr) return;
    int size = root-&gt;children.size();
    for (int i = 0; i &lt; size; i++)
        DFS(root-&gt;children[i], res);
    res.push_back(root-&gt;val);
&#125;

vector&lt;int&gt; postorder(Node* root) &#123;
    vector&lt;int&gt; res;
    DFS(root, res);
    return res;
&#125;
</code></pre><h2 id="method-2-迭代-7"><a class="anchor" href="#method-2-迭代-7">#</a> Method 2: 迭代</h2><p>算法思路：</p><ul><li><p>按照 根 - 右 - 左 的顺序访问节点，并将节点的值添加到目标数组</p></li><li><p>最后将目标数组反转，即为所求</p></li></ul><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; postorder(Node* root) &#123;
    vector&lt;int&gt; res;
    stack&lt;Node*&gt; stk;
    if (root) stk.push(root);
    Node* tmp = new Node(0);
    while (!stk.empty()) &#123;
        tmp = stk.top();
        stk.pop();
        res.push_back(tmp-&gt;val);
        int size = tmp-&gt;children.size();
        for (int i = 0; i &lt; size; i++) // 节点按从左到右顺序入栈，按逆序出栈
            if (tmp-&gt;children[i]) stk.push(tmp-&gt;children[i]);
    &#125;
    reverse(res.begin(), res.end());
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-617-合并二叉树"><a class="anchor" href="#leetcode-617-合并二叉树">#</a> LeetCode 617. 合并二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLWJpbmFyeS10cmVlcy8=">LeetCode 617. Merge Two Binary Trees</span></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意：</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/1.jpg" alt=""></p><pre><code>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root1 = [1], root2 = [1,2]
输出：[2,2]
</code></pre><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^4 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="method-递归-7"><a class="anchor" href="#method-递归-7">#</a> Method: 递归</h2><p>算法思路：</p><ol><li><p>确定递归的参数和返回值</p><ul><li>参数：两棵二叉树的根节点 <code>root1</code> 和 <code>root2</code></li><li>返回值：合并后的根节点</li></ul></li><li><p>递归终止条件</p><ul><li>若 <code>root1</code> 为空，合并结果即为 <code>root2</code> ，返回 <code>root2</code></li><li>若 <code>root2</code> 为空，合并结果即为 <code>root1</code> ，返回 <code>root1</code></li></ul></li><li><p>单层递归的逻辑</p><ul><li>合并节点：计算 <code>root1-&gt;val</code> 和 <code>root2-&gt;val</code> 的和</li><li>递归，合并左子树</li><li>递归，合并右子树</li><li>返回合并结果</li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;
    if (!root1) return root2;
    if (!root2) return root1;
    TreeNode *root = new TreeNode();
    root-&gt;val = root1-&gt;val + root2-&gt;val; // 合并节点
    root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left); // 递归，合并左子树
    root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right); // 递归，合并右子树
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 分别是两个二叉树的节点数</p><ul><li>对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作</li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，这里考虑了递归使用的栈空间</p><ul><li>递归调用的层数不会超过较小二叉树的高度，最坏情况下，二叉树的高度等于节点数</li></ul><p>参考：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA2MTcuJUU1JTkwJTg4JUU1JUI5JUI2JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录：合并二叉树</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzL3NvbHV0aW9uL2hlLWJpbmctZXItY2hhLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：合并二叉树</span></p></li></ul><h1 id="leetcode-637-二叉树的层平均值"><a class="anchor" href="#leetcode-637-二叉树的层平均值">#</a> LeetCode 637. 二叉树的层平均值</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hdmVyYWdlLW9mLWxldmVscy1pbi1iaW5hcnktdHJlZS8=">LeetCode 637. Average of Levels in Binary Tree</span></p><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/avg1-tree.jpg" alt=""></p><pre><code>输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/avg2-tree.jpg" alt=""></p><pre><code>输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li>树中节点数量范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="思路-27"><a class="anchor" href="#思路-27">#</a> 思路</h2><p>层次遍历</p><p>对于每一层，只需将 该层所有节点的平均值 添加到目标数组</p><p>注意，均值为 <code>double</code> 型</p><h2 id="method-广度优先搜索-6"><a class="anchor" href="#method-广度优先搜索-6">#</a> Method: 广度优先搜索</h2><p>算法流程：与 <a href="https://jiankychen.github.io/c7ba20f5">LeetCode 102. 二叉树的层序遍历</a> 类似，区别在于，只需记录每一层节点值的平均值</p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;
    vector&lt;double&gt; res;
    queue&lt;TreeNode*&gt; que;
    if (root) que.push(root);
    while (!que.empty()) &#123;
        int size = que.size();
        double sum = 0;               // double 型
        for (int i = 0; i &lt; size; i++) &#123;
            TreeNode* node = que.front();
            que.pop();
            sum += node-&gt;val;
            if (node-&gt;left) que.push(node-&gt;left);
            if (node-&gt;right) que.push(node-&gt;right);
        &#125;
        res.push_back(sum / size);    // 仅记录每一层节点的平均值
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-654-最大二叉树"><a class="anchor" href="#leetcode-654-最大二叉树">#</a> LeetCode 654. 最大二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJpbmFyeS10cmVlLw==">654. Maximum Binary Tree</span></p><p>给定一个不重复的整数数组 <code>nums</code> 。<strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ul><li>创建一个根节点，其值为 nums 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li><li>返回 <code>nums</code> 构建的 <strong>最大二叉树</strong> 。</li></ul><p></p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/tree1.jpg" alt=""></p><pre><code>输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/tree2.jpg" alt=""></p><pre><code>输入：nums = [3,2,1]
输出：[3,null,2,null,1]
</code></pre><p></p><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums.length</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>nums[i]</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><code>nums</code> 中的所有整数 互不相同</li></ul><h2 id="method-递归-8"><a class="anchor" href="#method-递归-8">#</a> Method: 递归</h2><p>算法思路：定义递归函数 <code>constructTree(nums, left, right)</code> ，找出数组在区间 <code>[left, right)</code> 内的最大值，利用最大值左侧元素构造左子树、最大值右侧元素构造右子树</p><blockquote><p>注意：类似的用数组构造二叉树的题目，每次分割时尽量不要定义新数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">TreeNode *constructTree(vector&lt;int&gt;&amp; nums, int left, int right) &#123; // 区间为 [left, right)
    if (left == right) return nullptr; // 允许空节点进入递归，终止条件为：遇到空数组
    int maxValueIndex = left; // 最大值对应的索引
    for (int i = left; i &lt; right; i++) &#123;
        if (nums[i] &gt; nums[maxValueIndex])
            maxValueIndex = i;
    &#125;
    TreeNode *root = new TreeNode(nums[maxValueIndex]);          // 根节点
    root-&gt;left = constructTree(nums, left, maxValueIndex);       // 左子节点
    root-&gt;right = constructTree(nums, maxValueIndex + 1, right); // 右子节点
    return root;
&#125;

TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;
    return constructTree(nums, 0, nums.size());
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><ul><li><code>constructTree</code> 函数一共被调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 次，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>每次调用需要遍历当前的 <code>[left, right)</code> 区间<ul><li>平均情况下，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li><li>最坏情况下， <code>nums</code> 本身有序，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，考虑了递归使用的栈空间</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA2NTQuJUU2JTlDJTgwJUU1JUE0JUE3JUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录：最大二叉树</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJpbmFyeS10cmVlL3NvbHV0aW9uL3p1aS1kYS1lci1jaGEtc2h1LWJ5LWxlZXRjb2RlLw==">力扣官方题解：最大二叉树</span></li></ul><h1 id="leetcode-669-修剪二叉搜索树"><a class="anchor" href="#leetcode-669-修剪二叉搜索树">#</a> LeetCode 669. 修剪二叉搜索树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmltLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">669. Trim a Binary Search Tree</span></p><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界 <code>low</code> 和最大边界 <code>high</code> 。通过修剪二叉搜索树，使得所有节点的值在 <code>[low, high]</code> 中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/trim1.jpg" alt=""></p><pre><code>输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/trim2.jpg" alt=""></p><pre><code>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li><li>树中每个节点的值都是 唯一 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>low</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span></span></span></span> <code>high</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路-28"><a class="anchor" href="#思路-28">#</a> 思路</h2><p>若节点 <code>node</code> 的值小于 <code>low</code> ，则节点 <code>node</code> 应删除，并且</p><ul><li><code>node</code> 左子树上节点的值一定小于 <code>low</code> ，因此左子树也应删除</li><li><code>node</code> 右子树上节点的值可能落在 <code>[low, high]</code> 外，因此需要修剪右子树，用修剪过的右子树接替 <code>node</code> 的位置</li></ul><p>若节点 <code>node</code> 的值大于 <code>high</code> ，则节点 <code>node</code> 应删除，并且</p><ul><li><code>node</code> 右子树上节点的值一定大于 <code>high</code> ，因此右子树也应删除</li><li><code>node</code> 左子树上节点的值可能落在 <code>[low, high]</code> 外，因此需要修剪左子树，用修剪过的左子树接替 <code>node</code> 的位置</li></ul><p>若节点 <code>node</code> 的值落在 <code>[low, high]</code> 内，需进一步修剪 <code>node</code> 的左子树、右子树</p><h2 id="method-递归-9"><a class="anchor" href="#method-递归-9">#</a> Method: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">TreeNode* trimBST(TreeNode* root, int low, int high) &#123;
    if (!root) return nullptr;
    if (root-&gt;val &lt; low)  // root 及其左子树应移除
        return trimBST(root-&gt;right, low, high); // 修剪右子树，并用右子树接替 root 的位置
    if (root-&gt;val &gt; high) // root 及其右子树应移除
        return trimBST(root-&gt;left, low, high);  // 修剪左子树，并用左子树接替 root 的位置
    root-&gt;left = trimBST(root-&gt;left, low, high);   // 递归到左子树
    root-&gt;right = trimBST(root-&gt;right, low, high); // 递归到右子树
    return root;
&#125;
</code></pre><p>注意：以下代码</p><pre><code class="language-cpp">if (root-&gt;val &lt; low)  // root 及其左子树应移除
    return trimBST(root-&gt;right, low, high); // 修剪右子树，并用右子树接替 root 的位置
if (root-&gt;val &gt; high) // root 及其右子树应移除
    return trimBST(root-&gt;left, low, high);  // 修剪左子树，并用左子树接替 root 的位置
</code></pre><p>不能被替换成</p><pre><code class="language-cpp">if (root-&gt;val &lt; low)
    return root-&gt;right; // 这里直接返回了 root 右子树，并未对其修剪（此后的遍历也不会再修剪该子树）
if (root-&gt;val &gt; high)
    return root-&gt;left); // 这里直接返回了 root 左子树，并未对其修剪（此后的遍历也不会再修剪该子树）
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用的栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA2NjkuJUU0JUJGJUFFJUU1JTg5JUFBJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxLmh0bWw=">代码随想录</span></p><h1 id="leetcode-700-二叉搜索树中的搜索"><a class="anchor" href="#leetcode-700-二叉搜索树中的搜索">#</a> LeetCode 700. 二叉搜索树中的搜索</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tYS1iaW5hcnktc2VhcmNoLXRyZWUv">700. Search in a Binary Search Tree</span></p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code> 。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/tree1.jpg" alt=""></p><pre><code>输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/tree2.jpg" alt=""></p><pre><code>输入：root = [4,2,7,1,3], val = 5
输出：[]
</code></pre><p><strong>提示：</strong></p><ul><li>数中节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 5000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></li><li><code>root</code> 是二叉搜索树</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="思路-29"><a class="anchor" href="#思路-29">#</a> 思路</h2><p>二叉搜索树是一个有序树</p><ul><li>若它的左子树非空，则左子树上所有节点的值均小于根节点值</li><li>若它的右子树非空，则右子树上所有节点的值均大于根节点值</li><li>左、右子树也分别为二叉搜索树</li></ul><h2 id="method-1-递归-13"><a class="anchor" href="#method-1-递归-13">#</a> Method 1: 递归</h2><p>算法思路：</p><ol><li><p>确定递归参数和返回值</p><ul><li>参数：根节点 <code>root</code> 与 目标值 <code>val</code></li><li>返回值：目标值对应的节点</li></ul></li><li><p>递归终止条件： <code>root</code> 为空，未找到 <code>val</code> ，返回 <code>NULL</code> ，递归结束</p></li><li><p>单层递归的逻辑</p><ul><li>若 <code>root-&gt;val == val</code> ，找到 <code>val</code> ，返回 <code>root</code></li><li>若 <code>root-&gt;val &gt; val</code> ，搜索左子树</li><li>若 <code>root-&gt;val &lt; val</code> ，搜索右子树</li><li>如果没有搜索到，返回 <code>NULL</code></li></ul></li></ol><p>代码实现：</p><pre><code class="language-cpp">TreeNode* searchBST(TreeNode* root, int val) &#123;
    if (!root) return nullptr;          // root 为空，未找到 val
    if (root-&gt;val == val) return root;  // root 节点值等于 val ，找到 val
    if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val); // 递归到左子树中搜索
    return searchBST(root-&gt;right, val); // 递归到右子树中搜索
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="method-2-迭代-8"><a class="anchor" href="#method-2-迭代-8">#</a> Method 2: 迭代</h2><p>由于二叉搜索树的特殊性（节点的有序性），无需辅助栈或者队列就可实现迭代法</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode* searchBST(TreeNode* root, int val) &#123;
    while (root != nullptr) &#123;
        if (root-&gt;val &lt; val) root = root-&gt;right;
        else if (root-&gt;val &gt; val) root = root-&gt;left;
        else return root;
    &#125;
    return nullptr;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDAuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTkwJTlDJUU3JUI0JUEyLmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEzJUU2JUIzJTk1">代码随想录：二叉搜索树中的搜索 - 迭代法</span></p><h1 id="leetcode-701-二叉搜索树中的插入操作"><a class="anchor" href="#leetcode-701-二叉搜索树中的插入操作">#</a> LeetCode 701. 二叉搜索树中的插入操作</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtaW50by1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">701. Insert into a Binary Search Tree</span></p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/example.jpg" alt="" height="200px"></p><pre><code>输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
</code></pre><p><img data-src="LeetCode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/result.jpg" alt="" height="200px"></p><p><strong>示例 2：</strong></p><pre><code>输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^8 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></li><li>所有值 <code>Node.val</code> 互不相同</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-10^8 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">\le 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></li><li>保证 <code>val</code> 在原始 BST 中不存在</li></ul><h2 id="思路-30"><a class="anchor" href="#思路-30">#</a> 思路</h2><p>根据 <code>root</code> 节点值与 <code>val</code> 的大小关系，确定将 <code>val</code> 插入到 <code>root</code> 的哪一棵子树</p><ul><li>如果该子树不为空，则问题转化为 将 <code>val</code> 插入到 <code>root</code> 子树的子树上</li><li>如果子树为空，则新建一个值为 <code>val</code> 的节点，将其链接到父节点 <code>root</code> 上</li></ul><h2 id="method-1-递归-14"><a class="anchor" href="#method-1-递归-14">#</a> Method 1: 递归</h2><h3 id="写法一有返回值"><a class="anchor" href="#写法一有返回值">#</a> 写法一：有返回值</h3><p>代码实现：</p><pre><code class="language-cpp">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
    if (root == nullptr) &#123; // 空节点，亦即 val 的插入点
        root = new TreeNode(val);
        return root;
    &#125;
    if (root-&gt;val &gt; val) // val 小于 root ，应将其插入到左子树
        root-&gt;left = insertIntoBST(root-&gt;left, val);
    if (root-&gt;val &lt; val) // val 大于 root ，应将其插入到右子树
        root-&gt;right = insertIntoBST(root-&gt;right, val);
    return root;
&#125;
</code></pre><p>注意， <code>root-&gt;left = insertIntoBST(root-&gt;left, val);</code> 和 <code>root-&gt;right = insertIntoBST(root-&gt;right, val);</code> 这两个命令是为了将插入的节点与其父节点建立连接</p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p><h3 id="写法二无返回值"><a class="anchor" href="#写法二无返回值">#</a> 写法二：无返回值</h3><p>算法思路：在不设定递归函数返回值的情况下，需要记录父节点，当找到插入节点的位置时，直接让其父节点指向插入节点。其中，新节点是作为左子节点还是右子节点，取决于父节点的值与 <code>val</code> 的大小关系</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode *parent = nullptr;
void helper(TreeNode *root, int val) &#123;
    if (root == nullptr) &#123;
        TreeNode *node = new TreeNode(val);
        if (parent-&gt;val &gt; val) parent-&gt;left = node;
        else parent-&gt;right = node;
        return;
    &#125;
    parent = root;
    if (root-&gt;val &gt; val) helper(root-&gt;left, val);
    if (root-&gt;val &lt; val) helper(root-&gt;right, val);
&#125;

TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
    if (root == nullptr) return new TreeNode(val);
    helper(root, val);
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，递归使用栈空间</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDEuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU2JThGJTkyJUU1JTg1JUE1JUU2JTkzJThEJUU0JUJEJTlDLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTky">代码随想录</span></p><h2 id="method-2-迭代-9"><a class="anchor" href="#method-2-迭代-9">#</a> Method 2: 迭代</h2><p>算法思路：利用迭代法实现插入节点</p><h3 id="写法一-4"><a class="anchor" href="#写法一-4">#</a> 写法一</h3><p>代码实现：</p><pre><code class="language-cpp">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
    if (!root) return new TreeNode(val);
    TreeNode *node = root;
    while (node != nullptr) &#123;
        if (node-&gt;val &gt; val) &#123; // 应插入到 node 的左子树
            if (node-&gt;left != nullptr) &#123;
                node = node-&gt;left;
            &#125; else &#123;
                node-&gt;left = new TreeNode(val);
                break;
            &#125;
        &#125; else &#123; // 应插入到 node 的右子树
            if (node-&gt;right != nullptr) &#123;
                node = node-&gt;right;
            &#125; else &#123;
                node-&gt;right = new TreeNode(val);
                break;
            &#125;
        &#125;
    &#125;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtaW50by1hLWJpbmFyeS1zZWFyY2gtdHJlZS9zb2x1dGlvbi9lci1jaGEtc291LXN1by1zaHUtemhvbmctZGUtY2hhLXJ1LWNhby16dW8tYnktbGUtMy8=">力扣官方题解</span></p><h3 id="写法二-4"><a class="anchor" href="#写法二-4">#</a> 写法二</h3><p>代码实现：</p><pre><code class="language-cpp">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
    if (root == NULL) &#123;
        TreeNode* node = new TreeNode(val);
        return node;
    &#125;
    TreeNode* cur = root;
    TreeNode* parent = root; // 记录上一个节点，以便链接新节点
    while (cur != NULL) &#123;
        parent = cur;
        if (cur-&gt;val &gt; val) cur = cur-&gt;left;
        else cur = cur-&gt;right;
    &#125;
    TreeNode* node = new TreeNode(val);
    if (val &lt; parent-&gt;val) parent-&gt;left = node;
    else parent-&gt;right = node;
    return root;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDEuJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxJUU0JUI4JUFEJUU3JTlBJTg0JUU2JThGJTkyJUU1JTg1JUE1JUU2JTkzJThEJUU0JUJEJTlDLmh0bWwjJUU4JUJGJUFEJUU0JUJCJUEz">代码随想录</span></p><h1 id="leetcode-94-二叉树的中序遍历"><a class="anchor" href="#leetcode-94-二叉树的中序遍历">#</a> LeetCode 94. 二叉树的中序遍历</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv">LeetCode 94. Binary Tree Inorder Traversal</span></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 它的 <strong>中序</strong> 遍历 。</p><p><strong>示例 1：</strong><br><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/1.jpg" alt="" height="200px"></p><pre><code>输入：root = [1,null,2,3]
输出：[1,3,2]
</code></pre><p><strong>示例 2：</strong><br><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/2.jpg" alt="" height="200px"></p><pre><code>输入：root = [1,2]
输出：[2,1]
</code></pre><p><strong>示例 3：</strong><br><img data-src="LeetCode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/3.jpg" alt="" height="200px"></p><pre><code>输入：root = [1,null,2]
输出：[1,2]
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ul><p><strong>进阶</strong>：递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路-31"><a class="anchor" href="#思路-31">#</a> 思路</h2><p>按照访问左子树 —— 根节点 —— 右子树的方式遍历这棵树，左子树或者右子树按照同样的方式遍历</p><h2 id="method-1-递归-15"><a class="anchor" href="#method-1-递归-15">#</a> Method 1: 递归</h2><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; res;
    inorder(root,res);         // 中序遍历
    return res;
&#125;

void inorder(TreeNode* root, vector&lt;int&gt; &amp;res) &#123;
    if (root == nullptr) return;
    inorder(root-&gt;left, res);   // 左子树
    res.push_back(root-&gt;val);   // 当前节点
    inorder(root-&gt;right, res);  // 右子树
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 为二叉树的节点个数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，栈的开销，这里忽略了目标数组所需空间</p><h2 id="method-2-迭代-10"><a class="anchor" href="#method-2-迭代-10">#</a> Method 2: 迭代</h2><p>按照中序遍历规则，遍历到某个节点时，并不直接获取它的值，而是先遍历它的左子树，然后才将它本身的值加入到目标数组中，然后再遍历右子树（注意，左、右子树的遍历规则也是如此）</p><p>换而言之，中序遍历首先要一层一层向下访问，直到到达左子树的最底部，才开始获取节点的值</p><p>算法流程：</p><ol><li><p>定义一个空的栈 <code>stk</code> ，定义一个指针 <code>cur</code> 指向当前遍历的节点</p></li><li><p>执行循环（直到 <code>stk</code> 为空 且 <code>cur</code> 为空指针）：</p><ul><li>执行以下循环，直到 <code>cur</code> 为空指针（此时，栈顶 是 指向最底层节点的指针）<ul><li>将 <code>cur</code> 压入栈</li><li>令 <code>cur</code> 指向 左子节点，即， <code>cur = cur-&gt;left;</code></li></ul></li><li>更新 <code>cur = stk.top()</code> ，使得 <code>cur</code> 指向最底层节点</li><li>将节点的值添加到目标数组，并将栈顶元素弹出</li><li>更新 <code>cur = cur-&gt;right</code> ，即，令 <code>cur</code> 指向其右子节点，以继续遍历</li></ul></li><li><p>循环结束时，所有节点均已被访问，返回目标数组</p></li></ol><p>有点抽象，建议根据实例模拟一遍，例如：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="" height="400px"></p><p>代码实现：</p><pre><code class="language-cpp">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; res;
    stack&lt;TreeNode*&gt; stk;
    TreeNode* cur = root;
    while (!stk.empty() || cur != nullptr) &#123;
        while (cur != nullptr) &#123; // 遍历至 cur 左子树的最底部
            stk.push(cur);
            cur = cur-&gt;left;
        &#125;
        cur = stk.top();         // 最左侧的节点（它不存在左子节点）
        res.push_back(cur-&gt;val); // 将节点的值加入到目标数组
        stk.pop();               // 出栈
        cur = cur-&gt;right;        // 遍历右子树
    &#125;
    return res;
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwvc29sdXRpb24vZXItY2hhLXNodS1kZS16aG9uZy14dS1iaWFuLWxpLWJ5LWxlZXRjb2RlLXNvbHV0aW8v">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLyVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSVFNyU5QSU4NCVFOCVCRiVBRCVFNCVCQiVBMyVFOSU4MSU4RCVFNSU4RSU4Ni5odG1s">代码随想录</span></li></ul><h1 id="leetcode-96-不同的二叉搜索树"><a class="anchor" href="#leetcode-96-不同的二叉搜索树">#</a> LeetCode 96. 不同的二叉搜索树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy8=">96. Unique Binary Search Trees</span></p><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img data-src="LeetCode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/example.jpg" alt=""></p><pre><code>输入：n = 3
输出：5
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1
输出：1
</code></pre><p><strong>提示：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">1 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> n <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>19</mn></mrow><annotation encoding="application/x-tex">\le 19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">9</span></span></span></span></li></ul><h2 id="思路-32"><a class="anchor" href="#思路-32">#</a> 思路</h2><p>定义以下两个函数：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ：长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的序列所能构成的二叉搜索树的个数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(i, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ：长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的序列所能构成的以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 为根节点的二叉搜索树的个数</li></ul><p>对于长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的序列而言，可以遍历每个数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69862em;vertical-align:-.0391em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> ：将数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 作为根节点，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext></mtext><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1, \cdots, (i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 序列作为左子树，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>⋯</mo><mtext></mtext><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">(i+1), \cdots, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span></span></span></span> 序列作为右子树。因此，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n) = \sum_{i = 1}^n F(i, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em"><span style="top:-1.872331em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p>注意，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 只依赖于序列的长度，而与序列中的内容无关。因此，将数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 作为根节点时，有：</p><ul><li>利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext></mtext><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1, \cdots, (i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 序列构造左子树，序列长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.74285em;vertical-align:-.08333em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> ，能构造出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(i - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 棵不同的左子树（二叉搜索树）</li><li>利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>⋯</mo><mtext></mtext><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">(i+1), \cdots, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span></span></span></span> 序列构造右子树，序列长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> ，能构造出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 棵不同的右子树（二叉搜索树）</li></ul><p>左子树与右子树的构造是相互独立的，因此，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 为根节点的二叉搜索树个数，应为 可构造的左子树个数 与 可构造的右子树个数 之积，即，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>G</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(i, n) = G(i - 1) \times G(n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span></p><p>因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的递推公式为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>G</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>G</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(n) = \sum_{i = 1}^n G(i - 1) \times G(n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em"><span style="top:-1.872331em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span></p><p>当序列长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 时，只能构造出一棵树，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G(0) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></span></p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy9zb2x1dGlvbi9idS10b25nLWRlLWVyLWNoYS1zb3Utc3VvLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwOTYuJUU0JUI4JThEJUU1JTkwJThDJUU3JTlBJTg0JUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码随想录</span></li></ul><h2 id="method-动态规划"><a class="anchor" href="#method-动态规划">#</a> Method: 动态规划</h2><p>代码实现：</p><pre><code class="language-cpp">int numTrees(int n) &#123;
    vector&lt;int&gt; dp(n + 1, 0);
    dp[0] = 1;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= i; j++) &#123;
            dp[i] += dp[j - 1] * dp[i - j];
        &#125;
    &#125;
    return dp[n];
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h1 id="leetcode-98-验证二叉搜索树"><a class="anchor" href="#leetcode-98-验证二叉搜索树">#</a> LeetCode 98. 验证二叉搜索树</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">98. Validate Binary Search Tree</span></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="LeetCode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/tree1.jpg" alt=""></p><pre><code>输入：root = [2,1,3]
输出：true
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="LeetCode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/tree2.jpg" alt=""></p><pre><code>输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>≤</mo></mrow><annotation encoding="application/x-tex">-2^{31} \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.950078em;vertical-align:-.13597em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span> <code>Node.val</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="method-1-中序遍历"><a class="anchor" href="#method-1-中序遍历">#</a> Method 1: 中序遍历</h2><p>二叉搜索树的中序遍历序列是一个有序序列（升序序列）</p><p>因此，可通过判断中序遍历序列是否有序来判断该二叉树是否为二叉搜索树</p><h3 id="写法一-5"><a class="anchor" href="#写法一-5">#</a> 写法一</h3><p>把二叉树转变为数组，判断数组元素按升序排列</p><p>代码实现：</p><pre><code class="language-cpp">void midorder(TreeNode *root, vector&lt;int&gt; &amp;nums) &#123; // 中序遍历
    if (!root) return;
    midorder(root-&gt;left, nums);
    nums.push_back(root-&gt;val);
    midorder(root-&gt;right, nums);
&#125;

bool isValidBST(TreeNode* root) &#123;
    vector&lt;int&gt; nums;
    midorder(root, nums);
    for (int i = 1; i &lt; nums.size(); i++) &#123; // 检查中序遍历数组是否按升序排列
        if (nums[i] &lt;= nums[i - 1]) return false;
    &#125;
    return true;
&#125;
</code></pre><h3 id="写法二-5"><a class="anchor" href="#写法二-5">#</a> 写法二</h3><p>可以直接在中序遍历的过程中判断前一个节点的值是否小于后一个节点的值，以判断中序遍历序列是否有序</p><p>代码实现：</p><pre><code class="language-cpp">TreeNode *pre = nullptr; // 前一个节点
bool isValidBST(TreeNode* root) &#123;
    if (!root) return true;
    if (!isValidBST(root-&gt;left)) return false;      // 验证左子树是否为二叉搜索树
    if (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false; // 检查中序遍历序列是否有序
    pre = root;          // 更新 pre
    return isValidBST(root-&gt;right); // 验证右子树是否为二叉搜索树
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>中序遍历也可以由迭代法实现</p></blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzAwOTguJUU5JUFBJThDJUU4JUFGJTgxJUU0JUJBJThDJUU1JThGJTg5JUU2JTkwJTlDJUU3JUI0JUEyJUU2JUEwJTkxLmh0bWwjJUU5JTgwJTkyJUU1JUJEJTkyJUU2JUIzJTk1">代码随想录：验证二叉搜索树</span></p><h2 id="method-2-前序遍历-3"><a class="anchor" href="#method-2-前序遍历-3">#</a> Method 2: 前序遍历</h2><p>二叉搜索树的性质：</p><ul><li>若二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值</li><li>若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值</li><li>它的左、右子树也为二叉搜索树</li></ul><p>由此，可以设计一个递归函数 <code>traversal(root, lowerBound, upperBound)</code> 来递归判断：</p><ul><li>如果 <code>root</code> 节点的值不在 <code>(lowerBound, upperBound)</code> 范围内，说明不满足条件，直接返回</li><li>否则，继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树</li></ul><p>算法思路：</p><ol><li><p>确定递归的参数和返回值：</p><ul><li>参数：根节点 <code>TreeNode *root</code> 、节点取值的下界 <code>long long lowerBound</code> 、节点取值的上界 <code>long long upperBound</code></li><li>返回值：所有节点取值是否都落在 <code>(lowerBound, upperBound)</code> 范围内</li></ul></li><li><p>递归终止条件：空节点，返回 <code>true</code> ，当前递归结束</p></li><li><p>单层递归的逻辑</p><ul><li>若 <code>root</code> 的值落在 <code>(lowerBound, upperBound)</code> 范围外，条件不满足，返回 <code>false</code></li><li>递归到左子树，其中，节点取值的下界、上界分别为 <code>lowerBound</code> 、 <code>root-&gt;val</code></li><li>递归到右子树，其中，节点取值的下界、上界分别为 <code>root-&gt;val</code> 、 <code>upperBound</code></li><li>若左、右子树均满足条件，返回 <code>true</code></li></ul></li></ol><blockquote><p>注意到 <code>Node.val</code> 可能取到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 这两个值，需要将 <code>lowerBound</code> 和 <code>upperBound</code> 分别设定为 <code>long long</code> 型，并分别初始化为 <code>LONG_MIN</code> 和 <code>LONG_MAX</code> ，即， <code>long long</code> 型的 <code>-inf</code> 和 <code>+inf</code> （因为递归函数的检验范围 <code>(lowerBound, upperBound)</code> 是开区间，若取 <code>int</code> 型的 <code>INT_MIN</code> 和 <code>INT_MAX</code> ，则无法正确处理 <code>Node.val</code> 取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 这两个值的情况）</p></blockquote><p>代码实现：</p><pre><code class="language-cpp">bool traversal(TreeNode* root, long long lowerBound, long long upperBound) &#123;
    if (!root) return true;
    if (root-&gt;val &lt;= lowerBound || root-&gt;val &gt;= upperBound)
        return false;
    bool left = traversal(root-&gt;left, lowerBound, root-&gt;val);
    bool right = traversal(root-&gt;right, root-&gt;val, upperBound);
    return left &amp;&amp; right;
&#125;

bool isValidBST(TreeNode* root) &#123;
    return traversal(root, LONG_MIN, LONG_MAX);
&#125;
</code></pre><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 是二叉树的节点数</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUvc29sdXRpb24veWFuLXpoZW5nLWVyLWNoYS1zb3Utc3VvLXNodS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">力扣官方题解：验证二叉搜索树</span></p><div class="tags"><a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag"><i class="ic i-tag"></i> 二叉树</a></div></div><footer><div class="meta"><span class="item"><time title="修改时间：2024-03-23 01:16:15" itemprop="dateModified" datetime="2024-03-23T01:16:15+08:00"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> 2024-03-23 </time></span><span id="posts/ed3025a8/" class="item leancloud_visitors" data-flag-title="LeetCode - 二叉树专题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jiankychen <i class="ic i-at"><em>@</em></i>Jiankychen's Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://jiankychen.github.io/posts/ed3025a8/" title="LeetCode - 二叉树专题">https://jiankychen.github.io/posts/ed3025a8/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/51f34f0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;8fe50780c15461b629c9aeab5a7f2acd.jpg" title="LeetCode - 栈与队列专题"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Coding</span><h3>LeetCode - 栈与队列专题</h3></a></div><div class="item right"><a href="/posts/b754d2ea/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;42bab566f107b9a16542343e0368fb77.jpg" title="回溯"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Data Structure</span><h3>回溯</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-100-%E7%9B%B8%E5%90%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 100. 相同二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92"><span class="toc-number">1.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.3.</span> <span class="toc-text">Method 2: 迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">写法二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">LeetCode 101. 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-2"><span class="toc-number">2.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-2"><span class="toc-number">2.3.</span> <span class="toc-text">Method 2: 迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">LeetCode 102. 二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.2.</span> <span class="toc-text">Method: 广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">LeetCode 104. 二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-3"><span class="toc-number">4.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.3.</span> <span class="toc-text">Method 2: 层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-559-n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">LeetCode 559. N 叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-4"><span class="toc-number">5.1.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">5.2.</span> <span class="toc-text">Method 2: 层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">LeetCode 105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92"><span class="toc-number">6.2.</span> <span class="toc-text">Method: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">LeetCode 106. 从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-2"><span class="toc-number">7.2.</span> <span class="toc-text">Method: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-2"><span class="toc-number">7.3.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-ii"><span class="toc-number">8.</span> <span class="toc-text">LeetCode 107. 二叉树的层序遍历 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-2"><span class="toc-number">8.2.</span> <span class="toc-text">Method: 广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">LeetCode 108. 将有序数组转换为二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-3"><span class="toc-number">9.2.</span> <span class="toc-text">Method: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">LeetCode 110. 平衡二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90"><span class="toc-number">11.</span> <span class="toc-text">概念辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E9%AB%98%E5%BA%A6"><span class="toc-number">11.1.</span> <span class="toc-text">节点的深度与高度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E9%AB%98%E5%BA%A6"><span class="toc-number">11.2.</span> <span class="toc-text">树的深度与高度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">11.3.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B"><span class="toc-number">11.4.</span> <span class="toc-text">Method 1: 自顶向下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="toc-number">11.5.</span> <span class="toc-text">Method 2: 自底向上</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">12.</span> <span class="toc-text">LeetCode 111. 二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">12.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-5"><span class="toc-number">12.2.</span> <span class="toc-text">Method 1: 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80-2"><span class="toc-number">12.2.1.</span> <span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C-2"><span class="toc-number">12.2.2.</span> <span class="toc-text">写法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-3"><span class="toc-number">12.3.</span> <span class="toc-text">Method 2: 层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">13.</span> <span class="toc-text">LeetCode 112. 路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-6"><span class="toc-number">13.1.</span> <span class="toc-text">Method 1: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii"><span class="toc-number">14.</span> <span class="toc-text">LeetCode 113. 路径总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-7"><span class="toc-number">14.1.</span> <span class="toc-text">Method 1: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">15.</span> <span class="toc-text">LeetCode 114. 二叉树展开为链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="toc-number">15.1.</span> <span class="toc-text">Method 1: 暴力法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E9%80%92%E5%BD%92"><span class="toc-number">15.2.</span> <span class="toc-text">Method 2: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">16.</span> <span class="toc-text">LeetCode 116. 填充每个节点的下一个右侧节点指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">16.1.</span> <span class="toc-text">Method 1: 层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E4%BD%BF%E7%94%A8%E5%B7%B2%E5%BB%BA%E7%AB%8B%E7%9A%84-next-%E6%8C%87%E9%92%88"><span class="toc-number">16.2.</span> <span class="toc-text">Method 2: 使用已建立的 next 指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-ii"><span class="toc-number">17.</span> <span class="toc-text">LeetCode 117. 填充每个节点的下一个右侧节点指针 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-number">17.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">17.2.</span> <span class="toc-text">Method 1: 层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E4%BD%BF%E7%94%A8%E5%B7%B2%E5%BB%BA%E7%AB%8B%E7%9A%84-next-%E6%8C%87%E9%92%88-2"><span class="toc-number">17.3.</span> <span class="toc-text">Method 2: 使用已建立的 next 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-3-%E9%93%BE%E8%A1%A8"><span class="toc-number">17.4.</span> <span class="toc-text">Method 3: 链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">18.</span> <span class="toc-text">LeetCode 124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">19.</span> <span class="toc-text">二叉树的最大路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-4"><span class="toc-number">19.1.</span> <span class="toc-text">Method: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">20.</span> <span class="toc-text">三叉树中的最大路径和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">21.</span> <span class="toc-text">LeetCode 144. 二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-number">21.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-8"><span class="toc-number">21.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-3"><span class="toc-number">21.3.</span> <span class="toc-text">Method 2: 迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">22.</span> <span class="toc-text">LeetCode 145. 二叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-number">22.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-9"><span class="toc-number">22.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-4"><span class="toc-number">22.3.</span> <span class="toc-text">Method 2: 迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">22.3.1.</span> <span class="toc-text">方案一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-number">22.3.2.</span> <span class="toc-text">方案二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">23.</span> <span class="toc-text">LeetCode 199. 二叉树的右视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-number">23.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-3"><span class="toc-number">23.2.</span> <span class="toc-text">Method: 广度优先搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">23.3.</span> <span class="toc-text">Method: 深度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">LeetCode 222. 完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%81%8D%E5%8E%86"><span class="toc-number">24.1.</span> <span class="toc-text">Method 1: 遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%AF%BB%E6%89%BE%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">24.2.</span> <span class="toc-text">Method 2: 寻找满二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">24.3.</span> <span class="toc-text">Method 3: 二分查找 + 位运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">25.</span> <span class="toc-text">LeetCode 226. 翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-number">25.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92"><span class="toc-number">25.2.</span> <span class="toc-text">Method 1: 前序遍历（递归）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3"><span class="toc-number">25.3.</span> <span class="toc-text">Method 2: 前序遍历（迭代）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80-3"><span class="toc-number">25.4.</span> <span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C-3"><span class="toc-number">25.5.</span> <span class="toc-text">写法二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-3-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">25.6.</span> <span class="toc-text">Method 3: 层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">26.</span> <span class="toc-text">LeetCode 235. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-number">26.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E7%A1%AE%E5%AE%9A%E8%B7%AF%E5%BE%84"><span class="toc-number">26.2.</span> <span class="toc-text">Method 1: 确定路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-5"><span class="toc-number">26.3.</span> <span class="toc-text">Method 2: 迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-3-%E9%80%92%E5%BD%92"><span class="toc-number">26.4.</span> <span class="toc-text">Method 3: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">27.</span> <span class="toc-text">LeetCode 236. 二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-number">27.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1"><span class="toc-number">27.2.</span> <span class="toc-text">Method 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2"><span class="toc-number">27.3.</span> <span class="toc-text">Method 2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">28.</span> <span class="toc-text">LeetCode 257. 二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">28.1.</span> <span class="toc-text">Method 1: 前序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">29.</span> <span class="toc-text">LeetCode 297. 二叉树的序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">29.1.</span> <span class="toc-text">Method: 前序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">30.</span> <span class="toc-text">LeetCode 404. 左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-number">30.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">30.2.</span> <span class="toc-text">Method 1: 后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">30.3.</span> <span class="toc-text">Method 2: 前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-3-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">30.4.</span> <span class="toc-text">Method 3: 层序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-429-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">31.</span> <span class="toc-text">LeetCode 429. N 叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-number">31.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-4"><span class="toc-number">31.2.</span> <span class="toc-text">Method: 广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii"><span class="toc-number">32.</span> <span class="toc-text">LeetCode 437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">32.1.</span> <span class="toc-text">Method 1: 深度优先搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">32.2.</span> <span class="toc-text">Method 2: 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">33.</span> <span class="toc-text">LeetCode 450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-number">33.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-10"><span class="toc-number">33.2.</span> <span class="toc-text">Method 1: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">34.</span> <span class="toc-text">LeetCode 501. 二叉搜索树中的众数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-number">34.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%A2%9D%E5%A4%96%E6%95%B0%E7%BB%84"><span class="toc-number">34.2.</span> <span class="toc-text">Method 1: 中序遍历（额外数组）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%97%A0%E9%A2%9D%E5%A4%96%E6%95%B0%E7%BB%84"><span class="toc-number">34.3.</span> <span class="toc-text">Method 2: 中序遍历（无额外数组）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">35.</span> <span class="toc-text">LeetCode 513. 找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-number">35.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-3"><span class="toc-number">35.2.</span> <span class="toc-text">Method 1: 层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">35.3.</span> <span class="toc-text">Method 2: 前序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">36.</span> <span class="toc-text">LeetCode 515. 在每个树行中找最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-number">36.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-5"><span class="toc-number">36.2.</span> <span class="toc-text">Method: 广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number">37.</span> <span class="toc-text">LeetCode 530. 二叉搜索树的最小绝对差</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-number">37.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">37.2.</span> <span class="toc-text">Method: 中序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number">38.</span> <span class="toc-text">LeetCode 538. 把二叉搜索树转换为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-5"><span class="toc-number">38.1.</span> <span class="toc-text">Method: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">38.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">38.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">38.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">39.</span> <span class="toc-text">LeetCode 543. 二叉树的直径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-6"><span class="toc-number">39.1.</span> <span class="toc-text">Method: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-2"><span class="toc-number">39.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">39.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">39.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">40.</span> <span class="toc-text">LeetCode 572. 另一棵树的子树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D"><span class="toc-number">40.1.</span> <span class="toc-text">Method 1: 深度优先遍历 + 暴力匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-kmp-%E5%8C%B9%E9%85%8D"><span class="toc-number">40.2.</span> <span class="toc-text">Method 2: 深度优先遍历 + KMP 匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-589-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">41.</span> <span class="toc-text">LeetCode 589. N 叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-number">41.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-11"><span class="toc-number">41.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-6"><span class="toc-number">41.3.</span> <span class="toc-text">Method 2: 迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-590-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">42.</span> <span class="toc-text">LeetCode 590. N 叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-number">42.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-12"><span class="toc-number">42.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-7"><span class="toc-number">42.3.</span> <span class="toc-text">Method 2: 迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">43.</span> <span class="toc-text">LeetCode 617. 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-7"><span class="toc-number">43.1.</span> <span class="toc-text">Method: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">44.</span> <span class="toc-text">LeetCode 637. 二叉树的层平均值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-number">44.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-6"><span class="toc-number">44.2.</span> <span class="toc-text">Method: 广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">45.</span> <span class="toc-text">LeetCode 654. 最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-8"><span class="toc-number">45.1.</span> <span class="toc-text">Method: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">46.</span> <span class="toc-text">LeetCode 669. 修剪二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-number">46.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E9%80%92%E5%BD%92-9"><span class="toc-number">46.2.</span> <span class="toc-text">Method: 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">47.</span> <span class="toc-text">LeetCode 700. 二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-number">47.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-13"><span class="toc-number">47.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-8"><span class="toc-number">47.3.</span> <span class="toc-text">Method 2: 迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">48.</span> <span class="toc-text">LeetCode 701. 二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-number">48.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-14"><span class="toc-number">48.2.</span> <span class="toc-text">Method 1: 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">48.2.1.</span> <span class="toc-text">写法一：有返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">48.2.2.</span> <span class="toc-text">写法二：无返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-9"><span class="toc-number">48.3.</span> <span class="toc-text">Method 2: 迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80-4"><span class="toc-number">48.3.1.</span> <span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C-4"><span class="toc-number">48.3.2.</span> <span class="toc-text">写法二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">49.</span> <span class="toc-text">LeetCode 94. 二叉树的中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-number">49.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E9%80%92%E5%BD%92-15"><span class="toc-number">49.2.</span> <span class="toc-text">Method 1: 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E8%BF%AD%E4%BB%A3-10"><span class="toc-number">49.3.</span> <span class="toc-text">Method 2: 迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">50.</span> <span class="toc-text">LeetCode 96. 不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-number">50.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">50.2.</span> <span class="toc-text">Method: 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">51.</span> <span class="toc-text">LeetCode 98. 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-1-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">51.1.</span> <span class="toc-text">Method 1: 中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%80-5"><span class="toc-number">51.1.1.</span> <span class="toc-text">写法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C-5"><span class="toc-number">51.1.2.</span> <span class="toc-text">写法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#method-2-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-3"><span class="toc-number">51.2.</span> <span class="toc-text">Method 2: 前序遍历</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/posts/1b7ed9b4/" rel="bookmark" title="LeetCode Records">LeetCode Records</a></li><li><a href="/posts/32d5c1f6/" rel="bookmark" title="LeetCode - 二分查找专题">LeetCode - 二分查找专题</a></li><li><a href="/posts/2057f45/" rel="bookmark" title="LeetCode - 数组专题">LeetCode - 数组专题</a></li><li><a href="/posts/bc32ab1e/" rel="bookmark" title="LeetCode - 链表专题">LeetCode - 链表专题</a></li><li><a href="/posts/29abbd18/" rel="bookmark" title="LeetCode - 哈希表专题">LeetCode - 哈希表专题</a></li><li><a href="/posts/36947f98/" rel="bookmark" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></li><li><a href="/posts/51f34f0/" rel="bookmark" title="LeetCode - 栈与队列专题">LeetCode - 栈与队列专题</a></li><li class="active"><a href="/posts/ed3025a8/" rel="bookmark" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></li><li><a href="/posts/6012cc6b/" rel="bookmark" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></li><li><a href="/posts/f3b1f59f/" rel="bookmark" title="LeetCode - 贪心专题">LeetCode - 贪心专题</a></li><li><a href="/posts/5e11e767/" rel="bookmark" title="LeetCode - 动态规划专题">LeetCode - 动态规划专题</a></li><li><a href="/posts/611c1217/" rel="bookmark" title="LeetCode - 双指针专题">LeetCode - 双指针专题</a></li><li><a href="/posts/691b4be6/" rel="bookmark" title="LeetCode - 单调栈专题">LeetCode - 单调栈专题</a></li><li><a href="/posts/537e2e53/" rel="bookmark" title="LeetCode - 搜索专题">LeetCode - 搜索专题</a></li><li><a href="/posts/242193c5/" rel="bookmark" title="LeetCode - 排序专题">LeetCode - 排序专题</a></li><li><a href="/posts/f994a74a/" rel="bookmark" title="常见输入输出">常见输入输出</a></li><li><a href="/posts/def81c82/" rel="bookmark" title="LeetCode - 模拟专题">LeetCode - 模拟专题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jiankychen" data-src="https://www.helloimg.com/image/oTb9AX"><p class="name" itemprop="name">Jiankychen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">52</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppYW5reWNoZW4=" title="https:&#x2F;&#x2F;github.com&#x2F;jiankychen"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjExMDI0NTkxMzJAcXEuY29t" title="mailto:1102459132@qq.com"><i class="ic i-envelope"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ0Nzc3MTI3NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;447771275"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaWFua3ljaGVu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jiankychen"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>链接</a><ul class="submenu"><li class="item"><a href="/peers/" rel="section"><i class="ic i-magic"></i>友链</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>链环</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-stars"></i>关于</a><ul class="submenu"><li class="item"><a href="/owner/" rel="section"><i class="ic i-user"></i>博主</a></li><li class="item"><a href="/site/" rel="section"><i class="ic i-paw"></i>本站</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clock"></i>统计</a><ul class="submenu"><li class="item"><a href="/census/" rel="section"><i class="ic i-person"></i>访问量</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-pen"></i>文章量</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/51f34f0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/b754d2ea/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/2d2eedc7/" title="C++ 表达式">C++ 表达式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/posts/ebba65fe/" title="pandas 基础">pandas 基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/29abbd18/" title="LeetCode - 哈希表专题">LeetCode - 哈希表专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Data-Structure/" title="分类于 Data Structure">Data Structure</a></div><span><a href="/posts/36b55f59/" title="KMP 算法">KMP 算法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/ed3025a8/" title="LeetCode - 二叉树专题">LeetCode - 二叉树专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/6012cc6b/" title="LeetCode - 回溯专题">LeetCode - 回溯专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tutorial/" title="分类于 Tutorial">Tutorial</a> <i class="ic i-angle-right"></i> <a href="/categories/Tutorial/Hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/posts/c61b9a60/" title="shoka 主题的若干改动">shoka 主题的若干改动</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Coding/" title="分类于 Coding">Coding</a></div><span><a href="/posts/36947f98/" title="LeetCode - 字符串专题">LeetCode - 字符串专题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tutorial/" title="分类于 Tutorial">Tutorial</a> <i class="ic i-angle-right"></i> <a href="/categories/Tutorial/LaTeX/" title="分类于 LaTeX">LaTeX</a></div><span><a href="/posts/99cbc47e/" title="LaTeX：跨 tex 文件的交叉引用">LaTeX：跨 tex 文件的交叉引用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/posts/3d6d9e02/" title="C++ 函数">C++ 函数</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jiankychen @ Jiankychen's Blog</span></div><div class="timing"><span id="RunTime"></span><script>function ShowRunTime(e){var t=new Date,o=parseInt(t-BootDate),n=Math.floor(o/864e5),a=Math.floor(o%864e5/36e5),r=Math.floor(o%864e5%36e5/6e4),h=Math.round(o%864e5%36e5%6e4/1e3),u=n+" 天 "+a+" 时 "+r+" 分 "+h+" 秒";document.getElementById(e).innerHTML="本站已运行 "+u}var BootDate=new Date("2021/10/24 23:00:00");setInterval("ShowRunTime('RunTime')",1e3)</script></div><script async src="https://fastly.jsdelivr.net/gh/jiankychen/jiankychen.github.io@master/js/busuanzi.pure.min.js"></script><div class="count"><span title="站点总字数"><span class="post-meta-item-icon"><i class="ic i-file" aria-hidden="true"></i> </span><span class="text">821k 字</span> </span><span class="post-meta-divider">|</span> <span title="站点总访客数"><span class="post-meta-item-icon"><i class="ic i-person" aria-hidden="true"></i> </span><span class="views"><span id="busuanzi_value_site_uv"></span> 人 </span></span><span class="post-meta-divider">|</span> <span title="站点总访问量"><span class="post-meta-item-icon"><i class="ic i-eye" aria-hidden="true"></i> </span><span class="visitors"><span id="busuanzi_value_site_pv"></span> 次 </span></span><span class="post-meta-divider">|</span> <span title="站点阅读时长"><span class="post-meta-item-icon"><i class="ic i-clock" aria-hidden="true"></i> </span><span class="text">22:48</span></span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/ed3025a8/",favicon:{show:"Jiankychen",hide:"Jiankychen"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="https://unpkg.com/whatwg-fetch@3.4.0/dist/fetch.umd.js"></script><script src="https://unpkg.com/animejs@3.2.0/lib/anime.min.js"></script><script src="https://unpkg.com/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="https://unpkg.com/lozad@1/dist/lozad.min.js"></script><script src="https://unpkg.com/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fcebea289ce233ad5cfe2379973b319";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->