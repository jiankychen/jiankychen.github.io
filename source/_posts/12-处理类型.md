---
title: 处理类型
date: 2022-03-02 11:18:43
tags:
categories:
 - C++
cover: false
---

# 类型别名
类型别名（type alias）是某种类型的同义词。

有两种方法可用于定义类型别名:
1. 传统的方法是使用关键字`typedef`：
    ```cpp
    typedef double wages;   // wages是double的同义词
    typedef wages base, *p; // base是double的同义词, p是double*的同义词
    ```

其中，关键字`typedef`作为声明语句中的基本数据类型的一部分出现。含有`typedef`的声明语句定义的不再是变量而是类型别名。这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。

2. 新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名：
    ```cpp
    using SI = Sales_item;  // SI是Sales_item的同义词
    ```
这种方法用关键字`using`作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。


类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：
```cpp
wages hourly, weekly;    // 等效于double hourly, weekly;
SI item;                 // 等效于Sales_item item
```

## 指针、常量和类型别名
如果某个类型别名指代的是复合类型或常量，当一条声明语句用到了类型别名时，**不能简单地用原复合类型来代替类型别名。**

例如下面的声明语句用到了类型`pstring`，它实际上是类型`char *`的别名：
```cpp
typedef char *pstring;
const pstring cstr = 0; // cstr是一个指向char对象的常量指针，相当于char *const cstr = 0;
const pstring *ps;      // ps是一个指针，它的对象是一个指向char的常量指针。因为const pstring是一个指向char的常量指针类型
```
上述两条声明语句的基本数据类型都是`const pstring`，和过去一样，`const`是对给定类型的修饰。`pstring`实际上是指向`char`的指针，因此，`const pstring`就是指向char的常量指针，而非指向常量字符的指针。

> 遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：
```cpp
const pstring cstr = 0;   //cstr是指向char的常量指针
const char *cstr = 0;     //对const pstring cstr的错误理解，将cstr错当成一个指向char常量的指针
```



# auto类型说明符
C++11新标准引入了`auto`类型说明符，`auto`让编译器通过初始值来推算变量的类型。

`auto`定义的变量必须有初始值：
```cpp
//根据val1和val2相加的结果来推断item的类型
auto item = val1 + val2;
```

使用`auto`也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：
```cpp
auto i = 0, *p = &i;      // ok: i是一个int型变量，p是一个指向int型对象的指针
auto sz = 0, pi = 3.14;   // error: sz和pi的类型不一致，根据sz会推导为int型，但pi会推断为float/double型
```

## 复合类型、常量和auto
编译器推断出来的`auto`类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

1. 当引用被用作初始值时，真正参与初始化的其实是引用对象的值，此时编译器以引用对象的类型作为`auto`的类型：
    ```cpp
    int i = 0, &r = i;
    auto a = r;  // a是int型（r是int型对象i的引用）
    ```

2. 其次，`auto`一般会忽略掉顶层`const`，同时底层`const`则会保留下来

    ```cpp
    const int ci = i, &cr = ci;
    auto b = ci;  // b是一个int型（顶层const被忽略）
    auto c = cr;  // c是一个int型
    auto d = &i;  // d是一个指向int的指针
    auto e = &ci; // e是一个指向int常量的指针（底层const被保留）
    ```

3. 如果希望推断出的`auto`类型是一个顶层`const`，需要明确指出：
    ```cpp
    const auto f = ci; // ci的类型是int，f是一个int常量（顶层const）
    ```

4. 可以将引用的类型设为`auto`，此时原来的初始化规则（引用的初始化规则）仍然适用：
    ```cpp
    auto &g = ci;       // g is a const int&. 因为ci是int常量，不允许存在通过g修改ci的风险，故而g是常量引用
    auto &h = 42;       // error: 不能为非常量引用绑定字面值。字面值常量42的类型为int，故auto推断为int型，此时存在通过h修改42的风险，故而语法错误
    const auto &j = 42; // ok: 可以为常量引用绑定字面值
    ```
设置一个类型为`auto`的引用时，初始值中的顶层常量属性仍然保留。即，不能通过引用修改所指对象的值。

5. 要在一条语句中定义多个变量，切记，符号`&`和`*`只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：
    ```cpp
    auto k = ci, &l = i;    // k是int型对象，l是int型对象i的引用
    auto &m = ci, *p = &ci; // m是一个int型常量引用，p是指向int常量的指针
    auto &n = i, *p2 = &ci; //error: 根据i推断的类型是int; 根据&ci推断的类型是const int。（存在通过p2修改ci的风险）
    ```



# decltype类型指示符
C++11新标准引入了类型说明符d`ecltype`，它的作用是选择并返回操作数的数据类型。

编译器分析表达式并得到它的类型，却不实际计算表达式的值：
```cpp
decltype(f()) sum = x;
```
编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。

如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：
```cpp
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&
decltype(cj) z;     // error: z是一个引用，必须初始化
```

> 需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。在decltype中，引用和引用所指对象是不同的数据类型，如上例，ci是const int型，而cj是const int&型。


## decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。
```cpp
//decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b;  // ok: 加法的结果是int型，故而b是一个（未初始化）的int对象
decltype(*p) c;     // error: c是int&型，必须初始化
```
因为`r`是一个引用，因此`decltype(r)`的结果是引用类型。如果想让结果类型是`r`所指的类型，可以把`r`作为表达式的一部分，如`r+0`，显然这个表达式的结果将是一个具体值而非一个引用。


如果表达式的内容是解引用操作，则`decltype`将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，`decltype(*p)`的结果类型就是`int&`，而非`int`。

如果`decltype`使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式,所以这样的`decltype`就会得到引用类型：
```cpp
// decltype of a parenthesized variable is always a reference
decltype((i)) d;    // error: d是int&，必须初始化
decltype(i) e;      // ok: e是一个（未被初始化的）int
```

> `decltype((variable))`（注意是双层括号）的结果永远是引用，而`decltype(variable)`结果只有当`variable`本身就是一个引用时才是引用。


> `auto`和`decltype`的区别主要有三个方面：
> 
> 1. `auto`类型说明符用编译器计算变量的初始值来推断其类型，而`decltype`虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。
> 
> 2. 编译器推断出来的`auto`类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，`auto`一般会忽略掉顶层`const`，而把底层`const`保留下来。与之相反，`decltype`会保留变量的顶层`const`。
> 
> 3. 与`auto`不同，`decltype`的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果`decltype`使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。