---
title: 优先级队列
date: 2022-04-30 16:22:32
tags:
 - 优先级队列
categories:
 - 数据结构
cover: false
---

队列是一个先进先出的线性表

优先级队列：结点之间的关系是由结点的优先级决定的，而不是由入队的先后次序决定。优先级高的先出队，优先级低的后出队

优先级队列可以基于线性结构实现
 - 按照 **优先级** 排序
   - 入队：按照优先级插入在合适的位置 - $O(N)$
   - 出队：队头元素 - $O(1)$
 - 按照 **到达时间** 排序
   - 入队：插入到队尾 - $O(1)$
   - 出队：寻找优先级最高的并删除 - $O(N)$


优先级队列也可以基于 **二叉堆** 实现

 - 二叉堆指的是父子之间的大小满足一定约束的完全二叉树

   - 最小化堆：父结点的值小于等于儿子结点
   - 最大化堆：父结点的值大于等于儿子结点

 - 出队：删除根结点 - $O(\log{N})$

 - 入队：在最后一层的第一个空位置上添加一个元素，但添加后要调整元素的位置，以保持堆的有序性 - $O(\log{N})$


基于二叉堆的优先级队列设计
 - 数据成员设计
   - 采用顺序存储
 - 数据成员包括：
   - 队列长度
   - 指向数组起始地址的指针
   - 数组大小
 - 成员函数包括：
   - 抽象类规定的所有功能
   - 创建一个队列：`create()`
   - 入队：`enQueue(x)`
   - 出队：`deQueue()`
   - 读队头：`getHead`
   - 判队空：`isEmpty`
 - 私有的工具函数
   - 扩展数组的工具函数 `doubleSpace`
   - 构造时的工具函数 `buildHeap`
   - 出队时的工具函数 `percolateDown`

基于二叉堆的优先级队列类定义

```cpp
template <class Type>
class priorityQueue:public queue<Type> {
    private:
        // 队列长度
        int currentSize;  
        // 指向数组起始地址的指针
        Type *array; 
        // 数组大小
        int maxSize;
        void doubleSpace();
        void buildHeap();
        void percolateDown(int hole);  
    public:
        priorityQueue(int capacity = 100);
        priorityQueue(const Type data[], int size);
        ~priorityQueue() { delete [] array; }
        bool isEmpty() const { return currentSize == 0; }
        void enQueue(const Type & x);
        Type deQueue();
        Type getHead() { return array[1]; }
};

// 构造函数 - 构造空的优先级队列
priorityQueue(int capacity = 100) { 
    array = new Type[capacity];
    maxSize = capacity;   
    currentSize = 0;
}
```