---
title: 二叉树
date: 2022-03-23 19:59:16
tags: 
 - 二叉树
categories:
 - 数据结构
cover: false
---

`树`：用来模拟具有树状结构性质的数据集合

`二叉树`：每个节点`最多有两个子树`的树结构，通常子树被称作“左子树”和“右子树”

[LeetBook: 二叉树](https://leetcode-cn.com/leetbook/detail/data-structure-binary-tree/)


# 树的遍历

`前序遍历`：首先访问根节点，然后遍历左子树，最后遍历右子树
![前序遍历](二叉树/1.png)


`中序遍历`：先遍历左子树，然后访问根节点，然后遍历右子树
![中序遍历](二叉树/2.png)

> 中序常用来在二叉搜索树中得到递增的有序序列

`后序遍历`：先遍历左子树，然后遍历右子树，最后访问树的根节点
![后序遍历](二叉树/3.png)

删除节点的过程将按照后序遍历的顺序进行

后序可用于数学中的后缀表示法，结合栈处理表达式，每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中


> 前序：根左右
> 
> 中序：左根右
> 
> 后序：左右根

> 所谓前中后序只针对于根节点，而左右子节点永远都是先左后右的顺序


## 前序遍历

[LeetCode 144. Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

给定二叉树的根节点 `root` ，返回它节点值的 `前序` 遍历

Example 1:
![](二叉树/4.jpg)

    Input：root = [1,null,2,3]
    Output：[1,2,3]

Example 2:
![](二叉树/5.jpg)

    Input：root = [1,2]
    Output：[1,2]

Example 3:
![](二叉树/6.jpg)

    Input：root = [1,null,2]
    Output：[1,2]


### Method 1: 递归
按照访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。

定义 `preorder(root)` 表示当前遍历到 `root` 节点的答案。按照定义，我们只要首先将 `root` 节点的值加入答案，然后递归调用 `preorder(root.left)` 来遍历 `root` 节点的左子树，最后递归调用 `preorder(root.right)` 来遍历 `root` 节点的右子树即可，递归终止的条件为碰到`空节点`。

```cpp
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;
    preorder(root,res);         // 先序遍历，调用递归函数
    return res;
}

void preorder(TreeNode* root, vector<int> &res) {
    if (root == nullptr) return;
    res.push_back(root->val);   // 记录遍历的顺序
    preorder(root->left,res);   // 左子树
    preorder(root->right,res);  // 右子树
}
```

时间复杂度：`O(n)`，其中 `n` 是二叉树的节点数。每一个节点恰好被遍历一次

空间复杂度：`O(n)`，为递归过程中栈的开销，平均情况下为 `O(logn)`，最坏情况下树呈现链状，为 `O(n)`

[^_^]: 这部分被注释掉了
    ### Method 2: 迭代
    也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同

    ```cpp
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        stack<TreeNode*> stk;
        TreeNode* node = root;
        while (!stk.empty() || node != nullptr) {
            while (node != nullptr) {
                res.emplace_back(node->val);
                stk.emplace(node);
                node = node->left;
            }
            node = stk.top();
            stk.pop();
            node = node->right;
        }
        return res;
    }
    ```

    时间复杂度：`O(n)`，其中 `n` 是二叉树的节点数。每一个节点恰好被遍历一次。

    空间复杂度：`O(n)`，为迭代过程中显式栈的开销，平均情况下为 `O(logn)`，最坏情况下树呈现链状，为 `O(n)`



[^_^]: 这部分被注释掉了
    ### Method 3: Morris遍历
    J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出

    Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：
    1. 新建临时节点，令该节点为 `root`；
    2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
    3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：
        - 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
        - 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。

    4. 重复步骤 2 和步骤 3，直到遍历结束。

    ```cpp
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        TreeNode *p1 = root, *p2 = nullptr;

        while (p1 != nullptr) {
            p2 = p1->left;
            if (p2 != nullptr) {
                while (p2->right != nullptr && p2->right != p1) {
                    p2 = p2->right;
                }
                if (p2->right == nullptr) {
                    res.emplace_back(p1->val);
                    p2->right = p1;
                    p1 = p1->left;
                    continue;
                } else {
                    p2->right = nullptr;
                }
            } else {
                res.emplace_back(p1->val);
            }
            p1 = p1->right;
        }
        return res;
    }
    ```

    时间复杂度：`O(n)`，其中 `n` 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次

    空间复杂度：`O(1)`。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间

[题解：二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/)


## 中序遍历

[LeetCode 94. Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定二叉树的根节点 `root` ，返回它节点值的 `中序` 遍历

Example 1:
![](二叉树/4.jpg)

    Input：root = [1,null,2,3]
    Output：[1,3,2]


Example 2:
![](二叉树/5.jpg)

    Input：root = [1,2]
    Output：[2,1]


Example 3:
![](二叉树/6.jpg)

    Input：root = [1,null,2]
    Output：[1,2]


### Method 1: 递归
```cpp
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    inorder(root,res);         // 中序遍历
    return res;
}

void inorder(TreeNode* root, vector<int> &res) {
    if (root == nullptr) return;
    inorder(root->left,res);   // 左子树
    res.push_back(root->val);  // 根节点
    inorder(root->right,res);  // 右子树
}
```

[^_^]: 这部分被注释掉了
    ### Method 2: 迭代

[^_^]: 这部分被注释掉了
    ### Method 3: Morris遍历


[题解：二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)


## 后序遍历

[LeetCode 145. Binary Tree Postorder Traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

给定二叉树的根节点 `root` ，返回它节点值的 `后序` 遍历

Example 1:
![](二叉树/4.jpg)

    Input：root = [1,null,2,3]
    Output：[3,2,1]


### Method 1: 递归
```cpp
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    postorder(root,res);         // 中序遍历
    return res;
}

void postorder(TreeNode* root, vector<int> &res) {
    if (root == nullptr) return;
    postorder(root->left,res);   // 左子树
    postorder(root->right,res);  // 右子树
    res.push_back(root->val);    // 根节点
}
```

[^_^]: 这部分被注释掉了
    ### Method 2: 迭代


[^_^]: 这部分被注释掉了
    ### Method 3: Morris遍历

[题解：二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/)


## 层序遍历
层序遍历就是逐层遍历树结构：从一个根节点开始，首先访问节点本身。然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推
![](二叉树/7.png)

当我们在**树**中进行**广度优先搜索**时，我们**访问的节点的顺序**是按照**层序遍历**顺序的

通常，我们使用一个叫做**队列**的数据结构来帮助我们做广度优先搜索

[LeetCode 102. Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给定二叉树的根节点 `root` ，返回其节点值的 `层序遍历`。（即逐层地，从左到右访问所有节点）

Example:
![](二叉树/8.jpg)

    Input：root = [3,9,20,null,null,15,7]
    Output：[[3],[9,20],[15,7]]


### Method: 广度优先搜索
1. 首先根元素入队
2. 当队列不为空的时候
    - 求当前队列的长度 $s_i$
    - 依次从队列中取 $s_i$ 个元素进行拓展，然后进入下一次迭代

普通广度优先搜索每次只取一个元素拓展，而这里每次取 $s_i$ 个元素。第 $i$ 次迭代就得到了二叉树的第 $i$ 层的 $s_i$ 个元素

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector <vector <int>> ret;
    if (!root) {
        return ret;
    }

    queue <TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int currentLevelSize = q.size();
        ret.push_back(vector <int> ());
        for (int i = 1; i <= currentLevelSize; ++i) {
            auto node = q.front(); q.pop();
            ret.back().push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    
    return ret;
}
```

时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 `O(n)`，`n` 为树的所有节点的个数

空间复杂度：队列中元素的个数不超过 `n` 个，故渐进空间复杂度为 `O(n)`