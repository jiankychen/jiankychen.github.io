---
title: 数据结构简介
date: 2022-03-26 22:28:41
# sticky: 3     # 置顶的优先级
tags:
categories:
 - 数据结构
cover: false
---

数据结构是为实现对计算机数据有效使用的各种数据组织形式，旨在降低各种算法计算的时间与空间复杂度

常见的数据结构可分为 *线性数据结构* 与 *非线性数据结构* ，具体包括： **数组** 、 **链表** 、 **栈** 、 **队列** 、 **树** 、 **图** 、 **散列表** 、 **堆** 

![](数据结构简介/1.png)


## 数组
数组是将相同类型的元素存储于 **连续内存空间** 的数据结构，其长度不可变。构建数组时需要在初始化时给定长度，例如：

```cpp
int array[5];

int array[] = {2, 3, 1, 0, 2};
```

详情可见 [C++：数组](https://jiankychen.github.io/2022/03/05/19-shu-zu/)


**可变数组** （**标准库类型 `vector`** ）是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：**访问元素**（下标运算符、范围 `for`、迭代器）、**添加元素**（成员函数 `push_back`）、**删除元素**（成员函数 `erase` 和 `remove`），例如：

```cpp
vector<int> array = {2，3，1，0，2};

array.push_back(2);         // 添加元素 2 到末尾

vector<int>::iterator it;   // 迭代器
it = array.begin() + 4;     // it 指向第 5 个元素
array.erase(it);            // 删除 it 指向的元素
```

详情可见于
[C++：标准库类型 vector](https://jiankychen.github.io/2022/03/04/17-biao-zhun-ku-lei-xing-vector/)
[vector 删除元素的方法](https://blog.csdn.net/JIAN_ZANG1125/article/details/120642243?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&utm_relevant_index=2)


## 链表
链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是 **非连续** 的

链表的节点对象具有两个成员变量：**值** `val` 、 **后继节点指针** `next`

> 注：需要用箭头运算符（`->`），其含义为 解引用 + 成员访问

```cpp
struct ListNode {
    int val;        // 节点值
    ListNode *next; // 后继节点指针
    ListNode(int x) : val(x), next(NULL) {}
};
```

建立链表需要实例化每个节点，并构建各节点的引用指向
```cpp
// 实例化节点
ListNode *n1 = new ListNode(4); // 节点 head
ListNode *n2 = new ListNode(5);
ListNode *n3 = new ListNode(1);

// 构建后继节点指针
n1->next = n2;
n2->next = n3;
```
![](数据结构简介/2.png)


## 栈
栈是一种具有 **先入后出** 特点的抽象数据结构，可使用数组或链表实现

```cpp
stack<int> stk;
```

如下图所示，通过常用操作 **入栈** `push()` ，**出栈** `pop()` ，展示了栈的先入后出特性
```cpp
stk.push(1); // 元素 1 入栈
stk.push(2); // 元素 2 入栈
stk.pop();   // 出栈 -> 元素 2
stk.pop();   // 出栈 -> 元素 1
```
![](数据结构简介/3.png)


## 队列
队列是一种具有 **先入先出** 特点的抽象数据结构，可使用链表实现
```cpp
queue<int> que;
```

如下图所示，通过常用操作 **入队** `push()` ，**出队** `pop()` ，展示了队列的先入先出特性
```cpp
que.push(1); // 元素 1 入队
que.push(2); // 元素 2 入队
que.pop();   // 出队 -> 元素 1
que.pop();   // 出队 -> 元素 2
```
![](数据结构简介/4.png)


## 树
树是一种非线性数据结构，根据子节点数量可分为 **二叉树** 和 **多叉树** ，最顶层的节点称为 **根节点** `root`

以二叉树为例，每个节点包含三个成员变量：**值** `val` 、**左子节点** `left` 、**右子节点** `right`

```cpp
struct TreeNode {
    int val;         // 节点值
    TreeNode *left;  // 左子节点
    TreeNode *right; // 右子节点
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

> 注：需要用箭头运算符（`->`），其含义为 解引用 + 成员访问

如下图所示，建立二叉树需要实例化每个节点，并构建各节点的子节点指针
```cpp
// 初始化节点
TreeNode *n1 = new TreeNode(3); // 根节点 root
TreeNode *n2 = new TreeNode(4);
TreeNode *n3 = new TreeNode(5);
TreeNode *n4 = new TreeNode(1);
TreeNode *n5 = new TreeNode(2);

// 构建子节点指针
n1->left = n2;
n1->right = n3;
n2->left = n4;
n2->right = n5;
```
![](数据结构简介/5.png)


## 图
图是一种非线性结构，由 **节点（顶点）** `vertex` 和 **边** `edge` 组成

根据边是否区分方向，图可分为 **有向图** 和 **无向图** ， 这里以无向图为例进行介绍

如下图所示，此无向图的 顶点 和 边 集合分别为
 - 顶点集合：`vertices = {1, 2, 3, 4, 5}`

 - 边集合：`edges = {(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)}`

![](数据结构简介/6.png)

表示图的方法通常有两种：

1. 邻接矩阵 ：使用数组 `vertices` 存储顶点，邻接矩阵 `edges` 存储边。其中，`edges[i][j]` 表示节点 `vertices[i]` 和节点 `vertices[j]` 之间是否有边

    ```cpp
    int vertices[5] = {1, 2, 3, 4, 5};
    int edges[5][5] = {{0, 1, 1, 1, 1},
                    {1, 0, 0, 1, 0},
                    {1, 0, 0, 0, 1},
                    {1, 1, 0, 0, 1},
                    {1, 0, 1, 1, 0}};
    ```


2. 邻接表 ：使用数组 `vertices` 存储顶点，邻接表 `edges` 存储边。其中，`edges` 是一个二维容器，第一维的 i 代表顶点 `vertices[i]` ，第二维 `edges[i]` 存储顶点 `vertices[i]` 对应的边集合，例如，`edges[0] = [1,2,3,4]` 表示 `vertices[0]` 的边集合为 `[1,2,3,4]`

    ```cpp
    int vertices[5] = {1, 2, 3, 4, 5};
    vector<vector<int>> edges;

    vector<int> edge_1 = {1, 2, 3, 4};
    vector<int> edge_2 = {0, 3};
    vector<int> edge_3 = {0, 4};
    vector<int> edge_4 = {0, 1, 4};
    vector<int> edge_5 = {0, 2, 3};
    edges.push_back(edge_1);
    edges.push_back(edge_2);
    edges.push_back(edge_3);
    edges.push_back(edge_4);
    edges.push_back(edge_5);
    ```

> 邻接矩阵的大小只与节点数量有关，即 $N^2$ ，其中 $N$ 为节点数量
> 
> 当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费（此时邻接矩阵为稀疏矩阵）
> 
> 因此，**邻接表** 适合存储 **顶点较多、边较少** 的 稀疏图 ，**邻接矩阵** 适合存储 **顶点较少、边较多** 的 稠密图


## 散列表
散列表是一种非线性数据结构，通过利用 Hash 函数 将指定的 **键** `key` 映射到对应的 **值** `value` ，以实现高效的元素查找


## 堆
堆是一种基于 **完全二叉树** 的数据结构，可使用数组实现

> 完全二叉树 ：设二叉树深度为 $k$，若二叉树除第 $k$ 层外，其他各层（第 $1$ 至第 $k - 1$ 层）节点个数都达到最大值，且处于第 $k$ 层的节点都连续集中在最左边，则称此二叉树为完全二叉树

![](数据结构简介/7.png)

以堆为原理的排序算法称为 **堆排序** ，基于堆实现的数据结构为 **优先队列**

堆分为 **大顶堆** 和 **小顶堆**
 - 大顶堆 ：任意节点的值不大于其父节点的值（根节点最大）
 - 小顶堆 ：任意节点的值不小于其父节点的值（根节点最小）

下图为包含 `1, 4, 2, 6, 8` 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式
![](数据结构简介/8.png)

通过使用 **优先队列** 的 **压入** `push()` 和 **弹出** `pop()` 操作，即可完成 **堆排序**
```cpp

// 初始化小顶堆
priority_queue<int, vector<int>, greater<int>> heap;

// 元素入堆
heap.push(1);
heap.push(4);
heap.push(2);
heap.push(6);
heap.push(8);

// 元素出堆（从小到大）
heap.pop(); // -> 1
heap.pop(); // -> 2
heap.pop(); // -> 4
heap.pop(); // -> 6
heap.pop(); // -> 8
```




以上内容来自于 [https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50e446/](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50e446/)