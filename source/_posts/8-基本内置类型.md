---
title: 基本内置类型
categories:
  - C++
cover: false
abbrlink: dfbe564
date: 2022-01-01 17:29:09
tags:
---

C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中，算术类型包含了字符、整数型、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。

# 算术类型
算术类型分为两类：整型（integral，包括字符和布尔类型在内）和浮点型。

| 类型 | 含义 | 最小尺寸 |
| :-: | :-: | :-: |
| `bool` | 布尔类型 | 未定义 |
| `char` | 字符 | 8位 |
| `wchar_t` | 宽字符 | 16位 |
| `char16_t` | Unicode字符 | 16位 |
| `char32_t` | Unicode字符 | 32位 |
| `short` | 短整型 | 16位 |
| `int` | 整型 | 16位 |
| `long` | 长整型 | 32位 |
| `long long` | 长整型 | 64位 |
| `float` | 单精度浮点数 | 6位有效数字 |
| `double` | 双精度浮点数 | 10位有效数字 |
| `long double` | 拓展精度浮点数 | 10位有效数字 |

上述表格列出了C++标准规定的算术类型的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

## 整型与浮点型
布尔类型（bool）的取值是真（True）或者假（False）。

基本的字符类型是`char`，一个`char`的空间应确保可以存放机器基本字符集（如ASCII表）中任意字符对应的数字值，即，一个`char`的大小和一个机器字节一样。

`wchar_t`类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型`char16_t`和`char32_t`则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。
> Unicode为每种语言中的每个字符设定了统一并且唯一的二进制编码，现在用的是UCS-2，即，2个字节编码。UTF-8，UTF-16，UTF-32均为字符编码方案。

大多数机器的字节（byte）由8比特（bit）构成，字（word）则由32或64比特构成，也就是4或8字节。

浮点型可表示单精度、双精度和扩展精度值。通常，`float`以1个字（32比特）来表示，`double`以2个字（64比特）来表示，`long double`以3或4个字（96或128比特）来表示。一般来说，类型`float`和`double`分别有7和16个有效位。
>浮点数在机器内用指数形式表示，分解为：数符，尾数，指数符，指数。

## 带符号类型和无符号类型
除布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。

带符号类型可以表示正数、负数或0；无符号类型仅能表示大于等于0的值。

带符号类型：`int`、`short`、`long`、`long long`；在这些类型名前添加`unsigned`就可以得到对应的无符号类型，即，无符号类型：`unsigned int`、`unsigned short`、`unsigned long`、`unsigned long long`。

类型`unsigned int`可以缩写为`unsigned`。

字符型分为三种：`char`、`signed char`、`unsigned char`。其中，`signed char`类型和`unsigned char`类型分别为带符号类型和无符号类型，`char`类型实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

无符号类型中所有比特都用来存储值。

C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。
> `8`比特的`signed char`理论上应该可以表示`-127`至`127`区间内的值，大多数现代计算机将`8`比特的`signed char`实际的表示范围定为 `-128~127`。


## 建议：如何选择类型
当明确知晓数值不可能为负时，选用无符号类型。

使用`int`执行整数运算。若数值超出`int`的表示范围，选用`long long`。

在算术表达式中不要使用`char`或`bool`，只有在存放字符或布尔值时才使用它们。
>因为类型`char`在一些机器上是有符号的，而在另一些机器上又是无符号的，所以使用`char`进行运算特别容易出问题。如果需要使用一个不大的整数，则应该明确指定类型是`signed char`或者`unsigned char`。

执行浮点数运算选用`double`。
>这是因为`float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。`long double`提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。


# 类型转换
类型转换是指，将对象从一种给定的类型转换（convert）为另一种相关类型。

## 转换规则（简介）
类型所能表示的值的范围决定了转换的过程：

1. 当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为`0`则结果为`false`，否则结果为`true`。

2. 当我们把一个布尔值赋给非布尔类型时，初始值为`false`则结果为`0`，初始值为`true`则结果为`1`。

3. 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。

4. 当我们把一个整数值赋给浮点类型时，小数部分记为`0`。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。

5. 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，`8`比特大小的`unsigned char`可以表示`0`至`255`区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对`256`取模后所得的余数。因此，把`-1`赋给`8`比特大小的`unsigned char`所得的结果是`255`。

6. 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

## 含有无符号类型的表达式
当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如`a*b`的式子中，如果`a = -1`，`b = 1`，而且`a`和`b`都是`int`，则表达式的值显然为`-1`。然而，如果`a`是`int`，而`b`是`unsigned`，则结果须视在当前机器上`int`所占位数而定。在我们的环境里，结果是`4294967295`。

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值。

无符号数不会小于0这一事实同样关系到循环的写法。
```cpp
// 以降序的形式逐个输出数字10到0
for (int i = 10; i >= 0; --i)
    std::cout << i <<std::endl;

// 错误：变量u永远也不会小于0，循环条件一直成立
for (unsigned u = 10, u >= 0; --u)
    std::cout << u <<std::endl;
```
> 当`u`等于`0`时这次迭代输出`0`，然后继续执行`for`语句里的表达式。表达式`--u`从`u`当中减去`1`，得到的结果`-1`并不满足无符号数的要求，此时`-1`被自动地转换成一个合法的无符号数。假设`int`类型占`32`位，则当`u`等于`0`时，`--u`的结果将会是`4294967295`。


# 字面值常量
字面值常量（literal）：形如42的值，一望而知。

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

## 整型和浮点型字面值
可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。
```cpp
20 //十进制
024 //八进制
0x14 //十六进制
```

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。
> 十进制字面值的类型是`int`、`long`和`long long`中尺寸最小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`（即，带符号的和无符号的`int`、`long`、`long long`）中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型`short`没有对应的字面值。

> 尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识:
```cpp
3.14159
3.14159E0
0.
0e0
.001
```

默认的，浮点型字面值是一个`double`。

## 字符和字符串字面值
由单引号括起来的一个字符称为`char`型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。
```cpp
'a' // 字符字面值
"Hello World!" // 字符串字面值
```


字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（′\0′），因此，字符串字面值的实际长度要比它的内容多1。
> 例如，字面值'A'表示的就是单独的字符A，而字符串"A"则代表了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。
```cpp
// 当书写的字符串字面值比较长，写在一行里不太合适时，分多行书写字符串字面值
std::cout << "a really, really long string literal "
        << "that spans two lines" << std::endl;
```

 ## 转义序列
 有两类字符程序员不能直接使用：一类是不可打印（nonprintable）的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。 这些情况需要用到转义序列（escape sequence）。

 C++语言规定的转义序列包括：
 > 换行符 `\n`
 > 纵向制表符 `\v`
 > 反斜线 `\\`
 > 回车符 `\r`
 > 横向制表符 `\t`
 > 退格符 `\b`
 > 问号 `\?`
 > 进纸符 `\f`
 > 报警（响铃）符 `\a`
 > 双引号 `\"`
 > 单引号 `\'`


在程序中，上述转义序列被当作一个字符使用。
```cpp
std::cout << '\n';          // 转到新一行
std::cout << "\tHi!\n";     // 输出一个制表符，输出"Hi!"，转到新一行
```

我们也可以使用泛化的转义序列，其形式是`\x`后紧跟1个或多个十六进制数字，或者`\`后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。
> 假设使用的是Latin-1字符集，以下是一些示例：（对应ASCII表）
> `\7` 响铃
> `\12` 换行符
> `\40` 空格
> `\0` 空字符
> `\115` 字符M
> `\x4d` 字符M

```cpp
std::cout << "Hi! \x4dO\115!\n";    // 输出"Hi MOM!"，转到新一行
std::cout << '\115' << '\n';        // 输出"M"，转到新一行
```

> 注意，如果反斜线`\`后面跟着的八进制数字超过3个，只有前3个数字与`\`构成转义序列。例如，`"\1234"`表示2个字符，即八进制数123对应的字符以及字符4。相反，`\x`要用到后面跟着的所有数字，例如，`"\x1234"`表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的`char`型数据占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。

## 指定字面值的类型
通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

字符和字符串字面值：
| 前缀 | 含义 | 类型
| :-: | :-: | :-: |
| u | Unicode 16 字符 | char16_t |
| U | Unicode 32 字符 | char32_t |
| L | 宽字符 | wchar_t |
| u8 | UTF-8 （仅用于字符串字面值常量） | char |


整型字面值：
| 后缀 | 最小匹配类型 |
| :-: | :-: |
| u 或 U | unsigned |
| l 或 L | long |
| ll 或 LL | long long |


浮点型字面值：
| 后缀 | 最小匹配类型 |
| :-: | :-: |
| f 或 F | float |
| l 或 L | long double |

> 当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了。

```cpp
L'a'        // 宽字符型字面值，类型是 wchar_t
u8"hi!"     // UTF-8 字符串字面值，类型是 char
42ULL       // 无符号整型字面值，类型是 unsigned long long
1E-3F       // 单精度浮点型字面值，类型是 float
3.14159L    // 扩展精度浮点型字面值，类型是 long double
```

对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。
> 如果后缀中有`U`，则该字面值属于无符号类型，也就是说，以`U`为后缀的十进制数、八进制数或十六进制数都将从`unsigned int`、`unsigned long`和`unsigned long long`中选择能匹配的空间最小的一个作为其数据类型。如果后缀中有`L`，则字面值的类型至少是`long`；如果后缀中有`LL`，则字面值的类型将是`long long`和`unsigned long long`中的一种。显然我们可以将`U`与`L`或`LL`合在一起使用。例如，以`UL`为后缀的字面值的数据类型将根据具体数值情况或者取`unsigned long`，或者取`unsigned long long`。


## 布尔字面值和指针字面值
`true`和`false`是布尔类型的字面值。

`nullptr`是指针字面值。