---
title: 二分查找
date: 2022-03-12 21:30:06
tags:
 - 二分查找
categories:
 - 算法
cover: false
---

**二分查找** （binary search），也称折半搜索（half-interval search）、对数搜索（logarithmic search），是用来在一个有序数组中查找某一元素的算法

一些边界情况：
1. 如何处理答案不存在的情况
2. 区间内只有两个数字时，代码是否正常工作
3. 数组中有很多个重复元素时，代码是否正常工作
4. 会不会出现死循环
    - 出现死循环时可以考虑将中点计算公式 `mid = left + right >> 1` 修改为 `mid = left + right + 1 >> 1` ，即，中点向上取整
5. 循环结束时， `left` 与 `right` 是什么样的关系


## 思路

### 定义 左闭右闭 区间 [left,right]

```cpp
int l = 0, r = nums.size() - 1;
while (l < r) {
    int mid = l + r >> 1;
    if (check(mid))
        r = mid;
    else 
        l = mid + 1；
}
```

### 定义 左闭右开 区间 [left,right)

```cpp
int l = 0, r = nums.size();
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (check(mid)) 
        l = mid;
    else 
        r = mid - 1；
}
```

为避免 off-by-one 问题造成的死循环（即，`left` 始终比 `right` 小 `1`），建议记住以下规律：
 - 如果代码用到 `left = mid` ，把 `left` 不断向右 push ，那么 `mid` 向上取整，即 `mid = left + right + 1 >> 1`
 - 如果代码用到 `right = mid` ，把 `right` 不断往左 push，那么 `mid` 向下取整，即 `mid = left + right >> 1`


## 示例

[LeetCode 704. 二分查找](https://jiankychen.github.io/2022/03/16/leetcode704-er-fen-cha-zhao/)


[^_^]:

    ## Frameworks

    ![](二分查找/1.png)

    **Framework 1: 寻找满足条件的最左边的元素**
    ```cpp
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) 
            r = mid;
        else 
            l = mid + 1；
    }
    ```

    **Framework 2: 寻找满足条件的最右边的元素**
    ```cpp
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check(mid)) 
            l = mid;
        else 
            r = mid - 1；
    }
    ```

    ## LeetCode 35. Search Insert position
    [LeetCode 35](https://leetcode-cn.com/problems/search-insert-position/)

    选择 Framework 1: 寻找满足条件的最左边的元素

    ```cpp
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); // 可能找到最后一个元素的下一个位置
        while (left < right)
        {
            int mid = (left + right) >> 1;
            if (nums[mid] >= target)
                right = mid;
            else
                left = mid + 1;
        };
        return right;
    }
    ```