---
title: 排序
description: 简单介绍各种排序算法
date: 2022-04-14 23:22:34
tags:
categories:
 - 算法
cover: false
---

排序算法性能汇总：

| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 稳定性 |
| :- | :- | :- | :- | :- |
| 选择排序 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 数组不稳定、链表稳定 |
| 冒泡排序 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 |
| 插入排序 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 |
| 快速排序 | $O(n \log{n})$ | $O(n^2)$ | $O(\log{n})$ | 不稳定 |
| 堆排序 | $O(n \log{n})$ | $O(n \log{n})$ | $O(1)$ | 不稳定 |
| 归并排序 | $O(n \log{n})$ | $O(n \log{n})$ | $O(n)$ | 稳定 |
| 希尔排序 | $O(n \log{n})$ | $O(n^2)$ | $O(1)$ | 不稳定 |
| 计数排序 | $O(n + m)$ | $O(n + m)$ | $O(n + m)$ | 稳定 |
| 桶排序 | $O(n)$ | $O(n)$ | $O(n)$ | 取决桶内排序算法 |
| 基数排序 | $O(kn)$ | $O(n^2)$ | $O(n)$ | 稳定 |


> 稳定的排序算法：在排序前的序列中，有超过一个相同的元素，排序后这两个元素的相对位置依然保持不变

参考：[https://dowalle.gitbook.io/algo/algorithm/2-suan-fa-ji-chu/1-pai-xu](https://dowalle.gitbook.io/algo/algorithm/2-suan-fa-ji-chu/1-pai-xu)



为便于表述以及理解，作出以下声明:

1. 各排序算法均以  "将包含 `n` 个元素的序列按从小到大的顺序排列"  为例

2. `第 i 个元素`的 `i` 的范围是 `[1, n]`

3. `第 i 位元素`的 `i` 的范围是 `[0, n - 1]`


## 选择排序
**选择** ：选出序列中的最小值，放到序列的首位

```cpp
// 选择：寻找最小值
int min_pos = 0;
for (int j = 1; j < n; j++) {
    if (a[j] < a[min_pos]) {   // 如果当前元素小于之前维护的最小值
        min_pos = j;           // 更改最小值出现的位置
    }
}
```


**选择排序** 的算法思想：

1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾

3. 以此类推，直到所有元素均排序完毕

代码实现：
```cpp
void selectionSort(vector<int>& a) {   // 选择排序
    int n = a.size();
    for (int i = 0; i < n - 1; i++) {      // 枚举应该归位的第 i 位元素
        int min_pos = i;                   // 将最小值位置设置为当前范围 i ~ n - 1 的首位
        for (int j = i + 1; j < n; j++) {  // 将第 i 位元素和剩下的元素相比较
            if (a[j] < a[min_pos]) {       // 如果当前元素小于之前维护的最小值
                min_pos = j;               // 更改最小值出现的位置
            }
        }
        swap(a[i], a[min_pos]);            // 将最小值与第 i 位元素交换
    }
}
```

时间复杂度：
 - 最优、平均和最坏时间复杂度均为 $O(n^2)$

空间复杂度：$O(1)$

稳定性：由于 `swap` 操作的存在，选择排序是一种 **不稳定** 的排序算法



## 冒泡排序

在算法的执行过程中，较小的元素像是气泡般慢慢浮到数列的顶端，故叫做冒泡排序

**冒泡** ：两个数比较大小，较大的数下沉，较小的数冒起来

    // 冒泡：连续交换过程
    for (int i = 0; i < n - 1; i++)    // 枚举两两交换的前一个元素序号
        if (a[i] > a[i + 1])
            swap(a[i], a[i + 1]);      // 如果前一个元素大于后一个，就进行交换


**冒泡排序** 的算法思想：

 - 针对 $i \in [0, n - 2]$ ，通过 **冒泡** 将前 `n - i` 个元素的最大值移动到第 `n - i - 1` 位，此时还剩前 `n - i - 1` 个元素（即，第 `0` 位到第 `n - i - 2` 位）未排序

注：也可以进行第 `i = n - 1` 阶段结束


代码实现：

```cpp
void bubbleSort(vector<int>& a) { // 冒泡排序，引用传递
    int n = a.size();
    for (int i = 0; i < n - 1; i++) { // 在第 i 个阶段，未排序的序列长度从 n - i 变成 n - i - 1 （注：i 的最大值可以设置成 n - 1，也可以设置成 n - 2）
        // 将第 0 位到第 n - i - 1 位元素的最大值，移到 n - i - 1 的位置
        for (int j = 0; j < n - i - 1; j++) // j 是冒泡操作中的前一个元素的下标，j 的最大值为 n - i - 2，对应 j + 1 最大值为 n - i - 1
            if (a[j] > a[j + 1])
                swap(a[j], a[j + 1]);
    }
}
```

时间复杂度：
 - 最优情况 $O(n)$，序列完全有序时，冒泡排序只需遍历一遍数组
 - 最坏情况 $O(n^2)$，冒泡排序要执行 $(n - 1) n / 2$ 次交换操作
 - 平均时间复杂度 $O(n^2)$

空间复杂度：$O(1)$

稳定性：冒泡排序是一种 **稳定** 的排序算法



## 插入排序
对于一个有序序列，如果想在其中新加入一个元素，就应通过 **插入操作** 找出正确的插入位置，并且将插入位置空出来，然后插入新元素

**插入** ：将第 `i` 个元素插入到前 `i - 1` 个元素的有序序列中，形成长度为 `i` 的有序序列

> 假设数组 `a` 的第 `0` 位到第 `i - 1` 位已经有序，插入操作的关键在于搜索插入位置，即：找出一条分界线 `j` ，使得 `a[j - 1] <= a[i]` 且 `a[j] > a[i]` 成立

[^_^]: 被注释掉了
    **插入** 操作的过程为：

    1. 将 `a[i]` 赋值给中间量 `x` ，**从 `i` 到 `0`** 扫描下标 `j` ：
        - 如果 `a[j - 1] > x` ，则 `a[j - 1]` 应在分界线以后，所以将 `a[j - 1]` 赋给 `a[j]`，并且，分界线前移，即：`j` 更新为 `j - 1`
        - 如果 `a[j - 1] <= x` 或 `j = 0` ，则分界线位置已找到，结束
    2. 将 `x` 赋给 `a[j]`


```cpp
// 插入：找出插入位置，并将该位置及以后的元素向右移动一位
int j = i - 1, x = a[i];    // 初始化分界线的位置，并将 a[i] 用临时变量保存防止被修改
for (; (j >= 0) && (a[j] > x); j--) { // 满足循环条件，分界线的位置应向左移
    a[j + 1] = a[j];
}
// 循环结束，找出分界线位置，插入 x
a[j + 1] = x;
```

[LeetCode 35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

**插入排序** 的算法流程为：

1. 待排序序列的第 `0` 位元素作为初始的有序序列

2. 针对 $i \in [1, n - 1]$，依次将第 `i` 位元素 **插入** 到有序序列中


代码实现：

```cpp
void InsertSort(int& a[]) { // 插入排序
    int n = a.size();
    for (int i = 1; i < n; i++) { // 从左到右遍历，将元素依次插入有序序列中
        int j, x = a[i];
        for (j = i - 1; (j >= 0) && (a[j] > x); j--) {   
            // 满足循环条件，相当于分界线应向左移
            a[j + 1] = a[j];                                 
        }
        // 找到分界线位置，插入元素 x
        a[j + 1] = x;
    }
}
```

时间复杂度：
 - 最优时间复杂度为 $O(n)$
 - 平均和最坏时间复杂度均为 $O(n^2)$

空间复杂度：$O(1)$

稳定性：插入排序是一种 **稳定** 的排序算法



## 快速排序（重要）
快速排序（Quicksort），又称分区交换排序（partition-exchange sort），简称快排

**快速排序** 用到的一个很重要的思想就是 **分治思想**

> **分治思想** ：“分而治之”，将一个复杂问题不断分解为规模更小、更容易解决的问题

**快速排序** 基本思想：
1. 选择基准：从数列中取出一个数作为基准数 `pivot` 
2. `partition` 过程：将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边
3. 再对左右区间重复第 2 步，直到各区间只有一个数

> 选择基准的方式：
>  - 固定位置：取序列的第一个或最后一个元素作为基准（基本的快速排序算法，不利于处理有序或部分有序的数组）
>  - 随机选取基准：取待排序列中任意一个元素作为基准（对于绝大多数输入数据，可以达到 $O(n \log{n})$ 的期望时间复杂度）
>  - 三数取中（median-of-three）：取第一个、最后一个和中心位置上的三个元素的中位数作为基准（可以避免极端数据（如升序序列或降序序列）带来的退化）

代码实现：
```cpp
void QuickSort(vector<int>& a, int l, int r) { // 将序列分成左右两个子序列，并对子序列分别排序
                                        // l 和 r 分别代表当前排序子段在原序列中左右端点的位置

    int pivot = a[r];   // 设置最右边的数为基准
    int pos = l - 1;    // 分界线 pos 及其左边的元素一定小于 pivot
    
    // partition: 划分子序列，并确定分界线新位置 pos
    // partition 包含 swap 操作，故而不是稳定的排序算法
    for (int j = l; j < r; j++)
        if (a[j] < pivot) 
            swap(a[j], a[++pos]);
    swap(a[r], a[++pos]); // 将 pivot 放到分界线位置
    
    // 对左子段和右子段分别进行排序
    if (l < pos - 1)
        quick_sort(a, l, pos - 1); // 如果左边子段长度大于 1，排序
    if (k + 1 < r)
        quick_sort(a, pos + 1, r); // 如果右边子段长度大于 1，排序
}
```

[^_^]:  以下代码已经被注释掉

    其中，partition 划分子序列的代码可以替换成：
    ```cpp
    int k = l;  // k 指向将要被交换的元素
    for (int j = l; j < r; j++)
        if (a[j] < pivot) {
            swap(a[j], a[k]);
            k++;
        }
    swap(a[r], a[k]);
    ```

    快排的另一种写法：
    ```cpp
    void QuickSort(vector<int>& v, int low, int high) {
        if (low >= high)		// 结束标志
            return;
        int first = low;		// 低位下标
        int last = high;		// 高位下标
        int key = v[first];		// 设第一个为基准

        while (first < last)
        {
            // 将比第一个小的移到前面
            while (first < last && v[last] >= key)
                last--;
            if (first < last)
                v[first++] = v[last];

            // 将比第一个大的移到后面
            while (first < last && v[first] <= key)
                first++;
            if (first < last)
                v[last--] = v[first];
        }
        //
        v[first] = key;
        // 前半递归
        QuickSort(v, low, first - 1);
        // 后半递归
        QuickSort(v, first + 1, high);
    }
    ```


时间复杂度：
 - 最优 $O(n \log{n})$，每一次选择的分界值都是序列的中位数
 - 最坏 $O(n^2)$，每一次选择的分界值都是序列的最值
 - 平均 $O(n \log{n})$

空间复杂度：$O(\log{n})$，递归调用时使用栈帧空间

稳定性：快速排序是一种 **不稳定** 的排序算法

[三种快速排序以及快速排序的优化](https://blog.csdn.net/insistGoGo/article/details/7785038)


### sort 函数

C++标准模板库（STL）定义了 **排序函数 `sort`** ，可以用于排序操作（对 **快速排序** 的优化实现）


**`sort` 函数** 有三个参数：**头指针** 、**尾后指针** 和 **比较函数**

> 如果已经针对排序对象定义了小于号（即，定义了小于号何时成立），比较函数可省略

例如，针对数组排序：
```cpp
int a[10] = {2, 3, 1, 5, 4};
int n = 5;
sort(a.begin(), a.end());  //sort函数的两个参数，头指针和尾后指针
for (int i = 0; i < n; ++i) 
    cout << a[i] << " ";
cout << endl;
```

如果想按照其他标准进行排序，可以定义一个比较函数。例如，按 **从大到小排序** ：
```cpp
int a[10] = {2, 3, 1, 5, 4};
int n = 5;

// 比较函数，函数的参数是当前比较的两个数组中的元素
bool cmp(int x, int y) { // x 和 y 分别为排序数组中的两个元素
    return (x > y);  // 当函数返回值为 true 时，x 应该排在 y 的前面
}

int main() {
    sort(a.begin(), a.end(), cmp); // 比较函数作为第三个参数传入 sort 函数
    for (int i = 0; i < n; ++i)
        cout << a[i] << " ";
    cout << endl;
    return 0;
}
```



参考：[sort 排序算法介绍及示例](https://www.cplusplus.com/reference/algorithm/sort/?kw=sort)






## 堆排序



## 归并排序（重要）



## 希尔排序


## 计数排序


## 桶排序（重要）

## 基数排序


参考资料：

 - [CodeSheep](https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ)

 - [OI Wiki](https://oi-wiki.org/basic/sort-intro/)

 - [algo](https://dowalle.gitbook.io/algo/algorithm/2-suan-fa-ji-chu/1-pai-xu)