---
title: 排序
date: 2022-04-14 23:22:34
tags:
categories:
 - 算法
cover: false
---

注：

1. 各排序算法均以  将包含 `n` 个元素的序列按从小到大的顺序排列  为例

2. 序列一共有 `n` 个元素

3. `第 i 个元素`的 `i` 的范围是 `[1, n]`

4. `第 i 位元素`的 `i` 的范围是 `[0, n - 1]`


## 选择排序

选择排序的过程为：

1. 遍历所有元素，找出最小值，将其与第 `1` 个元素互换

2. ...

3. 遍历第 `i` 到第 `n` 个元素，找出其中的最小值，将其与第 `i` 个元素互换

4. ...

5. 直到所有元素按照从小到大的顺序排列

[^_^]:  以下算法已经被注释掉
算法：

    for i = 0 to n-1
        遍历，找出第 i 位元素到第 n-1 位元素的最小值，记录最小值所在位置为 k
        交换第 i 位与第 k 位元素
    end for


代码实现：
```cpp
// 输入
int n;
cin >> n;
int a[n];
for (int i = 0; i < n; i++)
    cin >> a[i];

// 选择排序过程
for (int i = 0; i < n; i++) {  // 枚举应该归位的第 i 位元素
    int min_pos = i;           // 将最小值位置设置为当前范围 i ~ n-1 的首位
    for (int j = i + 1; j < n; j++) { // 将第 i 位元素和剩下的元素相比较
        if (a[j] < a[min_pos]) {       // 如果当前元素小于之前维护的最小值
            min_pos = j;               // 更改最小值出现的位置
        }
    }
    swap(a[i], a[min_pos]);            // 将最小值与第 i 位元素交换
}

// 输出
for (int i = 0; i < n; i++) 
    cout << a[i] << ' ';
cout << endl;
```

时间复杂度：$O(n^2)$。


## 冒泡排序

**冒泡**：从第 `1` 个到第 `n` 个进行连续交换，以使得最大值出现在最后

    // 冒泡：连续交换过程
    for (int i = 0; i < n - 1; i++)    // 枚举两两交换的前一个元素序号
        if (a[i] > a[i + 1])
            swap(a[i], a[i + 1]);      // 如果前一个元素大于后一个，就进行交换


冒泡算法分为 `n - 1` 个阶段：

1. 第 `0` 阶段，通过 **冒泡** 将前 `n - 0` 个元素的最大值移动到序列的最后，即，第 `n - 1` 位，此时还剩前 `n - 1` 个元素（即，第 `0` 位到第 `n - 2` 位）未排序

2. ...

3. 第 `i` 阶段，通过 **冒泡** 将前 `n - i` 个元素的最大值移动到第 `n - i - 1` 位，此时还剩前 `n - i - 1` 个元素（即，第 `0` 位到第 `n - i - 2` 位）未排序

4. ...

5. 第 `n - 2` 阶段，将前 `2` 个元素中的较大值移动到第 `1` 位，此时，第 `0` 位元素对应的是序列的最小值，排序完毕

代码实现：
```cpp
// 冒泡排序
for (int i = 0; i < n; i++) { 	        // 一共 n - 1 个阶段，在第 i 个阶段，未排序的序列长度从 n - i 变成 n - i - 1
    for (int j = 0; j < n - i - 1; j++)	// 将第 0 位到第 n - i - 1 位元素的最大值，移到 n - i - 1 的位置
        if (a[j] > a[j + 1])            // j 是前后交换时前一个元素的下标，j 的最大值为 n - i - 2，对应的 j + 1 最大值为 n - i - 1
            swap(a[j], a[j + 1]);
}
```