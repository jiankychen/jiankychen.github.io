---
title: 排序
date: 2022-04-14 23:22:34
tags:
categories:
 - 算法
cover: false
---

为便于表述以及理解，作出以下声明:

1. 各排序算法均以  "将包含 `n` 个元素的序列按从小到大的顺序排列"  为例

2. `第 i 个元素`的 `i` 的范围是 `[1, n]`

3. `第 i 位元素`的 `i` 的范围是 `[0, n - 1]`


## 选择排序
**选择** ：选出序列中的最小值，放到序列的首位

```cpp
// 选择：寻找最小值
int min_pos = 0;
for (int j = 1; j < n; j++) {
    if (a[j] < a[min_pos]) {   // 如果当前元素小于之前维护的最小值
        min_pos = j;           // 更改最小值出现的位置
    }
}
```


**选择排序** 的过程为：

1. 遍历所有元素，找出最小值，将其与第 `1` 个元素互换

2. ...

3. 遍历第 `i` 到第 `n` 个元素，找出其中的最小值，将其与第 `i` 个元素互换

4. ...

5. 直到所有元素按照从小到大的顺序排列

[^_^]:  以下算法已经被注释掉
算法：

    for i = 0 to n - 1
        遍历，找出第 i 位元素到第 n - 1 位元素的最小值，记录最小值所在位置为 k
        交换第 i 位与第 k 位元素
    end for


代码实现：
```cpp
// 输入
int n;
cin >> n;
int a[n];
for (int i = 0; i < n; i++)
    cin >> a[i];

// 选择排序过程
for (int i = 0; i < n; i++) {  // 枚举应该归位的第 i 位元素
    int min_pos = i;           // 将最小值位置设置为当前范围 i ~ n-1 的首位
    for (int j = i + 1; j < n; j++) { // 将第 i 位元素和剩下的元素相比较
        if (a[j] < a[min_pos]) {       // 如果当前元素小于之前维护的最小值
            min_pos = j;               // 更改最小值出现的位置
        }
    }
    swap(a[i], a[min_pos]);            // 将最小值与第 i 位元素交换
}

// 输出
for (int i = 0; i < n; i++) 
    cout << a[i] << ' ';
cout << endl;
```

时间复杂度：$O(n^2)$

空间复杂度：$O(1)$



## 冒泡排序

**冒泡** ：比较每一对相邻的元素，当这一对元素的顺序不正确时，交换这两个元素的位置

    // 冒泡：连续交换过程
    for (int i = 0; i < n - 1; i++)    // 枚举两两交换的前一个元素序号
        if (a[i] > a[i + 1])
            swap(a[i], a[i + 1]);      // 如果前一个元素大于后一个，就进行交换


**冒泡排序** 的过程可以分为 `n - 1` 个阶段：

1. 第 `0` 阶段，通过 **冒泡** 将前 `n - 0` 个元素的最大值移动到序列的最后，即，第 `n - 1` 位，此时还剩前 `n - 1` 个元素（即，第 `0` 位到第 `n - 2` 位）未排序

2. ...

3. 第 `i` 阶段，通过 **冒泡** 将前 `n - i` 个元素的最大值移动到第 `n - i - 1` 位，此时还剩前 `n - i - 1` 个元素（即，第 `0` 位到第 `n - i - 2` 位）未排序

4. ...

5. 第 `n - 2` 阶段，将前 `2` 个元素中的较大值移动到第 `1` 位，此时，第 `0` 位元素对应的是序列的最小值，排序完毕

注：若进行第 `n - 1` 阶段，即，仅针对第 `0` 位元素进行排序，并不影响实际结果。因此，算法可以从第 `0` 阶段进行至第 `n - 1` 阶段结束


[^_^]:  以下算法已经被注释掉
算法：

    for i = 0 to n - 1
        第 i 阶段，通过冒泡操作将前 n - i 个元素的最大值移动到第 n - i - 1 位
    end for



代码实现：

```cpp
// 冒泡排序
for (int i = 0; i < n; i++) { // 在第 i 个阶段，未排序的序列长度从 n - i 变成 n - i - 1 （注：i 的最大值可以是 n - 1，也可以是 n - 2）
    // 将第 0 位到第 n - i - 1 位元素的最大值，移到 n - i - 1 的位置
    for (int j = 0; j < n - i - 1; j++) // j 是冒泡操作中的前一个元素的下标，j 的最大值为 n - i - 2，对应 j + 1 最大值为 n - i - 1
        if (a[j] > a[j + 1])
            swap(a[j], a[j + 1]);
}
```

时间复杂度：$O(n^2)$

空间复杂度：$O(1)$


## 插入排序
对于一个有序序列，如果想在其中新加入一个元素，就应通过 **插入操作** 找出正确的插入位置，并且将插入位置空出来，然后插入新元素

**插入** ：将第 `i` 个元素插入到前 `i - 1` 个元素的有序序列中，形成长度为 `i` 的有序序列。

**插入操作** 的基本思想是，从后向前不断“试探”分界线的位置

[LeetCode 35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 假设数组 `a` 的第 `0` 位到第 `i - 1` 位已经有序，插入操作的关键在于搜索插入位置，即：找出一条分界线 `j` ，使得 `a[j - 1] <= a[i]` 且 `a[j] > a[i]` 成立

**插入** 操作的过程为：

1. 将 `a[i]` 赋值给中间量 `x` ，从 `i` 到 `0` 枚举分界线下标 `j` ：
    - 如果 `a[j - 1] > x` ，则 `a[j - 1]` 应在分界线以后，所以将 `a[j - 1]` 赋给 `a[j]`，并且，分界线前移，即：`j` 更新为 `j - 1`
    - 如果 `a[j - 1] <= x` 或 `j = 0` ，则分界线位置已找到，结束枚举
2. 将 `x` 赋给 `a[j]`

```cpp
// 插入：找出插入位置，并将该位置及以后的元素向右移动一位
int j, x = a[i];    // 初始化分界线的位置，并将 a[i] 用临时变量保存防止被修改
for (j = i; j > 0 && a[j - 1] > x; j--) { // // 满足循环条件，分界线的位置应向左移
    a[j] = a[j - 1];
}
// 循环结束，找出分界线位置，插入 x
a[j] = x;
```

**插入排序** 的算法流程为：

1. 待排序序列的第 `0` 位元素作为初始的有序序列
2. 将第 `1` 位元素**插入**到有序序列中
3. ...
4. 将第 `i` 位元素**插入**到有序序列中
5. ...
6. 将第 `n - 1` 位元素**插入**到有序序列中

[^_^]:  以下算法已经被注释掉
算法：

    for i = 1 to n
        前 i - 1 个元素为有序序列
        将第 i 个元素插入到前 i - 1 个元素的有序序列中，形成长度为 i 的有序序列
    end for


代码实现：

```cpp
// 插入排序
for (int i = 1; i < n; i++) { // 从左到右遍历，将元素按依次插入有序序列中
    int j, x = a[i];
    for (j = i; j > 0 && a[j - 1] > x; j--) {   
        // 满足循环条件，相当于分界线应向前移，
        a[j] = a[j - 1];              
                                                
    }
    // 找到分界线位置，插入元素 x
    a[j] = x;                         
}
```

时间复杂度：$O(n^2)$

空间复杂度：$O(1)$



## 快速排序




## 归并排序




## 计数排序