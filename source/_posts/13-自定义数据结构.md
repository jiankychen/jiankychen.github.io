---
title: 自定义数据结构
categories:
  - C++
cover: false
abbrlink: 13eb466a
date: 2022-03-02 20:53:38
tags:
---

从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。

C++语言允许用户以类的形式自定义数据类型，而库类型`string`、`istream`、`ostream`等也都是以类的形式定义的。

# 定义Sales_data类型
```cpp
struct Sales_data
{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```

这里的类以关键字`struct`开始，紧跟着类名和类体（其中类体部分可以为空）。类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。

**类体右侧的表示结束的花括号后必须写一个分号**，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：
```cpp
struct Sales_data { /* ... */ } accum, trans, *salesptr; // equivalent, but better way to define these objects
struct Sales_data { /* ... */ };
Sales_data accum, trans, *salesptr;
```
分号表示声明符（通常为空）的结束。

一般来说，最好不要把对象的定义和类的定义放在一起。

用户也可以使用C++语言提供的另外一个关键字`class`来定义自己的数据结构。

类的定义可以与`main`函数放在同一个文件内，但是，我们通常在头文件中定义类，并且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如，我们应该把Sales_data类定义在名为Sales_data.h的头文件中。

# 类数据成员
类体定义类的成员，我们上面定义的类只有数据成员（datamember）。

类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他`Sales_data`的对象。

定义数据成员的方法：首先说明一个基本类型，随后紧跟一个或多个声明符。

C++11新标准规定，可以为数据成员提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。
> 对类内初始值的限制：要么放在花括号里，要么放在等号右边，而不能使用圆括号。

# 使用Sales_data类

[详见：自己动手实现对于Sales_data类的操作](https://weread.qq.com/web/reader/ff732fe072021a24ff7bb24k1ff325f02181ff1de7742fc)

关键在于，使用点操作符(`.`)读入对象的成员，如
```cpp
Sales_data data1;                               // data1为Sales_data类型的对象
std::cin >> data1.bookNo >> data1.units_sold;   // 写入对象data1的bookNo成员和units_sold成员
```

# 编写自己的头文件
为了确保各个文件中类的定义一致，**类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。**

头文件通常包含那些只能被定义一次的实体，如类、`const`和`constexpr`变量等。

头文件也经常用到其他头文件的功能。因此，有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地工作。

> 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。

## 预处理器概述
确保头文件多次包含仍能安全工作的常用技术是**预处理器**（preprocessor），它由C++语言从C语言继承而来。
> 预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能`#include`，当预处理器看到`#include`标记时就会用指定的头文件的内容代替`#include`。

C++程序还会用到的一项预处理功能是**头文件保护符**（headerguard），头文件保护符依赖于预处理变量。
> 预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。

使用这些功能就能有效地防止重复包含的发生：
```cpp
#ifndef SALES_DATA_H    // SALES_DATA_H即为预处理变量，ifndef是if not defined的缩写。若未定义SALES_DATA_H，则执行后续操作，直到遇到#endif指令
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
```
第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直至遇到#endif为止。此时，预处理变量SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，则#ifndef的检查结果将为假，编译器将忽略#ifndef到#endif之间的部分。

> 预处理变量无视C++语言中关于作用域的规则。

整个程序中的预处理变量包括头文件保护符必须唯一，**通常的做法是基于头文件中类的名字来构建保护符的名字**，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，**一般把预处理变量的名字全部大写**。

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。