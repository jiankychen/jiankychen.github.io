---
title: const限定符
date: 2022-03-01 14:42:14
tags: 
categories:
 - C++
cover: false
---

用关键字`const`对变量的类型加以限定，使得变量成为常量：
```cpp
const int bufSize = 512;
```

`const`对象一旦创建后其值就不能再改变，所以，`const`对象必须初始化。初始值可以是任意复杂的表达式。

## 初始化和const

对于`const`类型的对象，只能执行不改变其内容的操作。

> 可以利用`const`对象去初始化指针，因为const对象是常量，而不是变量。

## 默认状态下，const对象仅在文件内有效

默认情况下，`const`对象被设定为仅在文件内有效。

某些时候，我们希望只在一个文件中定义`const`，而在其他多个文件中声明并使用它。解决的办法是，对于`const`变量不管是声明还是定义都添加`extern`关键字，这样只需定义一次就可以了。
> 任何包含了显式初始化的声明，就成为了定义。

**如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字。**


# const的引用
对常量的引用（reference to const）: 把引用绑定到const对象上。

对常量的引用不能被用于修改它所绑定的对象。
> 即，不能够通过该引用修改对象的值，但可以通过其他途径修改该对象的值
```cpp
const int ci = 1024;
const int &r1 = ci; //正确：引用及其对应的对象都是常量。不存在通过引用r1修改ci的风险，故而语法正确

r1 = 42;
int &r2 = ci;       //错误：试图让一个非常量引用指向一个常量对象。存在通过r2修改ci的风险，故而语法错误
```

> 术语：常量引用是对const的引用

引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:
```cpp
int i = 42;
const int &r1 = i;      //允许将const int &绑定到一个普通int对象上。仅仅是说，不能通过r1修改i的值
const int &r2 = 42;     //正确：r2是一个对const的引用。不存在通过r2修改42的风险
const int &r3 = r1 * 2; //正确：r3是一个对const的引用。不存在通过r3修改r1 * 2的风险
int &r4 = r1 * 2;       //错误：r4是一个普通的非常量引用。存在通过r4修改r1 * 2的风险
```

## 对const的引用可能引用一个并非const的对象
> 常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。

```cpp
int i = 42;
int &r1 = i;        //引用r1绑定对象i
const int &r2 = i;  //常量引用r2绑定对象i，不允许通过r2修改i的值
r1 = 0;             //r1并非常量，i的值修改为0
r2 = 0;             //错误：r2是常量引用，不允许通过r2修改i的值
```

# 指针和const

## 指向常量的指针
指向常量的指针（pointer toconst）：不能用于改变其所指对象的值。

要想存放常量对象的地址，只能使用指向常量的指针：
```cpp
const double pi = 3.14;     //pi是一个常量
double *ptr = &pi;          //错误：ptr是一个普通指针。存在通过解引用*ptr修改pi的值的风险，故语法错误
const double *cptr = &pi;   //正确: cptr是一个指向常量的指针。不存在通过*cptr修改pi的值的风险，故语法正确
*cptr = 42;                 //错误：cptr是指向常量的指针，不能给*cptr赋值。
```

指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：
```cpp
double dval = 3.14;     //dval是一个双精度浮点数，它的值可以改变
cptr = &dval;           //正确，但是不能通过cptr修改dval的值
```

和常量引用一样，**指向常量的指针也没有规定其所指的对象必须是一个常量。指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。**

> 试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。


## const指针（常量指针）

指针是对象，允许把指针本身定为常量。

常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。

把`*`放在`const`关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：
```cpp
int errNum = 0;
int *const curErr = &errNum;    //curErr将一直指向errNum
const double pi = 3.14;
const double *const pip = &pi;  //pi是一个指向常量的常量指针
```
要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离`curErr`最近的符号是`const`，意味着`curErr`本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是`*`，意思是`curErr`是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个`int`对象。与之相似，我们也能推断出，`pip`是一个常量指针，它指向的对象是一个双精度浮点型常量。

**指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。**
> 例如，`pip`是一个指向常量的常量指针，则不论是`pip`所指的对象值还是`pip`自己存储的那个地址都不能改变。相反的，`curErr`指向的是一个一般的非常量整数，那么就完全可以用`curErr`去修改`errNum`的值


# 顶层const

指针本身是不是常量，以及指针所指的对象是不是一个常量，是两个相互独立的问题。

顶层const（top-levelconst）表示指针本身是个常量。
> 更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。

底层const（low-level const）表示指针所指的对象是一个常量。

比较特殊的是，指针类型既可以是顶层const也可以是底层const。

```cpp
int i = 0;
int *const pi = &i;         //顶层const
const int ci = 42;          //顶层const
const int *p2 = &ci;        //底层const

const int *const p3 = p2;   //底层const，顶层const
const int &r = ci;          //底层const
```

当执行对象的拷贝操作时，顶层const不受什么影响（执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响）。
```cpp
i = ci;     //正确：拷贝对象ci的值，顶层const对此操作无影响
p2 = p3;    //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```

当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。
```cpp
int *p = p3;        //错误：p3包含底层const的定义，而p没有。存在通过p修改p3所指对象的值的风险，故语法错误
p2 = p3;            //正确：p2和p3都是底层const。不存在通过p2修改p3所指对象的值的风险，故语法正确
p2 = &i;            //正确：int *能转换成const int *。p2是一个指向常量的指针
int &r = ci;        //错误：普通的int &不能绑定int常量。存在通过引用r修改常量ci值的风险，故语法错误
const int &r2 = i;  //正确：const int &可以跟一个普通int对象绑定。r2是一个指向常量的指针
```

# constexpr和常量表达式
常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。

> **字面值**属于常量表达式，**用常量表达式初始化的`const`对象**也是常量表达式。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如:
```cpp
const int max_files = 20;           //是常量表达式
const int limit = max_files + 1;    //是常量表达式
int staff_size = 27;                //不是常量表达式（值会改变）

const int sz = get_size();          //不是常量表达式（无法在编译过程得到计算结果）
```

## constexpr变量
C++11新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化：
```cpp
constexpr int mf = 20;          //20是常量表达式
constexpr int limit = mf + 1;   //mf+1是常量表达式
constexpr int sz = size();      //只有当size是一个constexpr函数时才是一条正确的声明语句
```

尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

> 一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。

## 字面值类型
字面值类型（literal type）

算术类型、引用和指针都属于字面值类型。

自定义类`Sales_item`、`IO`库、`string`类型则不属于字面值类型，也就不能被定义成`constexpr`。

尽管指针和引用都能定义成`constexpr`，但它们的初始值却受到严格限制。一个`constexpr`指针的初始值必须是`nullptr`或者`0`，或者是存储于某个固定地址中的对象。
> 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。此外，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。

## 指针和constexpr
在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。
> 相当于一个常量指针，表示指针本身是常量，无法指向别的对象。

```cpp
const int *p = nullptr;         //指向常量的指针
int const *q1 = nullptr;        //常量指针
constexpr int *q2 = nullptr;    //常量指针
```
关键在于，`constexpr`把它所定义的对象置为了顶层const。

与其他常量指针类似，`constexpr`指针既可以指向常量也可以指向一个非常量。