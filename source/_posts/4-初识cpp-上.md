---
title: 初识C++(上)
date: 2021-10-26 22:43:23
tags:
categories:
 - C++
# cover: 4-初识cpp/1.png
cover: false
---


# main
`main`函数的返回类型必须是int，即整数类型

多数系统中，`main`的返回值用于指示状态：返回值0表示成功，非0返回值通常用来指出错误类型

当`return`语句包括一个值时，**该返回值的类型必须与函数返回类型相容**，如`main`函数的返回值0是int类型的值


# 编译、运行程序
源文件：带后缀`.c`、`.cxx`、`.cpp`、`.cp`、`.c`的程序文件

可执行文件：windows系统的`.exe`文件，UNIX系统的`.out`文件
*注：windows系统运行一个可执行文件时，需提供可执行文件的文件名，可以忽略其拓展名`.exe`，而UNIX系统则需要使用完整的文件名(包含文件拓展名)*

`.`后面跟一个反斜线，即`.\`，指出文件在当前目录中，如`.\prog1.exe`

运行GUN编译器的命令：`g++ -o prog1 prog1.cc`，其中，`-o prog1`是编译器参数，指定可执行文件的文件名。此命令生成名为`prog1`(UNIX)或`prog1.exe`(windows)的可执行文件。若省略`-o prog1`，则生成`a.out`(UNIX)或`a.exe`(windows)可执行文件


# 输入与输出
标准库`iostream`: 包含输入流`istream`与输出流`ostream`

IO对象: `cin`(标准输入)、`cout`(标准输出)、`cerr`(输出警告与错误信息)、`clog`(输出程序运行时的一般性信息)

`<<`: 输出运算符，将给定值写到给定的`ostream`对象中，如: `std::cout<<"Enter two number";`

`>>`: 输入运算符，从给定的`istream`读入数据，并存入给定对象中，如: `std::cin>>v1;`

`endl`: 操纵符，写入`endl`的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流(stream)

流(stream)：一个流就算一个字符序列，是从IO设备读出或写入IO设备的。术语“流”想要表达的是，随着时间的推移，字符是顺序生成或消耗的

```cpp
#include <iostream>
int main()
{
	std::cout << "Enter two number" << std::endl;
	int v1 = 0, v2 = 0;
	std::cin >> v1 >> v2;
	std::cout << "The sum of " << v1 << " and " << v2 << " is " << v1 + v2 << std::endl;
	return 0;
}
```

# include
程序使用标准库时，必须包含相关的头文件，如: `#include <iostream>`告诉编译器使用`iostream`库

尖括号内的名字即指出了一个头文件，如`iostream`、`array`、`cmath`、`algorithm`等

`#include`指令和头文件的名字必须写在同一行中，**不用以分号结束**

通常情况下，`#include`指令必须出现在所有函数之外

一般将一个程序的所有`#include`指令都放在源文件的开始位置


# 命名空间
命名空间可以避免名字定义冲突以及使用库中相同名字导致的冲突，标准库定义的所有名字都在命名空间`std`中

通过命名空间使用标准库有一个副作用：**当使用标准库中的一个名字时，必须显式说明使用的是命名空间`std`中的名字**

`::`: 作用域操作符，编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字

`std::`: 指出名字是定义在`std`的命名空间(namespace)中的，如: `std::cin`、`std::cout`、`std::endl`分别指出`cin`、`cout`、`endl`是命名空间`std`中的

`using`声明: 一开始对`cin`、`cout`、`endl`使用`using`声明，后续不需要添加`std::`形式的前缀即可使用它们。注意，**每行的`using`声明都要以分号结束**

```cpp
#include <iostream>
using std::cout;
using std::cin;
using std::endl;
void main()
{
	cout << "Enter two number" << endl;
	int v1 = 0, v2 = 0;
	cin >> v1 >> v2;
	cout << "The product of " << v1 << " and " << v2 << " is " << v1 * v2 << endl;
}
```


# 注释
单行注释: 以双斜线`//`开始，以换行符结束。这种注释可以包含任何文本，包括额外的双斜线

界定符对注释：以界定符`/*`开始，以界定符`*/`结束，可以包含除`*/`外的任意内容，包括换行符。因此，界定符对注释可以跨越程序中的多行

注释界定符可以放置于任何允许放置制表符、空格符或换行符的地方

当注释界定符跨越多行，最好能显示指出其内部的程序行都属于多行注释的一部分，C++ Primer所采用的风格是：注释内的每行都以一个星号开头，从而指出整个范围都是多行注释的一部分

```cpp
# include <iostream>
/*
* 简单主函数
* 读取两个数，求它们的和
*/
int main()
{
	//提示用户输入两个数
	std::cout << "Enter two numbers:" << std::endl;
	int v1 = 0, v2 = 0;     //保存用于读取输入数据的变量
	std::cin >> v1 >> v2;   //读取输入数据
	std::cout << "The sum of " << v1 << " and " << v2
			<< " is " << v1 + v2 << std::endl;
	return 0;
}
```

**注释界定符对通常用于多行解释，而双斜线注释常用于半行和单行附注**

注意：**注释界定符不能嵌套**，因为界定符对以`/*`开始，以`*/`结束

调试时，通常需要注释掉一些代码，由于这些代码本身可能包含界定符对形式的注释，若继续采用界定符对进行注释则可能导致注释嵌套错误，因此，调试时注释的最好的方式是用单行注释方式注释掉代码段的每一行

```cpp
// /*
// * 单行注释中的任何内容都会被忽略
// * 包括内部的注释对也一样会被忽略
// */
```