---
title: 哈希表
tags:
  - 哈希表
categories:
  - 数据结构
cover: false
abbrlink: 850f2080
date: 2022-05-01 12:03:02
---


哈希表（Hash table ，也被称为散列表）是根据关键码而直接进行访问的数据结构

> 一般把搜索的数据称为关键字（Key），和关键字对应的称为值（Value），将其称之为 <Key, value> 的键值对

哈希表可以近似理解成数组，哈希表中的关键码就是数组的索引下标，通过下标可以直接访问数组的元素

**一般哈希表都是用来快速判断一个元素是否出现集合当中**

哈希表 **以空间换时间** ，因为需要额外的 `数组` 、`set` 或 `map` 来存放数据，才能实现快速查找

## 哈希函数

哈希函数（hash function）将关键码映射为哈希表的索引

构造哈希函数的要求：
 - 定义域必须包含全部需要存储的关键码，而值域的范围则依赖于散列表的大小或地址范围。
 - 函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生
 - 函数应尽量简单，能够在较短的时间内计算出任一关键码对应的散列地址

常用的哈希函数
 - 直接地址法
   - 直接将关键码值作为地址 `H(key) = key` 或 做一个简单的线性映射 `H(key) = a × key + b`
 - 除留取余法
   - 最常用的一种哈希函数
   - 保证函数值是一个合法的下标
   - `H(key) = key MOD p` ，其中 `p` 是数组的大小，`p` 最好为质数，这样可以使得函数值分布更均匀
 - 数字分析法
   - 适用于关键码值范围比较大的情况（并非每一位都有区分意义）
   - 对所有关键码，分析每一位上的数字分布。取数字分布均匀的位作为地址的组成部分
 - 平方取中法
   - 适用于关键码中各位的分布都比较均匀，但关键码的值域比数组规模大（每一位都有区分意义）
   - 将关键码平方后，取其结果的中间各位作为散列函数值
   - 由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大
   - 中间部分究竟要选取几位，依赖于哈希表的单元总数
 - 折叠法
   - 如果关键字相当长，以至于和哈希表的单元总数相比大得多时，可采用此法
   - 选取一个长度后，将关键码按此长度分组相加

## 哈希碰撞

哈希碰撞是指：不同的关键码映射到同一个地址
 - 也称之为 冲突

两类解决方案：

1. 闭散列表：利用当前散列表中的空余单元
    - 线性探测法：$H_i = (H_{i-1} + 1) \text{ mod size}$
      - $H_{i-1}$ 是最近计算到的探测点（ $H_0$ 是原始的散列位置），$H_i$ 是要计算的新的探测点
    - 二次探测法：$H_i = (H_0 + i^2) \text{ mod size}$
    - 再次散列法：$H_i = (H_0 + i * \text{hash}^2(x)) \text{ mod size}$
2. 开散列表：将散列到同一地址的节点组织成一个单链表，存储散列表的数组中保存的是每个单链表的起始地址


[^_^]: 被注释掉了

    ### 线性探测法

    当散列发生冲突时，探测下一个单元，直到发现一个空单元，于是元素将存储在该空单元

    当需要查找元素时：

        计算 addr = H(key)
        从 addr 开始遍历数组
            if (找到)  返回 true
            if (内容为空)  返回 false 
            ++addr
        返回 false


    当需要删除元素时：采用迟删除方式，即，先找到该元素，做一个删除标记，告知程序 “该地址曾经有内容”
    - 若直接删除，后续查找到该地址时，会发现内容为空而直接返回 `false` ，但实际上所查找元素可能位于该地址之后，故造成查找错误

    #### 类定义

    数据成员：一个动态数组、指向函数的指针
    - 数组元素类型：存储数据及存储单元的状态

    成员函数：插入、查找和删除以及构造析构、一个缺省的关键码转换函数

    当关键码不都是整数时，由用户提供将关键码转成整数的函数

    如果关键码本身就是整数，不需要用户提供这个函数：为指向函数的指针成员提供一个缺省值

    类定义的实现代码：

    ```cpp
    template <class KEY, class OTHER>
    class closeHashTable:public dynamicSearchTable<KEY, OTHER>  {
    private:
        struct node {                 // 哈希表的节点类
                SET <KEY, OTHER>  data;
                int   state;            // 0 -- empty   1 -- active   2 -- deleted
            node() {state = 0;}
        };
        node *array;
        int  size;
        int (*key)(const KEY &x);
        static int defaultKey(const int &x) {return x;} 
    public: 
        closeHashTable(int length = 101, int (*f)(const KEY &x) = defaultKey) ;
        ~closeHashTable() {delete [] array;}
        SET<KEY, OTHER> *find(const KEY &x) const;
        void insert(const SET<KEY, OTHER> &x);
        void remove(const KEY &x) ;
    };
    ```

    构造函数：构造一个空的哈希表
    ```cpp
    template <class Type>
    closeHashTable<Type>::closeHashTable (int length, int (*f)(const Type  &x)) {
        size = length;
        array = new node[size];
        key = f;
    } 
    ```

    `insert` 函数：从哈希函数的映射地址开始寻找一个空单元或被删单元，哈希函数采用除留余数法
    ```cpp
    template <class KEY, class OTHER>
    void closeHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x) {
        int initPos, pos ;

        initPos = pos = key(x.key) % size;
        do {  
            if (array[pos].state != 1) { // 找到空单元或被删单元
                array[pos].data = x; 
                array[pos].state = 1; 
                return;
            }
            pos = (pos + 1) % size;
        } while (pos != initPos);
    }
    ```

    `find` 函数：从散列地址开始寻找被查元素，直到找到该元素或空单元
    ```cpp
    template <class KEY, class OTHER>
    SET<KEY, OTHER> *closeHashTable<KEY, OTHER>::find(const KEY &x) const {
        int initPos, pos ;

        initPos = pos = key(x) % size;
        do {
            if (array[pos].state == 0) return NULL;                 // 没有找到
            if (array[pos].state == 1 && array[pos].data.key == x)  // 找到
                return (SET<KEY,OTHER> *)&array[pos];
            pos = (pos + 1) % size;
        } while (pos != initPos);
        return NULL;
    }
    ```

    `remove` 函数：从散列地址开始寻找被删元素，找到后做删除标志
    ```cpp
    template <class KEY, class OTHER>
    void closeHashTable<KEY, OTHER>::remove(const KEY &x) {
        int initPos, pos ;

        initPos = pos = key(x) % size;
        do {
            if (array[pos].state == 0) return;
            if (array[pos].state == 1 && array[pos].data.key == x) {     // 找到，删除
                array[pos].state = 2;
                return;
            }
            pos = (pos+1) % size;
        } while (pos != initPos);
    }
    ```

    以上所定义的线性探测法类的缺陷：

    1. 没有保证表长为素数
        - 在构造函数中增加素数检测。如果实际参数的表长不是素数，则将大于等于表长的最小素数作为表长
    2. 运行一段时间以后，所有数组元素都成为 active 或 deleted ，所有操作的时间性能都是 $O(N)$
        - 可以增加一个整理散列表的功能，将被删元素真正删去
        - 可以增加一个数据成员记录 deleted 的单元数，自动调用整理函数


    ### 二次探测法

    ### 开散列表

    特点：

    - 将散列到同一地址的结点组织成一个单链表

    - 存储散列表的数组中保存的是每个单链表的起始地址

    开散列表的示意图：

    ![开散列表](哈希表/1.png)

    开散列表类：

    ```cpp
    template <class KEY, class OTHER>
    class openHashTable:public dynamicSearchTable<KEY, OTHER> {
    private:
        struct node {    // 开散列表中链表的节点类
            SET<KEY, OTHER>  data;
            node             *next; 
            node (const SET<KEY, OTHER> &d, node *n = NULL)    { data = d;  next = n;}
            node () {next = NULL;}
        };
        node **array;                          // 指针数组
        int  size;
        int (*key)(const KEY &x);
        static int defaultKey(const int &x) { return x;}
    public: 
        openHashTable(int length = 101,   int (*f)(const KEY &x) = defaultKey);
        ~openHashTable();
        SET<KEY, OTHER> *find(const KEY &x) const;
        void insert(const SET<KEY, OTHER> &x);
        void remove(const KEY &x);
    };
    ```

    构造函数：申请一动态指针数组，并设所有元素值为空指针

    ```cpp
    template <class KEY, class OTHER>
    openHashTable<KEY, OTHER>::openHashTable (int length,  int (*f)(const KEY  &x)) {
        size = length;
        array = new node*[size];
        key = f;
        for (int i = 0; i < size; ++i)
            array[i] = NULL;
    }
    ```

    析构函数：析构函数不仅要释放存放散列表的数组的空间，还要释放每个单链表中所有结点的空间

    ```cpp
    template <class KEY, class OTHER>
    openHashTable<KEY, OTHER>::~openHashTable() {
        node *p, *q;
        for (int i = 0; i< size; ++i) {           
            p = array[i]; 
            while (p != NULL) { 
                q= p->next; 
                delete p;
                p = q; 
            }
        }
        delete [] array;
    } 
    ```

    `insert` 函数：找到哈希地址，在相应的链表头上插入元素

    ```cpp
    template <class KEY, class OTHER>
    void openHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x) {
        int pos ;
        node *p;
        pos = key(x.key) % size;
        array[pos] = new node(x, array[pos]);
    }
    ```

    `remove` 函数：找到哈希地址，在相应的链表寻找并删除元素
    ```cpp
    template <class KEY, class OTHER>
    void openHashTable<KEY, OTHER>:: remove(const KEY &x) {
        int pos = key(x) % size;
        node * p = array[pos];, *q;
        if (array[pos] == NULL) return;
        if (array[pos]->data.key == x) {    
            array[pos] = p->next;
            delete p;   
            return;	   
        }
        while (p->next != NULL   && !(p->next->data.key == x) )    p = p->next;
        if (p->next != NULL) {
            q = p->next;  
            p->next = q->next;  
            delete q;    
        }
    }
    ```

    `find` 函数：找到哈希地址，在相应的链表寻找元素
    ```cpp
    template <class KEY, class OTHER>
    SET<KEY, OTHER> *openHashTable<KEY, OTHER> ::find(const KEY &x) const
    {
        int pos;
        node *p;

        pos = key(x) % size;
        p = array[pos];

        while (p != NULL && !(p->data.key == x) )
            p = p->next;

        if (p == NULL) return NULL;
        else return (SET<KEY, OTHER> *)p;
    }
    ```


    [青舟智学：哈希表](https://www.boyuai.com/learn/courses/152/lessons/2371/steps/0?from=qz)

[CodeSheep：哈希表详解](https://mp.weixin.qq.com/s/UanDueZi3MwlcKYGMNQPGg)

理想情况下，哈希查找的时间复杂度是 $O(1)$


## 常见的哈希结构

三种哈希结构
 - 数组
 - set （集合）
 - map （映射）

set 只存储 `key` ，而 map 存储了 `<key, value>` 的键值对

### 集合 set

在 set 中，元素的 `key` 就是它的 `value`
> 键值对 `<key, value>` ：用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量 `key` 和 `value` ，`key` 代表键值，`value` 表示与 `key` 对应的信息

在 set 中，不能修改元素的值，但是可以从容器中插入或删除


C++ 的 set 实现：
 - `std::set` ：底层实现为红黑树，`key` 是有序的
 - `std::multiset` ：底层实现是红黑树，`key` 有序
 - `std::unordered_set` ：底层实现是哈希表，`key` 无序

| set | 底层实现 | `key` 是否有序 | `key` 是否可以重复 | 能否更改 `key` | 查询效率 | 增删效率
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| `std::set` | 红黑树 | 有序 | 否 | 否 | $O(\log {n})$ | $O(\log {n})$ |
| `std::multiset` | 红黑树 | 有序 | 是 | 否 | $O(\log{n})$ | $O(\log{n})$ |
| `std::unordered_set` | 哈希表 | 无序 | 否 | 否 | $O(1)$ | $O(1)$ |

> **红黑树** 是一种平衡二叉搜索树，所以 `key` 是有序的，但 `key` 不可以修改，改动 `key` 会导致整棵树的错乱，所以只能删除和增加


1. 若要使用集合来解决哈希问题，优先使用 `unordered_set` ，因为它的查询和增删效率是最优的

2. 如果需要集合是有序的，那就用 `set` 

3. 如果不仅要求有序还要有重复数据，那么就用 `multiset`

虽然 `std::set` 、`std::multiset` 的底层实现是红黑树，不是哈希表，但是 `std::set`、`std::multiset` 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法（map 也是同样的道理）

[代码随想录：哈希表理论基础](https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

#### `std::set`

所有的元素都会被自动排序，不允许出现键值 `key` 重复
 - 总是按照其内部比较对象（类型比较）所指示的特定严格弱排序准则进行排序

set 容器通过 `key` 访问单个元素的速度通常比 unordered_set 容器慢，但 set 容器允许根据顺序对子集进行直接迭代

头文件：`#include <set>`

[^_^]: 被注释掉了

    ##### 构造

    | 函数声明 | 功能介绍 |
    | :-: | :-: |
    `set (const Compare& comp = Compare(), const Allocator& = Allocator());` | 构造空的 set
    `set (InputIterator ﬁrst, InputIterator last, const Compare& comp = Compare(), const Allocator& = Allocator());` | 用 [ﬁrst, last) 区间中的元素构造 set
    `set ( const set<Key, Compare, Allocator>& x);` | set 的拷贝构造

    ##### 迭代器

    函数声明 | 功能介绍
    | :-: | :-: |
    `iterator begin()` | 返回 set 中起始位置元素的迭代器
    `iterator end()` | 返回 set 中最后一个元素后面的迭代器
    `const_iterator cbegin()` | 返回 set 中起始位置元素的 const 迭代器
    `const_iterator cend()` | 返回 set 中最后一个元素后面的 const 迭代器
    `reverse_iterator rbegin()` | 返回 set 第一个元素的反向迭代器，即 end
    `reverse_iterator rend()` | 返回 set 最后一个元素下一个位置的反向迭代器，即 rbegin
    `const_reverse_iterator crbegin()` | 返回 set 第一个元素的反向 const 迭代器，即 cend
    `const_reverse_iterator crend()` | 返回 set 最后一个元素下一个位置的反向const迭代器，即crbegin

    ##### 容量

    函数声明 | 功能介绍
    | :-: | :-: |
    `bool empty ( ) const` | 检测 set 是否为空，空返回 true ，否则返回 true
    `size_type size() const` | 返回 set 中有效元素的个数

    ##### 修改

    函数声明 | 功能介绍
    | :-: | :-: |
    `pair<iterator,bool> insert ( const value_type& x )` | 在 set 中插入元素 x ，如果插入成功，返回 <该元素在 set 中的位置，true> ，否则，返回 < x 在 set 中的位置，false>
    `void erase ( iterator position )` | 删除 set 中 position 位置上的元素
    `size_type erase ( const key_type& x )` | 删除 set 中值为 x 的元素，返回删除的元素的个数
    `void erase ( iterator ﬁrst, iterator last )` | 删除 set 中 [ﬁrst, last) 区间中的元素
    `void swap ( set<Key,Compare,Allocator>& st )` | 交换 set 中的元素
    `void clear ( )` | 将 set 中的元素清空
    `iterator ﬁnd ( const key_type& x )` | 返回 set 中值为 x 的元素的位置
    `size_type count ( const key_type& x )` | 返回 set 中值为 x 的元素的个数



[cplusplus：std::set](http://www.cplusplus.com/reference/set/set/?kw=set)

#### `std::multiset`

所有的元素都会被自动排序，允许键值重复
 - multiset 底层存储的是 `<value, value>` 的键值对


multiset 容器通过 `key` 访问单个元素的速度通常 unordered_multiset 容器慢，但当使用迭代器遍历时会得到一个有序序列

头文件： `#include <set>`

multiset 的接口与 set 接口基本一致

[cplusplus：std::multiset](http://www.cplusplus.com/reference/set/multiset/?kw=multiset)


#### `std::unordered_set`

元素不会被自动排序，不允许出现键值重复

头文件：`#include <unordered_set>`



[cplusplus：std::unordered_set](http://www.cplusplus.com/reference/unordered_set/unordered_set/?kw=unordered_set)



### 映射 map

map 容器按照特定的次序（按照 `key` 来比较）存储由键值 `key` 和值 `value` 组合而成的元素

在 map 中，键值 `key` 通常用于排序和标识元素，而值 `value` 中存储与此键值 `key` 关联的内容
 - 键值 `key` 和值 `value` 的类型可能不同，并且在 map 的内部，`key` 与 `value` 通过成员类型 `value_type` 绑定在一起


在 map 中，不允许修改 `key` ，但可以修改 `key` 对应的 `value`

C++ 的 map 实现：
 - `std::map` ：底层实现是红黑树，`key` 有序
 - `std::multimap` ：底层实现是红黑树，`key` 有序
 - `std::unordered_map` ： 底层实现为哈希表，`key` 无序

| map | 底层实现 | `key` 是否有序 | `key` 是否可以重复 | 能否更改 `key` | 查询效率 | 增删效率
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| `std::map` | 红黑树 | 有序 | 否 | 否 | $O(\log {n})$ | $O(\log {n})$ |
| `std::multimap` | 红黑树 | 有序 | 是 | 否 | $O(\log {n})$ | $O(\log {n})$ |
| `std::unordered_map` | 哈希表 | 无序 | 否 | 否 | $O(1)$ | $O(1)$ |


另，`hash_set` 、`hash_map`  和 `unordered_set` 、`unordered_map` 功能一致，区别在于是否被引入标准库
 - `unordered_set` 和 `unordered_map` 被引入了  C++ 11 标准库
 - `hash_set` 和 `hash_map` 并未被引入 C++ 11 标准库


[代码随想录：哈希表理论基础](https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

#### `std::map`

map 中的元素总是按照键值 `key` 进行自动排序，`key` 不可重复

map 通过键值访问单个元素的速度通常比 unordered_map 容器慢，但 map 允许根据顺序对元素进行直接迭代（即对 map 中的元素进行迭代时，可以得到一个有序的序列）

map 支持下标访问符，即，`map[key]` 可以找到与 `key` 对应的 `value`

头文件： `#include <map>`

[cplusplus：std::map](http://www.cplusplus.com/reference/map/map/)

#### `std::multimap`

元素会被自动排序，键值 `key` 可以重复

multimap 不支持下标访问符

multimap 的接口与 map 类似

[cplusplus：std::multimap](http://www.cplusplus.com/reference/map/multimap/)

头文件： `#include <map>`

#### `std::unordered_map`

元素不被自动排序，键值 `key` 不可以重复

支持下标访问符

头文件：`#include <unordered_map>`

[cplusplus：std::unordered_map](http://www.cplusplus.com/reference/unordered_map/unordered_map/)