---
title: 多维数组
date: 2022-03-10 21:29:56
tags: 
 - 数组
categories:
 - C++
cover: false
---

严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。

当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：
```cpp
int ia[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组
// array of size 10; each element is a 20-element array whose elements are arrays of 30 ints
int arr[10][20][30] = {0}; // initialize all elements to 0
```

对于二维数组来说，常把第一个维度称作行，第二个维度称作列。

## 多维数组的初始化
**允许使用花括号括起来的一组值初始化多维数组**
```cpp
int ia[3][4] = {    // three elements; each element is an array of size 4
    {0, 1, 2, 3},   // initializers for the row indexed by 0
    {4, 5, 6, 7},   // initializers for the row indexed by 1
    {8, 9, 10, 11}  // initializers for the row indexed by 2
};
```
其中内层嵌套着的花括号并非必需的。例如下面的初始化语句，形式上更为简洁，完成的功能和上面这段代码完全一样：
```cpp
// equivalent initialization without the optional nested braces for each row
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：
```cpp
// explicitly initialize only element 0 in each row
int ia[3][4] = {{ 0 }, { 4 }, { 8 }};
```
其他**未列出的元素执行默认值初始化。**

在这种情况下如果再省略掉内层的花括号，结果就大不一样了:
```cpp
// explicitly initialize row 0; the remaining elements are value initialized
int ix[3][4] = {0, 3, 6, 9};
```
它初始化的是第一行的4个元素，其他元素被初始化为0。

## 多维数组的下标引用
**可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。**

如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：
```cpp
// assigns the first element of arr to the last element in the last row of ia
ia[2][3] = arr[0][0][0];
int (&row)[4] = ia[1]; // binds row to the second four-element array in ia
```
在第一个例子中，在等号左侧，`ia[2]`得到数组`ia`的最后一行，此时返回的是表示`ia`最后一行的那个一维数组而非任何实际元素；对这个一维数组再取下标，得到编号为`[3]`的元素，也就是这一行的最后一个元素。等号右侧也是类似的。
在第二个例子中，把`row`定义成一个含有4个整数的数组的引用，然后将其绑定到`ia`的第2行。

再举一个例子，程序中经常会用到两层嵌套的for循环来处理多维数组的元素：
```cpp
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];   // 12 uninitialized elements
// for each row
for (size_t i = 0; i != rowCnt; ++i) {
    // for each column within the row
    for (size_t j = 0; j != colCnt; ++j) {
        // assign the element's positional index as its value
        ia[i][j] = i * colCnt + j;
    }
}
```
外层的`for`循环遍历`ia`的所有元素，注意这里的元素是一维数组；内层的`for`循环则遍历那些一维数组的整数元素。此例中，我们将元素在整个数组中的序号设为该元素的值。


## 使用范围for语句处理多维数组
```cpp
size_t cnt = 0;
for (auto &row : ia)        // for every element in the outer array
    for (auto &col : row) { // for every element in the inner array
        col = cnt;          // give this element the next value
        ++cnt;              // increment cnt
    }
```
因为要改变元素的值，所以得把控制变量`row`和`col`声明成引用类型。第一个`for`循环遍历`ia`的所有元素，这些元素是大小为4的数组，因此`row`的类型就应该是含有4个整数的数组的引用。第二个`for`循环遍历那些4元素数组中的某一个，因此`col`的类型是整数的引用。

在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环：
```cpp
for (const auto &row : ia)  // for every element in the outer array
    for (auto col : row)    // for every element in the inner array
        cout << col << endl;
```
这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针。

假设不用引用类型，则循环如下述形式：
```cpp
for (auto row : ia)
    for (auto col : row)
```
程序将无法通过编译。这是因为，像之前一样第一个循环遍历`ia`的所有元素，注意这些元素实际上是大小为4的数组。因为`row`不是引用类型，所以编译器初始化`row`时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的`row`的类型就是`int*`，显然内层的循环就不合法了。

> **要使用`范围for`语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。**


## 指针和多维数组
当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：
```cpp
int ia[3][4];     // array of size 3; each element is an array of ints of size 4
int (*p)[4] = ia; // p points to an array of four ints（p指向ia的第一行）
p = &ia[2];       // p now points to the last element in ia（p指向ia的第三行）
```
等号左侧，首先由`(*p)`知道`p`是一个指针，由`int [4]`知道`p`指向的是一个包含4个整数的数组。等号右侧，`ia`返回的是`&ia[0]`，即`ia[0]`的地址。因此，`p`指向的是`ia[0]`，即`ia`的第一行。

注意，在上述声明中，圆括号必不可少：
```cpp
int *ip[4];    // array of pointers to int（[]优先级高于*，故而ip是一个数组，其元素为整形指针）
int (*ip)[4];  // pointer to an array of four ints
```

随着C++11新标准的提出，通过使用`auto`或者`decltype`就能尽可能地避免在数组前面加上一个指针类型了：
```cpp
// print the value of each element in ia, with each inner array on its own line
// p points to an array of four ints
for (auto p = ia; p != ia + 3; ++p) {
    // q points to the first element of an array of four ints; that is, q points to an int
    for (auto q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```

外层的`for`循环首先声明一个指针`p`并令其指向`ia`的第一个内层数组，然后依次迭代直到`ia`的全部3行都处理完为止。其中递增运算`++p`负责将指针`p`移动到`ia`的下一行。
内层的`for`循环负责输出内层数组所包含的值。它首先令指针`q`指向`p`当前所在行的第一个元素。`*p`是一个含有4个整数的数组，像往常一样，数组名被自动地转换成指向该数组首元素的指针。内层`for`循环不断迭代直到我们处理完了当前内层数组的所有元素为止。为了获取内层`for`循环的终止条件，再一次解引用`p`得到指向内层数组首元素的指针，给它加上4就得到了终止条件。

使用标准库函数`begin`和`end`也能实现同样的功能，而且看起来更简洁一些:
```cpp
// p points to the first array in ia
for (auto p = begin(ia); p != end(ia); ++p) {
    // q points to the first element in an inner array
    for (auto q = begin(*p); q != end(*p); ++q)
        cout << *q << ' ';   // prints the int value to which q points
    cout << endl;
}
```


## 类型别名简化多维数组的指针
读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名（[处理类型-类型别名](https://jiankychen.github.io/2022/03/02/12-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/)）能让这项工作变得简单一点儿，例如：
```cpp
using int_array = int[4]; // new style type alias declaration; equivalent typedef declaration: typedef int int_array[4];
// print the value of each element in ia, with each inner array on its own line
for (int_array *p = ia; p != ia + 3; ++p) {
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```

程序将类型“4个整数组成的数组”命名为`int_array`，用类型名`int_array`定义外层循环的控制变量让程序显得简洁明了。（由`*p`知道`p`是一个指针，指向一个包含4个整数的数组。`q`是一个指向整数的指针。）