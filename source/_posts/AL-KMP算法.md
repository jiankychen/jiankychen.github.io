---
title: KMP 算法
date: 2022-05-10 21:22:31
tags: KMP
categories:
 - 算法
cover: false
---

Knuth-Morris-Pratt 算法，简称 KMP 算法，由 Donald Knuth、James H. Morris 和 Vaughan Pratt 三人于 1977 年联合发表

KMP 算法主要应用于字符串匹配

基本思想：当出现字符串不匹配时，可以利用前面已经匹配的那些字符中的信息，避免从头再做匹配

以 在文本串中查找是否出现过一个模式串 为例：检测文本串 "aabaabaaf" 中是否含有 模式串 "aabaaf" ：
 - 若采用暴力匹配，即，首先检查以第一个字符 'a' 开头的子串是否可以与 "aabaaf" 相匹配，发现子串 "aabaab" 的第二个 'b' 无法与 "aabaaf" 对应位置上的 'f' 匹配，因此，重新检查字符串 "aabaabaaf" 中以第二个字符 'a' 开头的子串是否可以与 "aabaaf" 相匹配，依此类推
 - 若采用 KMP 算法，当发现子串 "aabaab" 的第二个 'b' 无法与 "aabaaf" 对应位置上的 'f' 匹配时，会利用此前已经匹配的子串 "aabaa" 的信息，以确定下一步的匹配起点

KMP 算法的查找过程如下所示：

![](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif)

可以看出，如果暴力匹配，会当发现不匹配时，需要对模式串从头开始匹配，但如果使用 KMP ，就不会从头匹配，而是从上次已经匹配的内容开始匹配，即，找到模式串中第三个字符 'b' 继续开始匹配

## 前缀表

前缀表是用来回退的，它记录了之前已经匹配的文本中的信息，并告诉我们：当文本串中的字符 `x` 与模式串中的字符 `y` 匹配失败时，下一步应该将模式串中的哪个字符与文本串中的字符 `x` 重新进行匹配

[^_^]: 被注释掉了

    例如，文本串字符 `b` 与模式串 `f` 不匹配时，前缀表会告知，应将模式串中的 `b` 与文本串的 `b` 进行匹配
    - 因为模式串字符 `f` 前面的 "aa" 与文本串字符 `b` 前面的 "aa" 是匹配的，而模式串字符 `b` 前面也有一个 "aa" ，因此，模式串字符 `b` 前面的 "aa" 也可以与文本串字符 `b` 前面的 "aa" 相匹配，故而可以将这两个 "aa" 进行匹配，并检查 "aa" 后面的对应字符是否匹配

    对应的，这也就是前缀表的工作原理：匹配失败位置前一位的前缀表元素，记录了匹配成功子串（`"aabaa"`）的最长相同前后缀（`"aa"`）的长度（`2`），该长度对应的位置，即为下一步匹配的起点（将模式串下标为 `2` 的字符与文本串的 `b` 匹配）

前缀表中，下标为 `i` 的元素，记录了 “ 在模式串里边，以下标 `i` 结束的子串有多大长度的相同前缀后缀，即，相同前后缀的最大长度 ”

### 前缀与后缀

字符串的 **前缀** ：**不包含最后一个字符** 的、**以第一个字符开头** 的连续子串
 - 例如，字符串 "aabaaf" 的前缀有："a"、"aa"、"aab"、"aaba" 和 "aabaa"

字符串的 **后缀** ：**不包含第一个字符** 的、**以最后一个字符结尾** 的连续子串
 - 例如，字符串 "aabaaf" 的后缀有："f"、"af"、"aaf"、"baaf" 和 "abaaf"

### 最长相同前后缀

针对某一字符串，使得 前缀和后缀相同 的前缀/后缀长度的最大值，即为所谓的 相同前后缀的最大长度，对应的前缀/后缀即为 最长相同前后缀

例如，字符串 "aabaa" 的前缀有 "a"、"aa"、"aab"、"aaba"，后缀有 "a"、"aa"、"baa"、"abaa"，其中，相同前后缀的最大长度为 2，最长相同前后缀为 "aa"


### 前缀表的计算

以模式串中某个位置为结尾的子串，其相同前后缀最大长度，就是前缀表对应位置的元素

以模式串 "aabaaf" 为例：

 - 子串 "a" 的相同前后缀最大长度为 0（没有前缀，也没有后缀）
 - 子串 "aa" 的相同前后缀最大长度为 1（前缀为 "a"，后缀也为 "a"）
 - 子串 "aab" 的相同前后缀最大长度为 0（前缀不含 'b'，后缀一定含 'b' ，不存在相同前后缀）
 - 子串 "aaba" 的相同前后缀最大长度为 1（最长相同前后缀为 "a"）
 - 子串 "aabaa" 的相同前后缀最大长度为 2（最长相同前后缀为 "aa"）
 - 子串 "aabaaf" 的相同前后缀最大长度为 0（前缀不含 'f'，后缀一定含 'f' ，不存在相同前后缀）

即，

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 模式串 | a | a | b | a | a | f |
| 前缀表 | 0 | 1 | 0 | 1 | 2 | 0 |

因此，当模式串的 `f` 与文本串匹配失败时，找到 `f` 前一位所对应的前缀表元素 `2` ，模式串下标为 `2` 的字符将与文本串重新匹配
 - 下标 5 之前这部分的字符串（也就是字符串 "aabaa" ）的最长相等前后缀字符串是 "aa" ，匹配失败的位置是后缀子串的下一位，那么我们找到与其相同前缀的下一位重新匹配即可

![](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif)

## next 数组


参考：
 - [代码随想录](https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html)
 - [力扣官方题解](https://leetcode.cn/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/)